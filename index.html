<!DOCTYPE html>
<html lang="en" translate="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <title>Simplos</title>
    
    <!-- Fonts and Styles -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2.39.7"></script>
    <script src="vocabs.js"></script>
    <style>

:root {
  /* Update core color scheme */
  --primary-dark: #1a1a2e;  /* Keep dark base */
  --primary: #16213e;      /* Deep blue */
  --secondary: #0f3460;    /* Lapis lazuli */
  --accent: #1E90FF;       /* Bright lapis instead of pink */
  --text: #ffffff;         /* Keep white */
  --gold: #ffd700;        /* Keep gold */
  --silver: #c0c0c0;      /* Keep silver */
  --bronze: #cd7f32;      /* Keep bronze */
  --success: #4CAF50;     /* Keep success green */
  --error: #f44336;       /* Keep error red for warnings only */
  --gradient: linear-gradient(135deg, var(--secondary), var(--primary-dark));
  --glass: rgba(255, 255, 255, 0.1);
  --locked: #808080;

  /* New accent gradients */
  --royal-gradient: linear-gradient(135deg, var(--gold), var(--accent));
  --blue-gradient: linear-gradient(135deg, var(--secondary), var(--accent));
  --gold-gradient: linear-gradient(135deg, var(--gold), #ffa500);
}



/* Update auth modal */
.auth-modal-content {
    background: var(--glass);
    border: 1px solid var(--accent);
}


/* Update side panel */
.side-panel {
    background: linear-gradient(135deg, 
        rgba(22, 33, 62, 0.95),
        rgba(15, 52, 96, 0.95)
    );
}

/* Update user profile section */
.user-profile-section {
    background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.05), 
        rgba(30, 144, 255, 0.05)
    );
    border: 1px solid rgba(30, 144, 255, 0.1);
}

/* Update status badges */
.status-badge.premium {
    background: var(--royal-gradient);
}

.status-badge.pending {
    background: var(--blue-gradient);
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Montserrat', sans-serif;
}

body {
  margin: 0;
  padding: 0;
  min-height: 100vh;
  background: var(--gradient);
  color: var(--text);
  overflow-x: hidden;
}

.screen {
  display: none;
  min-height: 100vh;
  padding: 2rem;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  background: radial-gradient(circle at center, var(--secondary) 0%, var(--primary-dark) 100%);
}

.screen.visible {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.5s ease-in-out;
}

.welcome-title {
  font-size: 4rem;
  font-weight: 700;
  margin-bottom: 2rem;
  background: linear-gradient(to right, var(--gold), var(--accent));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  text-shadow: 0 2px 10px rgba(0,0,0,0.2);
  animation: shimmer 2s infinite;
  font-size: 2.5rem;
  margin-bottom: 1.5rem;
}

/* Neon Outline Button Style */
.start-button,
.custom-lists-button,
.auth-tab,
.auth-form-login-button,
.auth-form-signup-button,
.edit-button,
.delete-button,
.process-words-button,
.save-list-button,
.add-word-button {
    position: relative;
    padding: 0.5rem 1rem;
    border: 2px solid var(--accent);
    background: transparent;
    color: var(--text);
    border-radius: 50px;
    font-weight: 600;
    font-size: 0.9rem;
    overflow: hidden;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: none;
    min-width: none;
    max-width: none;  
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: auto;  
}

/* Neon glow effect on hover */
.start-button:hover,
.custom-lists-button:hover,
.auth-tab:hover,
.auth-form-login-button:hover,
.auth-form-signup-button:hover,
.edit-button:hover,
.delete-button:hover,
.process-words-button:hover,
.save-list-button:hover,
.add-word-button:hover {
    box-shadow: 0 0 15px var(--accent), 0 0 30px var(--accent);
}

/* Hover shine effect */
.start-button::before,
.custom-lists-button::before,
.auth-tab::before,
.auth-form-login-button::before,
.auth-form-signup-button::before,
.edit-button::before,
.delete-button::before,
.process-words-button::before,
.save-list-button::before,
.add-word-button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(120deg, transparent, rgba(233, 69, 96, 0.3), transparent);
    transition: all 0.6s ease;
}

.start-button:hover::before,
.custom-lists-button:hover::before,
.auth-tab:hover::before,
.auth-form-login-button:hover::before,
.auth-form-signup-button:hover::before,
.edit-button:hover::before,
.delete-button:hover::before,
.process-words-button:hover::before,
.save-list-button:hover::before,
.add-word-button:hover::before {
    left: 100%;
}

.share-button {
    position: relative; 
    padding: 0.5rem 1rem;
    border: 2px solid var(--accent);
    background: transparent;
    color: var(--text);
    border-radius: 50px;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.share-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--glass);
    backdrop-filter: blur(10px);
    padding: 2rem;
    border-radius: 20px;
    z-index: 1000;
    width: 90%;
    max-width: 500px;
}

.share-modal-header {
    color: var(--gold);
    margin-bottom: 1.5rem;
}

.users-list {
    max-height: 300px;
    overflow-y: auto;
    margin: 1rem 0;
}

.user-item {
    display: flex;
    align-items: center;
    padding: 0.75rem;
    margin: 0.5rem 0;
    background: rgba(255,255,255,0.1);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.user-item:hover {
    background: rgba(255,255,255,0.2);
    transform: translateY(-2px);
}

@keyframes shareGlow {
    0% { box-shadow: 0 0 5px var(--accent); }
    50% { box-shadow: 0 0 20px var(--accent); }
    100% { box-shadow: 0 0 5px var(--accent); }
}

.shared-list {
    animation: shareGlow 2s ease-in-out;
}

.shared-list {
    border: 2px solid transparent;
    background: linear-gradient(135deg, #00f2fe, #4facfe);
    background-clip: padding-box;
}

.modal-backdrop {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    backdrop-filter: blur(5px);
    z-index: 999;
}

.user-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1rem;
    margin: 0.5rem 0;
    background: rgba(255,255,255,0.1);
    border-radius: 10px;
    transition: all 0.3s ease;
}

.user-item:hover {
    background: rgba(255,255,255,0.2);
}

.modal-close {
    margin-top: 1rem;
    width: 100%;
}

.upgrade-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(5px);
    z-index: 1000;
}

.upgrade-form {
    width: 100%;
    max-width: 500px;
    padding: 2rem;
    background: var(--glass);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    text-align: right;
    direction: rtl;
}

.upgrade-form h2 {
    font-size: 1.5rem;
    font-weight: bold;
    text-align: center;
    margin-bottom: 1.5rem;
    background: linear-gradient(to right, var(--gold), var(--accent));
    -webkit-background-clip: text;
background-clip: text;
    -webkit-text-fill-color: transparent;
}

.form-group {
    margin-bottom: 1rem;
}

.form-group label {
    display: block;
    margin-bottom: 0.5rem;
    color: var(--text);
}

.form-group input[type="tel"],
.form-group select {
    width: 100%;
    padding: 0.75rem;
    border-radius: 25px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: var(--text);
}

.form-group input[type="checkbox"] {
    margin-right: 0.5rem;
}

.submit-button {
    width: 100%;
    padding: 1rem;
    border: 2px solid var(--accent);
    background: transparent;
    color: var(--text);
    border-radius: 25px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-top: 1rem;
}

.submit-button:hover {
    box-shadow: 0 0 15px var(--accent), 0 0 30px var(--accent);
}

.upgrade-form p {
    text-align: center;
    color: var(--text);
    margin-top: 1rem;
    font-size: 0.9rem;
    opacity: 0.8;
}

/* Maintain active state for auth tabs */
.auth-container {
    position: fixed;
    top: 20%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
    padding: 1rem 2rem;
    border-radius: 1rem;
    display: flex;
    gap: 1rem;
    align-items: center;
    z-index: 100;
    width: 90%;
    max-width: 320px; /* Added to ensure consistent width */
}


.auth-input:focus {
    border-color: var(--accent);
}

.auth-button:hover {
    background: rgba(233, 69, 96, 0.1);
}

@keyframes pulse-glow {
    0%, 100% { 
        box-shadow: 0 0 10px var(--accent), 0 0 5px var(--accent); 
        transform: translate(-50%, -50%) scale(1.02);
    }
    50% { 
        box-shadow: 0 0 20px var(--accent), 0 0 10px var(--accent); 
        transform: translate(-50%, -50%) scale(1.05);
    }
}

.auth-container.highlight {
    animation: pulse-glow 1.5s ease-in-out infinite;
    background: rgba(233, 69, 96, 0.1);
}

.auth-toggle {
    color: rgba(255, 255, 255, 0.6);
    font-size: 0.85rem;
    background: transparent;
    border: none;
    cursor: pointer;
    transition: color 0.3s ease;
}

.auth-toggle:hover {
    color: var(--text);
}

.user-info {
    position: fixed;
    top: 2rem;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    z-index: 100;
}

#userEmail {
    font-size: 1.5rem;
    color: var(--gold);
    margin-bottom: 0.5rem;
}

.student-mode {
    color: var(--text);
    font-size: 1rem;
    opacity: 0.8;
    display: block;
}


@media (max-width: 768px) {
    .auth-container {
        flex-direction: column;
        padding: 1rem;
        width: 90%;
        max-width: 320px;
    }

    .auth-input {
        width: 100%;
    }
}

/* Neon style for custom practice screen buttons */
.start-button, .edit-mode-button {
    position: relative;
    padding: 0.5rem 1rem;
    border: 2px solid var(--accent);
    background: transparent;
    color: var(--text);
    border-radius: 50px;
    font-size: 0.9rem;
    font-weight: 600;
    overflow: hidden;
    cursor: pointer;
    transition: all 0.3s ease;
    flex: 0 1 auto;
    min-width: 100px;
    max-width: 150px;
    box-shadow: none;
}

.start-button:hover, .edit-mode-button:hover {
    box-shadow: 0 0 15px var(--accent), 0 0 30px var(--accent);
}

.start-button::before, .edit-mode-button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(120deg, transparent, rgba(233, 69, 96, 0.3), transparent);
    transition: all 0.6s ease;
}

.start-button:hover::before, .edit-mode-button:hover::before {
    left: 100%;
}

.auth-form button {
    position: relative;
    padding: 0.875rem 2rem;
    border: 2px solid var(--accent);
    background: transparent;
    color: var(--text);
    border-radius: 50px;
    font-size: 1.1rem;
    font-weight: 600;
    overflow: hidden;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: none;
    width: 100%;
}

.auth-form button:hover {
    box-shadow: 0 0 15px var(--accent), 0 0 30px var(--accent);
}

.auth-form button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(120deg, transparent, rgba(233, 69, 96, 0.3), transparent);
    transition: all 0.6s ease;
}

.auth-form button:hover::before {
    left: 100%;
}



@media (max-width: 768px) {
    .welcome-buttons {
        max-width: 250px;
        
    }
    }

    .welcome-buttons {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    width: 100%;
    max-width: 300px;
    margin: 0 auto;
    padding: 0 1rem;
}

.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
}

.modal-content {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--glass);
    padding: 2rem;
    border-radius: 20px;
    backdrop-filter: blur(10px);
    text-align: center;
}

#otpInput {
    padding: 1rem;
    margin: 1rem 0;
    background: rgba(255,255,255,0.1);
    border: none;
    border-radius: 10px;
    color: white;
    font-size: 1.2rem;
    text-align: center;
}

.leaderboard-entry .name {
    color: var(--gold);
}

.leaderboard-entry .words {
    color: var(--accent);
}

.leaderboard-entry .coins {
    color: var(--text);
}

.stage-selector {
    margin: 2rem 0;
    text-align: left;
    width: 100%;
}

.stage-checkboxes {
    display: flex;
    flex-wrap: wrap;
    gap: 1.5rem;
    margin: 1rem 0;
    justify-content: center;
}

.stage-checkboxes label {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    cursor: pointer;
    font-size: 1.2rem;
    padding: 1rem;
    background: rgba(255,255,255,0.1);
    border-radius: 15px;
    transition: all 0.3s ease;
}

.stage-checkboxes label:hover {
    background: rgba(255,255,255,0.2);
}

.stage-checkboxes input[type="checkbox"] {
    width: 24px;
    height: 24px;
    cursor: pointer;
}

.word-goal {
    margin: 2rem 0;
    text-align: center;
}

#wordGoal {
    padding: 0.75rem;
    border-radius: 10px;
    background: rgba(255,255,255,0.1);
    color: var(--text);
    border: 1px solid rgba(255,255,255,0.2);
    width: 120px;
    font-size: 1.1rem;
    text-align: center;
}

.navigation-button.initialize-button {
    background: var(--accent);
    color: var(--text);
}

.navigation-button.initialize-button:hover {
    filter: brightness(1.2);
}

/* Make leaderboard entries clickable for moderator */
.moderator .leaderboard-entry {
    cursor: pointer;
}

.moderator-header {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    margin-bottom: 2rem;
    padding: 2rem;
    background: var(--glass);
    border-radius: 20px;
    backdrop-filter: blur(10px);
}

.otp-display {
    font-size: 3rem;
    color: var(--gold);
    text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
    letter-spacing: 0.5rem;
    margin: 1rem 0;
    font-weight: bold;
}

.join-game-button {
    position: relative;
    padding: 0.875rem 2rem;
    border: 2px solid var(--accent);
    background: transparent;
    color: var(--text);
    border-radius: 50px;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-top: 2rem;
    animation: pulseGlow 1.5s ease-in-out infinite;
}

@keyframes pulseGlow {
    0%, 100% { 
        box-shadow: 0 0 10px var(--accent), 0 0 5px var(--accent); 
        transform: scale(1.02);
    }
    50% { 
        box-shadow: 0 0 20px var(--accent), 0 0 10px var(--accent); 
        transform: scale(1.05);
    }
}

.game-controls {
    display: flex;
    gap: 1rem;
    margin: 1rem 0;
}

.end-arcade-button {
    background: var(--error);
    color: var(--text);
    border: none;
    padding: 1rem 2rem;
    border-radius: 50px;
    font-size: 1.2rem;
    cursor: pointer;
    transition: all 0.3s ease;
    display: none;
}

.end-arcade-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(244, 67, 54, 0.4);
}

.end-arcade-button.visible {
    display: block;
    animation: fadeIn 0.3s ease-in-out;
}

.leaderboard-entry {
    display: grid;
    grid-template-columns: 1fr 3fr 1fr 1fr;
    align-items: center;
    padding: 1rem;
    margin-bottom: 0.5rem;
    background: rgba(255,255,255,0.05);
    border-radius: 10px;
    transition: all 0.3s ease;
    position: relative;
}

.leaderboard-entry > div {
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
}

.leaderboard-entry div[data-username] {
    font-weight: 600;
}

.leaderboard-entry div[data-words],
.leaderboard-entry div[data-coins] {
    justify-content: center;
    transition: color 0.3s ease;
}

.leaderboard-header {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr 1fr;
    padding: 1rem;
    background: rgba(255,255,255,0.1);
    border-radius: 10px;
    margin-bottom: 1rem;
    font-weight: bold;
    text-align: center;
}

.leaderboard-header > div {
    text-align: center;
}

/* Waiting state adjustments */
.leaderboard-entry.waiting .player-name {
    grid-column: 2;
}

.player-status-waiting {
    grid-column: 3 / span 2;
    display: flex;
    justify-content: center;
    width: 100%;
}

.player-status-waiting .status-text {
    background: rgba(30, 144, 255, 0.1);
    color: var(--accent);
    padding: 0.375rem 1rem;
    border-radius: 12px;
    font-size: 1.2rem;
    text-transform: uppercase;
    letter-spacing: 1px;
    text-align: center;
}

.waiting-indicator {
    position: absolute;
    right: 50px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    align-items: center;
    gap: 9px;
}

.waiting-indicator .dot {
    width: 6px;
    height: 6px;
    background-color: var(--accent);
    border-radius: 50%;
    opacity: 0.7;
}

.waiting-indicator .dot:nth-child(1) {
    animation: dotPulse 1.4s infinite ease-in-out;
}

.waiting-indicator .dot:nth-child(2) {
    animation: dotPulse 1.4s infinite ease-in-out 0.2s;
}

.waiting-indicator .dot:nth-child(3) {
    animation: dotPulse 1.4s infinite ease-in-out 0.4s;
}

@keyframes dotPulse {
    0%, 60%, 100% { transform: scale(1); opacity: 0.7; }
    30% { transform: scale(1.5); opacity: 1; }
}

.completion-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.completion-content {
    background: var(--glass);
    backdrop-filter: blur(10px);
    padding: 2rem;
    border-radius: 20px;
    text-align: center;
}

.completion-content h2 {
    color: var(--gold);
    margin-bottom: 1.5rem;
}

.arcade-progress {
    position: fixed;
    top: 1rem;
    left: 50%;
    transform: translateX(-50%);
    background: var(--glass);
    padding: 0.5rem 1rem;
    border-radius: 15px;
    backdrop-filter: blur(5px);
}

.leaderboard-entry.moving-up {
    background: rgba(76, 175, 80, 0.08);
    animation: moveUp 0.8s ease-in-out forwards;
    z-index: 2;
}

.leaderboard-entry.moving-down {
    background: rgba(244, 67, 54, 0.08);
    animation: moveDown 0.8s ease-in-out forwards;
    z-index: 1;
}

@keyframes moveUp {
    0% { transform: translateY(65px); }
    100% { transform: translateY(0); }
}

@keyframes moveDown {
    0% { transform: translateY(-65px); }
    100% { transform: translateY(0); }
}

.moderator-container {
    display: flex;
    height: 100vh;
    width: 100%;
}

.session-info-panel {
    width: 25%;
    background: var(--glass);
    padding: 2rem;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    backdrop-filter: blur(10px);
    border-right: 1px solid rgba(255,255,255,0.1);
}

.session-details {
    text-align: center;
}

.session-details h2 {
    color: var(--gold);
    margin-bottom: 1.5rem;
}

.otp-display {
    font-size: 3rem;
    color: var(--gold);
    margin: 1rem 0;
    text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
}

.session-metadata {
    background: rgba(255,255,255,0.05);
    border-radius: 10px;
    padding: 1rem;
    margin: 1rem 0;
    text-align: left;
}

.session-metadata p {
    margin: 0.5rem 0;
    color: var(--text);
    opacity: 0.8;
}

.leaderboard-panel {
    width: 75%;
    overflow-y: auto;
    background: var(--primary-dark);
}

.moderator-leaderboard .leaderboard-entry {
    display: grid;
    grid-template-columns: 0.5fr 2fr 1fr 1fr 1fr;
    padding: 1.5rem;
    margin: 0.5rem;
    background: var(--glass);
    border-radius: 15px;
    font-size: 1.2rem;
    align-items: center;
    transition: all 0.3s ease;
}

.moderator-leaderboard .leaderboard-entry .player-actions {
    display: flex;
    gap: 0.5rem;
}

.moderator-leaderboard .leaderboard-entry .player-actions button {
    padding: 0.5rem;
    border-radius: 5px;
    background: var(--accent);
    color: white;
    border: none;
    cursor: pointer;
}

@media (max-width: 768px) {
    .moderator-container {
        flex-direction: column;
    }
    
    .session-info-panel,
    .leaderboard-panel {
        width: 100%;
    }
}

.arcade-completion-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.arcade-completion-modal.show {
    opacity: 1;
}

.completion-modal-content {
    background: var(--glass);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 2rem;
    max-width: 500px;
    width: 90%;
    text-align: center;
    transform: scale(0.7);
    transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.arcade-completion-modal.show .completion-modal-content {
    transform: scale(1);
}

.completion-stats {
    display: flex;
    justify-content: space-around;
    margin: 2rem 0;
}

.stat-item {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.stat-item i {
    font-size: 2rem;
    color: var(--gold);
    margin-bottom: 0.5rem;
}

.stat-item strong {
    font-size: 1.5rem;
    color: var(--gold);
}

.leaderboard-preview {
    margin: 2rem 0;
    background: rgba(255,255,255,0.1);
    border-radius: 15px;
    padding: 1rem;
}

.podium-player {
    display: flex;
    justify-content: space-between;
    padding: 0.5rem;
    margin: 0.5rem 0;
    background: rgba(255,255,255,0.05);
    border-radius: 10px;
}

.podium-player.rank-1 {
    background: linear-gradient(135deg, var(--gold), #FFD700);
    color: var(--primary-dark);
}

.podium-player.rank-2 {
    background: linear-gradient(135deg, #C0C0C0, #A0A0A0);
    color: var(--primary-dark);
}

.podium-player.rank-3 {
    background: linear-gradient(135deg, #CD7F32, #B87333);
    color: var(--primary-dark);
}


.download-app-button {
    opacity: 0.7;
    font-size: 0.9rem;
    margin-top: 0.5rem;
}

.auth-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
}

.auth-modal.show {
    opacity: 1;
    visibility: visible;
}

.auth-modal-content {
    background: var(--glass);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 2rem;
    width: 90%;
    max-width: 400px;
    transform: scale(0.9);
    transition: transform 0.3s ease;
}

.auth-modal.show .auth-modal-content {
    transform: scale(1);
}

.auth-form {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.auth-input {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 25px;
    padding: 0.75rem 1rem;
    color: var(--text);
    width: 100%;
}

.auth-input:focus {
    outline: none;
    border-color: var(--accent);
}

.auth-button {
    background: var(--accent);
    color: var(--text);
    border: none;
    border-radius: 25px;
    padding: 0.75rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

.auth-toggle {
    background: none;
    border: none;
    color: var(--text);
    opacity: 0.7;
    cursor: pointer;
    transition: opacity 0.3s ease;
}

.auth-toggle:hover {
    opacity: 1;
}

.hidden {
    display: none;
}


/* Side Panel Core */
.side-panel {
    position: fixed;
    top: 0;
    right: -100%;
    width: 320px;
    height: 100vh;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(10px);
    padding: 2rem 1.5rem;
    transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    box-shadow: -5px 0 20px rgba(0, 0, 0, 0.3);
}

.side-panel.open {
    right: 0;
}

/* Navigation Links */
.side-panel .welcome-buttons {
    display: flex;
    flex-direction: column;
    margin-top: 1rem;
    gap: 0.5rem;
    align-items: stretch; /* This makes all items stretch to full width */
}

.side-panel .nav-link {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.875rem 1rem;
    transition: all 0.3s ease;
    text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
    justify-content: flex-start;
    text-align: left;
    color: var(--text); /* Ensure text color is consistent */
    text-decoration: none; /* Remove underline */
    background: transparent;
    border-radius: 10px;
    cursor: pointer;
    opacity: 0.8;
}

.side-panel .nav-link:hover {
    background: rgba(255,255,255,0.1);
    opacity: 1;
    transform: translateX(5px);
}

.side-panel .nav-link i {
    color: var(--gold);
    margin-right: 0.5rem;
    opacity: 0.7;
    transition: all 0.3s ease;
}

.side-panel .nav-link:hover i {
    opacity: 1;
    color: var(--accent);
}

.side-panel .nav-link:hover {
    opacity: 1;
    color: var(--gold);
    transform: translateX(10px);
}

.side-panel .nav-link i {
    min-width: 20px;
    text-align: center;
    opacity: 0.7;
}

.nav-link {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.875rem 1rem;
    transition: all 0.3s ease;
    text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
    justify-content: flex-start;
    text-align: left;
    color: var(--text); /* Ensure text color is consistent */
    text-decoration: none; /* Remove underline */
    background: transparent;
    border-radius: 10px;
    cursor: pointer;
    opacity: 0.8;
}

.side-panel .logout-top-button {
    display: flex;
    align-items: center;
    padding: 0.875rem 1rem;

    text-align: center;
    color: var(--text); /* Ensure text color is consistent */
    background: transparent;
    border-radius: 10px;
    cursor: pointer;
    opacity: 0.8;
}

.side-panel .logout-top-button i {
    min-width: 20px;
    text-align: center;
    color: #bbff10;
    opacity: 1;
}

.side-panel .logout-top-button:hover i {
    opacity: 1;
}

.side-panel-content {
    display: flex;
    flex-direction: column;
    height: 100%;
    align-items: center; /* Center items horizontally */
}
.user-profile-bottom {
    margin-top: auto;
    padding: 1rem;
    border-top: 1px solid rgba(255,255,255,0.1);
}

/* User Profile Section */
.user-profile-section {
    margin-top: 3rem;
    text-align: center;
    padding: 1.5rem;
    background: linear-gradient(135deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
    border-radius: 15px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.username-display {
    font-size: 1.4rem;
    color: var(--gold);
    margin-bottom: 0.5rem;
    font-weight: 600;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.status-badge {
    display: inline-block;
    padding: 0.4rem 1.2rem;
    border-radius: 50px;
    font-size: 0.9rem;
    font-weight: 500;
    margin-top: 0.5rem;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.status-badge.premium {
    background: linear-gradient(135deg, #FFD700, #FFA500);
    color: #000;
    box-shadow: 0 2px 10px rgba(255,215,0,0.3);
}

.status-badge.pending {
    background: linear-gradient(135deg, #00BCD4, #03A9F4);
    color: white;
    animation: pendingPulse 2s infinite;
}

.status-badge.trial {
    background: linear-gradient(135deg, #9C27B0, #673AB7);
    color: white;
}

@media (max-width: 768px) {
    .side-panel {
        width: 85%;
        padding: 1.5rem 1rem;
    }
    
    .hamburger-button.open {
        right: 87%;
    }
    
    .main-buttons {
        padding: 0 1rem;
    }
}

/* Small Screen Optimization */
@media (max-width: 360px) {
    .side-panel {
        width: 90%;
        padding: 1.25rem 0.75rem;
    }
}

/* Stats Section */
.user-stats {
    margin-top: 2rem;
    display: flex;
    justify-content: space-around;
    padding: 1rem 0;
    border-top: 1px solid rgba(255,255,255,0.1);
    border-bottom: 1px solid rgba(255,255,255,0.1);
}

.stat-item {
    text-align: center;
}

.stat-value {
    font-size: 1.2rem;
    color: var(--text);
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.game-notification {
    position: fixed;
    top: 15%;  /* Adjusted to be above question word */
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    background: var(--glass);
    padding: 1rem 2rem;
    border-radius: 25px;
    color: var(--text);
    backdrop-filter: blur(10px);
    z-index: 1000;
    opacity: 0;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    text-align: center;
    min-width: 200px;
}

.game-notification.blessing {
    border: 2px solid #3498db;
}

.game-notification.curse {
    border: 2px solid #e74c3c;
}

.game-notification.show {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
}

.particle {
    position: fixed;
    pointer-events: none;
    z-index: 1000;
}

.particle.blessing {
    background: #3498db;
}

.particle.curse {
    background: #e74c3c;
}

.coin-icon {
    color: var(--gold);
    animation: coinPulse 3s ease-in-out infinite;
}

@keyframes coinPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

/* Hamburger Button */
.hamburger-button {
    position: fixed;
    top: 1rem;
    right: 1rem;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: var(--glass);
    border: 1px solid rgba(255, 255, 255, 0.1);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(10px);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 1001;
}

.hamburger-button:hover {
    transform: scale(1.1);
    background: rgba(255, 255, 255, 0.15);
}

.hamburger-button.open {
    right: 290px;
}

.hamburger-button i {
    color: var(--text);
    font-size: 1.25rem;
    transition: transform 0.3s ease;
}

.hamburger-button.open i {
    transform: rotate(90deg);
}


/* Welcome Screen Buttons */
.main-buttons {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1.25rem;
    width: 100%;
    max-width: 260px;
    margin: 0 auto;
}

.main-button {
    position: relative;
    padding: 0.875rem 2rem;
    background: transparent;
    color: var(--text);
    border: none;
    border-radius: 12px;
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    width: 100%;
    overflow: hidden;
    background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
    backdrop-filter: blur(5px);
    text-transform: uppercase;
    letter-spacing: 1px;
}

.main-button::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, var(--accent), #ff6b6b);
    opacity: 0;
    transition: opacity 0.3s ease;
    border-radius: inherit;
    z-index: -1;
}

.main-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(233, 69, 96, 0.2);
}

.main-button:hover::before {
    opacity: 1;
}

/* Mobile Optimization */
@media (max-width: 768px) {
    .side-panel {
        width: 85%;
        padding: 1.5rem 1rem;
    }
    
    .hamburger-button.open {
        right: 87%;
    }
    
    .main-buttons {
        padding: 0 1rem;
    }
}

/* Small Screen Optimization */
@media (max-width: 360px) {
    .side-panel {
        width: 90%;
        padding: 1.25rem 0.75rem;
    }
}

.leaderboard-entry div[data-words],
.leaderboard-entry div[data-coins] {
    transition: color 0.3s ease;
}

.leaderboard-entry.moving-up {
    animation: moveUp 0.8s ease-in-out forwards;
    z-index: 2;
}

.leaderboard-entry.moving-down {
    animation: moveDown 0.8s ease-in-out forwards;
    z-index: 1;
}

@keyframes moveUp {
    0% { transform: translateY(65px); }
    100% { transform: translateY(0); }
}

@keyframes moveDown {
    0% { transform: translateY(-65px); }
    100% { transform: translateY(0); }
}




.arcade-join-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    padding: 1rem;
}

.arcade-join-modal .modal-content {
    background: var(--glass);
    backdrop-filter: blur(10px);
    padding: 2rem;
    border-radius: 20px;
    width: 100%;
    max-width: 400px;
    text-align: center;
    position: relative;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

#player-view {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
}

#player-view h2 {
    font-size: 1.5rem;
    margin-bottom: 1rem;
    text-align: center;
    color: var(--gold);
}

.input-group {
    width: 100%;
    margin: 0;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.input-group input,
#otpInput {
    width: 100%;
    padding: 1rem;
    font-size: 1rem;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 15px;
    color: var(--text);
    text-align: center;
    transition: all 0.3s ease;
    outline: none;
}

.input-group input:focus,
#otpInput:focus {
    border-color: var(--accent);
    box-shadow: 0 0 15px rgba(233, 69, 96, 0.2);
}

#arcadeUsername {
    margin-bottom: 0.5rem;
}

#otpInput {
    margin: 0;
    letter-spacing: 0.2em;
}

.join-button {
    width: 100%;
    padding: 1rem;
    border: none;
    border-radius: 25px;
    background: var(--accent);
    color: var(--text);
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-top: 1rem;
}

.join-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(233, 69, 96, 0.4);
}

@media (max-width: 768px) {
    .arcade-join-modal {
        padding: 0.5rem;
    }

    .arcade-join-modal .modal-content {
        padding: 1.5rem;
        max-width: 350px;
    }

    #player-view h2 {
        font-size: 1.3rem;
        margin-bottom: 0.75rem;
    }

    .input-group input,
    #otpInput {
        font-size: 0.95rem;
        padding: 0.875rem;
        min-width: 250px; /* New line: ensures minimum width */
        width: 100%; /* Maintains full-width responsiveness */
    }

    #arcadeUsername {
        font-size: 1rem; /* Slightly larger font */
        letter-spacing: -0.5px; /* Tighter letter spacing to fit more text */
    }

    .join-button {
        font-size: 0.95rem;
        padding: 0.875rem;
    }
}

@media (max-width: 480px) {
    .input-group input,
    #otpInput {
        min-width: 220px; /* Slightly narrower for very small screens */
        font-size: 0.9rem;
    }

    #arcadeUsername {
        font-size: 0.95rem;
    }
}


.powerups-container {
    display: flex;
    gap: 0.5rem;
    padding: 5px;
    justify-content: center;
    width: 100%;
    margin-bottom: 1rem;
}

.powerup-card {
    position: relative;
    width: calc(33% - 10px);
    max-width: 100px;
    height: 100px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 5px;
    border-radius: 8px;
    text-align: center;
    font-size: 0.8em;
    transition: transform 0.2s ease;
}

.powerup-card.goodie {
    border: 2px solid #3498db;
    box-shadow: 0 0 15px rgba(52, 152, 219, 0.3);
}

.powerup-card.baddie {
    border: 2px solid #e74c3c;
    box-shadow: 0 0 15px rgba(231, 76, 60, 0.3);
}

.powerup-card:hover {
    transform: translateY(-2px);
}

.powerup-icon {
    font-size: 1.5rem;
    color: var(--text);
}

.powerup-name {
    font-size: 0.8rem;
    text-align: center;
    margin: 0.25rem 0;
    font-weight: bold;
}

.powerup-cost {
    position: absolute;
    top: -8px;
    right: -8px;
    background: var(--gold);
    color: var(--primary-dark);
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.7rem;
    font-weight: bold;
    border: 2px solid var(--primary-dark);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.powerup-card:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

@media (max-width: 768px) {
    .powerup-card {
        width: calc(33% - 10px);
        height: 90px;
        font-size: 0.7em;
    }
    
    .powerup-icon {
        font-size: 1.2rem;
    }
    
    .powerup-name {
        font-size: 0.7rem;
        margin: 0.2rem 0;
    }
    
    .powerup-cost {
        width: 20px;
        height: 20px;
        font-size: 0.65rem;
    }
}

.qr-section {
    background: white;
    padding: 1rem;
    border-radius: 15px;
    margin: 1rem 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
}

.qr-section canvas {
    width: 200px;
    height: 200px;
}

.qr-hint {
    color: var(--primary-dark);
    font-size: 0.9rem;
    font-weight: 600;
}

@media (max-width: 768px) {
    .qr-section canvas {
        width: 150px;
        height: 150px;
    }
}

@media (max-width: 768px) {
    .arcade-join-modal {
        padding: 0.5rem;
    }

    .arcade-join-modal .modal-content {
        padding: 1.5rem;
        max-width: 350px;
    }

    #player-view h2 {
        font-size: 1.3rem;
        margin-bottom: 0.75rem;
    }

    .input-group input,
    #otpInput {
        font-size: 0.95rem;
        padding: 0.875rem;
        min-width: 250px; /* New line: ensures minimum width */
        width: 100%; /* Maintains full-width responsiveness */
    }

    #arcadeUsername {
        font-size: 1rem; /* Slightly larger font */
        letter-spacing: -0.5px; /* Tighter letter spacing to fit more text */
    }

    .join-button {
        font-size: 0.95rem;
        padding: 0.875rem;
    }
}

@media (max-width: 480px) {
    .input-group input,
    #otpInput {
        min-width: 220px; /* Slightly narrower for very small screens */
        font-size: 0.9rem;
    }

    #arcadeUsername {
        font-size: 0.95rem;
    }
}

#qr-landing {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    background: var(--gradient);
    text-align: center;
    padding: 2rem;
}

.qr-landing-content {
    background: var(--glass);
    backdrop-filter: blur(10px);
    padding: 2rem;
    border-radius: 20px;
    width: 90%;
    max-width: 400px;
}

.qr-landing-content h2 {
    color: var(--gold);
    margin-bottom: 1.5rem;
}

.game-code-display {
    font-size: 2.5rem;
    color: var(--text);
    font-weight: bold;
    padding: 1rem;
    margin: 1rem 0;
    background: rgba(255,255,255,0.1);
    border-radius: 15px;
    letter-spacing: 0.2em;
}

#qr-landing .join-game-button {
    width: 100%;
    padding: 1rem;
    margin-top: 1.5rem;
    font-size: 1.2rem;
    animation: pulseGlow 1.5s ease-in-out infinite;
}

.waiting-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    position: relative;
    overflow: hidden;
}

.spinner-container {
    position: relative;
    width: 100px;
    height: 100px;
    margin-bottom: 2rem;
}

.spinner {
    position: absolute;
    width: 100%;
    height: 100%;
    border: 4px solid rgba(255,255,255,0.1);
    border-top-color: var(--gold);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.waiting-title {
    font-size: 2rem;
    color: var(--gold);
    margin-bottom: 1rem;
    text-shadow: 0 2px 10px rgba(255,215,0,0.3);
}

.player-count {
    font-size: 1.2rem;
    color: var(--text);
    opacity: 0.8;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* Floating particles */
.floating-particles {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    pointer-events: none;
}

.floating-particle {
    position: absolute;
    width: 10px;
    height: 10px;
    background: var(--gold);
    border-radius: 50%;
    opacity: 0.3;
    animation: float 3s infinite ease-in-out;
}

.slide-transition {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 9999;
    pointer-events: none;
    display: flex;
    justify-content: center;
    align-items: center;
    background: transparent;
}

.slide-panel-left, .slide-panel-right {
    position: absolute;
    width: 50%;
    height: 100%;
    background: linear-gradient(135deg, var(--primary-dark), var(--secondary));
    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.slide-panel-left {
    left: 0;
    transform: translateX(-100%);
    border-right: 2px solid var(--gold);
}

.slide-panel-right {
    right: 0;
    transform: translateX(100%);
    border-left: 2px solid var(--gold);
}

.slide-transition.show .slide-panel-left {
    transform: translateX(0);
    box-shadow: 5px 0 15px rgba(0,0,0,0.3);
}

.slide-transition.show .slide-panel-right {
    transform: translateX(0);
    box-shadow: -5px 0 15px rgba(0,0,0,0.3);
}

.level-announcement {
    position: absolute;
    z-index: 10000;
    color: var(--text);
    text-align: center;
    opacity: 0;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    transform: scale(0.9);
    background: rgba(0, 0, 0, 0.3);
    padding: 2rem 3rem;
    border-radius: 20px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}

.level-announcement.show {
    opacity: 1;
    transform: scale(1);
}

.level-announcement h1 {
    font-size: 2.5rem;
    background: linear-gradient(to right, var(--gold), #FFA500);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    margin-bottom: 1rem;
    position: relative;
    text-transform: uppercase;
    letter-spacing: 2px;
    font-weight: 700;
}

.level-announcement h1::after {
    content: '';
    position: absolute;
    bottom: -5px;
    left: 50%;
    transform: translateX(-50%);
    width: 50px;
    height: 2px;
    background: var(--gold);
    box-shadow: 0 0 10px var(--gold);
}

.level-announcement h2 {
    font-size: 2rem;
    color: var(--text);
    font-weight: 500;
    opacity: 0.9;
    letter-spacing: 1px;
}

/* Add subtle edge glow */
.slide-panel-left::after,
.slide-panel-right::after {
    content: '';
    position: absolute;
    top: 0;
    width: 2px;
    height: 100%;
    background: linear-gradient(to bottom, transparent, var(--gold), transparent);
    opacity: 0.5;
}

.slide-panel-left::after {
    right: 0;
}

.slide-panel-right::after {
    left: 0;
}

/* Add subtle animated line at the bottom */
.level-announcement::before {
    content: '';
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    height: 1px;
    background: linear-gradient(to right, transparent, var(--gold), transparent);
    animation: lineWidth 2s ease-in-out infinite;
}

@keyframes lineWidth {
    0%, 100% { width: 60%; opacity: 0.3; }
    50% { width: 80%; opacity: 0.7; }
}

.leaderboard-entry {
    display: grid;
    grid-template-columns: 1fr 5fr 3fr;
    align-items: center;
    padding: 1rem;
    margin-bottom: 0.5rem;
    background: rgba(255,255,255,0.05);
    border-radius: 10px;
    transition: background-color 0.3s ease;
    position: relative;
}

.leaderboard-entry > div:first-child {
    text-align: center;
    font-weight: bold;
    color: var(--gold);
}

.leaderboard-entry > div:nth-child(2) {
    text-align: center;
    font-weight: 500;
}


.leaderboard-entry div[data-words],
.leaderboard-entry div[data-coins] {
    transition: color 0.3s ease;
}

.leaderboard-entry.moving-up {
    background: rgba(76, 175, 80, 0.08);
    animation: moveUp 0.8s ease-in-out forwards;
    z-index: 2;
}

.leaderboard-entry.moving-down {
    background: rgba(244, 67, 54, 0.08);
    animation: moveDown 0.8s ease-in-out forwards;
    z-index: 1;
}

@keyframes moveUp {
    0% { transform: translateY(65px); }
    100% { transform: translateY(0); }
}

@keyframes moveDown {
    0% { transform: translateY(-65px); }
    100% { transform: translateY(0); }
}


.coins-header .coin-icon {
  color: var(--gold);
  font-size: 1.5rem;
  filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.3));
}

.coins-header .coin-count {
  font-size: 1.2rem;
  font-weight: bold;
  color: var(--text);
}

.coin-count {
    transition: none; /* Remove any existing transitions */
}

.coin-count.animating {
    transition: content 1s ease-out;
}


.stage-container, .set-container, .level-selection {
  display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 2rem;
    width: 100%;
    max-width: 1200px;
    padding: 2rem;
    z-index: 1;
}



.stage-button, .set-button, .level {
  aspect-ratio: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--text);
    background: var(--glass);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    position: relative;
    overflow: hidden;
    flex-direction: column;
}

@media (max-width: 768px) {
    .level-selection {
        grid-template-columns: repeat(4, 1fr);
        gap: 0.75rem;
        padding: 1rem;
    }

    .level {
        aspect-ratio: 1;
        min-height: 60px;
        font-size: 1.2rem;
    }
}

.stage-name {
  font-size: 1.2rem;
    margin-bottom: 0.5rem;
    color: var(--text);
    text-transform: uppercase;
    letter-spacing: 1px;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.stage-button::before, .set-button.active::before, .level.blue::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.2) 0%, transparent 70%);
  opacity: 0;
  transition: opacity 0.3s ease;
}

.stage-button:hover, .set-button.active:hover, .level.blue:hover {
  transform: translateY(-10px) scale(1.05);
  box-shadow: 0 20px 40px rgba(0,0,0,0.2);
}

.stage-button:hover::before, .set-button.active:hover::before, .level.blue:hover::before {
  opacity: 1;
}

.set-button {
  cursor: not-allowed;
    opacity: 0.5;
    background: var(--locked);
    transition: all 0.5s ease;
}

.set-button.active {
  opacity: 1;
    cursor: pointer;
    background: linear-gradient(135deg, var(--gold), #ffa500);
    box-shadow: 0 10px 20px rgba(255, 215, 0, 0.3);
}

/* Test Level Visual Distinction */
.level.test-level {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    position: relative;
    border: 2px solid #00f2fe;
}

.level.test-level::before {
    content: 'â†»';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 1.5em;
    color: rgba(255, 255, 255, 0.2);
    animation: rotate 3s linear infinite;
}

.test-badge {
    background: rgba(255, 255, 255, 0.1);
    padding: 0.5rem 1rem;
    border-radius: 15px;
    margin-top: 1rem;
    font-size: 0.9rem;
    animation: pulse 2s infinite;
}

@keyframes rotate {
    from { transform: translate(-50%, -50%) rotate(0deg); }
    to { transform: translate(-50%, -50%) rotate(360deg); }
}

@keyframes pulse {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 1; }
}

/* Level announcement styles */
.level-announcement.test-level h1 {
    color: #4facfe;
    text-shadow: 0 0 10px rgba(79, 172, 254, 0.5);
}

.level-announcement.boss-level {
    background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%);
}

@keyframes switchDirection {
    0%, 100% { transform: scaleX(1); }
    50% { transform: scaleX(-1); }
}

/* Boss Level Styles */
.boss-mode {
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    animation: pulseBg 4s infinite;
}

.boss-word {
    color: #ffd700;
    text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    animation: pulseWord 2s infinite;
}

.boss-word.fading {
    animation: fadeWord 5s forwards;
}

@keyframes pulseBg {
    0%, 100% { filter: brightness(1); }
    50% { filter: brightness(1.2); }
}

@keyframes pulseWord {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

@keyframes fadeWord {
    0% { opacity: 1; }
    100% { opacity: 0.3; }
}

.perk-disabled {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 1.5em;
    color: red;
    pointer-events: none;
}


/* Lock icon styling */
.level:not(.blue):not(.green)::before {
    content: '\f023'; /* Font Awesome lock icon */
    font-family: 'Font Awesome 6 Free';
    font-weight: 900;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 1.5rem;
    color: rgba(255, 255, 255, 0.5);
    z-index: 1;
    pointer-events: none;
}

/* Optional hover effect for locked levels */
.level:not(.blue):not(.green):hover::before {
    color: rgba(255, 255, 255, 0.7);
    transform: translate(-50%, -50%) scale(1.1);
    transition: all 0.3s ease;
}

/* Ensure the level number stays visible */
.level {
    display: flex;
    align-items: center;
    justify-content: center;
    color: rgba(255, 255, 255, 0.5); /* Dim the number on locked levels */
}

.level.blue, .level.green {
    color: rgba(255, 255, 255, 1); /* Full opacity for unlocked levels */
}


.level.completing {
    animation: completeLevel 1.5s forwards;
}

.level.unlocking {
    animation: unlockLevel 1.5s forwards;
}

@keyframes completeLevel {
    0% {
        transform: scale(1);
        background: linear-gradient(135deg, var(--accent), #1E90FF);
    }
    50% {
        transform: scale(1.1);
        background: var(--success);
        box-shadow: 0 0 30px var(--gold);
    }
    100% {
        transform: scale(1);
        background: var(--success);
        border: 2px solid var(--gold);
        box-shadow: 0 0 20px var(--gold);
    }
}

/* Animation for unlocking next level */
@keyframes unlockLevel {
    0% { 
        transform: scale(1);
        background: var(--locked);
    }
    40% { 
        transform: scale(1.1);
    }
    50% { 
        transform: scale(1.1);
        background: var(--gold);
        box-shadow: 0 0 30px var(--gold);
    }
    60% {
        transform: scale(1.1);
    }
    100% { 
        transform: scale(1);
        background: linear-gradient(135deg, var(--accent), #ff1f5a);
        box-shadow: 0 10px 20px rgba(233, 69, 96, 0.3);
    }
}

/* Update the unlocking animation to handle the lock icon */
.level.unlocking::before {
    animation: fadeLockOut 0.5s forwards;
}

@keyframes fadeLockOut {
    0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0);
    }
}

.level.blue {
  background: linear-gradient(135deg, var(--accent), #1E90FF);
  cursor: pointer;
  box-shadow: 0 10px 20px rgba(233, 69, 96, 0.3);
}

.level.unlocking {
  animation: unlockLevel 1s forwards;
}

.level.green {
  background: linear-gradient(135deg, var(--success), #45b649);
  border: 2px solid var(--gold);
  box-shadow: 0 0 30px var(--gold);
  animation: pulse 2s infinite;
}

/* Question screen specific styles */
.question-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1.5rem;
  height: 100vh;
  padding: 1rem 1rem 2rem;
    min-height: 100vh;
    height: auto;
    justify-content: space-between;
    gap: 0.5rem;
    justify-content: space-between;
    padding: 1rem 1rem 2rem;
    overflow: hidden;
}

.question-word {
  font-size: 4rem;
  font-weight: 700;
  color: var(--gold);
  text-shadow: 0 2px 10px rgba(255,215,0,0.3);
  animation: float 3s ease-in-out infinite;
  margin: 0;
  padding: 1rem;
}

/* Progress Circle Styles - Updated */
.progress-circle {
    width: 200px;
    height: 200px;
    position: relative;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 1rem 0;
}

.progress-circle svg {
    position: absolute;
    width: 100%;
    height: 100%;
    transform: rotate(-90deg);
}

.progress-circle circle {
    fill: none;
    stroke-linecap: round;
}

.progress-circle .bg {
    stroke: rgba(255, 255, 255, 0.1);
}

.progress-circle .progress {
    stroke: var(--gold);
    transition: stroke-dashoffset 0.5s ease;
}

.progress-circle.completed {
    animation: pulseGrow 0.4s ease-in-out infinite;
}

.progress-circle.completed circle.progress {
    animation: colorShift 0.4s ease-in-out infinite;
    transition: stroke 0.3s linear;
}

@keyframes colorShift {
    0%, 100% { 
        stroke: var(--gold);
        filter: brightness(1.5);
    }
    50% { 
        stroke: #1E90FF; /* Lapiz Lazuli */
        filter: brightness(1.2);
    }
}

.progress-circle[data-progress="low"] .progress {
    stroke: var(--gold);
}

.progress-circle[data-progress="medium"] .progress {
    stroke: #FFA500; /* Orange */
}

.progress-circle[data-progress="high"] .progress {
    stroke: var(--success);
}

.progress-circle[data-progress="complete"] .progress {
    stroke: #1E90FF; /* Lapiz Lazuli */
}

.completion-ripple {
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    border: 2px solid var(--gold);
    animation: rippleOut 1s ease-out forwards;
}

@keyframes rippleOut {
    0% {
        transform: scale(1);
        opacity: 1;
    }
    100% {
        transform: scale(1.5);
        opacity: 0;
    }
}

@keyframes pulseGrow {
    0%, 100% { 
        transform: scale(1); 
        filter: brightness(1);
    }
    50% { 
        transform: scale(1.05); 
        filter: brightness(1.2);
    }
}

.failure-overlay .failure-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2rem;
}

.failure-overlay .restart-button {
    margin: 0 auto;
}

.failure-overlay .home-button {
    display: none;
}

.game-notification {
    position: fixed;
    top: 20px;
    left: 20px;
    padding: 1rem 2rem;
    border-radius: 10px;
    color: var(--text);
    background: var(--glass);
    backdrop-filter: blur(10px);
    z-index: 1100;
    transform: translateX(-100%);
    opacity: 0;
    transition: all 0.3s ease;
}

.game-notification.show {
    transform: translateX(0);
    opacity: 1;
}

.game-notification.success {
    border-left: 4px solid var(--success);
}

.game-notification.error {
    border-left: 4px solid var(--error);
}

.level.mixed {
    background: linear-gradient(135deg, var(--accent), var(--gold));
    position: relative;
    overflow: hidden;
}

.level.mixed::before {
    content: '';
    position: absolute;
    inset: -50%;
    background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.2) 50%, transparent 70%);
    animation: shimmerEffect 3s infinite linear;
}

@keyframes shimmerEffect {
    0% { transform: translate(-100%, -100%) rotate(45deg); }
    100% { transform: translate(100%, 100%) rotate(45deg); }
}

.custom-list-dropdown {
    position: absolute;
    top: 100%;
    left: 0;
    width: 100%;
    max-height: 300px;
    overflow-y: auto;
    background: var(--glass);
    backdrop-filter: blur(10px);
    border-radius: 15px;
    padding: 1rem;
    margin-top: 0.5rem;
    z-index: 1000;
    border: 1px solid rgba(255,255,255,0.1);
}

.selected-lists {
    margin: 1rem 0;
}

.list-item {
    display: flex;
    align-items: center;
    padding: 0.75rem;
    margin: 0.5rem 0;
    background: rgba(255,255,255,0.1);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.list-item:hover {
    background: rgba(255,255,255,0.2);
    transform: translateY(-2px);
}

.perks-container {
  display: flex;
  gap: 1rem;
  margin: 1rem 0;
  background: var(--glass);
  padding: 0.75rem;
  border-radius: 25px;
  backdrop-filter: blur(10px);
}

.perk-button {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.25rem;
  padding: 0.5rem;
  border-radius: 15px;
  cursor: pointer;
  transition: all 0.3s ease;
  background: rgba(255, 255, 255, 0.1);
  border: none;
  color: var(--text);
}

.perk-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.perk-button:not(:disabled):hover {
  background: rgba(255, 255, 255, 0.2);
  transform: translateY(-2px);
}

.perk-icon {
  font-size: 1.5rem;
  color: var(--gold);
}

.perk-count {
  font-size: 0.8rem;
  font-weight: bold;
}

.timer-container {
    position: absolute;
    visibility: hidden;
    opacity: 0;
    pointer-events: none;
    height: 0;
    margin: 0;
}

.timer-value {
    font-size: 0;
    padding: 0;
}

.timer-value.warning {
  color: var(--error);
  text-shadow: 0 0 15px rgba(244, 67, 54, 0.5);
  animation: warningPulse 1s infinite;
}

.buttons {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
  max-width: 800px;
  width: 100%;
  margin: 1rem auto;
  margin-bottom: 0rem;
  padding: 0 1rem;
}

.buttons button {
  padding: 1rem 2rem;
  font-size: 1.2rem;
  font-weight: 600;
  color: var(--primary);
  background: var(--text);
  border: none;
  border-radius: 15px;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 5px 15px rgba(0,0,0,0.1);
}

.buttons button:hover {
  transform: translateY(-5px);
  box-shadow: 0 10px 20px rgba(0,0,0,0.2);
}

.buttons button.correct {
  background: var(--success);
  color: var(--text);
  animation: correctAnswer 0.5s ease;
}

.buttons button.wrong {
  background: var(--error);
  color: var(--text);
  animation: wrongAnswer 0.5s ease;
}

.failure-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background 1s ease;
  z-index: 1000;
}

.failure-overlay.show {
  background: rgba(0, 0, 0, 0.9);
}

.failure-content {
  text-align: center;
  transform: translateY(50px);
  opacity: 0;
  transition: all 1s ease;
}

.failure-overlay.show .failure-content {
  transform: translateY(0);
  opacity: 1;
}

.failure-title {
  font-size: 3rem;
  color: var(--error);
  margin-bottom: 2rem;
  text-shadow: 0 2px 10px rgba(244, 67, 54, 0.3);
}

.failure-buttons {
  display: flex;
  gap: 2rem;
  justify-content: center;
}

.restart-button, .home-button {
  padding: 1rem;
  width: 80px;
  height: 80px;
  font-size: 2rem;
  color: var(--text);
  background: var(--accent);
  border: none;
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 10px 20px rgba(233, 69, 96, 0.3);
}

.restart-button:hover, .home-button:hover {
  transform: translateY(-5px);
  box-shadow: 0 15px 30px rgba(233, 69, 96, 0.4);
}

.coins-container {
    position: absolute;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 2;
}

.coins-container .coin-icon {
    color: var(--gold);
    font-size: 2rem;
    filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.5));
}

.coins-container .coin-count {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--text);
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
}

.coin-pulse {
    animation: coinPulse 0.5s ease-in-out 3;
}

.skip-button {
    position: absolute;
    top: 1rem;
    left: 1rem;
    padding: 0.5rem 1rem;
    border: none;
    background: rgba(255,255,255,0.1);
    color: var(--text);
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.skip-button:hover {
    background: rgba(255,255,255,0.2);
}

.coins-header {
  position: fixed;
  top: 2rem;
  right: 2rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  background: var(--glass);
  padding: 0.75rem 1.5rem;
  border-radius: 25px;
  backdrop-filter: blur(10px);
  z-index: 100;
}

.user-tier {
    position: relative;
    top: 2rem;
    display: flex; /* Add this to enable flexbox alignment */
    justify-content: center; /* Center horizontally */
    align-items: center; /* Center vertically */
    z-index: 100;
    min-width: 200px;
    text-align: center;
    backdrop-filter: blur(10px);
    padding: 0;
    border-radius: 0;
}

.user-info {
    position: fixed;
    top: 2rem;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    z-index: 100;
}

#userEmail {
    font-size: 1.5rem;
    color: var(--gold);
    margin-bottom: 0.5rem;
}

.tier-text {
    font-weight: 600;
    font-size: 1.1rem;
}

.tier-text.unregistered {
    color: #ff4444;
}

.tier-text.trial {
    color: #ffa500;
}

.tier-text.pending {
    color: #00bfff;
    animation: pendingBlink 2s infinite;
}

.tier-text.premium {
    color: #4CAF50;
}

@keyframes pendingBlink {
    0%, 100% { opacity: 0.7; }
    50% { opacity: 1; }
}

.upgrade-confirmation-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
}

.modal-backdrop {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
}

.confirmation-content {
    background: var(--glass);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 2rem;
    text-align: center;
    max-width: 400px;
    z-index: 2001;
}

.confirmation-content h2 {
    color: var(--gold);
    margin-bottom: 1rem;
}

.continue-button {
    margin-top: 1rem;
    padding: 0.75rem 1.5rem;
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 25px;
    cursor: pointer;
    transition: background 0.3s ease;
}

.continue-button:hover {
    background: color-mix(in srgb, var(--accent) 90%, white);
}

.confirmation-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.7);
    opacity: 0;
    transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    z-index: 1001;
    pointer-events: none;
    width: 90%;
    max-width: 500px;
    background: var(--primary-dark);
    padding: 2rem;
    border-radius: 20px;
    box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    border: 2px solid var(--accent);
    text-align: center;
}

.confirmation-popup.show {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
    pointer-events: auto;
    animation: popupAppear 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.confirmation-popup h2 {
    color: var(--gold);
    margin-bottom: 1.5rem;
}

.confirmation-popup p {
    color: var(--text);
    margin-bottom: 2rem;
}

.confirmation-popup button {
    position: relative;
    padding: 0.875rem 2rem;
    border: 2px solid var(--accent);
    background: transparent;
    color: var(--text);
    border-radius: 50px;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.confirmation-popup button:hover {
    box-shadow: 0 0 15px var(--accent), 0 0 30px var(--accent);
}

.level.boss {
    background: linear-gradient(135deg, var(--gold), var(--accent));
    border: 2px solid var(--gold);
    box-shadow: 0 0 20px var(--gold);
    position: relative;
    overflow: hidden;
}

.level.boss::before {
    content: 'ðŸ‘‘';
    position: absolute;
    top: -10px;
    right: -10px;
    font-size: 1.2rem;
    transform: rotate(45deg);
}

/* Update level grid for 21 levels */
.level-selection {
    grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
    max-width: 1200px;
    gap: 1rem;
    padding: 2rem;
}

.user-tier {
    display: block; /* Ensure it's always visible */
    text-align: center;
    margin-top: 0.5rem;
}

.tier-text {
    font-weight: 600;
    font-size: 1rem;
    padding: 0.25rem 0.5rem;
    border-radius: 15px;
    background: rgba(255,255,255,0.1);
}

.tier-text.unregistered { color: #ff4444; }
.tier-text.trial { color: #ffa500; }
.tier-text.pending { 
    color: #00bfff;
    animation: pendingBlink 2s infinite;
}
.tier-text.premium { color: #4CAF50; }

@keyframes pendingBlink {
    0%, 100% { opacity: 0.7; }
    50% { opacity: 1; }
}

.leaderboard-screen {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 2rem;
    min-height: 100vh;
}

.leaderboard-container {
    background: var(--glass);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 2rem;
    width: 100%;
    max-width: 800px;
    margin-top: 2rem;
}

#arcade-leaderboard {
    width: 100%;
    max-width: 800px;
    margin: 0 auto;
    padding: 2rem;
}

.leaderboard-header {
    display: grid;
    grid-template-columns: 0.5fr 2fr 1fr 1fr;
    padding: 1rem 2rem;
    background: rgba(255,255,255,0.1);
    border-radius: 10px;
    margin-bottom: 1rem;
    font-weight: bold;
    font-size: 1.1rem;
}

.leaderboard-header > div {
    text-align: center;
}

.leaderboard-entry.moving-up {
    background: rgba(76, 175, 80, 0.08);
    animation: moveUp 0.8s ease-in-out forwards;
    z-index: 2;
}

.leaderboard-entry.moving-down {
    background: rgba(244, 67, 54, 0.08);
    animation: moveDown 0.8s ease-in-out forwards;
    z-index: 1;
}

@keyframes moveUp {
    0% { transform: translateY(65px); }
    100% { transform: translateY(0); }
}

@keyframes moveDown {
    0% { transform: translateY(-65px); }
    100% { transform: translateY(0); }
}

.leaderboard-entry:hover {
    background: rgba(255,255,255,0.1);
}

.leaderboard-entry.you {
    background: rgba(6, 145, 64, 0.2);
    border: 1px solid var(--gold);
}

.leaderboard-entry.rank-1 {
    color: var(--gold);
}

.leaderboard-entry.rank-2 {
    color: var(--silver);
}

.leaderboard-entry.rank-3 {
    color: var(--bronze);
}

@media (max-width: 768px) {
    .leaderboard-header, 
    .leaderboard-entry {
        padding: 1rem;
        font-size: 0.9rem;
    }
}

    .leaderboard-header, 
    .leaderboard-entry {
        grid-template-columns: 0.5fr 2fr 1fr 1fr 1fr;
        font-size: 0.9rem;
        padding: 0.75rem;
    }

.premium-celebration {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, rgba(26, 26, 46, 0.95), rgba(22, 33, 62, 0.95));
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.5s ease;
}

.premium-celebration.show {
    opacity: 1;
    pointer-events: auto;
}

.celebration-content {
    text-align: center;
    transform: translateY(30px);
    transition: transform 0.5s ease;
}

.premium-celebration.show .celebration-content {
    transform: translateY(0);
}

.celebration-title {
    font-size: 3rem;
    color: var(--gold);
    margin-bottom: 2rem;
    text-shadow: 0 2px 10px rgba(255,215,0,0.3);
}

.celebration-message {
    font-size: 1.5rem;
    color: var(--text);
    margin-bottom: 2rem;
    line-height: 1.5;
}

.celebration-button {
    padding: 1rem 2rem;
    font-size: 1.2rem;
    background: var(--gold);
    color: var(--primary-dark);
    border: none;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.celebration-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(255,215,0,0.3);
}

.toast {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    padding: 1rem 2rem;
    border-radius: 25px;
    z-index: 1000;
    color: white;
    font-weight: bold;
    opacity: 0;
    transition: all 0.3s ease;
}

.toast.success {
    background-color: #4CAF50;
}

.toast.error {
    background-color: #f44336;
}

.toast.show {
    opacity: 1;
    transform: translate(-50%, 0);
}

.toast.hide {
    opacity: 0;
    transform: translate(-50%, -20px);
}

/* Shop Styles */
.shop-container {
  display: flex;
  flex-direction: column;
  gap: 2rem;
  max-width: 800px;
  width: 100%;
  padding: 1rem;
}

.shop-title {
  font-size: 3rem;
  font-weight: 700;
  text-align: center;
  color: var(--gold);
  margin-bottom: 2rem;
}

.shop-items {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
}

.shop-item {
  background: var(--glass);
  border-radius: 20px;
  padding: 2rem;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1.5rem;
  backdrop-filter: blur(10px);
  transition: all 0.3s ease;
  cursor: pointer;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.shop-item:hover {
  transform: translateY(-5px);
  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
}

.shop-item.disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.shop-item-title {
  font-size: 1.5rem;
  font-weight: 600;
  color: var(--text);
}

.shop-item-icon {
  font-size: 2.5rem;
  color: var(--gold);
}

.shop-item-description {
  color: var(--text);
  opacity: 0.8;
  font-size: 0.9rem;
  line-height: 1.4;
}

.shop-item-price {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  color: var(--gold);
  font-size: 1.2rem;
  font-weight: 600;
}

.shop-item-price i {
  font-size: 1.5rem;
}

/* Animations */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes shimmer {
  0% { background-position: -200% center; }
  100% { background-position: 200% center; }
}

@keyframes shine {
  to { transform: rotate(45deg) translate(100%, 100%); }
}

@keyframes pulse {
  0% { box-shadow: 0 0 30px var(--gold); }
  50% { box-shadow: 0 0 50px var(--gold); }
  100% { box-shadow: 0 0 30px var(--gold); }
}

@keyframes float {
  0% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
  100% { transform: translateY(0); }
}

@keyframes correctAnswer {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

@keyframes wrongAnswer {
  0%, 100% { transform: translateX(0); }
  20%, 60% { transform: translateX(-5px); }
  40%, 80% { transform: translateX(5px); }
}

@keyframes unlockSet {
  0% { 
    transform: scale(1);
    background: var(--locked);
  }
  50% { 
    transform: scale(1.1);
    background: var(--gold);
    box-shadow: 0 0 50px var(--gold);
  }
  100% { 
    transform: scale(1);
    background: linear-gradient(135deg, var(--gold), #ffa500);
  }
}

@keyframes unlockLevel {
  0% { 
    transform: scale(1);
    background: var(--locked);
  }
  50% { 
    transform: scale(1.1);
    background: var(--accent);
    box-shadow: 0 0 50px var(--accent);
  }
  100% { 
    transform: scale(1);
    background: linear-gradient(135deg, var(--accent), #1E90FF);
  }
}

@keyframes progressPulsate {
  0% { transform: scale(1); filter: brightness(1); }
  50% { transform: scale(1.1); filter: brightness(1.5); }
  100% { transform: scale(1); filter: brightness(1); }
}

@keyframes warningPulse {
  0% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.8; transform: scale(1.05); }
  100% { opacity: 1; transform: scale(1); }
}

@keyframes coinPulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.2); filter: drop-shadow(0 0 20px var(--gold)); }
  100% { transform: scale(1); }
}

/* Media Queries */
@media (max-width: 768px) {
  .question-screen {
    padding-top: 2rem;
    gap: 1rem;
  }

  .welcome-title {
    font-size: 3rem;
  }
  
  .stage-container {
    grid-template-columns: repeat(2, 1fr);
    padding: 1rem;
    gap: 1rem;
  }
  
  .set-container {
    grid-template-columns: repeat(3, 1fr);
    gap: 0.75rem;
    padding: 0.75rem;
  }
  
  .level-selection {
    grid-template-columns: repeat(5, 1fr);
    gap: 0.5rem;
    padding: 0.5rem;
  }
  
  .level {
    max-width: none;
    aspect-ratio: 1;
    font-size: 1.5rem;
  }
  
  .question-word {
    font-size: 2.5rem;
    margin: 0.5rem 0;
  }

  .progress-circle {
    width: 150px;
    height: 150px;
    margin: 0.5rem 0;
  }
  
  .progress-circle .timer-progress.warning {
    stroke: #f44336; /* This is the --error color */
    filter: drop-shadow(0 0 5px rgba(244, 67, 54, 0.5));
    transition: stroke 0.3s ease, stroke-dashoffset 1s linear;
}


  .timer-value {
    font-size: 2.5rem;
  }
  
  .buttons {
    grid-template-columns: 1fr;
    gap: 0.75rem;
  }
  
  .buttons button {
    min-height: 3.5rem;
    font-size: 1rem;
    padding: 0.75rem;
    line-height: 1.2;
  }

  .coins-header {
    top: 1rem;
    right: 1rem;
    padding: 0.5rem 1rem;
  }

  .perks-container {
    padding: 0.5rem;
    gap: 0.5rem;
    margin: 0.5rem 0;
  }

  .perk-button {
    padding: 0.35rem;
  }

  .perk-icon {
    font-size: 1.2rem;
  }

  .perk-count {
    font-size: 0.7rem;
  }
}

@media (max-width: 480px) {
  .welcome-title {
    font-size: 2.5rem;
    text-align: center;
    padding: 0 1rem;
  }
    
  .stage-container {
    grid-template-columns: 1fr;
  }
  
  .set-container {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .level-selection {
    grid-template-columns: repeat(4, 1fr);
  }

  .question-word {
    font-size: 2rem;
  }

  .progress-circle {
    width: 120px;
    height: 120px;
    margin: 0.5rem 0;
  }

  .timer-value {
    font-size: 2rem;
  }
}

/* Touch Optimizations */
@media (hover: none) {
  .buttons button,
  .stage-button,
  .set-button,
  .level {
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    -webkit-user-select: none;
  }

  .stage-button:hover,
  .set-button:hover,
  .level:hover,
  .buttons button:hover {
    transform: none;
    box-shadow: none;
  }
  
  .buttons button:active,
  .stage-button:active,
  .set-button:active,
  .level:active {
    transform: scale(0.95);
    transition: transform 0.1s;
  }
}

@supports(padding: max(0px)) {
  .screen {
    padding-left: max(2rem, env(safe-area-inset-left));
    padding-right: max(2rem, env(safe-area-inset-right));
    padding-bottom: max(2rem, env(safe-area-inset-bottom));
  }
}

/* Stage-specific themes */
.stage-1 {
  background: linear-gradient(135deg, var(--stage1-primary), var(--stage1-secondary));
}

.stage-1 .stage-button, .stage-1 .set-button.active {
  background: var(--stage1-accent);
}

.stage-2 {
  background: linear-gradient(135deg, var(--stage2-primary), var(--stage2-secondary));
}

.stage-2 .stage-button, .stage-2 .set-button.active {
  background: var(--stage2-accent);
}

.stage-3 {
  background: linear-gradient(135deg, var(--stage3-primary), var(--stage3-secondary));
}

.stage-3 .stage-button, .stage-3 .set-button.active {
  background: var(--stage3-accent);
}

.stage-4 {
  background: linear-gradient(135deg, var(--stage4-primary), var(--stage4-secondary));
}

.stage-4 .stage-button, .stage-4 .set-button.active {
  background: var(--stage4-accent);
}

.stage-5 {
  background: linear-gradient(135deg, var(--stage5-primary), var(--stage5-secondary));
}

.stage-5 .stage-button, .stage-5 .set-button.active {
  background: var(--stage5-accent);
}
  .screen {
    padding-left: max(2rem, env(safe-area-inset-left));
    padding-right: max(2rem, env(safe-area-inset-right));
    padding-bottom: max(2rem, env(safe-area-inset-bottom));
  }

  @keyframes goldGreenPulse {
    0%, 100% { 
        stroke: var(--gold);
        filter: brightness(1.5);
    }
    50% { 
        stroke: #1E90FF; /* Lapiz Lazuli */
        filter: brightness(1.2);
    }
}

@keyframes particleBurst {
    0% { transform: translate(0, 0); opacity: 1; }
    100% { transform: translate(var(--x), var(--y)); opacity: 0; }
}

.particle {
    position: absolute;
    width: 12px; /* Increased from 8px */
    height: 12px; /* Increased from 8px */
    border-radius: 50%;
    pointer-events: none;
    z-index: 1000;
    animation: particleBurst 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
}

@keyframes particleBurst {
    0% { 
        transform: translate(0, 0) scale(1); 
        opacity: 1; 
    }
    100% { 
        transform: translate(var(--x), var(--y)) scale(0.5); 
        opacity: 0; 
    }
}

.progress-circle.completed {
    animation: pulseGrow 0.4s ease-in-out infinite;
}

.progress-circle.completed circle.progress {
    animation: colorShift 0.4s ease-in-out infinite;
    transition: stroke 0.3s linear;
}

@keyframes particleBurst {
    0% { 
        transform: translate(0, 0) scale(1); 
        opacity: 1; 
    }
    100% { 
        transform: translate(var(--x), var(--y)) scale(0); 
        opacity: 0; 
    }
}

/* Add to the existing CSS, preferably in the level-related section */
.level {
    transition: 
        background-color 0.5s ease, 
        box-shadow 0.5s ease, 
        transform 0.5s ease;
}

.level.unlocking {
    animation: unlockLevel 1s forwards;
}

@keyframes unlockLevel {
    0% { 
        transform: scale(1);
        background: var(--locked);
        box-shadow: none;
    }
    50% { 
        transform: scale(1.1);
        background: var(--gold);
        box-shadow: 0 0 30px var(--gold);
    }
    100% { 
        transform: scale(1);
        background: linear-gradient(135deg, var(--accent), #1E90FF);
        box-shadow: 0 10px 20px rgba(233, 69, 96, 0.3);
    }
}

.particle-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    pointer-events: none;
    z-index: 0;
}

.letter-particle {
    position: absolute;
    font-size: 16px;
    color: rgba(255,255,255,0.2);
    user-select: none;
    pointer-events: none;
    opacity: 0;
    font-weight: bold;
    text-shadow: 0 0 3px rgba(255,255,255,0.1);
}

@keyframes letterFloat {
    0% {
        transform: translate(0, 0) rotate(0deg);
        opacity: 0;
    }
    10% {
        opacity: var(--opacity);
    }
    90% {
        opacity: var(--opacity);
    }
    100% {
        transform: translate(var(--moveX), var(--moveY)) rotate(var(--rotate));
        opacity: 0;
    }
}

/* Timer circle styles */
.progress-circle .timer-bg {
    stroke: rgba(255, 255, 255, 0.1);
    fill: none;
}

.progress-circle .timer-progress {
    stroke: rgba(255, 255, 255, 0.9);
    fill: none;
    transform-origin: center;
    transform: rotate(-180deg);
    transition: stroke-dashoffset 1s linear, stroke 0.3s ease;
}

.progress-circle .timer-progress.warning {
    stroke: #f44336;
    filter: drop-shadow(0 0 5px rgba(244, 67, 54, 0.5));
}

/* Initialize the circle properties */
.progress-circle circle.timer-bg,
.progress-circle circle.timer-progress {
    stroke-linecap: round;
}

/* Ensure inner circle doesn't get affected by outer circle animations */
.progress-circle.completed circle.timer-progress {
    animation: none;
}

/* Override any inherited animations for timer circles */
.progress-circle.completed .timer-bg,
.progress-circle.completed .timer-progress {
    animation: none !important;
}



.home-button i, .back-button i {
    color: var(--text);
    font-size: 1.5rem;
}

.home-button:hover, .back-button:hover {
    background: var(--accent);
    transform: scale(1.1);
}

.perk-button.disabled {
    opacity: 0.3;
    cursor: not-allowed;
}

.reset-button i {
    color: var(--text);
    font-size: 1.5rem;
}

.reset-button.warning {
    animation: blinkRed 0.2s linear 5;
}

@keyframes blinkRed {
    0%, 100% { background-color: transparent; }
    50% { background-color: var(--error); }
}


.admin-verification {
    background: var(--glass);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 2rem;
    width: 100%;
    max-width: 800px;
    margin: 2rem auto;
}

.pending-payments {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.payment-request {
    background: rgba(255,255,255,0.1);
    border-radius: 15px;
    padding: 1.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.verification-actions {
    display: flex;
    gap: 1rem;
}

.verification-actions button {
    padding: 0.5rem 1rem;
    border-radius: 25px;
    border: none;
    cursor: pointer;
    transition: all 0.3s ease;
}

.verification-actions button:not(.reject) {
    background: var(--success);
    color: white;
}

.verification-actions button.reject {
    background: var(--error);
    color: white;
}


.navigation-container {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    margin: 1rem 0;
    background: var(--glass);
    padding: 0.75rem;
    border-radius: 25px;
    backdrop-filter: blur(10px);
    position: fixed;
    top: 1rem;
    left: 1rem;
    z-index: 100;
}

.navigation-button {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    padding: 0;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    border: none;
    cursor: pointer;
    transition: background-color 0.3s ease;
    box-shadow: none;
}

.navigation-button:hover {
    background: transparent !important;
    box-shadow: none !important;
    transform: none !important;
}

.navigation-button:hover svg {
    fill: var(--text) !important;
    stroke: var(--text) !important;
}

.navigation-icon {
    font-size: 1.5rem;
    color: var(--text);
}

/* Override any glow effects */
.navigation-button.restart-level {
    color: var(--text);
    animation: none;
}

.navigation-button.restart-level:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-2px);
}

.navigation-button.disabled {
    cursor: pointer;
    opacity: 0.3;
}

@keyframes blinkRed {
    0%, 100% { background-color: transparent; }
    50% { background-color: var(--error); }
}

@keyframes particleBurst {
    0% { 
        transform: translate(0, 0) scale(1); 
        opacity: 1; 
    }
    100% { 
        transform: translate(var(--x), var(--y)) scale(0.5); 
        opacity: 0; 
    }
}

.menu-button {
    position: fixed;
    top: 2rem;
    right: 2rem;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: var(--glass);
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
    z-index: 100;
}

.menu-button:hover {
    transform: scale(1.1);
    background: rgba(255, 255, 255, 0.2);
}

.menu-button .navigation-icon {
    color: var(--text);
    font-size: 1.5rem;
}

.upgrade-prompt {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.7);
    opacity: 0;
    transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    z-index: 1000;
    pointer-events: none;
    width: 90%;
    max-width: 500px;
    background: var(--glass);
    backdrop-filter: blur(10px);
    padding: 2rem;
    border-radius: 20px;
    box-shadow: 0 20px 50px rgba(0,0,0,0.2);
    border: 1px solid rgba(255,255,255,0.1);
}

.upgrade-prompt.show {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
    pointer-events: auto;
    animation: popupAppear 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.upgrade-prompt h2 {
    color: var(--gold);
    margin-bottom: 1.5rem;
    text-align: center;
}

.upgrade-prompt-buttons {
    display: flex;
    gap: 1rem;
    justify-content: center;
    margin-top: 2rem;
}

.lock-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: inherit;
}

.lock-overlay i {
    color: var(--text);
    font-size: 2rem;
    opacity: 0.8;
}

@keyframes popupAppear {
    0% {
        transform: translate(-50%, -50%) scale(0.7) rotate(-5deg);
        opacity: 0;
    }
    70% {
        transform: translate(-50%, -50%) scale(1.05) rotate(2deg);
        opacity: 0.8;
    }
    100% {
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
        opacity: 1;
    }
}


/* Main Custom Practice Container */
.custom-practice-container {
    display: flex;
    gap: 2rem;
    max-width: 1400px;
    margin: 0 auto;
    padding: 2rem;
}

.practice-section {
    flex: 1;
    background: transparent;
    border-radius: 20px;
    padding: 2rem;
    backdrop-filter: none;
    box-shadow: none;
    border: 1px solid rgba(255,255,255,0.1);
}

.lists-section {
    flex: 1;
    background: transparent;
    border-radius: 20px;
    padding: 2rem;
    backdrop-filter: none;
    box-shadow: none;
    border: 1px solid rgba(255,255,255,0.1);
}

.list-name-section {
    margin-bottom: 1.5rem;
}

.list-name-input {
    width: 100%;
    padding: 0.875rem;
    border-radius: 50px;
    border: 1px solid rgba(255,255,255,0.2);
    background: rgba(255,255,255,0.1);
    color: var(--text);
    text-align: center;
    font-size: 1rem;
    transition: all 0.3s ease;
}

.list-name-input:focus {
    outline: none;
    border-color: var(--gold);
    box-shadow: 0 0 10px rgba(255,215,0,0.3);
}

#custom-word-input {
    width: 100%;
    margin-bottom: 1.5rem;
    padding: 1rem;
    border-radius: 15px;
    border: 1px solid rgba(255,255,255,0.2);
    background: rgba(255,255,255,0.1);
    color: var(--text);
    min-height: 120px;
    resize: vertical;
    transition: all 0.3s ease;
}

#custom-word-input:focus {
    outline: none;
    border-color: var(--gold);
    box-shadow: 0 0 10px rgba(255,215,0,0.3);
}

.translation-results {
    background: rgba(255,255,255,0.05);
    border-radius: 15px;
    padding: 1.5rem;
    margin-top: 1.5rem;
}

.word-translation-list {
    display: table;
    width: 100%;
    border-spacing: 0 0.75rem;
}

.word-translation-item {
    display: table-row;
    background: rgba(255,255,255,0.05);
    border-radius: 10px;
    transition: all 0.3s ease;
    cursor: grab;
}

.word-translation-item.dragging {
    opacity: 0.5;
    background: rgba(255,255,255,0.2);
    cursor: grabbing;
}

.word-translation-item > * {
    display: table-cell;
    padding: 0.75rem;
    vertical-align: middle;
    text-align: center;
}

.drag-handle {
    width: 20px;
    color: var(--text);
    opacity: 0.7;
    cursor: grab;
}

.drag-handle:hover {
    opacity: 1;
}

/* Split word input field styles */
.word-translation-item .source-word {
    padding: 0.5rem;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.1);
    color: var(--text);
    margin: 0.5rem;
    width: 200px;
    min-height: 36px;
    text-align: center;
    border: 1px solid rgba(255,255,255,0.2);
    transition: all 0.3s ease;
    display: inline-block;
    vertical-align: middle;
}

.word-translation-item .target-word {
    padding: 0.5rem;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.1);
    color: var(--text);
    margin: 0.5rem;
    width: 200px;
    min-height: 36px;
    text-align: center;
    border: 1px solid rgba(255,255,255,0.2);
    transition: all 0.3s ease;
    display: inline-block;
    vertical-align: middle;
}

.word-translation-item .source-word[contenteditable="true"] {
    font-family: inherit;
    font-size: inherit;
    appearance: none;
    -webkit-appearance: none;
}

.word-translation-item .target-word[contenteditable="true"] {
    font-family: inherit;
    font-size: inherit;
    appearance: none;
    -webkit-appearance: none;
}

.word-translation-item .target-word:not([readonly]) {
    font-family: inherit;
    font-size: inherit;
    appearance: none;
    -webkit-appearance: none;
}

.word-input-actions {
    display: flex;
    gap: 1rem;
    margin: 1rem 0;
    flex-wrap: wrap;
    justify-content: flex-start;
}

/* Split button styles */


.edit-mode-button {
    padding: 0.5rem 1rem;
    border-radius: 50px;
    font-size: 0.9rem;
    font-weight: 600;
    background: var(--accent);
    color: var(--text);
    border: none;
    cursor: pointer;
    transition: all 0.3s ease;
    flex: 0 1 auto;
    min-width: 100px;
    max-width: 150px;
    position: relative;
}

.edit-mode-button::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, transparent 70%);
    transform: rotate(45deg);
    transition: all 0.3s ease;
    opacity: 0;
}

.edit-mode-button:hover::before {
    opacity: 1;
}

.list-actions {
    position: sticky;
    top: 0;
    z-index: 5;
    display: flex;
    gap: 0.75rem;
    padding: 0.5rem 0;
    justify-content: flex-start;
    flex-wrap: wrap;
    background: inherit;
    border-radius: 15px 15px 0 0;
}

.list-actions button {
    position: relative;
    padding: 0.5rem 1rem;
    border: 2px solid var(--accent);
    background: transparent;
    color: var(--text);
    border-radius: 50px;
    font-size: 0.9rem;
    font-weight: 600;
    overflow: hidden;
    cursor: pointer;
    transition: all 0.3s ease;
    flex: 0 1 auto;
    min-width: 100px;
    max-width: 150px;
    box-shadow: none;
}

.list-actions button:hover {
    box-shadow: 0 0 15px var(--accent), 0 0 30px var(--accent);
}

.list-actions button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(120deg, transparent, rgba(233, 69, 96, 0.3), transparent);
    transition: all 0.6s ease;
}

.list-actions button:hover::before {
    left: 100%;
}

.delete-word-btn {
    background: none;
    border: none;
    color: var(--text);
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.2s;
    padding: 0.25rem;
}

.delete-word-btn:hover {
    opacity: 1;
}

.custom-list-item {
    position: relative;
    display: flex;
    flex-direction: column;
    padding: 1.25rem;
    margin-bottom: 1.5rem;
    background: transparent;
    border-radius: 15px;
    backdrop-filter: none;
    border: 1px solid rgba(255,255,255,0.1);
}

.custom-list-item h3 {
    margin-bottom: 0.5rem;
    color: var(--gold);
}

.custom-list-item .list-info {
    margin: 1rem 0;
    color: var(--text);
    opacity: 0.8;
}

.list-header {
    cursor: pointer;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    order: 1; /* Places header after buttons */
}

.list-summary {
    font-size: 0.9rem;
    opacity: 0.8;
}

.list-content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease;
}

.custom-list-item:not(.collapsed) .list-content {
    max-height: 1000px;
    margin-top: 1rem;
}

.list-header {
    cursor: pointer;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.word-preview {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
    margin-top: 0.25rem;
}

.add-word-button {
    display: none;
    margin-top: 1rem;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    border-radius: 50px;
    background: var(--accent);
}

/* Media Queries */

@media (max-width: 768px) {
    .list-actions {
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        width: 100%;
    }
    
    .add-word-button {
        width: 100%;
        justify-content: center;
    }
}

@media (max-width: 768px) {
    .custom-practice-container {
        flex-direction: column;
        gap: 1.5rem;
        padding: 1rem;
    }

    .practice-section {
        padding: 1rem;
        width: 100%;
    }

    .lists-section {
        padding: 1rem;
        width: 100%;
    }

    #custom-word-input {
        min-height: 150px;
        font-size: 16px;
        padding: 1rem;
    }

    .word-translation-list {
        display: block;
    }

    .word-translation-item {
    display: table-row;
    background: transparent;
    border-radius: 10px;
    transition: all 0.3s ease;
    cursor: grab;
    border: 1px solid rgba(255,255,255,0.1);
}

    .word-translation-item .source-word {
        width: 100%;
        min-height: 44px;
        font-size: 16px;
        padding: 0.75rem;
        margin: 0;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
    }

    .word-translation-item .target-word {
        width: 100%;
        min-height: 44px;
        font-size: 16px;
        padding: 0.75rem;
        margin: 0;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
    }

    .word-input-actions {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        width: 100%;
        margin: 1rem 0;
    }

    .word-input-actions button {
        width: 100%;
        min-height: 44px;
        font-size: 1rem;
        padding: 0.75rem;
        margin: 0;
    }

    .list-actions {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 0.75rem;
        margin-top: 1rem;
        width: 100%;
    }

    .list-actions button {
        width: 100%;
        min-height: 44px;
        font-size: 1rem;
        padding: 0.75rem;
        margin: 0;
    }

    .custom-list-item {
        padding: 1.25rem;
        margin-bottom: 1rem;
    }

    .custom-list-item h3 {
        font-size: 1.25rem;
        margin-bottom: 0.75rem;
    }

    .list-info {
        font-size: 0.9rem;
        margin: 0.75rem 0;
    }

    .list-stats {
        grid-column: 1 / -1;
        text-align: center;
        margin-top: 0.75rem;
        font-size: 0.875rem;
        opacity: 0.8;
    }

    .drag-handle {
        display: none;
    }

    .delete-word-btn {
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto;
    }

    .word-preview {
        font-size: 0.85rem;
    }
    
    .custom-list-item:not(.collapsed) {
        padding-bottom: 0.75rem;
    }
}

@media (max-width: 480px) {
    .custom-practice-container {
        padding: 0.5rem;
    }

    .start-button {
        width: 100%;
        max-width: 250px;
        font-size: 0.9rem;
        padding: 0.6rem;
    }

    .edit-mode-button {
        width: 100%;
        max-width: none;
        font-size: 0.9rem;
        padding: 0.6rem;
    }

    .list-actions button {
        width: 100%;
        max-width: none;
        font-size: 0.9rem;
        padding: 0.6rem;
    }

    .list-actions {
        grid-template-columns: 1fr;
    }

    .custom-list-item h3 {
        font-size: 1.1rem;
    }

    .list-info {
        font-size: 0.85rem;
    }

    .word-translation-item {
        padding: 0.75rem;
    }

    .word-translation-item .source-word {
        font-size: 0.95rem;
        padding: 0.6rem;
    }

    .word-translation-item .target-word {
        font-size: 0.95rem;
        padding: 0.6rem;
    }
}

@media (max-width: 360px) {
    .custom-practice-container {
        padding: 0.25rem;
    }

    .practice-section {
        padding: 0.75rem;
    }

    .lists-section {
        padding: 0.75rem;
    }

    .word-input-actions button {
        font-size: 0.85rem;
        padding: 0.5rem;
    }

    .list-actions button {
        font-size: 0.85rem;
        padding: 0.5rem;
    }

    .custom-list-item {
        padding: 1rem;
    }

    .custom-list-item h3 {
        font-size: 1rem;
    }
}

.username-display {
    padding: 0.75rem;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 15px;
    margin-bottom: 0.5rem;
    color: var(--gold);
    font-weight: bold;
}

.victory-screen {
    background: rgba(0,0,0,0.9);
}

.victory-screen .completion-modal-content {
    background: transparent;
    display: flex;
    flex-direction: column;
    align-items: center;
    max-width: 400px;
    padding: 0;
    border-radius: 20px;
    overflow: hidden;
}

.victory-header {
    width: 100%;
    text-align: center;
    padding: 1.5rem;
    color: white;
}

.victory-header .rank-emoji {
    font-size: 3rem;
    display: block;
    margin-bottom: 0.5rem;
}

.victory-header h2 {
    font-size: 1.5rem;
    text-transform: uppercase;
    letter-spacing: 2px;
}

.victory-message {
    padding: 1rem;
    text-align: center;
    background: rgba(255,255,255,0.1);
    width: 100%;
}

.completion-stats {
    display: flex;
    justify-content: space-around;
    width: 100%;
    padding: 1.5rem;
    background: rgba(255,255,255,0.05);
}

.stat-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}

.stat-icon {
    font-size: 2rem;
    margin-bottom: 0.5rem;
}

.stat-label {
    font-size: 0.8rem;
    color: rgba(255,255,255,0.7);
    text-transform: uppercase;
}

.stat-value {
    font-size: 1.5rem;
    font-weight: bold;
    color: white;
}

.victory-button {
    width: 100%;
    padding: 1rem;
    background: var(--accent);
    color: white;
    border: none;
    font-size: 1rem;
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: background 0.3s ease;
}

.victory-button:hover {
    background: color-mix(in srgb, var(--accent) 90%, white);
}

    </style>
</head>
<body>

<div id="qr-landing" class="screen" style="display: none;">
    <div class="qr-landing-content">
        <h2>Welcome to Simplos Arcade!</h2>
        <p>Your game code is:</p>
        <div class="game-code-display"></div>
        <button class="join-game-button" onclick="proceedToGame()">
            Join Game
        </button>
    </div>
</div>


  <div id="welcome-screen" class="screen visible">
    <div class="particle-container" id="particleContainer"></div>    
    <h1 class="welcome-title">Simplos</h1>
    
    <div class="main-buttons">
    <button class="main-button primary" onclick="showAuthModal()">Login / Sign Up</button>
    <button class="main-button guest-play-button" onclick="startGame()">Play as Guest</button>
    <button class="main-button arcade-button" onclick="showArcadeModal()">Arcade</button>
    <button class="main-button" disabled>Download the App</button>
</div>

    <!-- New Auth Modal -->
    <div id="authModal" class="auth-modal">
        <div class="auth-modal-content">
            <div id="loginForm" class="auth-form">
                <h2>Login</h2>
                <input type="text" class="auth-input" placeholder="Username" id="loginUsername">
                <input type="password" class="auth-input" placeholder="Password" id="loginPassword">
                <button class="auth-button" onclick="handleLogin()">Login</button>
                <button class="auth-toggle" onclick="toggleAuthMode()">New? Register here</button>
            </div>
            <div id="signupForm" class="auth-form hidden">
                <h2>Sign Up</h2>
                <input type="email" class="auth-input" placeholder="Email" id="signupEmail">
                <input type="text" class="auth-input" placeholder="Username" id="signupUsername">
                <input type="password" class="auth-input" placeholder="Password" id="signupPassword">
                <button class="auth-button" onclick="handleSignup()">Sign Up</button>
                <button class="auth-toggle" onclick="toggleAuthMode()">Already have an account?</button>
            </div>
        </div>
    </div>

    <!-- Side Panel -->
    <button class="hamburger-button" onclick="toggleSidePanel()">
       <i class="fas fa-bars"></i>
   </button>

   <div class="side-panel">
    <div class="side-panel-content">
        <button class="logout-button logout-top-button">
    <i class="fas fa-sign-out-alt"></i> Logout
</button>        
        <div class="welcome-buttons">
            <a href="#" class="nav-link" onclick="showScreen('stage-screen'); return false;">
    <i class="fas fa-map-marked-alt"></i> Level Map
</a>
            <a href="#" class="nav-link" onclick="showCustomListsManager(); return false;">
                <i class="fas fa-list"></i> My Lists
            </a>
            <a href="#" class="nav-link" onclick="showLeaderboard(); return false;">
                <i class="fas fa-trophy"></i> Speedboard
            </a>
            <a href="#" class="nav-link" onclick="showPricesScreen(); return false;">
                <i class="fas fa-dollar-sign"></i> Prices
            </a>
            <a href="#" class="nav-link" onclick="showRightsAndPolicies(); return false;">
                <i class="fas fa-balance-scale"></i> Rights & Policies
            </a>
            <a href="#" class="nav-link" onclick="showAboutPage(); return false;">
                <i class="fas fa-info-circle"></i> About
            </a>
            <a href="#" class="nav-link" onclick="showContactUs(); return false;">
                <i class="fas fa-envelope"></i> Contact Us
            </a>
        </div>
        
        <div class="user-profile-section user-profile-bottom">
            <div class="username-display" id="userEmail"></div>
            <div class="status-badge" id="userTierText"></div>
            
            <div class="user-stats">
                <div class="stat-item">
                    <div class="stat-label">Words</div>
                    <div class="stat-value" id="totalWords">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Coins</div>
                    <div class="stat-value">
                        <i class="fas fa-coins coin-icon"></i>
                        <span id="totalCoins">0</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
</div>

<div id="stage-screen" class="screen">
    <div class="particle-container"></div>
    <div class="navigation-container" style="position: fixed; top: 1rem; left: 50%; transform: translateX(-50%); flex-direction: row; gap: 0.75rem; background: none; margin: 0;">
    <button class="navigation-button home-button" onclick="navigateHome()">
        <i class="fas fa-home navigation-icon"></i>
    </button>
    <button class="navigation-button reset-button" onclick="handleResetProgress()">
        <i class="fas fa-trash-alt navigation-icon"></i>
    </button>
    <button class="navigation-button fullscreen-button" onclick="toggleFullScreen()">
        <i class="fas fa-expand navigation-icon"></i>
    </button>
</div>
    <div class="stage-container">
        <div class="stage-button junior-level" onclick="showSetScreen(1)">
            <div class="stage-name">×ž×ª×—×™×œ×™×</div>
            Stage 1
        </div>
        <div class="stage-button bronze-level" onclick="showSetScreen(2)">
            <div class="stage-name">×™×¡×•×“×™</div>
            Stage 2
        </div>
        <div class="stage-button silver-level" onclick="showSetScreen(3)">
            <div class="stage-name">×—×˜×™×‘×ª ×‘×™× ×™×™×</div>
            Stage 3
        </div>
        <div class="stage-button gold-level" onclick="showSetScreen(4)">
            <div class="stage-name">×ª×™×›×•×Ÿ</div>
            Stage 4
        </div>
        <div class="stage-button diamond-level" onclick="showSetScreen(5)">
            <div class="stage-name">××•× ×™×‘×¨×¡×™×˜×”</div>
            Stage 5
        </div>
    </div>
</div>

<div id="set-screen" class="screen">
    <div class="particle-container"></div>
    <div class="navigation-container">
        <button class="navigation-button home-button" onclick="showScreen('welcome-screen')">
            <i class="fas fa-home navigation-icon"></i>
        </button>
    </div>
    <div class="set-container" id="set-container"></div>
</div>

<div id="level-screen" class="screen">
    <div class="particle-container"></div>
    <div class="navigation-container">
        <button class="navigation-button home-button" onclick="showScreen('welcome-screen')">
            <i class="fas fa-home navigation-icon"></i>
        </button>
    </div>
    <div class="level-selection" id="level-container"></div>
</div>

<div id="question-screen" class="screen">
    <div class="particle-container"></div>
    <div class="navigation-container">
        <button class="navigation-button home-button" onclick="showScreen('welcome-screen')">
            <i class="fas fa-home navigation-icon"></i>
        </button>
    </div>

    

    <!-- Question Word -->
    <div class="question-word" id="question-word"></div>

    <!-- Progress Circle with Timer and Coins -->
    <div class="progress-circle">
        <svg width="100%" height="100%" viewBox="0 0 120 120">
            <circle class="bg" cx="60" cy="60" r="54" stroke-width="8"/>
            <circle class="progress" cx="60" cy="60" r="54" stroke-width="8"/>
            <circle class="timer-bg" cx="60" cy="60" r="40" stroke-width="4"/>
            <circle class="timer-progress" cx="60" cy="60" r="40" stroke-width="4"/>
        </svg>
        <div class="coins-container">
            <i class="fas fa-coins coin-icon"></i>
            <span class="coin-count">0</span>
        </div>
    </div>

    <!-- Perks Container -->
    <div class="perks-container">
        <button class="perk-button" id="timeFreezePerk">
            <i class="fas fa-clock perk-icon"></i>
            <span class="perk-count">0</span>
        </button>
        <button class="perk-button" id="skipPerk">
            <i class="fas fa-forward perk-icon"></i>
            <span class="perk-count">0</span>
        </button>
        <button class="perk-button" id="cluePerk">
            <i class="fas fa-lightbulb perk-icon"></i>
            <span class="perk-count">0</span>
        </button>
        <button class="perk-button" id="revealPerk">
            <i class="fas fa-eye perk-icon"></i>
            <span class="perk-count">0</span>
        </button>
    </div>


    
    <!-- Replace the old powerups-container content with this -->
    <div class="powerups-container">
    <!-- Goodies -->
    <div class="powerup-card goodie" id="highFiveCard">
        <i class="fas fa-hand-paper powerup-icon"></i>
        <div class="powerup-name">High Five</div>
        <div class="powerup-cost">30</div>
    </div>
    <div class="powerup-card goodie" id="fistBumpCard">
        <i class="fas fa-fist-raised powerup-icon"></i>
        <div class="powerup-name">Fist Bump</div>
        <div class="powerup-cost">40</div>
    </div>
    <div class="powerup-card goodie" id="energyBoostCard">
        <i class="fas fa-bolt powerup-icon"></i>
        <div class="powerup-name">Energy Boost</div>
        <div class="powerup-cost">45</div>
    </div>

    <!-- Baddies -->
    <div class="powerup-card baddie" id="freezeCard">
        <i class="fas fa-snowflake powerup-icon"></i>
        <div class="powerup-name">Freeze</div>
        <div class="powerup-cost">150</div>
    </div>
    <div class="powerup-card baddie" id="coinStormCard">
        <i class="fas fa-cloud-showers-heavy powerup-icon"></i>
        <div class="powerup-name">Coin Storm</div>
        <div class="powerup-cost">160</div>
    </div>
    <div class="powerup-card baddie" id="screenShakeCard">
        <i class="fas fa-shake powerup-icon"></i>
        <div class="powerup-name">Screen Shake</div>
        <div class="powerup-cost">130</div>
    </div>
</div>

    <!-- Timer Container -->
    <div class="timer-container">
        <div class="timer-value">00:00</div>
    </div>

    <!-- Answer Buttons -->
    <div class="buttons" id="buttons"></div>
</div>

<!-- Failure Overlay -->
<div class="failure-overlay" style="display: none;">
    <div class="failure-content">
        <h2 class="failure-title">Time's Up!</h2>
        <div class="failure-buttons">
            <button class="restart-button">
                <i class="fas fa-redo"></i>
            </button>
            <button class="home-button">
                <i class="fas fa-home"></i>
            </button>
        </div>
    </div>
</div>
<div id="custom-practice-screen" class="screen">
    <div class="navigation-container">
        <button class="navigation-button home-button" onclick="showScreen('welcome-screen')">
            <i class="fas fa-home navigation-icon"></i>
        </button>
    </div>

    <div class="custom-practice-container">
        <div class="lists-section">
            <h2 class="welcome-title">My Word Lists</h2>
            <div id="custom-lists-container" class="custom-lists-container">
                <!-- Lists will be dynamically populated here -->
            </div>
        </div>
        
        <div class="practice-section">
            <h2 class="welcome-title">Create Custom Word List</h2>
            <div class="list-name-section">
                <input 
                    type="text" 
                    id="custom-list-name" 
                    class="list-name-input" 
                    placeholder="List Name"
                >
            </div>
            <textarea 
                id="custom-word-input" 
                placeholder="Enter words, separated by commas or newlines"
            ></textarea>
            <div class="word-input-actions">
    <button 
        onclick="processCustomWords()" 
        class="start-button"
    >
        Make
    </button>
    <button 
        onclick="saveCurrentList()" 
        class="start-button"
    >
        Save
    </button>
    <button 
    onclick="addNewWord()" 
    class="start-button add-word-button"
>
    Add Word
</button>
</div>
<div class="translation-results" id="translation-results">
    <div class="word-translation-list" id="word-translation-list">
        <!-- Processed words will appear here -->
    </div>
</div>
            </div>
        </div>
    </div>
</div>


<div id="upgrade-screen" class="screen">
    <div class="upgrade-modal">
        <div class="upgrade-form">
    <h2>×©×“×¨×•×’ ×œ×¤×¨×™×ž×™×•×</h2>
    <form id="upgradeForm" onsubmit="handleUpgradeSubmit(event)">
        <div class="form-group">
            <label>
                <input type="checkbox" id="isAdult" onchange="toggleParentFields()" name="isAdult">
                ×× ×™ ×ž×¢×œ ×’×™×œ 18
            </label>
        </div>
        
        <!-- Parent Info Section -->
        <div id="parentInfoSection">
            <div class="form-group">
                <label>×©× ×ž×œ× ×©×œ ×”×•×¨×”</label>
                <input type="text" id="parentName" name="parentName">
            </div>
            <div class="form-group">
                <label>×ž×¡×¤×¨ ×˜×œ×¤×•×Ÿ ×©×œ ×”×•×¨×”</label>
                <input type="tel" id="parentPhone" name="parentPhone" 
                       pattern="[0-9]{10}" placeholder="×”×–×Ÿ ×ž×¡×¤×¨ ×˜×œ×¤×•×Ÿ ×©×œ ×”×•×¨×”">
            </div>
        </div>

        <!-- Adult Info Section -->
        <div id="adultInfoSection" style="display:none;">
            <div class="form-group">
                <label>×©× ×ž×œ×</label>
                <input type="text" id="fullName" name="fullName">
            </div>
            <div class="form-group">
                <label>×ž×¡×¤×¨ ×˜×œ×¤×•×Ÿ</label>
                <input type="tel" id="phone" name="phone" 
                       pattern="[0-9]{10}" placeholder="×”×–×Ÿ ×ž×¡×¤×¨ ×˜×œ×¤×•×Ÿ">
            </div>
        </div>

        <div class="form-group">
            <label>××™×š ×©×ž×¢×ª ×¢×œ×™× ×•?</label>
            <select id="referralSource" name="referralSource">
                <option value="friend">×—×‘×¨/×”</option>
                <option value="teacher">×ž×•×¨×”</option>
                <option value="social">×¨×©×ª×•×ª ×—×‘×¨×ª×™×•×ª</option>
                <option value="other">××—×¨</option>
            </select>
        </div>

        <button type="submit" class="submit-button">×©×œ×—/×™ ×‘×§×©×”</button>
        <button type="button" class="skip-button" onclick="skipUpgrade()">×“×œ×’</button>
    </form>
    <p>×œ××—×¨ ×©×œ×™×—×ª ×”×‘×§×©×” × ×™×¦×•×¨ ××™×ª×š ×§×©×¨ ×‘×•×•×˜×¡××¤</p>
</div>
    </div>
</div>

<div id="leaderboard-screen" class="screen">
    <div class="navigation-container">
        <button class="navigation-button home-button" onclick="showScreen('welcome-screen')">
            <i class="fas fa-home navigation-icon"></i>
        </button>
    </div>
    
    <h1 class="welcome-title">Speedboard</h1>
    
    <div class="leaderboard-header">
        <div>Rank</div>
        <div>Player</div>
        <div>Status</div>
    </div>


        <div id="leaderboard-entries">
            <!-- Entries will be populated here -->
        </div>
    </div>
</div>

<div id="arcade-modal" class="modal">
   <div class="modal-content">
       <div id="teacher-view" style="display: none;">
           <h2>Your OTP: <span id="otp"></span></h2>
           <p>Players: <span id="player-count">0</span></p>
           
           <div class="stage-selector">
               <h3>Select Word Pools:</h3>
               <div class="stage-checkboxes">
                   <label>
                       <input type="checkbox" value="1"> Stage 1
                   </label>
                   <label>
                       <input type="checkbox" value="2"> Stage 2
                   </label>
                   <label>
                       <input type="checkbox" value="3"> Stage 3
                   </label>
                   <label>
                       <input type="checkbox" value="4"> Stage 4
                   </label>
                   <label>
                       <input type="checkbox" value="5"> Stage 5
                   </label>
               </div>
               <p class="stage-warning" style="display: none; color: var(--error);">Please select at least one stage</p>
           </div>

           <div class="word-goal">
               <h3>Word Goal:</h3>
               <select id="wordGoal">
                   <option value="5">5 words</option>
                   <option value="100">100 words</option>
                   <option value="200">200 words</option>
               </select>
           </div>

           <button class="start-button" onclick="startArcade()">Start</button>
       </div>

       <div id="player-view" style="display: none;">
        <h2>Join Arcade</h2>
    <div class="input-group">
        <input 
            type="text" 
            id="arcadeUsername" 
            placeholder="Choose your username"
            maxlength="15"
        >
        <input 
            type="text" 
            id="otpInput" 
            placeholder="Enter 4-digit Game Code"
            maxlength="4" 
            pattern="[0-9]{4}"
            inputmode="numeric"
        >
    </div>
    <button class="join-button" onclick="joinArcadeWithUsername()">Join Game</button>
</div>
   </div>
</div>

<div id="waiting-screen" class="screen">
    <div class="waiting-container">
        <div class="spinner-container">
            <div class="spinner"></div>
        </div>
        <h2 class="waiting-title">Waiting for Game to Start...</h2>
        <div class="player-count">
            <span id="waiting-player-count">0</span> Players Ready
        </div>
        <div class="floating-particles"></div>
    </div>
</div>

<div id="moderator-screen" class="screen">
    <div class="moderator-container">
        <div class="session-info-panel">
            <div class="session-details">
    <h2>Arcade Session</h2>
    <div class="otp-display" id="moderatorOtp"></div>
    <div class="qr-section">
        <canvas id="qrCode"></canvas>
        <p class="qr-hint">Scan to join game</p>
                </div>
                    <div class="session-metadata">
                    <p>Date: <span id="sessionDate"></span></p>
                    <p>Start Time: <span id="sessionStartTime"></span></p>
                    <p>Word Goal: <span id="sessionWordGoal"></span></p>
                    <p>Active Participants: <span id="activeParticipantCount">0</span></p>
                </div>
                <div class="game-controls">
                    <button class="start-button initialize-button" onclick="initializeArcade()">
                        Initialize Arcade
                    </button>
                    <button class="end-arcade-button" onclick="endArcade()">
                        End Arcade
                    </button>
                </div>
            </div>
        </div>
        <div class="leaderboard-panel">
            <div id="arcade-leaderboard" class="moderator-leaderboard">
                <div class="leaderboard-header">
                    <div>Rank</div>
                    <div>Player</div>
                    <div>Words</div>
                    <div>Coins</div>
                    <div>Actions</div>
                </div>
                <!-- Participants will be dynamically populated here -->
            </div>
        </div>
    </div>
</div>

<div id="remove-player-modal" class="modal">
   <div class="modal-content">
       <h3>Remove Player</h3>
       <p>Remove <span id="player-to-remove"></span> from the game?</p>
       <div class="modal-buttons">
           <button class="start-button" onclick="confirmRemovePlayer()">Remove</button>
           <button class="start-button secondary" onclick="closeRemoveModal()">Cancel</button>
       </div>
   </div>
</div>

<script>
    
    document.addEventListener('DOMContentLoaded', () => {
    const logoutButton = document.querySelector('.logout-button');
    if (logoutButton) {
        logoutButton.addEventListener('click', handleLogout);
    }
});

document.addEventListener('click', (e) => {
    const sidePanel = document.querySelector('.side-panel');
    const hamburgerButton = document.querySelector('.hamburger-button');
    
    if (sidePanel.classList.contains('open') && 
        !sidePanel.contains(e.target) && 
        !hamburgerButton.contains(e.target)) {
        toggleSidePanel();
    }
});

    document.addEventListener('DOMContentLoaded', () => {
    const gameAssets = {
        stages: {}, // Cache stage data
        currentWords: [], // Cache current level words
        particles: new Set() // Reuse particle elements
    };
});

const ParticleSystem = {
    particlePool: [],
    maxParticles: 50,

    init() {
        // Pre-create particle elements
        for(let i = 0; i < this.maxParticles; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            this.particlePool.push(particle);
        }
    },

    createParticle(x, y) {
        const particle = this.particlePool.pop();
        if (!particle) return;

        // Reuse particle instead of creating new
        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;
        
        setTimeout(() => {
            this.particlePool.push(particle);
        }, 1000);
    }
};

// Use event delegation instead of multiple listeners
document.addEventListener('click', (e) => {
    const target = e.target;
    
    if (target.matches('.game-btn')) {
        handleButtonClick(target);
    } else if (target.matches('.level')) {
        handleLevelClick(target);
    }
});

function updateUI() {
    // Batch DOM updates
    requestAnimationFrame(() => {
        const fragment = document.createDocumentFragment();
        // Add elements to fragment
        document.body.appendChild(fragment);
    });
}

const CoinsManager = {
    displayElements: new Set(),
    
    initialize() {
        this.displayElements.clear();
        document.querySelectorAll('.coin-count').forEach(display => {
            this.displayElements.add(display);
        });
    },
    
    async loadUserCoins() {
        if (!currentUser) {
            return parseInt(localStorage.getItem('simploxCustomCoins') || '0');
        }

        try {
            const { data, error } = await supabaseClient
                .from('game_progress')
                .select('coins')
                .eq('user_id', currentUser.id)
                .single();

            if (error) throw error;
            return data.coins || 0;
        } catch (error) {
            console.error('Error loading coins:', error);
            return 0;
        }
    },

    async updateCoins(amount) {
        try {
            const oldTotal = gameState.coins;
            const newTotal = oldTotal + amount;
            gameState.coins = newTotal;

            // Animate all displays
            this.displayElements.forEach(display => {
                let currentValue = oldTotal;
                const duration = 1000;
                const startTime = performance.now();
                
                function animate(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    currentValue = oldTotal + (newTotal - oldTotal) * progress;
                    display.textContent = Math.round(currentValue);
                    
                    if (amount > 0) {
                        display.style.color = 'var(--success)';
                    } else if (amount < 0) {
                        display.style.color = 'var(--error)';
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        display.textContent = newTotal;
                        setTimeout(() => {
                            display.style.color = 'var(--text)';
                        }, 300);
                    }
                }
                
                requestAnimationFrame(animate);
            });

            // Save to database/localStorage
            if (currentUser) {
                const { error } = await supabaseClient
                    .from('game_progress')
                    .update({ coins: newTotal })
                    .eq('user_id', currentUser.id);

                if (error) throw error;
            } else {
                localStorage.setItem('simploxCustomCoins', newTotal.toString());
            }

            // Update perk buttons based on new coin total
            updatePerkButtons();
            return true;

        } catch (error) {
            console.error('Failed to update coins:', error);
            this.displayElements.forEach(display => {
                display.textContent = gameState.coins - amount;
            });
            updatePerkButtons();  // Also update buttons on error
            return false;
        }
    },

    updateDisplays() {
        this.displayElements.forEach(display => {
            display.textContent = gameState.coins;
        });
        updatePerkButtons();  // Update buttons whenever displays are updated
    }
};

const WordsManager = {
    displayElements: new Set(),
    
    initialize() {
        this.displayElements.clear();
        document.querySelectorAll('#totalWords').forEach(display => {
            this.displayElements.add(display);
        });
    },
    
    async loadUserWords() {
        if (!currentUser) return 0;

        try {
            const { data, error } = await supabaseClient
                .from('player_stats')
                .select('unique_words_practiced')
                .eq('user_id', currentUser.id)
                .single();

            if (error) throw error;
            return data?.unique_words_practiced || 0;
        } catch (error) {
            console.error('Error loading words:', error);
            return 0;
        }
    },

    async updateWords(amount) {
        try {
            // Get current total
            const oldTotal = parseInt(document.getElementById('totalWords').textContent) || 0;
            const newTotal = oldTotal + amount;

            // Animate all displays
            this.displayElements.forEach(display => {
                let currentValue = oldTotal;
                const duration = 1000;
                const startTime = performance.now();
                
                function animate(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    currentValue = oldTotal + (newTotal - oldTotal) * progress;
                    display.textContent = Math.round(currentValue);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        display.textContent = newTotal;
                    }
                }
                
                requestAnimationFrame(animate);
            });

            // Save to database if user is logged in
            if (currentUser) {
                const { error } = await supabaseClient
                    .from('player_stats')
                    .update({ unique_words_practiced: newTotal })
                    .eq('user_id', currentUser.id);

                if (error) throw error;
            }

            return true;
        } catch (error) {
            console.error('Failed to update words:', error);
            return false;
        }
    },

    updateDisplays(value) {
        this.displayElements.forEach(display => {
            display.textContent = value;
        });
    }
};


const perkButtons = {
    timeFreeze: document.getElementById('timeFreezePerk'),
    skip: document.getElementById('skipPerk'),
    clue: document.getElementById('cluePerk'),
    reveal: document.getElementById('revealPerk')
};

// REPLACE the perk button initialization
Object.entries(perkButtons).forEach(([perkType, button]) => {
    if (button) {
        button.onclick = () => buyPerk(perkType);
    }
});

const GameTimer = {
    lastTick: 0,
    
    update(timestamp) {
        if (!this.lastTick) this.lastTick = timestamp;
        const delta = timestamp - this.lastTick;
        
        if (delta >= 1000) { // Update every second
            this.updateTimer();
            this.lastTick = timestamp;
        }
        
        requestAnimationFrame(this.update.bind(this));
    }
};

function cleanupLevel() {
    // Clear unused event listeners
    document.querySelectorAll('.buttons button').forEach(btn => {
        btn.onclick = null;
    });
    
    // Clear particle effects
    ParticleSystem.clear();
    
    // Clear timeouts
    clearTimeout(levelTimeout);
}


async function transitionScreen(screenType) {
    const currentScreen = document.querySelector('.screen.visible');
    if (currentScreen) {
        currentScreen.style.opacity = 0;
        await new Promise(r => setTimeout(r, 300));
        currentScreen.style.display = 'none';
    }
    
    const nextScreen = document.getElementById(`${screenType}-screen`);
    nextScreen.style.display = 'flex';
    requestAnimationFrame(() => {
        nextScreen.style.opacity = 1;
    });
}

const GameCache = {
    words: new Map(),
    
    async getWords(setId) {
        if (this.words.has(setId)) {
            return this.words.get(setId);
        }
        
        const words = await loadWords(setId);
        this.words.set(setId, words);
        return words;
    }
};

const gameInit = {
    async init() {
        await checkExistingSession();
        initializeGame();
        updatePerkButtons();
        const welcomeScreen = document.getElementById('welcome-screen');
        initializeParticles(welcomeScreen);
        await loadCustomLists();
    }
};

// Replace window.onload with:
document.addEventListener('DOMContentLoaded', () => {
    gameInit.init();
});

const { createClient } = supabase;
const supabaseClient = createClient(
    'https://mczfgzffyyyacisrccqb.supabase.co',
    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1jemZnemZmeXl5YWNpc3JjY3FiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzgzODYyMDQsImV4cCI6MjA1Mzk2MjIwNH0.rLga_B29Coz1LMeJzFTGLIhckdcojGXnD1ae1bw-QAI',
    {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true
    }
);

function showSetScreen(stageId) {
    gameState.currentStage = stageId;
    const container = document.getElementById('set-container');
    container.innerHTML = '';
    
    const stage = gameStructure.stages[stageId - 1];
    
    for (let i = 1; i <= stage.numSets; i++) {
        const setButton = document.createElement('div');
        setButton.className = 'set-button';
        setButton.textContent = `Set ${i}`;
        
        if (gameState.unlockedSets[stageId]?.has(i)) {
            setButton.classList.add('active');
            setButton.onclick = () => showLevelScreen(i);
        }
        
        container.appendChild(setButton);
    }
    
    // Check user access and apply lock overlay if needed
    checkUserAccess().then(access => {
        if (!access) return;
        
        container.querySelectorAll('.set-button').forEach((btn, index) => {
            const i = index + 1;
            const hasAccess = access.unlockedStages[stageId] === 'full' || 
                             (access.unlockedStages[stageId] && access.unlockedStages[stageId].includes(i));
            
            if (!hasAccess) {
                btn.classList.remove('active');
                btn.classList.add('locked');
                btn.innerHTML += `<div class="lock-overlay"><i class="fas fa-lock"></i></div>`;
                btn.onclick = () => showUpgradePrompt();
            }
        });
    });
}

document.addEventListener('DOMContentLoaded', async () => {
    await checkExistingSession();
    initializeGame();
    updatePerkButtons();
    updateGuestPlayButton();
    CoinsManager.initialize();
    WordsManager.initialize();
    
    // Load initial coins
    if (currentUser) {
        gameState.coins = await CoinsManager.loadUserCoins();
        CoinsManager.updateDisplays();
     
        const words = await WordsManager.loadUserWords();
        WordsManager.updateDisplays(words);
    }
    
    // Handle QR code joining
    window.addEventListener('hashchange', handleHashChange);
    window.addEventListener('load', handleHashChange);
    
    // Check for join hash on initial load
    if (window.location.hash.startsWith('#join=')) {
        console.log('Initial join hash detected');
        const otp = window.location.hash.replace('#join=', '');
        history.pushState("", document.title, window.location.pathname);
        showJoinModal(otp);
    }

    // Ensure particles on welcome screen
    const welcomeScreen = document.getElementById('welcome-screen');
    initializeParticles(welcomeScreen);
    
    await loadCustomLists();

    // Mobile fullscreen handling
    if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        // Request on first touch
        document.addEventListener('touchstart', function onFirstTouch() {
            requestFullscreenMode();
            document.removeEventListener('touchstart', onFirstTouch);
        }, { once: true });
        
        // Request when clicking any button
        document.addEventListener('click', function(e) {
            if (e.target.tagName === 'BUTTON') {
                requestFullscreenMode();
            }
        });
        
        // Screen orientation handling
        if (screen.orientation) {
            screen.orientation.lock('portrait')
                .catch(err => console.log('Failed to lock orientation:', err));
        }
    }

    // OTP input handling
    const otpInput = document.getElementById('otpInput');
    if (otpInput) {
        otpInput.addEventListener('input', function(e) {
            // Remove any non-numeric characters
            this.value = this.value.replace(/[^0-9]/g, '');
            
            // Limit to 4 digits
            if (this.value.length > 4) {
                this.value = this.value.slice(0, 4);
            }
        });
    }

    // Initialize real-time channels if user is logged in
    if (currentUser) {
        setupUserStatusSubscription();
        initializeStatusCheck();
    }
});

// Add this to the existing showJoinModal function to ensure proper mobile display
function showJoinModal(otp = '') {
    console.log('Opening join modal with OTP:', otp);
    const modal = document.getElementById('arcade-modal');
    const teacherView = document.getElementById('teacher-view');
    const playerView = document.getElementById('player-view');
    const otpInput = document.getElementById('otpInput');
    
    if (modal) {
        modal.style.display = 'block';
        if (teacherView) teacherView.style.display = 'none';
        if (playerView) playerView.style.display = 'block';
        
        if (otpInput && otp) {
            otpInput.value = otp;
            // Auto-focus username input
            const usernameInput = document.getElementById('arcadeUsername');
            if (usernameInput) {
                setTimeout(() => usernameInput.focus(), 300);
            }
        }
    }
}

// Auth UI functions
// Modify the existing authentication functions

async function handleSignup() {
    const email = document.getElementById('signupEmail').value;
    const username = document.getElementById('signupUsername').value;
    const password = document.getElementById('signupPassword').value;

    if (!email || !username || !password) {
        alert('All fields are required');
        return;
    }

    try {
        // Step 1: Sign up with Supabase Auth
        const { data: authData, error: authError } = await supabaseClient.auth.signUp({
            email,
            password,
            options: {
                data: { 
                    username: username,
                    full_name: username
                }
            }
        });

        if (authError) throw authError;

        // Step 2: Upsert user profile
        const { error: profileError } = await supabaseClient
            .from('user_profiles')
            .upsert({
                id: authData.user.id,
                username: username,
                email: email,
                status: 'free',
                role: 'student'
            }, {
                onConflict: 'id'
            });

        if (profileError) {
            console.error('Profile upsert error:', profileError);
        }

        // Step 3: Initialize game progress
        const { error: progressError } = await supabaseClient
            .from('game_progress')
            .upsert({
                user_id: authData.user.id,
                stage: 1,
                set_number: 1,
                level: 1,
                coins: 0,
                perks: {},
                unlocked_sets: { "1": [1] },
                unlocked_levels: { "1_1": [1] },
                perfect_levels: [],
                completed_levels: []
            }, {
                onConflict: 'user_id'
            });

        if (progressError) {
            console.error('Progress initialization error:', progressError);
        }

        // Step 4: Auto-login
        const { data: loginData, error: loginError } = await supabaseClient.auth.signInWithPassword({
            email,
            password
        });

        if (loginError) throw loginError;

        // Hide auth modal first
        hideAuthModal();

        // Update current user and UI
        currentUser = loginData.user;
        updateAuthUI();
        
        // Show welcome screen
        showScreen('welcome-screen');

    } catch (error) {
        console.error('Detailed signup error:', error);
        if (error.message.includes('duplicate key')) {
            alert('This username or email is already taken. Please try another.');
        } else {
            alert('Signup error: ' + error.message);
        }
    }
}

async function initializeGameProgressForUser(userId) {
    const { error } = await supabaseClient
        .from('game_progress')
        .insert({
            user_id: userId,
            stage: 1,
            set_number: 1,
            level: 1,
            coins: 0,
            perks: {},
            unlocked_sets: { "1": [1] },
            unlocked_levels: { "1_1": [1] },
            perfect_levels: [],
            completed_levels: []
        });

    if (error) {
        console.error('Error initializing game progress:', error);
    }
}

async function handleLogin() {
    const email = document.getElementById('loginUsername').value;
    const password = document.getElementById('loginPassword').value;
    
    if (!email || !password) {
        alert('Please enter both email and password');
        return;
    }

    try {
        const { data, error } = await supabaseClient.auth.signInWithPassword({
            email,
            password
        });

        if (error) {
            console.error('Login Error:', error);
            alert(error.message);
            return;
        }

        if (data.user) {
            currentUser = data.user;
            
            // Hide auth modal first
            hideAuthModal();
            
            // Then update UI and load data
            const { data: profile } = await supabaseClient
                .from('user_profiles')
                .select('status')
                .eq('id', currentUser.id)
                .single();
                
            if (profile) {
                currentUser.status = profile.status;
                updateUserStatusDisplay(profile.status);
            }

            await Promise.all([
                loadCustomLists(),
                loadUserGameProgress(currentUser.id)
            ]);

            updateAuthUI();
            updateGuestPlayButton(); // Add this line
            showScreen('welcome-screen');
        }

    } catch (error) {
        console.error('Unexpected Login Error:', error);
        alert('An unexpected error occurred during login');
    }
}

function initializeGame() {
    const saved = localStorage.getItem('simploxProgress');
    
    if (saved) {
        const parsedSaved = JSON.parse(saved);
        gameState.currentStage = parsedSaved.currentStage || 1;
        gameState.currentSet = parsedSaved.currentSet || 1;
        gameState.currentLevel = parsedSaved.currentLevel || 1;
        gameState.coins = parsedSaved.coins || 0;
                
        if (parsedSaved.unlockedSets) {
            gameState.unlockedSets = Object.fromEntries(
                Object.entries(parsedSaved.unlockedSets).map(([k, v]) => [k, new Set(v)])
            );
        }
        if (parsedSaved.unlockedLevels) {
            gameState.unlockedLevels = Object.fromEntries(
                Object.entries(parsedSaved.unlockedLevels).map(([k, v]) => [k, new Set(v)])
            );
        }
        gameState.perfectLevels = new Set(parsedSaved.perfectLevels || []);
        gameState.completedLevels = new Set(parsedSaved.completedLevels || []);
    } else {
        setupDefaultUnlocks();
    }

    updateAllCoinDisplays();
    updatePerkButtons();
}

function setupDefaultUnlocks() {
    // Stage 1: Level 1 of all sets should be unlocked
    if (!gameState.unlockedSets[1]) {
        gameState.unlockedSets[1] = new Set();
    }
    for (let i = 1; i <= 9; i++) {
        gameState.unlockedSets[1].add(i);
        const setKey = `1_${i}`;
        if (!gameState.unlockedLevels[setKey]) {
            gameState.unlockedLevels[setKey] = new Set([1]);
        }
    }

    // Stages 2-5: Level 1 of Set 1 should be unlocked
    for (let stage = 2; stage <= 5; stage++) {
        if (!gameState.unlockedSets[stage]) {
            gameState.unlockedSets[stage] = new Set([1]);
        }
        const setKey = `${stage}_1`;
        if (!gameState.unlockedLevels[setKey]) {
            gameState.unlockedLevels[setKey] = new Set([1]);
        }
    }
}



document.addEventListener('DOMContentLoaded', function() {
    currentUser = null;
    checkExistingSession().then(() => {
        initializeGame();
        updatePerkButtons();
    });
});

document.addEventListener('DOMContentLoaded', () => {
    // Immediately invoke an async function
    (async () => {
        await checkExistingSession();
        initializeGame();
        updatePerkButtons();
        updateGuestPlayButton();
        
        CoinsManager.initialize();
        WordsManager.initialize();
        
        // Load initial values if user is logged in
        if (currentUser) {
            const [coins, words] = await Promise.all([
                CoinsManager.loadUserCoins(),
                WordsManager.loadUserWords()
            ]);
            
            gameState.coins = coins;
            CoinsManager.updateDisplays();
            WordsManager.updateDisplays(words);
        }
        
        // Check for join hash on initial load
        if (window.location.hash.startsWith('#join=')) {
            console.log('Initial join hash detected');
            const otp = window.location.hash.replace('#join=', '');
            history.pushState("", document.title, window.location.pathname);
            showJoinModal(otp);
        }

        // Ensure particles on welcome screen
        const welcomeScreen = document.getElementById('welcome-screen');
        initializeParticles(welcomeScreen);
        
        await loadCustomLists();

        // Mobile fullscreen handling
        if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
            // Request on first touch
            document.addEventListener('touchstart', function onFirstTouch() {
                requestFullscreenMode();
                document.removeEventListener('touchstart', onFirstTouch);
            }, { once: true });
            
            // Request when clicking any button
            document.addEventListener('click', function(e) {
                if (e.target.tagName === 'BUTTON') {
                    requestFullscreenMode();
                }
            });
            
            // Screen orientation handling
            if (screen.orientation) {
                screen.orientation.lock('portrait')
                    .catch(err => console.log('Failed to lock orientation:', err));
            }
        }

        // Initialize real-time channels if user is logged in
        if (currentUser) {
            setupUserStatusSubscription();
            initializeStatusCheck();
        }
    })().catch(error => {
        console.error('Initialization error:', error);
    });
});

async function loadUserGameProgress(userId) {
    try {
        let progressData;
        
        // First try to get existing progress
        const { data: existingData, error: fetchError } = await supabaseClient
            .from('game_progress')
            .select('*')
            .eq('user_id', userId)
            .single();

        if (fetchError) {
            // If no record exists, create initial progress
            if (fetchError.code === 'PGRST116') {
                const initialProgress = {
                    user_id: userId,
                    stage: 1,
                    set_number: 1,
                    level: 1,
                    coins: 0,
                    perks: {},
                    unlocked_sets: { "1": [1] },
                    unlocked_levels: { "1_1": [1] },
                    perfect_levels: [],
                    completed_levels: []
                };

                const { data: newData, error: insertError } = await supabaseClient
                    .from('game_progress')
                    .upsert([initialProgress])
                    .select()
                    .single();

                if (insertError) {
                    console.error('Error creating initial game progress:', insertError);
                    return;
                }
                progressData = newData;
            } else {
                console.error('Error loading game progress:', fetchError);
                return;
            }
        } else {
            progressData = existingData;
        }

        // Update game state with loaded/created progress
        if (progressData) {
            gameState.currentStage = progressData.stage;
            gameState.currentSet = progressData.set_number;
            gameState.coins = progressData.coins;
            gameState.perks = progressData.perks;
            gameState.unlockedSets = Object.fromEntries(
                Object.entries(progressData.unlocked_sets).map(([k, v]) => [k, new Set(v)])
            );
            gameState.unlockedLevels = Object.fromEntries(
                Object.entries(progressData.unlocked_levels).map(([k, v]) => [k, new Set(v)])
            );
            gameState.perfectLevels = new Set(progressData.perfect_levels);
            gameState.completedLevels = new Set(progressData.completed_levels);
        }

        // After loading progress, ensure default unlocks are in place
        setupDefaultUnlocks();

        updateAllCoinDisplays();

    } catch (e) {
        console.error('Unexpected error in loadUserGameProgress:', e);
    }
}

async function handleLogout() {
    try {
        const { error } = await supabaseClient.auth.signOut();
        
        if (error) {
            console.error('Supabase logout error:', error.message);
        }

        // Reset game state
        gameState.coins = 0;
        gameState.unlockedSets = {};
        gameState.unlockedLevels = {};
        gameState.perfectLevels = new Set();
        gameState.completedLevels = new Set();


        // Clear all input fields and UI state
        clearCustomPracticeUI();

        // Reset current user and update UI
        currentUser = null;
        updateAuthUI();
        updateUserStatusDisplay(null);
        updateGuestPlayButton(); // Add this line
        
        // Show welcome screen
        showScreen('welcome-screen');

    } catch (error) {
        console.error('Unexpected error during logout:', error);
        // Ensure UI is reset even if logout fails
        currentUser = null;
        updateAuthUI();
        updateUserStatusDisplay(null);
        updateGuestPlayButton(); // Add this line
        showScreen('welcome-screen');
    }
}

function clearCustomPracticeUI() {
    // Clear list name input
    const listNameInput = document.getElementById('custom-list-name');
    if (listNameInput) {
        listNameInput.value = '';
    }

    // Clear word input
    const wordInput = document.getElementById('custom-word-input');
    if (wordInput) {
        wordInput.value = '';
    }

    // Clear translation results
    const translationResults = document.getElementById('translation-results');
    if (translationResults) {
        translationResults.style.display = 'none';
    }

    // Clear word translation list
    const wordList = document.getElementById('word-translation-list');
    if (wordList) {
        wordList.innerHTML = '';
    }

    // Reset current list
    customPracticeLists.currentList = null;
    customPracticeLists.lists = [];
}

function saveProgress() {
    // Ensure currentUser is always defined, even for unregistered users
    const userId = currentUser ? currentUser.id : 'guest';

    // For guest users, save to localStorage
    const progressToSave = {
        currentStage: gameState.currentStage || 1,
        currentSet: gameState.currentSet || 1,
        currentLevel: gameState.currentLevel || 1,
        unlockedSets: Object.fromEntries(
            Object.entries(gameState.unlockedSets).map(([k, v]) => [k, Array.from(v)])
        ),
        unlockedLevels: Object.fromEntries(
            Object.entries(gameState.unlockedLevels).map(([k, v]) => [k, Array.from(v)])
        ),
        perfectLevels: Array.from(gameState.perfectLevels),
        completedLevels: Array.from(gameState.completedLevels),
        coins: gameState.coins || 0
        };

    if (currentUser) {
        // Save to Supabase for logged-in users
        supabaseClient
            .from('game_progress')
            .update(progressToSave)
            .eq('user_id', currentUser.id)
            .then(({ error }) => {
                if (error) console.error('Error saving game progress:', error);
            });
    } else {
        // Save to localStorage for guest users
        localStorage.setItem('simploxProgress', JSON.stringify(progressToSave));
    }
}

async function saveCustomList() {
    const listNameInput = document.getElementById('custom-list-name');
    const name = listNameInput.value.trim() || `List ${customPracticeLists.lists.length + 1}`;
    
    const wordItems = document.querySelectorAll('.word-translation-item');
    const words = [];
    const translations = [];
    
    wordItems.forEach(item => {
        const englishWord = item.querySelector('.source-word').textContent.trim();
        const hebrewTranslation = item.querySelector('.target-word').value.trim();
        
        if (englishWord && hebrewTranslation) {
            words.push(englishWord);
            translations.push(hebrewTranslation);
        }
    });

    const newList = {
        id: customPracticeLists.currentList ? customPracticeLists.currentList.id : Date.now(),
        name: name,
        words: words,
        translations: translations
    };

    // If we're editing an existing list, replace it
    if (customPracticeLists.currentList) {
        const index = customPracticeLists.lists.findIndex(l => l.id === customPracticeLists.currentList.id);
        if (index !== -1) {
            customPracticeLists.lists[index] = newList;
        } else {
            customPracticeLists.lists.push(newList);
        }
    } else {
        customPracticeLists.lists.push(newList);
    }
    
    // Reset current list
    customPracticeLists.currentList = null;
    
    // Save to Supabase if logged in
    if (currentUser) {
        await saveCustomListToSupabase(newList);
    } else {
        // Save to localStorage for guest users
        localStorage.setItem('simploxCustomLists', JSON.stringify(customPracticeLists.lists));
    }

    // Update UI after saving
    showCustomListsManager();
}

async function loadCustomLists() {
    if (currentUser) {
        const { data, error } = await supabaseClient
            .from('custom_lists')
            .select('*')
            .or(`user_id.eq.${currentUser.id},shared_with.cs.{${currentUser.id}}`);

        if (error) {
            console.error('Error loading custom lists:', error);
            customPracticeLists.lists = [];
        } else {
            customPracticeLists.lists = data.map(item => ({
                id: item.local_id || Date.now(),
                supabaseId: item.id,
                name: item.name,
                words: item.words,
                translations: item.translations,
                is_shared: item.is_shared,
                shared_by: item.shared_by
            }));
        }
    } else {
        const savedLists = localStorage.getItem('simploxCustomLists');
        customPracticeLists.lists = savedLists ? JSON.parse(savedLists) : [];
    }
    
    updateListsDisplay();
}

function switchAuthTab(tab) {
    const loginTab = document.querySelector('.auth-tab[onclick="switchAuthTab(\'login\')"]');
    const signupTab = document.querySelector('.auth-tab[onclick="switchAuthTab(\'signup\')"]');
    const loginForm = document.getElementById('loginForm');
    const signupForm = document.getElementById('signupForm');

    if (tab === 'login') {
        loginTab.classList.add('active');
        signupTab.classList.remove('active');
        loginForm.classList.remove('hidden');
        signupForm.classList.add('hidden');
    } else {
        loginTab.classList.remove('active');
        signupTab.classList.add('active');
        loginForm.classList.add('hidden');
        signupForm.classList.remove('hidden');
    }
}

function updateAuthUI() {
    const authBox = document.getElementById('authBox');
    const userInfo = document.getElementById('userInfo');
    const userEmailElement = document.getElementById('userEmail');
    const logoutButton = document.querySelector('.logout-button');

    if (currentUser) {
        authBox.classList.add('hidden');
        userInfo.classList.remove('hidden');
        logoutButton.classList.remove('hidden');
        
        // Display username from metadata if available, fallback to email
        userEmailElement.textContent = currentUser.user_metadata?.username || currentUser.email;
        
        // Get and display user status
        supabaseClient
            .from('user_profiles')
            .select('status, username')
            .eq('id', currentUser.id)
            .single()
            .then(({ data }) => {
                if (data) {
                    // If we have a username in the profile, use it
                    if (data.username) {
                        userEmailElement.textContent = data.username;
                    }
                    updateUserStatusDisplay(data.status);
                }
            })
            .catch(error => console.error('Error fetching user status:', error));
            
    } else {
        authBox.classList.remove('hidden');
        userInfo.classList.add('hidden');
        logoutButton.classList.add('hidden');
        userEmailElement.textContent = '';
    }
}



// Game Constants & State Management
const gameStructure = {
    stages: [
        { id: 1, numSets: 9, levelsPerSet: 21, bossLevel: 21 },
        { id: 2, numSets: 10, levelsPerSet: 21, bossLevel: 21 },
        { id: 3, numSets: 12, levelsPerSet: 21, bossLevel: 21 },
        { id: 4, numSets: 30, levelsPerSet: 21, bossLevel: 21 },
        { id: 5, numSets: 14, levelsPerSet: 21, bossLevel: 21 }
    ],
    levelTypes: {
        normal: 'normal',
        boss: 'boss'
    }
};

const gameState = {
    currentStage: null,
    currentSet: null,
    currentLevel: null,
    unlockedSets: {},
    unlockedLevels: {},
    levelScores: {},
    completedLevels: new Set(),
    perfectLevels: new Set(),
    coins: 0,
    
};

// ADD this clean perk configuration
const PERK_CONFIG = {
    timeFreeze: {
        name: 'Time Freeze',
        description: 'Pause the timer for 5 seconds',
        cost: 15,
        icon: 'fa-clock',
        duration: 5000
    },
    skip: {
        name: 'Skip Question',
        description: 'Skip the current word without penalty',
        cost: 25,
        icon: 'fa-forward'
    },
    clue: {
        name: 'Eliminate Wrong Answer',
        description: 'Remove one incorrect answer',
        cost: 35,
        icon: 'fa-lightbulb'
    },
    reveal: {
        name: 'Reveal Correct Answer',
        description: 'Show the correct translation',
        cost: 50,
        icon: 'fa-eye'
    }
};

function buyPerk(perkType) {
    const perkConfig = PERK_CONFIG[perkType];
    if (!perkConfig) return;

    if (gameState.coins < perkConfig.cost) {
        showNotification(`Need ${perkConfig.cost} coins!`, 'error');
        return;
    }

    gameState.coins -= perkConfig.cost;
    updateAllCoinDisplays();

    switch(perkType) {
        case 'timeFreeze':
            isFrozen = true;
            setTimeout(() => {
                isFrozen = false;
            }, perkConfig.duration);
            break;

        case 'skip':
            handleAnswer(true, true);
            break;

        case 'clue':
            const buttons = document.querySelectorAll('.buttons button');
            const correctAnswer = currentGame.isHebrewToEnglish ? 
                currentGame.words[currentGame.currentIndex] : 
                currentGame.translations[currentGame.currentIndex];
            
            const wrongButtons = Array.from(buttons).filter(btn => 
                btn.textContent !== correctAnswer);
            
            if (wrongButtons.length > 0) {
                const buttonToDisable = wrongButtons[Math.floor(Math.random() * wrongButtons.length)];
                buttonToDisable.disabled = true;
                buttonToDisable.style.opacity = '0.5';
            }
            break;

        // REPLACE the reveal case in buyPerk function
case 'reveal':
    const correctAns = currentGame.isHebrewToEnglish ? 
        currentGame.words[currentGame.currentIndex] : 
        currentGame.translations[currentGame.currentIndex];
    
    document.querySelectorAll('.buttons button').forEach(btn => {
        if (btn.textContent === correctAns) {
            btn.classList.add('correct');
            // Store original background
            const originalBackground = btn.style.background;
            btn.style.background = 'var(--success)';
            
            // Reset after 5 seconds
            setTimeout(() => {
                btn.classList.remove('correct');
                btn.style.background = originalBackground;
            }, 5000);
        }
    });
    break;
    }

    saveProgress();
}


function updatePerkButtons() {
    Object.entries(PERK_CONFIG).forEach(([perkType, config]) => {
        const button = document.getElementById(`${perkType}Perk`);
        if (button) {
            // Calculate number of times perk can be purchased
            const availablePurchases = Math.floor(gameState.coins / config.cost);
            const canAfford = availablePurchases > 0;
            
            button.disabled = !canAfford;
            button.classList.toggle('disabled', !canAfford);
            
            // Update counter to show number of purchasable perks
            const countElement = button.querySelector('.perk-count');
            if (countElement) {
                countElement.textContent = canAfford ? availablePurchases.toString() : '0';
            }
        }
    });
}

updatePerkButtons();

let currentGame = {
    words: [],
    translations: [],
    currentIndex: 0,
    correctAnswers: 0,
    firstAttempt: true,
    isHebrewToEnglish: false,
    mixed: false,
    speedChallenge: false,
    startTime: 0,
    levelStartTime: 0,
    timeBonus: 0,
    streakBonus: true,
    questionStartTime: 0,
    wrongStreak: 0,
    progressLost: 0
};

let timer = null;
let timeRemaining = 0;
let isFrozen = false;

let resetProgressTimeout = null;
let isFirstResetAttempt = true;


// Progress Management
function saveProgress() {
    if (currentUser) {
        // Save to Supabase for logged in users
        const progressToSave = {
            stage: gameState.currentStage,
            set_number: gameState.currentSet,
            level: gameState.currentLevel,
            coins: gameState.coins,
            perks: gameState.perks,
            unlocked_sets: Object.fromEntries(
                Object.entries(gameState.unlockedSets).map(([k, v]) => [k, Array.from(v)])
            ),
            unlocked_levels: Object.fromEntries(
                Object.entries(gameState.unlockedLevels).map(([k, v]) => [k, Array.from(v)])
            ),
            perfect_levels: Array.from(gameState.perfectLevels),
            completed_levels: Array.from(gameState.completedLevels)
        };

        supabaseClient
            .from('game_progress')
            .update(progressToSave)
            .eq('user_id', currentUser.id)
            .then(({ error }) => {
                if (error) console.error('Error saving game progress:', error);
            });
    } else {
        // For guest users, save to localStorage
        localStorage.setItem('simploxProgress', JSON.stringify({
            unlockedSets: Object.fromEntries(
                Object.entries(gameState.unlockedSets).map(([k, v]) => [k, Array.from(v)])
            ),
            unlockedLevels: Object.fromEntries(
                Object.entries(gameState.unlockedLevels).map(([k, v]) => [k, Array.from(v)])
            ),
            perfectLevels: Array.from(gameState.perfectLevels),
            completedLevels: Array.from(gameState.completedLevels),
            coins: gameState.coins,
            perks: gameState.perks
        }));
    }
}


function loadProgress() {
    const saved = localStorage.getItem('simploxProgress');
    if (saved) {
        const data = JSON.parse(saved);
        gameState.unlockedSets = Object.fromEntries(
            Object.entries(data.unlockedSets).map(([k, v]) => [k, new Set(v)])
        );
        gameState.unlockedLevels = Object.fromEntries(
            Object.entries(data.unlockedLevels).map(([k, v]) => [k, new Set(v)])
        );
        gameState.perfectLevels = new Set(data.perfectLevels);
        gameState.completedLevels = new Set(data.completedLevels || []);
        gameState.coins = data.coins;
        gameState.perks = data.perks || {timeFreeze: 0, skip: 0, clue: 0, reveal: 0};
    }
    const savedCustomCoins = localStorage.getItem('simploxCustomCoins');
    if (savedCustomCoins) {
        gameState.coins = parseInt(savedCustomCoins);
    }
}

async function handleLogout() {
    try {
        const { error } = await supabaseClient.auth.signOut();
        
        if (error) {
            console.error('Supabase logout error:', error.message);
        }

        currentUser = null;
        updateAuthUI();
        showScreen('welcome-screen');
        
        // Reload game progress from localStorage
        initializeGame();

    } catch (error) {
        console.error('Unexpected error during logout:', error);
    }
}



// Timer Functions
// Replace the startTimer function:
function startTimer(questionCount) {
    clearTimer();
    if (currentGame.currentIndex >= currentGame.words.length) return;
    
    // Set initial time only if not already set
    if (!currentGame.initialTimeRemaining) {
        currentGame.initialTimeRemaining = currentGame.words.length * 10;
        timeRemaining = currentGame.initialTimeRemaining;
        currentGame.totalTime = timeRemaining; // Store the initial total time
    } else {
        // Use the remaining time from the previous interval
        timeRemaining = currentGame.initialTimeRemaining;
    }
    
    console.log('Starting timer with:', timeRemaining, 'seconds');
    currentGame.questionStartTime = Date.now();
    updateTimerDisplay();
    updateTimerCircle(timeRemaining, currentGame.totalTime); // Use stored total time
    
    timer = setInterval(() => {
        if (!isFrozen) {
            timeRemaining = Math.max(0, timeRemaining - 1);
            updateTimerDisplay();
            updateTimerCircle(timeRemaining, currentGame.totalTime); // Use stored total time
            
            // Update the initialTimeRemaining to track remaining time
            currentGame.initialTimeRemaining = timeRemaining;
            
            if (timeRemaining <= 10) {
                document.querySelector('.timer-value').classList.add('warning');
            }
            
            if (timeRemaining <= 0) {
                handleTimeUp();
            }
        }
    }, 1000);
}

function updateTimerDisplay() {
    const minutes = Math.floor(timeRemaining / 60);
    const seconds = timeRemaining % 60;
    const timerElement = document.querySelector('.timer-value');
    timerElement.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    
    if (timeRemaining <= 10) {
        timerElement.classList.add('warning');
    } else {
        timerElement.classList.remove('warning');
    }
}

function clearTimer() {
    if (timer) {
        clearInterval(timer);
        timer = null;
    }
    timeRemaining = 0;
    isFrozen = false;
    
    const timerProgress = document.querySelector('.timer-progress');
    if (timerProgress) {
        timerProgress.classList.remove('warning');
    }
    
    updateTimerCircle(0, 1); // This will empty the circle
}

function createParticles(x, y) {
    // Detect mobile device
    const isMobile = window.matchMedia("(max-width: 768px)").matches;
    
    // Define particle parameters based on device type
    const particleConfig = isMobile 
        ? {
            count: 10,      // Fewer particles on mobile
            size: 6,        // Smaller particles
            distance: 50,   // Shorter spread
            opacity: 0.7,   // Lower opacity
            duration: 1000  // Shorter animation
        }
        : {
            count: 40,      // More particles on desktop
            size: 10,       // Standard particle size
            distance: 150,  // Wider spread
            opacity: 1,     // Full opacity
            duration: 1500  // Longer animation
        };

    const colors = ['#ffd700', '#FFA500', '#4CAF50', '#FFD700'];
    const container = document.body;
    
    for (let i = 0; i < particleConfig.count; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        
        // Position relative to click point
        particle.style.position = 'fixed';
        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;
        
        // Randomize particle properties
        const angle = (Math.random() * Math.PI * 2);
        const distance = particleConfig.distance + (Math.random() * 50);
        
        particle.style.width = `${particleConfig.size}px`;
        particle.style.height = `${particleConfig.size}px`;
        particle.style.opacity = `${particleConfig.opacity}`;
        
        particle.style.setProperty('--x', `${Math.cos(angle) * distance}px`);
        particle.style.setProperty('--y', `${Math.sin(angle) * distance}px`);
        
        // Create adaptive animation
        particle.style.animation = `particleBurst ${particleConfig.duration / 1000}s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards`;
        
        container.appendChild(particle);
        
        // Remove particle after animation completes
        setTimeout(() => {
            container.removeChild(particle);
        }, particleConfig.duration);
    }
}

function animateCoinsChange(element, startValue, endValue) {
    if (!element) return;
    
    const duration = 1000; // 1 second
    const frameRate = 60;
    const frames = duration / (1000 / frameRate);
    const increment = (endValue - startValue) / frames;
    
    let currentFrame = 0;
    let currentValue = startValue;

    function updateFrame() {
        currentFrame++;
        currentValue += increment;
        
        if (currentFrame <= frames) {
            // Round to nearest integer for whole number display
            element.textContent = Math.round(currentValue);
            
            // Add color change based on increase/decrease
            if (increment > 0) {
                element.style.color = 'var(--success)';
            } else if (increment < 0) {
                element.style.color = 'var(--error)';
            }
            
            requestAnimationFrame(updateFrame);
        } else {
            // Final frame
            element.textContent = endValue;
            
            // Reset color after animation
            setTimeout(() => {
                element.style.color = 'var(--text)';
            }, 300);
        }
    }

    updateFrame();
}


function updatePlayerProgress(payload) {
    const existingPlayerIndex = currentArcadeSession.participants.findIndex(
        p => p.username === payload.username
    );
    
    // Store old positions and values for animation
    const oldPositions = {};
    const oldValues = {};
    document.querySelectorAll('.leaderboard-entry').forEach(entry => {
        const username = entry.querySelector('[data-username]').dataset.username;
        oldPositions[username] = entry.getBoundingClientRect();
        
        const wordsElement = entry.querySelector('[data-words]');
        const coinsElement = entry.querySelector('[data-coins]');
        
        if (wordsElement) oldValues[username] = {
            words: parseInt(wordsElement.textContent),
            coins: parseInt(coinsElement.textContent)
        };
    });
    
    if (existingPlayerIndex !== -1) {
        currentArcadeSession.participants[existingPlayerIndex] = {
            ...currentArcadeSession.participants[existingPlayerIndex],
            ...payload
        };
    } else {
        currentArcadeSession.participants.push({
            username: payload.username,
            wordsCompleted: payload.wordsCompleted || 0,
            coins: payload.coins || 0
        });
    }
    
    // Sort and create new entries
    const sortedPlayers = [...currentArcadeSession.participants]
        .sort((a, b) => {
            if (b.wordsCompleted !== a.wordsCompleted) {
                return b.wordsCompleted - a.wordsCompleted;
            }
            return b.coins - a.coins;
        });
    
    const entries = sortedPlayers.map((player, index) => `
        <div class="leaderboard-entry ${index < 3 ? `rank-${index + 1}` : ''}"
             data-rank="${index + 1}">
            <div>${index + 1}</div>
            <div data-username="${player.username}">${player.username}</div>
            <div data-words="${player.wordsCompleted}">${player.wordsCompleted || 0}</div>
            <div data-coins="${player.coins}">${player.coins || 0}</div>
        </div>
    `).join('');
    
    const leaderboard = document.getElementById('arcade-leaderboard');
    leaderboard.innerHTML = leaderboard.querySelector('.leaderboard-header').outerHTML + entries;

    // Apply animations
    const newEntries = leaderboard.querySelectorAll('.leaderboard-entry');
    newEntries.forEach(entry => {
        const username = entry.querySelector('[data-username]').dataset.username;
        if (oldPositions[username]) {
            const oldPos = oldPositions[username];
            const newPos = entry.getBoundingClientRect();
            const diff = oldPos.top - newPos.top;
            
            if (diff > 0) {
                entry.classList.add('moving-up');
            } else if (diff < 0) {
                entry.classList.add('moving-down');
            }
            
            // Animate words and coins if values changed
            if (oldValues[username]) {
                const wordsElement = entry.querySelector('[data-words]');
                const coinsElement = entry.querySelector('[data-coins]');
                
                animateCoinsChange(
                    wordsElement, 
                    oldValues[username].words, 
                    parseInt(wordsElement.textContent)
                );
                
                animateCoinsChange(
                    coinsElement, 
                    oldValues[username].coins, 
                    parseInt(coinsElement.textContent)
                );
            }
            
            entry.addEventListener('animationend', () => {
                entry.classList.remove('moving-up', 'moving-down');
            }, { once: true });
        }
    });
}

function handleTimeUp() {
    if (currentGame.currentIndex >= currentGame.words.length) return; // Don't show if level is complete
    
    clearTimer();
    const overlay = document.querySelector('.failure-overlay');
    overlay.style.display = 'flex';
    setTimeout(() => {
        overlay.classList.add('show');
    }, 100);
    
    // Update home button functionality
    document.querySelector('.failure-overlay .home-button').onclick = () => {
        overlay.classList.remove('show');
        setTimeout(() => {
            overlay.style.display = 'none';
            showScreen('welcome-screen');
        }, 1000);
    };
    
    // Keep restart functionality
    document.querySelector('.failure-overlay .restart-button').onclick = () => {
        overlay.classList.remove('show');
        setTimeout(() => {
            overlay.style.display = 'none';
            startLevel(gameState.currentLevel);
        }, 1000);
    };
}

// Screen Management
function showScreen(screenId, forceRefresh = false) {
    // Extensive logging for debugging
    console.log('showScreen called with:', {
        screenId: screenId,
        forceRefresh: forceRefresh,
        currentUser: currentUser ? currentUser.id : 'No user'
    });

    if (document.querySelector('.screen.visible')?.id === 'leaderboard-screen') {
        cleanupLeaderboard();
    }

    // Clear any running timer when leaving question screen
    const currentVisibleScreen = document.querySelector('.screen.visible');
    if (currentVisibleScreen && currentVisibleScreen.id === 'question-screen') {
        clearTimer();
        isFrozen = false; // Reset freeze state
    }

    // Comprehensive refresh mechanism
    if (forceRefresh && screenId === 'welcome-screen') {
        console.log('Initiating full page reload');
        
        // Save any critical state before reload if needed
        saveProgress(); // Ensure current progress is saved
        
        // Use modern reload method with cache bypass
        window.location.reload(true);
        return;
    }

    // Hide all screens
    document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('visible');
        
        // Remove existing particle containers
        const existingParticleContainer = screen.querySelector('.particle-container');
        if (existingParticleContainer) {
            existingParticleContainer.remove();
        }
    });

    // Show target screen
    const screenElement = document.getElementById(screenId);
    if (!screenElement) {
        console.error(`Screen with id ${screenId} not found`);
        return;
    }
    
    screenElement.classList.add('visible');
    
    // Reinitialize particles for current screen
    initializeParticles(screenElement);
    
    // Update UI elements
    updateAllCoinDisplays();
    
    // Screen-specific initialization
    switch(screenId) {
        case 'question-screen':
            updatePerkButtons();
            break;
        case 'welcome-screen':
            // Check for restored game context
            if (restoreGameContext()) {
                // If context exists, potentially start game from where it left off
                startGame();
            }
            break;
        case 'stage-screen':
            // Any stage screen specific logic
            break;
    }

    console.log(`Switched to screen: ${screenId}`);
}

document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.home-button').forEach(button => {
        button.addEventListener('click', (event) => {
            event.preventDefault();
            showScreen('welcome-screen', true);
        });
    });
});


// Add full-screen event listener
document.addEventListener('fullscreenchange', function() {
    if (!document.fullscreenElement) {
        console.log('Exited full-screen');
    }
});

function showSetScreen(stageId) {
    gameState.currentStage = stageId;
    const container = document.getElementById('set-container');
    container.innerHTML = '';
    
    const stage = gameStructure.stages[stageId - 1];
    
    for (let i = 1; i <= stage.numSets; i++) {
        const setButton = document.createElement('div');
        setButton.className = 'set-button active';
        setButton.textContent = `Set ${i}`;
        
        if (gameState.unlockedSets[stageId]?.has(i)) {
            setButton.onclick = () => showLevelScreen(i);
        }
        
        container.appendChild(setButton);
    }
    
    showScreen('set-screen');

    // Run access check after showing screen
    checkUserAccess().then(access => {
        if (!access) return;
        
        container.querySelectorAll('.set-button').forEach((btn, index) => {
            const i = index + 1;
            const hasAccess = access.unlockedStages[stageId] === 'full' || 
                             (access.unlockedStages[stageId] && access.unlockedStages[stageId].includes(i));
            
            if (!hasAccess) {
                btn.classList.remove('active');
                btn.classList.add('locked');
                btn.innerHTML += `<div class="lock-overlay"><i class="fas fa-lock"></i></div>`;
                btn.onclick = () => showUpgradePrompt();
            }
        });
    });
}

function showLevelScreen(setId) {
    gameState.currentSet = setId;
    const container = document.getElementById('level-container');
    container.innerHTML = '';
    const stage = gameStructure.stages[gameState.currentStage - 1];
    const testLevels = [3, 6, 9, 10, 13, 16, 19, 20];

    for (let i = 1; i <= stage.levelsPerSet; i++) {
        const levelDiv = document.createElement('div');
        const levelKey = `${gameState.currentStage}_${setId}_${i}`;
        const isUnlocked = gameState.unlockedLevels[`${gameState.currentStage}_${setId}`]?.has(i);
        const isPerfect = gameState.perfectLevels.has(levelKey);
        const isBossLevel = i === stage.bossLevel;
        const isTestLevel = testLevels.includes(i);

        levelDiv.className = `level ${isUnlocked ? 'blue' : ''} 
                            ${isPerfect ? 'green' : ''} 
                            ${isBossLevel ? 'boss' : ''} 
                            ${isTestLevel ? 'mixed' : ''}`;
        levelDiv.textContent = i;
        
        if (isUnlocked) {
            levelDiv.onclick = () => startLevel(i);
        }
        
        container.appendChild(levelDiv);
    }
    
    showScreen('level-screen');
}

// Level Logic
function calculateWordsForLevel(level, vocabulary) {
    const totalWords = vocabulary.words.length;
    const wordSurplus = totalWords - 50;

    // Boss Level (21) - all words from the set with special mechanics
    if (level === 21) {
        return {
            startIndex: 0,
            count: totalWords,
            isBossLevel: true,
            speedChallenge: true,
            mixed: true,                    // Mix Hebrew/English questions
            isTestLevel: true,              // Boss is always a test level
            isHebrewToEnglish: Math.random() < 0.5,
            testLevels: []                  // Boss level doesn't need test levels
        };
    }

    // Level 1-2: Choose 3 new words
    if (level === 1 || level === 2) {
        return {
            startIndex: (level - 1) * 3,
            count: 3,
            testLevels: [3, 10, 21]
        };
    }

    // Level 3: Test words from levels 1-2
    if (level === 3) {
        return {
            startIndex: 0,
            count: 6,
            isTestLevel: true,
            mixed: true,
            isHebrewToEnglish: Math.random() < 0.5
        };
    }

    // Level 4-5: Choose 3 new words
    if (level === 4 || level === 5) {
        return {
            startIndex: 6 + (level - 4) * 3,
            count: 3,
            testLevels: [6, 10, 21]
        };
    }

    // Level 6: Test words from levels 4-5
    if (level === 6) {
        return {
            startIndex: 6,
            count: 6,
            isTestLevel: true,
            mixed: true,
            isHebrewToEnglish: Math.random() < 0.5
        };
    }

    // Level 7-8: Choose 4 new words
    if (level === 7 || level === 8) {
        return {
            startIndex: 12 + (level - 7) * 4,
            count: 4,
            testLevels: [9, 10, 21]
        };
    }

    // Level 9: Test words from levels 7-8
    if (level === 9) {
        return {
            startIndex: 12,
            count: 8,
            isTestLevel: true,
            mixed: true,
            isHebrewToEnglish: Math.random() < 0.5
        };
    }

    // Level 10: Test words from levels 1,2,4,5,7,8
    if (level === 10) {
        return {
            startIndex: 0,
            count: 20,
            isTestLevel: true,
            speedChallenge: true,
            mixed: true,
            isHebrewToEnglish: Math.random() < 0.5
        };
    }

    // Level 11-12: Choose 4 new words
    if (level === 11 || level === 12) {
        return {
            startIndex: 20 + (level - 11) * 4,
            count: 4,
            testLevels: [13, 20, 21]
        };
    }

    // Level 13: Test words from levels 11-12
    if (level === 13) {
        return {
            startIndex: 20,
            count: 8,
            isTestLevel: true,
            mixed: true,
            isHebrewToEnglish: Math.random() < 0.5
        };
    }

    // Level 14-15: Choose 5-6 new words
    if (level === 14 || level === 15) {
        return {
            startIndex: 28 + (level === 14 ? 0 : 5),
            count: level === 14 ? 5 : 6,
            testLevels: [16, 20, 21]
        };
    }

    // Level 16: Test words from levels 14-15
    if (level === 16) {
        return {
            startIndex: 28,
            count: 11,
            isTestLevel: true,
            mixed: true,
            isHebrewToEnglish: Math.random() < 0.5
        };
    }

    // Level 17-18: Flexible word count based on total vocabulary
    if (level === 17 || level === 18) {
        const baseCount = level === 17 ? 5 : 6;
        const adjustedCount = baseCount + (wordSurplus > 0 ? wordSurplus : 0);
        return {
            startIndex: 39 + (level === 17 ? 0 : adjustedCount),
            count: adjustedCount,
            testLevels: [19, 20, 21]
        };
    }

    // Level 19: Test words from levels 17-18
    if (level === 19) {
        return {
            startIndex: 39,
            count: 11,
            isTestLevel: true,
            mixed: true,
            isHebrewToEnglish: Math.random() < 0.5
        };
    }

    // Level 20: Test words from levels 11,12,14,15,17,18
    if (level === 20) {
        return {
            startIndex: 20,
            count: 30,
            isTestLevel: true,
            speedChallenge: true,
            mixed: true,
            isHebrewToEnglish: Math.random() < 0.5
        };
    }
}

function getUnusedWords(vocabulary) {
    // Track used words in gameState
    if (!gameState.usedWords) gameState.usedWords = new Set();
    
    return vocabulary.words.map((_, index) => index)
        .filter(i => !gameState.usedWords.has(i));
}

function selectRandomWords(availableIndices, count) {
    const selected = new Set();
    
    while (selected.size < count && availableIndices.length > selected.size) {
        const randomIndex = Math.floor(Math.random() * availableIndices.length);
        selected.add(availableIndices[randomIndex]);
        gameState.usedWords.add(availableIndices[randomIndex]);
    }
    
    return Array.from(selected);
}

function generateAnswerChoices(correctAnswer, vocabulary) {
    const choices = new Set([correctAnswer]);
    const allChoices = vocabulary.translations;
    
    while (choices.size < 3) {
        const randomChoice = allChoices[Math.floor(Math.random() * allChoices.length)];
        choices.add(randomChoice);
    }
    
    return Array.from(choices).sort(() => Math.random() - 0.5);
}

async function startLevel(levelId) {
    // Reset stats tracking
    currentGame.wrongStreak = 0;
    currentGame.correctAnswers = 0;
    currentGame.levelStartTime = Date.now();
    currentGame.firstAttempt = true;
    currentGame.streakBonus = true;

    updatePerkButtons();

    const perksContainer = document.querySelector('.perks-container');
    const powerupsContainer = document.querySelector('.powerups-container');    
    perksContainer.style.display = 'flex';
    powerupsContainer.style.display = 'none';

    // Ensure coin display is initialized
    const coinDisplay = document.querySelector('.coin-count');
    if (coinDisplay) {
        coinDisplay.textContent = gameState.coins || 0;
    }

    // Initialize coins and ensure containers are visible
    const coinsContainer = document.querySelector('.coins-container');
    if (coinsContainer) {
        coinsContainer.style.display = 'flex';
    }

    // Ensure progress circle is visible
    const progressCircle = document.querySelector('.progress-circle');
    if (progressCircle) {
        progressCircle.style.display = 'flex';
    }

    // Regular game initialization
    gameState.currentStage = gameState.currentStage || 1;
    gameState.currentSet = gameState.currentSet || 1;
    gameState.currentLevel = levelId;

    const userStatus = currentUser ? currentUser.status : 'unregistered';
    const triggerLevels = [2, 7, 11, 15, 20];    
    if (gameState.currentStage === 1 && 
        gameState.currentSet === 1 && 
        triggerLevels.includes(levelId) && 
        userStatus !== 'premium') {
            
        const continueLevelId = levelId; // Store levelId for callback
            
        if (!currentUser) {
            showUnregisteredWarning(() => {
                proceedWithLevel(continueLevelId);
            });
            return;
        } else if (!localStorage.getItem(`upgradeRequested_${currentUser.id}`)) {
            showUpgradePrompt(() => {
                proceedWithLevel(continueLevelId);
            });
            return;
        }
    }

    proceedWithLevel(levelId);
}

document.querySelector('.perks-container').innerHTML = `
    ${Object.entries(PERK_CONFIG).map(([type, config]) => `
        <button class="perk-button" id="${type}Perk" onclick="buyPerk('${type}')">
            <i class="fas ${config.icon} perk-icon"></i>
            <span class="perk-count">0</span>
        </button>
    `).join('')}
`;

function proceedWithLevel(levelId) {
    if (!currentGame.restartsRemaining) {
        currentGame.restartsRemaining = 2;
    }
    
    gameState.currentLevel = levelId;
    const setKey = `${gameState.currentStage}_${gameState.currentSet}`;
    const vocabulary = vocabularySets[setKey];

    // Ensure coin display remains visible
    const coinDisplay = document.querySelector('.coin-count');
    if (coinDisplay) {
        coinDisplay.textContent = gameState.coins || 0;
        coinDisplay.style.display = 'block';
    }

    // Prepare all game state first
    currentGame.startingCoins = gameState.coins;
    currentGame.startingPerks = { ...gameState.perks };
    currentGame.timeBonus = 0;
    currentGame.initialTimeRemaining = null;
    currentGame.streakBonus = true;
    currentGame.levelStartTime = Date.now();
    
    // Show intro, but prepare the level during the curtain-down moment
    showLevelIntro(levelId, () => {
        // Setup all game state while curtain is down
        const levelConfig = calculateWordsForLevel(levelId, vocabulary);
        if (typeof levelConfig === 'object') {
            const { startIndex, count, isHebrewToEnglish, mixed, speedChallenge } = levelConfig;
            currentGame = {
                ...currentGame,
                words: vocabulary.words.slice(startIndex, startIndex + count),
                translations: vocabulary.translations.slice(startIndex, startIndex + count),
                currentIndex: 0,
                correctAnswers: 0,
                firstAttempt: true,
                isHebrewToEnglish: isHebrewToEnglish || false,
                mixed: mixed || false,
                speedChallenge: speedChallenge || false
            };
        } else {
            currentGame = {
                ...currentGame,
                words: vocabulary.words.slice(0, levelConfig),
                translations: vocabulary.translations.slice(0, levelConfig),
                currentIndex: 0,
                correctAnswers: 0,
                firstAttempt: true,
                isHebrewToEnglish: false,
                mixed: false,
                speedChallenge: false
            };
        }
        
        // Prepare the question screen while curtain is still down
        showScreen('question-screen');
        updateProgressCircle();
        loadNextQuestion();
        
        // Only start the timer after curtain is fully up
        setTimeout(() => {
            startTimer(currentGame.words.length);
        }, 200);
    });
}

function setupGameState(levelConfig, vocabulary) {
    if (typeof levelConfig === 'object') {
        const { startIndex, count, isHebrewToEnglish, mixed } = levelConfig;
        Object.assign(currentGame, {
            words: vocabulary.words.slice(startIndex, startIndex + count),
            translations: vocabulary.translations.slice(startIndex, startIndex + count),
            currentIndex: 0,
            correctAnswers: 0,
            firstAttempt: true,
            isHebrewToEnglish: isHebrewToEnglish || false,
            mixed: mixed || false
        });
    } else {
        Object.assign(currentGame, {
            words: vocabulary.words.slice(0, levelConfig),
            translations: vocabulary.translations.slice(0, levelConfig),
            currentIndex: 0,
            correctAnswers: 0,
            firstAttempt: true,
            isHebrewToEnglish: false,
            mixed: false
        });
    }
}

function handleLevelProgression() {
    const currentStageConfig = gameStructure.stages[gameState.currentStage - 1];
    const isLastLevelInSet = gameState.currentLevel === currentStageConfig.levelsPerSet;
    const isLastSetInStage = gameState.currentSet === currentStageConfig.numSets;

    if (isLastLevelInSet) {
        if (!isLastSetInStage) {
            gameState.currentSet++;
            startLevel(1);
        } else if (gameState.currentStage < 5) {
            gameState.currentStage++;
            gameState.currentSet = 1;
            startLevel(1);
        } else {
            showScreen('stage-screen');
        }
    } else {
        startLevel(gameState.currentLevel + 1);
    }
}

function updateNavigationIcons(screenId) {
    // Remove existing navigation containers
    
    // Screens that should have navigation
    const screensWithNav = ['stage-screen', 'set-screen', 'level-screen', 'question-screen'];
    
    if (screensWithNav.includes(screenId)) {
        const navContainer = document.createElement('div');
        navContainer.className = 'screen-nav';
        
        // Home button (always present)
        const homeButton = document.createElement('button');
        homeButton.className = 'home-button';
        homeButton.innerHTML = '<i class="fas fa-home"></i>';
        homeButton.onclick = () => showScreen('welcome-screen');
        navContainer.appendChild(homeButton);
        
        // Back button (not for stage screen)
        if (screenId !== 'stage-screen') {
            const backButton = document.createElement('button');
            backButton.className = 'back-button';
            backButton.innerHTML = '<i class="fas fa-arrow-left"></i>';
            
            // Determine back navigation based on current screen
            switch(screenId) {
                case 'set-screen':
                    backButton.onclick = () => showScreen('stage-screen');
                    break;
                case 'level-screen':
                    backButton.onclick = () => showSetScreen(gameState.currentStage);
                    break;
                case 'question-screen':
                    backButton.onclick = () => stopLevelAndGoBack();
                    break;
            }
            
            navContainer.appendChild(backButton);
        }
        
        // Add navigation to the current screen
        const currentScreen = document.getElementById(screenId);
        currentScreen.appendChild(navContainer);
    }
}

// Visual Updates
function updateProgressCircle() {
    const circle = document.querySelector('.progress-circle .progress');
    const progressCircle = document.querySelector('.progress-circle');
    
    const radius = 54;
    const circumference = 2 * Math.PI * radius;
    
    const progress = currentGame.currentIndex / currentGame.words.length;
    
    circle.style.strokeDasharray = `${circumference} ${circumference}`;
    circle.style.strokeDashoffset = circumference * (1 - progress);
    
    // Advanced color progression
    let hue, saturation, lightness;
    
    if (progress <= 0.2) {
        // 0-20%: Dark Red
        hue = 0;
        saturation = 100;
        lightness = 20;
    } else if (progress <= 0.4) {
        // 20-40%: Bright Red
        hue = 0;
        saturation = 100;
        lightness = 50;
    } else if (progress <= 0.6) {
        // 40-60%: Orange
        hue = 30;
        saturation = 100;
        lightness = 50;
    } else if (progress <= 0.8) {
        // 60-80%: Bright Green
        hue = 120;
        saturation = 100;
        lightness = 40;
    } else {
        // 80-100%: Gold to Blue transition
        const goldToBlueProgress = (progress - 0.8) * 5;
        hue = 120 * (1 - goldToBlueProgress) + 60 * goldToBlueProgress;
        saturation = 100;
        lightness = 40 + (20 * goldToBlueProgress);
    }
    
    circle.style.stroke = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    
    if (progress >= 1) {
        showCompletionEffect(progressCircle);
    }
}

function showCompletionEffect(progressCircle) {
    // Add completion class to trigger animations
    progressCircle.classList.add('completed');
    
    // Create a ripple effect
    const ripple = document.createElement('div');
    ripple.className = 'completion-ripple';
    progressCircle.appendChild(ripple);
    
    // Remove completion animations after 2 seconds
    setTimeout(() => {
        progressCircle.classList.remove('completed');
        ripple.remove();
    }, 2000);
}

// Question Management
function loadNextQuestion() {
    if (currentGame.currentIndex >= currentGame.words.length) {
        handleLevelCompletion();
        return;
    }

    const isTestLevel = [3,6,9,10,13,16,19,20,21].includes(gameState.currentLevel);
    const isHebrewToEnglish = isTestLevel ? Math.random() < 0.5 : false;
    
    // Get current word pair
    const wordIndex = currentGame.currentIndex;
    const questionWord = isHebrewToEnglish ? 
        currentGame.translations[wordIndex] : 
        currentGame.words[wordIndex];
    
    // Set question word
    document.getElementById('question-word').textContent = questionWord;

    // Generate answer choices including correct answer
    const correctAnswer = isHebrewToEnglish ? 
        currentGame.words[wordIndex] : 
        currentGame.translations[wordIndex];
    
    // Get all possible answers from vocabulary
    const allAnswers = isHebrewToEnglish ? 
        currentGame.words : 
        currentGame.translations;
    
    // Create answer choices with random wrong answers
    const choices = new Set([correctAnswer]);
    while(choices.size < 3) {
        const randomIndex = Math.floor(Math.random() * allAnswers.length);
        const randomAnswer = allAnswers[randomIndex];
        if (randomAnswer !== correctAnswer) {
            choices.add(randomAnswer);
        }
    }

    // Create and shuffle buttons
    const buttonsDiv = document.getElementById('buttons');
    buttonsDiv.innerHTML = '';
    Array.from(choices)
        .sort(() => Math.random() - 0.5)
        .forEach(choice => {
            const button = document.createElement('button');
            button.textContent = choice;
            button.onclick = () => handleAnswer(choice === correctAnswer);
            buttonsDiv.appendChild(button);
        });
}

async function handleAnswer(isCorrect, fromPerk = false) {
    const now = Date.now();
    const lastAnswerTime = currentGame.lastAnswerTime || 0;
    
    // Enforce 1-second cooldown between answers
    if (now - lastAnswerTime < 1000) {
        return;
    }
    
    currentGame.lastAnswerTime = now;

    const levelKey = `${gameState.currentStage}_${gameState.currentSet}_${gameState.currentLevel}`;
    const isLevelCompleted = gameState.perfectLevels.has(levelKey);

    if (!isCorrect) {
        currentGame.firstAttempt = false;
        currentGame.streakBonus = false;
        currentGame.wrongStreak++;
        
        try {
            await CoinsManager.updateCoins(-3);
            updatePerkButtons();
        } catch (error) {
            console.error('Error updating coins:', error);
        }

        // Move progress bar backwards
        if (currentGame.currentIndex > 0) {
            currentGame.progressLost++;
            currentGame.currentIndex = Math.max(0, currentGame.currentIndex - 1);
        }

        // Check for game over condition
        if (currentGame.wrongStreak >= 3) {
            if (currentGame.isCustomPractice) {
                showGameOverOverlay();
                document.querySelector('.restart-button').onclick = () => {
                    document.querySelector('.failure-overlay').style.display = 'none';
                    startCustomLevel(currentGame.currentCustomLevel, {
                        ...currentGame.practiceState,
                        currentLevel: currentGame.currentCustomLevel
                    });
                };
                return;
            } else {
                showGameOverOverlay();
                return;
            }
        }

    } else if (isCorrect && !isLevelCompleted && !fromPerk) {
        let totalCoinsEarned = 0;

        // Award time bonus and update perks
        const timeBonus = awardTimeBonus();
        if (timeBonus > 0) {
            totalCoinsEarned += timeBonus;
            pulseCoins(timeBonus);

            // Add perk chance when earning time bonus
            if (Math.random() < 0.15) { // 15% chance
                const perkTypes = ['timeFreeze', 'skip', 'clue', 'reveal'];
                const randomPerk = perkTypes[Math.floor(Math.random() * perkTypes.length)];
                gameState.perks[randomPerk]++;
                updatePerkButtons();
            }
        }

        // Award coins based on first attempt
        if (currentGame.firstAttempt) {
            totalCoinsEarned += 3;
            pulseCoins(3);
            
            try {
                // Update words count for first-time correct answers
                await WordsManager.updateWords(1);
            } catch (error) {
                console.error('Error updating words:', error);
            }
            
            // Additional chance for perk on first attempt
            if (Math.random() < 0.1) { // 10% chance
                const perkTypes = ['timeFreeze', 'skip', 'clue', 'reveal'];
                const randomPerk = perkTypes[Math.floor(Math.random() * perkTypes.length)];
                gameState.perks[randomPerk]++;
                updatePerkButtons();
            }
        } else {
            totalCoinsEarned += 1;
            pulseCoins(1);
        }

        try {
            // Update coins once with total amount
            await CoinsManager.updateCoins(totalCoinsEarned);
            updatePerkButtons();
        } catch (error) {
            console.error('Error updating total coins:', error);
        }
        
        currentGame.correctAnswers++;
    }

    const correctAnswer = currentGame.isHebrewToEnglish ? 
        currentGame.words[currentGame.currentIndex] : 
        currentGame.translations[currentGame.currentIndex];

    document.querySelectorAll('.buttons button').forEach(btn => {
        if (btn.textContent === correctAnswer) {
            btn.classList.add('correct');
        } else if (!isCorrect && btn.textContent === event.target.textContent) {
            btn.classList.add('wrong');
        }
    });

    if (isCorrect) {
        currentGame.currentIndex++;
    }
    
    updateProgressCircle();
    saveProgress();
   
    // Use setTimeout for consistent timing
    setTimeout(() => {
        if (currentGame.currentIndex < currentGame.words.length) {
            startTimer(currentGame.words.length - currentGame.currentIndex);
            loadNextQuestion();
            updatePerkButtons();
        } else {
            handleLevelCompletion();
        }
    }, 333);
}

function awardTimeBonus() {
   const timeSpent = (Date.now() - currentGame.questionStartTime) / 1000;
   const maxTime = 10; // Maximum time allowed per question
   if (timeSpent < maxTime) {
       const bonusCoins = Math.floor(maxTime - timeSpent);
       currentGame.timeBonus += bonusCoins;
       return bonusCoins;
   }
   return 0;
}

function pulseCoins(times = 1) {
    // Update both the header coin icon and the in-game coin icon
    const coinIcons = document.querySelectorAll('.coin-icon');
    
    coinIcons.forEach(coinIcon => {
        let pulseCount = 0;
        const doPulse = () => {
            coinIcon.classList.add('coin-pulse');
            setTimeout(() => {
                coinIcon.classList.remove('coin-pulse');
                pulseCount++;
                if (pulseCount < times) {
                    setTimeout(doPulse, 100);
                }
            }, 500);
        };
        
        doPulse();
    });
}


function updateAllCoinDisplays() {
    const displays = document.querySelectorAll('.coin-count');
    displays.forEach(display => {
        const currentValue = parseInt(display.textContent) || 0;
        let targetValue;

        // Determine the target value based on the context
        if (window.location.pathname.includes('arcade')) {
            targetValue = currentGame.coins || 0;
        } else {
            targetValue = gameState.coins || 0;
        }

        // Ensure we're using actual numeric values
        const startNum = Number(currentValue);
        const endNum = Number(targetValue);

        animateNumber(display, startNum, endNum);
    });
}




function eliminateWrongAnswer() {
   const buttons = document.querySelectorAll('.buttons button');
   const correctAnswer = currentGame.isHebrewToEnglish ? 
       currentGame.words[currentGame.currentIndex] : 
       currentGame.translations[currentGame.currentIndex];
   
   const wrongButtons = Array.from(buttons).filter(btn => 
       btn.textContent !== correctAnswer
   );
   
   if (wrongButtons.length > 0) {
       const buttonToDisable = wrongButtons[Math.floor(Math.random() * wrongButtons.length)];
       buttonToDisable.disabled = true;
       buttonToDisable.style.opacity = '0.5';
   }
}

function revealCorrectAnswer() {
   const correctAnswer = currentGame.isHebrewToEnglish ? 
       currentGame.words[currentGame.currentIndex] : 
       currentGame.translations[currentGame.currentIndex];
   
   document.querySelectorAll('.buttons button').forEach(btn => {
       if (btn.textContent === correctAnswer) {
           btn.classList.add('correct');
           setTimeout(() => {
               currentGame.correctAnswers++;
               currentGame.currentIndex++;
               loadNextQuestion();
           }, 1000);
       } else {
           btn.disabled = true;
           btn.style.opacity = '0.5';
       }
   });
}


// REPLACE buyPerk function
function buyPerk(perkType) {
    const perkConfig = PERK_CONFIG[perkType];
    const button = document.getElementById(`${perkType}Perk`);
    
    if (!perkConfig) {
        console.error('Invalid perk type:', perkType);
        return;
    }

    // Simple coin check
    if (gameState.coins < perkConfig.cost) {
        showNotification(`Need ${perkConfig.cost} coins for ${perkConfig.name}!`, 'error');
        return;
    }

    // Deduct coins first
    gameState.coins -= perkConfig.cost;
    updateAllCoinDisplays();

    // Apply effect immediately
    switch(perkType) {
        case 'timeFreeze':
            isFrozen = true;
            button.disabled = true;
            if (button) {
                const countElement = button.querySelector('.perk-count');
                if (countElement) countElement.textContent = '0';
            }
            setTimeout(() => {
                isFrozen = false;
                button.disabled = false;
                // Re-enable button only if player has enough coins
                if (gameState.coins >= perkConfig.cost) {
                    button.disabled = false;
                }
            }, perkConfig.duration);
            break;

        case 'skip':
            if (button) {
                const countElement = button.querySelector('.perk-count');
                if (countElement) countElement.textContent = '0';
            }
            handleAnswer(true, true);
            break;

        case 'clue':
            if (button) {
                const countElement = button.querySelector('.perk-count');
                if (countElement) countElement.textContent = '0';
            }
            eliminateWrongAnswer();
            break;

        case 'reveal':
            if (button) {
                const countElement = button.querySelector('.perk-count');
                if (countElement) countElement.textContent = '0';
            }
            revealCorrectAnswer();
            break;
    }

    // Update button state based on remaining coins
    if (button) {
        button.disabled = gameState.coins < perkConfig.cost;
        button.classList.toggle('disabled', gameState.coins < perkConfig.cost);
    }

    // Save progress after perk use
    saveProgress();
}

function startCustomListPractice(listId) {
    const list = customPracticeLists.lists.find(l => l.id === listId);
    if (!list) return;

    updatePerkButtons();

    currentGame = {
        words: Array.isArray(list.words) ? list.words : [],
        translations: Array.isArray(list.translations) ? list.translations : [],
        currentIndex: 0,
        correctAnswers: 0,
        firstAttempt: true,
        isCustomPractice: true,
        startingCoins: gameState.coins,
        startingPerks: { ...gameState.perks },
        practiceState: {
            currentLevel: 1,
            words: Array.isArray(list.words) ? list.words : [],
            translations: Array.isArray(list.translations) ? list.translations : [],
            unlockedLevels: new Set([1]),
            progress: {},
            maxLevel: 10,
            listId: listId
        }
    };

    startCustomLevel(1, currentGame.practiceState);
}

function handleLevelCompletion() {
    clearTimer();
    const levelKey = `${gameState.currentStage}_${gameState.currentSet}_${gameState.currentLevel}`;
    const isLevelCompleted = gameState.perfectLevels.has(levelKey);

    const isPerfectRun = !isLevelCompleted && 
                        currentGame.streakBonus && 
                        currentGame.correctAnswers === currentGame.words.length;

    if (isPerfectRun) {
    const finalCoins = gameState.coins;
    
    const bonusAmount = 5;
    
    CoinsManager.updateCoins(bonusAmount).then(() => {
        gameState.perfectLevels.add(levelKey);
        
        const questionScreen = document.getElementById('question-screen');
        const rect = questionScreen.getBoundingClientRect();
        createParticles(rect.left + (rect.width / 2), rect.top + (rect.height / 2));
        gameState.perfectLevels.add(levelKey);
    
    });
}

    pulseCoins(5);
    updatePerkButtons();  
    gameState.perfectLevels.add(levelKey);

    const questionScreen = document.getElementById('question-screen');
    const rect = questionScreen.getBoundingClientRect();
    createParticles(rect.left + (rect.width / 2), rect.top + (rect.height / 2));

    const currentStageConfig = gameStructure.stages[gameState.currentStage - 1];
    const isLastLevelInSet = gameState.currentLevel === currentStageConfig.levelsPerSet;
    const isLastSetInStage = gameState.currentSet === currentStageConfig.numSets;
    const userStatus = currentUser ? currentUser.status : 'unregistered';

    const setKey = `${gameState.currentStage}_${gameState.currentSet}`;
    if (!gameState.unlockedLevels[setKey]) {
        gameState.unlockedLevels[setKey] = new Set();
    }
    gameState.unlockedLevels[setKey].add(gameState.currentLevel);

    // Handle progression based on completion
    if (isLastLevelInSet) {
        if (!isLastSetInStage && userStatus === 'premium') {
            // Premium users: Unlock next set
            const nextSetKey = `${gameState.currentStage}_${gameState.currentSet + 1}`;
            if (!gameState.unlockedSets[gameState.currentStage]) {
                gameState.unlockedSets[gameState.currentStage] = new Set();
            }
            gameState.unlockedSets[gameState.currentStage].add(gameState.currentSet + 1);
            if (!gameState.unlockedLevels[nextSetKey]) {
                gameState.unlockedLevels[nextSetKey] = new Set([1]);
            }
            
            // Progress to next set
            gameState.currentSet++;
            setTimeout(() => startLevel(1), 1500);
        } else if (isLastSetInStage && userStatus === 'premium') {
            // Premium users: Progress to next stage
            if (gameState.currentStage < 5) {
                gameState.currentStage++;
                gameState.currentSet = 1;
                const newSetKey = `${gameState.currentStage}_1`;
                if (!gameState.unlockedSets[gameState.currentStage]) {
                    gameState.unlockedSets[gameState.currentStage] = new Set([1]);
                }
                if (!gameState.unlockedLevels[newSetKey]) {
                    gameState.unlockedLevels[newSetKey] = new Set([1]);
                }
                setTimeout(() => startLevel(1), 1500);
            } else {
                setTimeout(() => showScreen('stage-screen'), 1500);
            }
        } else {
            // Non-premium users: Show upgrade prompt
            showUpgradePrompt();
        }
    } else {
        // Unlock and proceed to next level
        gameState.unlockedLevels[setKey].add(gameState.currentLevel + 1);
        saveProgress();
        setTimeout(() => startLevel(gameState.currentLevel + 1), 1500);
    }

    // Save progress
    saveProgress();
    updateAllCoinDisplays();
    updatePerkButtons();
}

function handleProgression(levelKey) {
    const setKey = `${gameState.currentStage}_${gameState.currentSet}`;
    if (!gameState.unlockedLevels[setKey]) {
        gameState.unlockedLevels[setKey] = new Set();
    }
    gameState.unlockedLevels[setKey].add(gameState.currentLevel);

    const currentStageConfig = gameStructure.stages[gameState.currentStage - 1];
    const isLastLevelInSet = gameState.currentLevel === currentStageConfig.levelsPerSet;
    const isLastSetInStage = gameState.currentSet === currentStageConfig.numSets;

    // Handle unlocks
    if (!isLastLevelInSet) {
        gameState.unlockedLevels[setKey].add(gameState.currentLevel + 1);
    } else if (!isLastSetInStage) {
        unlockNextSet();
    } else if (gameState.currentStage < 5) {
        unlockNextStage();
    }

    saveProgress();
    updateAllCoinDisplays();

    // Progress to next level
    setTimeout(() => {
        if (isLastLevelInSet) {
            if (!isLastSetInStage) {
                gameState.currentSet++;
                startLevel(1);
            } else if (gameState.currentStage < 5) {
                gameState.currentStage++;
                gameState.currentSet = 1;
                startLevel(1);
            } else {
                showScreen('stage-screen');
            }
        } else {
            startLevel(gameState.currentLevel + 1);
        }
    }, 1500);
}

function createCompletionParticles() {
    const questionScreen = document.getElementById('question-screen');
    const rect = questionScreen.getBoundingClientRect();
    const viewportX = rect.left + (rect.width / 2);
    const viewportY = rect.top + (rect.height / 2);
    
    for (let i = 0; i < 5; i++) {
        setTimeout(() => createParticles(viewportX, viewportY), i * 300);
    }
}


function activatePerk(perkType, cost) {
    const powerupCooldown = powerupCooldowns.get(perkType) || 0;
    const now = Date.now();
    
    if (now - powerupCooldown < 5000) { // 5-second cooldown
        showNotification('Perk is on cooldown', 'warning');
        return;
    }

    CoinsManager.updateCoins(-cost).then(success => {
        if (success) {
            gameState.perks[perkType]++;
            saveProgress();
            updatePerkButtons();
            
            // Use perk immediately
            usePerk(perkType);
            
            // Set cooldown
            powerupCooldowns.set(perkType, now);
            
            // Show feedback
            showNotification(`${perkType} activated!`, 'success');
        } else {
            showNotification('Not enough coins', 'error');
        }
    }).catch(error => {
        console.error('Perk activation failed:', error);
        showNotification('Failed to activate perk', 'error');
    });
}
  

// Particle background initialization
function initializeParticles(container = document.body) {
    // Ensure container is a valid DOM element
    if (!(container instanceof HTMLElement)) {
        container = document.body;
    }
    
    // Find or create the particle container
    let particleContainer = container.querySelector('.particle-container');
    if (!particleContainer) {
        particleContainer = document.createElement('div');
        particleContainer.classList.add('particle-container');
        container.appendChild(particleContainer);
    }
    
    const characterSet = [
        ...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
        ...'Î‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎžÎŸÎ Î¡Î£Î¤Î¥Î¦Î§Î¨Î©Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰',
        ...'××‘×’×“×”×•×–×—×˜×™×›×œ×ž× ×¡×¢×¤×¦×§×¨×©×ª'
    ];

    function createLetterParticle() {
        const particle = document.createElement('div');
        particle.classList.add('letter-particle');
        
        particle.textContent = characterSet[Math.floor(Math.random() * characterSet.length)];
        
        const startX = Math.random() * container.clientWidth;
        const startY = Math.random() * container.clientHeight;
        
        const moveX = -100 + Math.random() * 200;
        const moveY = -100 + Math.random() * 200;
        
        const size = 12 + Math.random() * 16;
        const opacity = 0.2 + Math.random() * 0.3;
        const rotate = Math.random() * 180;
        const duration = 8 + Math.random() * 10;
        
        particle.style.cssText = `
            position: absolute;
            left: ${startX}px;
            top: ${startY}px;
            font-size: ${size}px;
            animation: letterFloat ${duration}s ease-in-out forwards;
            --moveX: ${moveX}px;
            --moveY: ${moveY}px;
            --opacity: ${opacity};
            --rotate: ${rotate}deg;
            pointer-events: none;
        `;
        
        particleContainer.appendChild(particle);
        
        setTimeout(() => {
            particleContainer.removeChild(particle);
        }, duration * 1000);
    }
    
    // Initial particles
    for (let i = 0; i < 50; i++) {
        createLetterParticle();
    }
    
    // Continuous particle generation
    const particleInterval = setInterval(createLetterParticle, 1000);
    
    // Optional: store the interval to clear it if needed
    particleContainer.dataset.intervalId = particleInterval;
}

// Modify the existing window.onload
window.onload = async () => {
    await checkExistingSession();
    initializeGame();
    updatePerkButtons();
    
    // Ensure particles on welcome screen
    const welcomeScreen = document.getElementById('welcome-screen');
    initializeParticles(welcomeScreen);
    
    await loadCustomLists();
};

function stopLevelAndGoBack() {
    clearTimer();
    isFrozen = false;
    
    // Reset game state
    currentGame = {
        words: [],
        translations: [],
        currentIndex: 0,
        correctAnswers: 0,
        firstAttempt: true,
        isHebrewToEnglish: false,
        mixed: false,
        speedChallenge: false,
        timeBonus: 0,
        initialTimeRemaining: null,
        streakBonus: true,
        restartsRemaining: null
    };
    
    // Immediately show welcome screen
    showScreen('welcome-screen');
}


function showGameOverOverlay() {
    clearTimer();
    const overlay = document.querySelector('.failure-overlay');
    const title = overlay.querySelector('.failure-title');
    title.textContent = 'Game Over!';
    
    overlay.style.display = 'flex';
    setTimeout(() => {
        overlay.classList.add('show');
    }, 100);
    
    // Set up restart button
    document.querySelector('.restart-button').onclick = () => {
        overlay.classList.remove('show');
        setTimeout(() => {
            overlay.style.display = 'none';
            if (currentGame.isCustomPractice) {
                startCustomLevel(currentGame.practiceState.currentLevel, currentGame.practiceState);
            } else {
                startLevel(gameState.currentLevel);
            }
        }, 1000);
    };
    
    // Set up home button
    document.querySelector('.home-button').onclick = () => {
        overlay.classList.remove('show');
        setTimeout(() => {
            overlay.style.display = 'none';
            showScreen('welcome-screen');
        }, 1000);
    };
}

function updateTimerCircle(timeRemaining, totalTime) {
    const timerProgress = document.querySelector('.timer-progress');
    if (!timerProgress) return;

    const radius = 40;
    const circumference = 2 * Math.PI * radius;
    
    timerProgress.style.strokeDasharray = `${circumference} ${circumference}`;
    
    const percentage = timeRemaining / totalTime;
    const dashoffset = circumference * (1 - percentage);
    timerProgress.style.strokeDashoffset = dashoffset;

    // Add warning state when time is low
    if (timeRemaining <= 10) {
        timerProgress.classList.add('warning');
    } else {
        timerProgress.classList.remove('warning');
    }
}

function handleResetProgress() { 
    if (!isFirstResetAttempt) {
        // Reset game state
        gameState.currentStage = 1;
        gameState.currentSet = 1;
        gameState.currentLevel = 1;
        gameState.coins = 0;
        gameState.unlockedSets = { "1": new Set([1]) };
        gameState.unlockedLevels = { "1_1": new Set([1]) };
        gameState.perfectLevels = new Set();
        gameState.completedLevels = new Set();

        // Clear localStorage
        localStorage.removeItem('simploxProgress');
        localStorage.removeItem('simploxCustomCoins');
        
        // Update UI
        updatePerkButtons();
        updateAllCoinDisplays();
        showScreen('welcome-screen');
        
        // Reset the first attempt flag
        isFirstResetAttempt = true;
        return;
    }

    // First attempt - show warning
    const resetButton = document.querySelector('.reset-button');
    resetButton.classList.add('warning');
    isFirstResetAttempt = false;

    // Clear warning after animation
    setTimeout(() => {
        resetButton.classList.remove('warning');
    }, 1000);

    // Reset the attempt after 10 seconds
    if (resetProgressTimeout) {
        clearTimeout(resetProgressTimeout);
    }
    
    resetProgressTimeout = setTimeout(() => {
        isFirstResetAttempt = true;
    }, 10000);
}

function toggleFullScreen() {
    const button = document.querySelector('.fullscreen-button i');
    
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen()
            .then(() => {
                button.classList.remove('fa-expand');
                button.classList.add('fa-compress');
            })
            .catch(err => {
                console.log(`Error attempting to enable fullscreen: ${err.message}`);
            });
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen()
                .then(() => {
                    button.classList.remove('fa-compress');
                    button.classList.add('fa-expand');
                })
                .catch(err => {
                    console.log(`Error attempting to exit fullscreen: ${err.message}`);
                });
        }
    }
}

async function handleLogout() {
    try {
        const { error } = await supabaseClient.auth.signOut();
        
        if (error) {
            console.error('Supabase logout error:', error.message);
        }

        currentUser = null;
        updateAuthUI();
        showScreen('welcome-screen');
        
        // Reload game progress from localStorage
        initializeGame();

    } catch (error) {
        console.error('Unexpected error during logout:', error);
    }
}


function handleRestartLevel() {
    // If no restarts remaining, ignore the click entirely
    if (currentGame.restartsRemaining <= 0) {
        return;
    }
    
    const restartButton = document.querySelector('.navigation-button.restart-level');
    
    // Update the restarts counter
    currentGame.restartsRemaining--;
    
    // Show visual feedback of remaining restarts
    if (currentGame.restartsRemaining === 1) {
        restartButton.style.opacity = '0.7';
    } else if (currentGame.restartsRemaining === 0) {
        restartButton.classList.add('disabled');
        
        // Remove the click handler when out of restarts
        restartButton.onclick = null;
        // Additional safety: explicitly disable the button
        restartButton.disabled = true;
    }
    
    // Restore initial state
    gameState.coins = currentGame.startingCoins;
    gameState.perks = { ...currentGame.startingPerks };
    
    // Update UI
    updatePerkButtons();
    updateAllCoinDisplays();
    
    // Save current state
    saveProgress();
    
    // Restart the level
    startLevel(gameState.currentLevel);
}

function showStagesFromMenu() {
    showScreen('stage-screen');
}

function findFurthestProgression() {
    // First, check the most recent completed level in Stage 1
    for (let set = 1; set <= 9; set++) {
        const setKey = `1_${set}`;
        const levels = gameState.unlockedLevels[setKey];
        
        if (!levels) continue;
        
        // Get all levels in ascending order
        const levelArray = Array.from(levels).sort((a, b) => a - b);
        const maxLevel = Math.max(...levelArray);
        
        // Find the first incomplete level in this set
        for (let level = 1; level <= maxLevel; level++) {
            const levelKey = `1_${set}_${level}`;
            if (!gameState.perfectLevels.has(levelKey)) {
                return {
                    stage: 1,
                    set: set,
                    level: level
                };
            }
        }
    }
    
    // If no incomplete level found in Stage 1, proceed with other stages
    for (let stage = 1; stage <= 5; stage++) {
        if (!gameState.unlockedSets[stage]) continue;
        
        const sets = Array.from(gameState.unlockedSets[stage]).sort((a, b) => a - b);
        
        for (const set of sets) {
            const setKey = `${stage}_${set}`;
            const levels = gameState.unlockedLevels[setKey];
            
            if (!levels) continue;
            
            const levelArray = Array.from(levels).sort((a, b) => a - b);
            const maxLevel = Math.max(...levelArray);
            
            for (let level = 1; level <= maxLevel; level++) {
                const levelKey = `${stage}_${set}_${level}`;
                if (!gameState.perfectLevels.has(levelKey)) {
                    return {
                        stage: stage,
                        set: set,
                        level: level
                    };
                }
            }
        }
    }
    
    // If no incomplete level found anywhere, return stage 1, set 1, level 1
    return { stage: 1, set: 1, level: 1 };
}



function startGame() {
    
    if (!gameState.unlockedSets[1] || !gameState.unlockedLevels['1_1']) {
        gameState.unlockedSets[1] = new Set([1]);
        gameState.unlockedLevels['1_1'] = new Set([1]);
        gameState.currentStage = 1;
        gameState.currentSet = 1;
        startLevel(1);
        return;
    }
    
    const furthestPoint = findFurthestProgression();
    console.log('Furthest Progression:', furthestPoint); // Diagnostic log
    
    gameState.currentStage = furthestPoint.stage;
    gameState.currentSet = furthestPoint.set;
    startLevel(furthestPoint.level);
}

function showLevelIntro(levelId, setupCallback) {
    // Skip intro for custom practice
    if (currentGame.isCustomPractice) {
        setupCallback();
        return;
    }

    const transitionElement = document.createElement('div');
    transitionElement.className = 'slide-transition';
    
    // Determine level type for styling
    const isTestLevel = [3,6,9,10,13,16,19,20].includes(levelId);
    const isBossLevel = levelId === 21;
    
    let introClass = 'normal-level';
    if (isTestLevel) introClass = 'test-level';
    if (isBossLevel) introClass = 'boss-level';

    transitionElement.innerHTML = `
        <div class="slide-panel-left"></div>
        <div class="slide-panel-right"></div>
        <div class="level-announcement ${introClass}">
            <h1>Stage ${gameState.currentStage}</h1>
            <h2>Level ${gameState.currentSet}-${levelId}</h2>
            ${isTestLevel ? '<div class="test-badge">Review Challenge</div>' : ''}
            ${isBossLevel ? '<div class="boss-badge">Boss Level</div>' : ''}
        </div>
    `;
    
    document.body.appendChild(transitionElement);
    const announcement = transitionElement.querySelector('.level-announcement');
    
    // Force reflow
    transitionElement.offsetHeight;
    
    // Show transition
    transitionElement.classList.add('show');
    announcement.classList.add('show');
    
    // Wait and execute callback
    setTimeout(() => {
        setupCallback();
        transitionElement.classList.remove('show');
        announcement.classList.remove('show');
        
        setTimeout(() => {
            document.body.removeChild(transitionElement);
        }, 400);
    }, 1500);
}

const customPracticeLists = {
    lists: [],
    currentList: null,
    maxLists: 5
};

// Function to add a new word list
function addCustomWordList(name = null) {
    // Check if we've reached the maximum number of lists
    if (customPracticeLists.lists.length >= customPracticeLists.maxLists) {
        alert(`You can only create up to ${customPracticeLists.maxLists} custom lists.`);
        return null;
    }

    // Generate a default name if not provided
    if (!name) {
        name = `List ${customPracticeLists.lists.length + 1}`;
    }

    const newList = {
        id: Date.now(),
        name: name,
        words: [],
        translations: []
    };

    customPracticeLists.lists.push(newList);
    saveCustomLists();
    return newList;
}


// Function to translate a single word using MyMemory Translation API
function translateWord(word) {
    const apiUrl = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(word)}&langpair=en|he`;
    
    return fetch(apiUrl)
        .then(response => response.json())
        .then(data => {
            // Extract translation, fallback to original word if translation fails
            return data.responseData.translatedText || word;
        })
        .catch(() => word);
}

function trackListPlay(listId) {
    const playCountKey = `listPlays_${listId}`;
    let plays = parseInt(localStorage.getItem(playCountKey) || '0');
    plays++;
    
    const limits = getUserListLimits();
    localStorage.setItem(playCountKey, plays);

    if (plays >= limits.maxPlays) {
        // Remove list if max plays reached
        deleteCustomList(listId);
        return false;
    }
    
    return limits.maxPlays - plays;
}



// Function to delete a word from the translation list
function deleteWord(button) {
    button.closest('.word-translation-item').remove();
}



function addNewWord() {
    const wordList = document.getElementById('word-translation-list');
    if (!wordList) return;
    
    const wordItem = document.createElement('div');
    wordItem.className = 'word-translation-item';
    wordItem.draggable = true;
    
    wordItem.innerHTML = `
        <div class="drag-handle">
            <i class="fas fa-grip-vertical"></i>
        </div>
        <span class="source-word" contenteditable="true"></span>
        <input type="text" class="target-word" placeholder="Hebrew translation">
        <button class="delete-word-btn" onclick="deleteWord(this)">âŒ</button>
    `;
    
    wordList.appendChild(wordItem);
    
    // Focus on the new source word field
    const sourceWord = wordItem.querySelector('.source-word');
    sourceWord.focus();
    
    // Initialize drag functionality for the new item
    initializeDragAndDrop(wordItem);
}

function initializeDragAndDrop(item) {
    if (!item) return;
    
    item.setAttribute('draggable', 'true');
    
    item.addEventListener('dragstart', (e) => {
        e.stopPropagation();
        item.classList.add('dragging');
        e.dataTransfer.setData('text/plain', ''); // Firefox compatibility
    });
    
    item.addEventListener('dragend', (e) => {
        e.stopPropagation();
        item.classList.remove('dragging');
    });
}

function makeWordListDraggable(listId) {
    const wordList = document.getElementById('word-translation-list');
    if (!wordList) return;
    
    wordList.addEventListener('dragover', (e) => {
        e.preventDefault();
        const draggingItem = wordList.querySelector('.dragging');
        if (!draggingItem) return;
        
        const afterElement = getDragAfterElement(wordList, e.clientY);
        if (afterElement) {
            wordList.insertBefore(draggingItem, afterElement);
        } else {
            wordList.appendChild(draggingItem);
        }
    });

    const items = wordList.querySelectorAll('.word-translation-item');
    items.forEach(item => initializeDragAndDrop(item));
}

function createWordItem(word, translation) {
    const item = document.createElement('div');
    item.className = 'word-translation-item';
    item.draggable = true;
    
    item.innerHTML = `
        <div class="drag-handle">
            <i class="fas fa-grip-vertical"></i>
        </div>
        <span class="source-word" contenteditable="true">${word}</span>
        <input type="text" class="target-word" value="${translation}" placeholder="Hebrew translation">
        <button class="delete-word-btn" onclick="deleteWord(this)">âŒ</button>
    `;
    
    return item;
}

function createWordTranslationItem(word = '', translation = '', isEditable = false) {
    const wordList = document.getElementById('word-translation-list');
    const wordItem = document.createElement('div');
    wordItem.className = 'word-translation-item';
    wordItem.draggable = true;
    wordItem.innerHTML = `
        <div class="drag-handle">
            <i class="fas fa-grip-vertical"></i>
        </div>
        <span class="source-word ${isEditable ? 'editable' : ''}" 
              contenteditable="${isEditable}">${word}</span>
        <input 
            type="text" 
            class="target-word ${isEditable ? 'editable' : ''}"
            value="${translation}" 
            data-original="${translation}"
            ${isEditable ? '' : 'readonly'}
            placeholder="Hebrew translation"
        >
        <button class="delete-word-btn" onclick="deleteWord(this)">âŒ</button>
    `;
    wordList.appendChild(wordItem);
}

async function saveCustomListToSupabase(list) {
    if (!currentUser || !list) return;

    try {
        const { data, error } = await supabaseClient
            .from('custom_lists')
            .upsert({
                user_id: currentUser.id,
                name: list.name,
                words: list.words,
                translations: list.translations,
                status: list.status || currentUser.status
            }, { onConflict: 'id' });

        if (error) throw error;
    } catch (error) {
        console.error('Error saving list to Supabase:', error);
        showNotification('Failed to save list', 'error');
    }
}


function saveCustomLists() {
    localStorage.setItem('simploxCustomLists', JSON.stringify(customPracticeLists.lists));
    
    if (currentUser) {
        // Also save to Supabase for logged-in users
        customPracticeLists.lists.forEach(list => {
            saveCustomListToSupabase(list);
        });
    }
}

function processCustomWords() {
    const wordInput = document.getElementById('custom-word-input');
    const translationResults = document.getElementById('translation-results');
    const wordList = document.getElementById('word-translation-list');
    const limits = getUserListLimits();
    const rawInput = wordInput.value.trim();
    
    if (!rawInput) {
        showNotification('Please enter at least one word.', 'error');
        return;
    }

    // Parse input based on format
    let words = rawInput.includes(',') ?
        rawInput.split(',').map(word => word.trim()) :
        rawInput.split(/\s+/).filter(word => word.length > 0);

    // Handle phrase entries properly
    words = words.map(word => word.includes(' ') ? [word] : word.split(/\s+/)).flat();

    // Apply limits
    const maxWords = currentUser ? limits.maxWords : 10;
    if (words.length > maxWords) {
        showNotification(`Maximum ${maxWords} words allowed.`, 'error');
        words = words.slice(0, maxWords);
    }

    // Clear and prepare container
    wordList.innerHTML = '';
    translationResults.style.display = 'block';

    // Process and create word items
    words.forEach(word => {
        const foundTranslation = findTranslation(word);
        const wordItem = createWordItem(word, foundTranslation);
        wordList.appendChild(wordItem);
        initializeDragAndDrop(wordItem);
    });

    makeWordListDraggable();
}

function findTranslation(word) {
    for (const set in vocabularySets) {
        const index = vocabularySets[set].words.indexOf(word.toLowerCase());
        if (index !== -1) return vocabularySets[set].translations[index];
    }
    return '';
}


function setupWordListKeyNavigation() {
    const container = document.getElementById('word-translation-list');
    if (!container) return;
    
    container.addEventListener('keydown', (e) => {
        const currentItem = document.activeElement.closest('.word-translation-item');
        if (!currentItem) return;
        
        let targetElement;
        
        switch(e.key) {
            case 'ArrowUp':
                e.preventDefault();
                targetElement = currentItem.previousElementSibling?.querySelector('.source-word');
                break;
            case 'ArrowDown':
                e.preventDefault();
                targetElement = currentItem.nextElementSibling?.querySelector('.source-word');
                break;
            case 'ArrowRight':
                e.preventDefault();
                targetElement = currentItem.querySelector('.target-word');
                break;
            case 'ArrowLeft':
                e.preventDefault();
                targetElement = currentItem.querySelector('.source-word');
                break;
        }
        
        if (targetElement) {
            targetElement.focus();
        }
    });
}

// Call this when word list is populated
setupWordListKeyNavigation();

function editCustomList(listId) {
    // Ensure listId is a number
    listId = typeof listId === 'string' ? parseInt(listId) : listId;
    
    const listItem = document.querySelector(`.custom-list-item[data-list-id="${listId}"]`);
    const editButton = listItem.querySelector('.edit-button');
    const wordList = document.getElementById(`list-${listId}`);
    
    // If currently in edit mode, save the list
    if (editButton.textContent === 'Save') {
        saveCurrentList();
        editButton.textContent = 'Edit';
        listItem.removeAttribute('data-in-edit-mode');
        wordList.innerHTML = '';
        showCustomListsManager();
        return;
    }
    
    const list = customPracticeLists.lists.find(l => l.id === listId);
    if (!list) return;
    
    // Switch to custom practice screen
    showScreen('custom-practice-screen');
    
    // Set the list name
    const listNameInput = document.getElementById('custom-list-name');
    listNameInput.value = list.name;
    
    // Show translations section
    const translationResults = document.getElementById('translation-results');
    const editWordList = document.getElementById('word-translation-list');
    
    // Clear previous translations
    editWordList.innerHTML = '';
    
    // Create translation items for each word
    list.words.forEach((word, index) => {
        const wordItem = document.createElement('div');
        wordItem.className = 'word-translation-item';
        wordItem.draggable = true;
        
        wordItem.innerHTML = `
            <div class="drag-handle">
                <i class="fas fa-grip-vertical"></i>
            </div>
            <span class="source-word" contenteditable="true">${word}</span>
            <input type="text" class="target-word" value="${list.translations[index]}" placeholder="Hebrew translation">
            <button class="delete-word-btn" onclick="deleteWord(this)">âŒ</button>
        `;
        
        editWordList.appendChild(wordItem);
    });
    
    translationResults.style.display = 'block';
    
    // Mark list as in edit mode
    listItem.setAttribute('data-in-edit-mode', 'true');
    
    // Change edit button text
    editButton.textContent = 'Save';
    
    // Store the current list for later saving
    customPracticeLists.currentList = list;
    
    // Initialize drag functionality
    makeWordListDraggable();
}


function saveCurrentList() {
    // Check if editing an existing list
    const existingList = customPracticeLists.currentList;
    
    const listNameInput = document.getElementById('custom-list-name');
    const wordList = document.getElementById('word-translation-list');
    
    // Get current list name
    const name = listNameInput.value.trim() || (existingList ? existingList.name : `List ${customPracticeLists.lists.length + 1}`);
    const words = [];
    const translations = [];
    
    const items = wordList.querySelectorAll('.word-translation-item');
    items.forEach(item => {
        const word = item.querySelector('.source-word').textContent.trim();
        const translation = item.querySelector('.target-word').value.trim();
        
        if (word && translation) {
            words.push(word);
            translations.push(translation);
        }
    });

    if (existingList) {
        // Update existing list
        const index = customPracticeLists.lists.findIndex(l => l.id === existingList.id);
        if (index !== -1) {
            customPracticeLists.lists[index] = {
                ...existingList,
                name: name,
                words: words,
                translations: translations
            };
        }
        customPracticeLists.currentList = null;
    } else {
        // Create new list with limit check
        if (!canCreateMoreLists()) {
            showNotification('Maximum lists limit reached', 'error');
            return;
        }
        customPracticeLists.lists.push({
            id: Date.now(),
            name: name,
            words: words,
            translations: translations
        });
    }
    
    saveCustomLists();
    showCustomListsManager();
}


function canCreateMoreLists() {
    const limits = getUserListLimits();
    return customPracticeLists.lists.length < limits.maxLists;
}

function saveCurrentList() {
    if (!canCreateMoreLists()) {
        alert(`You can only create ${getUserListLimits().maxLists} custom lists.`);
        return;
    }

    const listNameInput = document.getElementById('custom-list-name');
    const wordInput = document.getElementById('custom-word-input');
    const wordList = document.getElementById('word-translation-list');
    const translationResults = document.getElementById('translation-results');
    
    const name = listNameInput.value.trim() || `List ${customPracticeLists.lists.length + 1}`;
    const words = [];
    const translations = [];
    
    const items = wordList.querySelectorAll('.word-translation-item');
    items.forEach(item => {
        const word = item.querySelector('.source-word').textContent.trim();
        const translation = item.querySelector('.target-word').value.trim();
        
        if (word && translation) {
            words.push(word);
            translations.push(translation);
        }
    });

    const limits = getUserListLimits();
    if (words.length > limits.maxWords) {
        alert(`You can only create lists with up to ${limits.maxWords} words.`);
        return;
    }

    const newList = {
        id: Date.now(),
        name: name,
        words: words,
        translations: translations
    };

    customPracticeLists.lists.push(newList);
    
    // Save to localStorage for guest users
    localStorage.setItem('simploxCustomLists', JSON.stringify(customPracticeLists.lists));
    
    // Clear form
    listNameInput.value = '';
    wordInput.value = '';
    wordList.innerHTML = '';
    translationResults.style.display = 'none';
    
    showCustomListsManager();
}

function updateListsDisplay() {
    const container = document.getElementById('custom-lists-container');
    if (!container) return;

    container.innerHTML = '';

    if (customPracticeLists.lists.length === 0) {
        container.innerHTML = '<p>No custom lists created yet. Create your first list!</p>';
        return;
    }

    customPracticeLists.lists.forEach(list => {
        const listItem = document.createElement('div');
        listItem.className = 'custom-list-item';
        listItem.innerHTML = `
            <h3>${list.name}</h3>
            <p>${list.words.length} words</p>
            <div class="list-actions">
                <button onclick="startCustomListPractice(${list.id})">Practice</button>
                <button onclick="editCustomList(${list.id})">Edit</button>
                <button onclick="deleteCustomList(${list.id})">Delete</button>
            </div>
        `;
        container.appendChild(listItem);
    });
}

function startCustomListPractice(listId) {
    const list = customPracticeLists.lists.find(l => l.id === listId);
    if (!list) return;

    // Get play count for this list
    const playCountKey = `listPlays_${listId}`;
    let playsUsed = parseInt(localStorage.getItem(playCountKey) || '0');
    
    // Check play limits
    const limits = getUserListLimits();
    if (playsUsed >= limits.maxPlays) {
        deleteCustomList(listId);
        showCustomListsManager();
        return;
    }

    // Increment play count
    playsUsed++;
    localStorage.setItem(playCountKey, playsUsed);

    currentGame = {
        words: list.words,
        translations: list.translations,
        currentIndex: 0,
        correctAnswers: 0,
        firstAttempt: true,
        isCustomPractice: true,
        startingCoins: gameState.coins,
        startingPerks: { ...gameState.perks },
        practiceState: {
            currentLevel: 1,
            words: list.words,
            translations: list.translations,
            unlockedLevels: new Set([1]),
            progress: {},
            maxLevel: 10,
            listId: listId,
            playsUsed: playsUsed  // Store current play count
        }
    };

    startCustomLevel(1, currentGame.practiceState);
}




function calculateCustomLevelWords(level, practiceState) {
    const { words, translations } = practiceState;
    
    const levelConfigs = {
        1: { start: 0, count: 3, isTest: false },
        2: { start: 3, count: 3, isTest: false },
        3: { start: 0, count: 6, isTest: true },
        4: { start: 6, count: 3, isTest: false },
        5: { start: 9, count: 3, isTest: false },
        6: { start: 6, count: 6, isTest: true },
        7: { start: 12, count: 4, isTest: false },
        8: { start: 16, count: 4, isTest: false },
        9: { start: 12, count: 8, isTest: true },
        10: { start: 0, count: 20, isTest: true, isFinal: true }
    };

    const config = levelConfigs[level];
    if (!config) return null;

    return {
        words: words.slice(config.start, config.start + config.count),
        translations: translations.slice(config.start, config.start + config.count),
        isTest: config.isTest,
        isFinal: config.isFinal
    };
}

function startCustomLevel(levelId, practiceState) {
    const powerupsContainer = document.querySelector('.powerups-container');
if (powerupsContainer) {
    powerupsContainer.style.display = 'none';
}
    const levelData = calculateCustomLevelWords(levelId, practiceState);
    if (!levelData) return;

    currentGame = {
        words: levelData.words,
        translations: levelData.translations,
        currentIndex: 0,
        correctAnswers: 0,
        firstAttempt: true,
        isHebrewToEnglish: levelData.isTest ? Math.random() < 0.5 : false,
        mixed: levelData.isTest,
        speedChallenge: false,
        practiceState: practiceState,
        currentCustomLevel: levelId,
        isCustomPractice: true,
        startingCoins: gameState.coins,
        startingPerks: { ...gameState.perks },
        timeBonus: 0,
        initialTimeRemaining: null,
        streakBonus: true,
        levelStartTime: Date.now(),
        questionStartTime: 0,
        wrongStreak: 0,
        progressLost: 0
    };

    showLevelIntro(levelId, () => {
        showScreen('question-screen');
        updateProgressCircle();
        loadNextQuestion();
        startTimer(currentGame.words.length * 10); // 10 seconds per word
    });
}

function showCustomListsManager() {
    showScreen('custom-practice-screen');
    
    const container = document.getElementById('custom-lists-container');
    if (!container) return;
    
    const limits = getUserListLimits();
    const userStatus = currentUser?.status || 'unregistered';
    
    container.innerHTML = '';
    
    if (customPracticeLists.lists.length === 0) {
        container.innerHTML = '<p style="color: white; text-align: center;">No custom lists created yet. Create your first list!</p>';
        return;
    }

    customPracticeLists.lists.forEach(list => {
        // Get play count
        const playCountKey = `listPlays_${list.id}`;
        const playsUsed = parseInt(localStorage.getItem(playCountKey) || '0');
        const playsLeft = limits.maxPlays - playsUsed;

        if (playsLeft <= 0) return;
        
        const listItem = document.createElement('div');
        listItem.className = `custom-list-item collapsed ${list.is_shared ? 'shared-list' : ''}`;
        listItem.dataset.listId = list.id;
        
        listItem.innerHTML = `
            <div class="list-actions">
                <button class="start-button practice-button">Practice</button>
                <button class="edit-button" data-list-id="${list.id}">Edit</button>
                <button class="start-button delete-button">Delete</button>
                ${userStatus === 'premium' ? `
                    <button class="share-button" onclick="showShareModal(${list.id})">
                        <i class="fas fa-share-alt"></i> Share
                    </button>
                ` : ''}
            </div>
            <div class="list-header">
                <h3>${list.name}</h3>
                <div class="list-summary">
                    <span>${list.words.length} words</span>
                    <span style="color: ${playsLeft <= 2 ? '#ff4444' : '#ffffff'}; margin-left: 1rem;">
                        ${limits.playDisplay}
                    </span>
                    <p class="word-preview">${list.words.slice(0,5).join(', ')}${list.words.length > 5 ? '...' : ''}</p>
                </div>
            </div>
        `;

        // Add event listeners with explicit function calls
        const practiceButton = listItem.querySelector('.practice-button');
        practiceButton.addEventListener('click', () => startCustomListPractice(list.id));

        const editButton = listItem.querySelector('.edit-button');
        editButton.addEventListener('click', () => {
            console.log('Edit button clicked for list:', list.id);
            editCustomList(list.id);
        });

        const deleteButton = listItem.querySelector('.delete-button');
        deleteButton.addEventListener('click', () => {
            console.log('Delete button clicked for list:', list.id);
            deleteCustomList(list.id);
        });

        const header = listItem.querySelector('.list-header');
        header.addEventListener('click', () => toggleListCollapse(list.id));

        container.appendChild(listItem);
    });
}

function getUserListLimits() {
    if (!currentUser) {
        return {
            maxLists: 3,
            maxWords: 10,
            maxPlays: 5,
            canShare: false
        };
    }

    // Get user status from Supabase
    const userStatus = currentUser.status || 'unregistered';
    
    switch(userStatus) {
        case 'free':  // Trial user
            return {
                maxLists: 5,
                maxWords: 20,
                maxPlays: 10,
                canShare: false
            };
            case 'pending':  // Pending premium
            return {
                maxLists: 30,
                maxWords: 50,
                maxPlays: Infinity,
                canShare: false,
                playDisplay: 'âˆž'
            };
        case 'premium':  // Confirmed premium
            return {
                maxLists: 30,
                maxWords: 50,
                maxPlays: Infinity,
                canShare: true,
                playDisplay: 'âˆž'            };
        default:
            return {
                maxLists: 3,
                maxWords: 10,
                maxPlays: 5,
                canShare: false
            };
    }
}

function toggleListCollapse(listId) {
    const listItem = document.querySelector(`.custom-list-item[data-list-id="${listId}"]`);
    const editButton = listItem.querySelector('.edit-button');
    
    if (editButton.textContent === 'Save') {
        // Don't toggle if in edit mode
        return;
    }
    
    listItem.classList.toggle('collapsed');
}

function toggleEditMode(listId) {
    // Convert listId to number if it's a string
    listId = typeof listId === 'string' ? parseInt(listId) : listId;

    const listItem = document.querySelector(`.custom-list-item[data-list-id="${listId}"]`);
    if (!listItem) return;

    const editButton = listItem.querySelector('.edit-button');
    if (!editButton) return;

    const wordList = document.getElementById(`list-${listId}`);
    
    if (editButton.textContent === 'Edit') {
        editButton.textContent = 'Save';
        listItem.classList.remove('collapsed');
        listItem.setAttribute('data-in-edit-mode', 'true');
        
        const list = customPracticeLists.lists.find(l => l.id === listId);
        if (!list) return;

        wordList.innerHTML = '';
        
        list.words.forEach((word, index) => {
            const wordItem = document.createElement('div');
            wordItem.className = 'word-translation-item';
            wordItem.draggable = true;
            
            wordItem.innerHTML = `
                <div class="drag-handle">
                    <i class="fas fa-grip-vertical"></i>
                </div>
                <span class="source-word" contenteditable="true">${word}</span>
                <input type="text" class="target-word" value="${list.translations[index]}" placeholder="Hebrew translation">
                <button class="delete-word-btn" onclick="deleteWord(this)">âŒ</button>
            `;
            
            wordList.appendChild(wordItem);
            initializeDragAndDrop(wordItem);
        });
        
        makeWordListDraggable(listId);
    } else {
        saveListChanges(listId, wordList, listItem);
    }
}

function editCustomList(listId) {
    // Ensure listId is a number
    listId = typeof listId === 'string' ? parseInt(listId) : listId;
    
    const listItem = document.querySelector(`.custom-list-item[data-list-id="${listId}"]`);
    const editButton = listItem.querySelector('.edit-button');
    const wordList = document.getElementById(`list-${listId}`);
    
    // If currently in edit mode, save the list
    if (editButton.textContent === 'Save') {
        saveCurrentList();
        editButton.textContent = 'Edit';
        listItem.removeAttribute('data-in-edit-mode');
        wordList.innerHTML = '';
        showCustomListsManager();
        return;
    }
    
    const list = customPracticeLists.lists.find(l => l.id === listId);
    if (!list) return;
    
    // Switch to custom practice screen
    showScreen('custom-practice-screen');
    
    // Set the list name
    const listNameInput = document.getElementById('custom-list-name');
    listNameInput.value = list.name;
    
    // Show translations section
    const translationResults = document.getElementById('translation-results');
    const editWordList = document.getElementById('word-translation-list');
    
    // Clear previous translations
    editWordList.innerHTML = '';
    
    // Create translation items for each word
    list.words.forEach((word, index) => {
        const wordItem = document.createElement('div');
        wordItem.className = 'word-translation-item';
        wordItem.draggable = true;
        
        wordItem.innerHTML = `
            <div class="drag-handle">
                <i class="fas fa-grip-vertical"></i>
            </div>
            <span class="source-word" contenteditable="true">${word}</span>
            <input type="text" class="target-word" value="${list.translations[index]}" placeholder="Hebrew translation">
            <button class="delete-word-btn" onclick="deleteWord(this)">âŒ</button>
        `;
        
        editWordList.appendChild(wordItem);
    });
    
    translationResults.style.display = 'block';
    
    // Mark list as in edit mode
    listItem.setAttribute('data-in-edit-mode', 'true');
    
    // Change edit button text
    editButton.textContent = 'Save';
    
    // Store the current list for later saving
    customPracticeLists.currentList = list;
    
    // Initialize drag functionality
    makeWordListDraggable();
}

function loadCustomList(listId) {
    const list = customPracticeLists.lists.find(l => l.id === listId);
    if (!list) return;

    customPracticeLists.currentList = list;

    // Populate word input area
    const wordInput = document.getElementById('custom-word-input');
    wordInput.value = list.words.join(', ');

    // Populate list name
    const listNameInput = document.getElementById('custom-list-name');
    listNameInput.value = list.name;

    // Trigger translation process to show the words
    processCustomWords();

    // Show the practice screen
    showScreen('custom-practice-screen');
}

function deleteCustomList(listId) {
    // Ensure listId is a number
    listId = typeof listId === 'string' ? parseInt(listId) : listId;

    // Remove from lists array
    customPracticeLists.lists = customPracticeLists.lists.filter(l => l.id !== listId);
    
    // Remove play count from localStorage
    localStorage.removeItem(`listPlays_${listId}`);
    
    // Update localStorage with remaining lists
    localStorage.setItem('simploxCustomLists', JSON.stringify(customPracticeLists.lists));
    
    // Refresh the lists display
    showCustomListsManager();
}


function addWordToList(listId) {
    const listElement = document.getElementById(`list-${listId}`);
    const listItem = document.querySelector(`.custom-list-item:has([data-list-id="${listId}"])`);
    const editButton = listItem.querySelector('.edit-button');
    
    // Only add word if in edit mode
    if (editButton.textContent !== 'Save') return;

    const wordItem = document.createElement('div');
    wordItem.className = 'word-translation-item';
    wordItem.draggable = true;
    
    wordItem.innerHTML = `
        <div class="drag-handle">
            <i class="fas fa-grip-vertical"></i>
        </div>
        <span class="source-word" contenteditable="true"></span>
        <input type="text" class="target-word" placeholder="Hebrew translation">
        <button class="delete-word-btn" onclick="deleteWord(this)">âŒ</button>
    `;
    
    // Add at the top of the list
    if (listElement.firstChild) {
        listElement.insertBefore(wordItem, listElement.firstChild);
    } else {
        listElement.appendChild(wordItem);
    }
    
    // Make the new item draggable
    initializeDragAndDrop(wordItem);
    
    // Focus on the new word input
    const sourceWord = wordItem.querySelector('.source-word');
    sourceWord.focus();
}

function makeWordListDraggable(listId) {
    const wordList = document.getElementById(`list-${listId}`);
    if (!wordList) return;
    
    // Add dragover event listener to the container
    wordList.addEventListener('dragover', e => {
        e.preventDefault();
        const draggable = wordList.querySelector('.dragging');
        if (!draggable) return;
        
        const afterElement = getDragAfterElement(wordList, e.clientY);
        if (afterElement) {
            wordList.insertBefore(draggable, afterElement);
        } else {
            wordList.appendChild(draggable);
        }
    });

    wordList.addEventListener('drop', e => {
        e.preventDefault();
        const draggingElement = document.querySelector('.dragging');
        if (draggingElement) {
            draggingElement.style.opacity = '1';
            draggingElement.classList.remove('dragging');
        }
    });

    // Initialize drag events for all items
    const items = wordList.querySelectorAll('.word-translation-item');
    items.forEach(item => initializeDragAndDrop(item));
}

function getDragAfterElement(container, y) {
    const draggableItems = [...container.querySelectorAll('.word-translation-item:not(.dragging)')];
    
    return draggableItems.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}


function toggleEditMode(listId) {
    const listItem = document.querySelector(`.custom-list-item:has([data-list-id="${listId}"])`);
    const editButton = listItem.querySelector('.edit-button');
    const wordList = document.getElementById(`list-${listId}`);
    
    if (editButton.textContent === 'Edit') {
        // Enter edit mode
        editButton.textContent = 'Save';
        listItem.classList.remove('collapsed');
        
        // Load editable word list
        const list = customPracticeLists.lists.find(l => l.id === listId);
        wordList.innerHTML = '';
        
        list.words.forEach((word, index) => {
            const wordItem = document.createElement('div');
            wordItem.className = 'word-translation-item';
            wordItem.draggable = true;
            
            wordItem.innerHTML = `
                <div class="drag-handle">
                    <i class="fas fa-grip-vertical"></i>
                </div>
                <span class="source-word" contenteditable="true">${word}</span>
                <input type="text" class="target-word" value="${list.translations[index]}" placeholder="Hebrew translation">
                <button class="delete-word-btn" onclick="deleteWord(this)">âŒ</button>
            `;
            
            wordList.appendChild(wordItem);
        });
        
        // Initialize drag functionality
        makeWordListDraggable(listId);
    } else {
        // Save changes
        saveListChanges(listId, wordList, listItem);
    }
}

function saveListChanges(listId, wordList, listItem) {
    const list = customPracticeLists.lists.find(l => l.id === parseInt(listId));
    const editButton = listItem.querySelector('.edit-button');
    const items = wordList.querySelectorAll('.word-translation-item');
    
    const words = [];
    const translations = [];
    
    items.forEach(item => {
        const word = item.querySelector('.source-word').textContent.trim();
        const translation = item.querySelector('.target-word').value.trim();
        if (word && translation) {
            words.push(word);
            translations.push(translation);
        }
    });
    
    list.words = words;
    list.translations = translations;
    saveCustomLists();
    
    editButton.textContent = 'Edit';
    listItem.removeAttribute('data-in-edit-mode');
    listItem.classList.add('collapsed');
    
    const summary = listItem.querySelector('.list-summary');
    summary.innerHTML = `
        <span>${words.length} words</span>
        <p class="word-preview">${words.slice(0,5).join(', ')}${words.length > 5 ? '...' : ''}</p>
    `;
}


function toggleAuthMode() {
    const loginForm = document.getElementById('loginForm');
    const signupForm = document.getElementById('signupForm');
    
    loginForm.classList.toggle('hidden');
    signupForm.classList.toggle('hidden');
}

async function shareListWithUser(listId, recipientId) {
    try {
        // Enhanced logging and error tracking
        console.group('Share List Diagnostics');
        console.log('Current User ID:', currentUser.id);
        console.log('Recipient User ID:', recipientId);
        console.log('List ID:', listId);

        // Find the original list with more robust checking
        const list = customPracticeLists.lists.find(l => l.id === listId);
        if (!list) {
            console.error('List not found');
            throw new Error('List not found');
        }

        // Comprehensive validation
        if (!recipientId) {
            console.error('Invalid recipient');
            throw new Error('Invalid recipient');
        }

        // Fetch recipient details to confirm existence
        const { data: recipientData, error: recipientError } = await supabaseClient
            .from('user_profiles')
            .select('id, username')
            .eq('id', recipientId)
            .single();

        if (recipientError) {
            console.error('Recipient verification failed:', recipientError);
            throw new Error('Cannot verify recipient');
        }

        // Create shared list with explicit type casting
        const sharedList = {
            user_id: recipientId,
            name: `${list.name} (Shared by ${currentUser.user_metadata?.username || 'Anonymous'})`,
            words: Array.isArray(list.words) ? list.words : [],
            translations: Array.isArray(list.translations) ? list.translations : [],
            is_shared: true,
            local_id: Date.now(),
            shared_with: [recipientId],
            shared_by: currentUser.id
        };

        // Log the payload before insertion
        console.log('Sharing Payload:', sharedList);

        // Use bypass RLS for initial testing
        const { data, error } = await supabaseClient.rpc('insert_shared_list', {
            p_user_id: sharedList.user_id,
            p_name: sharedList.name,
            p_words: sharedList.words,
            p_translations: sharedList.translations,
            p_is_shared: sharedList.is_shared,
            p_local_id: sharedList.local_id,
            p_shared_with: sharedList.shared_with,
            p_shared_by: sharedList.shared_by
        });

        if (error) {
            console.error('Detailed Sharing Error:', error);
            throw error;
        }

        console.log('Share Successful:', data);
        console.groupEnd();

        showSuccessToast('List shared successfully!');
        closeShareModal();

    } catch (error) {
        console.error('Comprehensive Share Failure:', error);
        console.groupEnd();
        showErrorToast(error.message || 'Failed to share list');
    }
}

function updateLocalSharedLists(sharedList) {
    // Add the shared list to the recipient's local lists
    if (currentUser) {
        customPracticeLists.lists.push({
            id: sharedList.local_id,
            supabaseId: sharedList.id,
            name: sharedList.name,
            words: sharedList.words,
            translations: sharedList.translations,
            is_shared: true,
            shared_by: sharedList.shared_by
        });
        
        // Save to local storage or sync
        saveCustomLists();
    }
}

function showSuccessToast(message) {
    const toast = document.createElement('div');
    toast.className = 'toast success';
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
        toast.classList.add('hide');
        setTimeout(() => document.body.removeChild(toast), 600);
    }, 3000);
}

function showErrorToast(message) {
    const toast = document.createElement('div');
    toast.className = 'toast error';
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
        toast.classList.add('hide');
        setTimeout(() => document.body.removeChild(toast), 600);
    }, 3000);
}

function closeShareModal() {
    const modal = document.querySelector('.share-modal');
    const backdrop = document.querySelector('.modal-backdrop');
    
    if (modal) modal.remove();
    if (backdrop) backdrop.remove();
}

async function loadSharedLists() {
    if (!currentUser) return [];

    const { data, error } = await supabaseClient
        .from('custom_lists')
        .select('*')
        .or(`shared_with.cs.{${currentUser.id}},is_shared.eq.true`);

    if (error) {
        console.error('Error loading shared lists:', error);
        return [];
    }

    return data.map(list => ({
        ...list,
        isShared: true
    }));
}

async function showShareModal(listId) {
    // Create modal HTML
    const modal = document.createElement('div');
    modal.innerHTML = `
        <div class="modal-backdrop"></div>
        <div class="share-modal">
            <h3 class="share-modal-header">Share List</h3>
            <div class="users-list">Loading users...</div>
            <button class="share-button modal-close">Cancel</button>
        </div>
    `;
    document.body.appendChild(modal);

    // Fetch users directly from user_profiles
    const { data: users, error } = await supabaseClient
        .from('user_profiles')
        .select('id, username')
        .neq('id', currentUser.id);

    const usersList = modal.querySelector('.users-list');
    usersList.innerHTML = '';

    if (error || !users?.length) {
        usersList.innerHTML = error ? 'Error loading users' : 'No other users found';
        return;
    }

    // Create user list
    users.forEach(user => {
        const userItem = document.createElement('div');
        userItem.className = 'user-item';
        userItem.innerHTML = `
            <span>${user.username || 'Unnamed User'}</span>
            <button class="share-button">Share</button>
        `;
        userItem.querySelector('button').onclick = () => shareListWithUser(listId, user.id);
        usersList.appendChild(userItem);
    });

    // Modal close handlers
    modal.querySelector('.modal-close').onclick = () => document.body.removeChild(modal);
    modal.querySelector('.modal-backdrop').onclick = () => document.body.removeChild(modal);
}



function handleProgressionAfterCompletion(isLevelCompleted) {
    if (!isLevelCompleted && currentGame.streakBonus) {
        // Award completion bonus
        gameState.coins += 5;
        pulseCoins(5);
        
        // Handle level unlocks and progression
        const setKey = `${gameState.currentStage}_${gameState.currentSet}`;
        if (!gameState.unlockedLevels[setKey]) {
            gameState.unlockedLevels[setKey] = new Set();
        }
        gameState.unlockedLevels[setKey].add(gameState.currentLevel);

        const currentStageConfig = gameStructure.stages[gameState.currentStage - 1];
        const isLastLevelInSet = gameState.currentLevel === currentStageConfig.levelsPerSet;
        const isLastSetInStage = gameState.currentSet === currentStageConfig.numSets;

        if (!isLastLevelInSet) {
            startLevel(gameState.currentLevel + 1);
        } else if (!isLastSetInStage) {
            gameState.currentSet++;
            startLevel(1);
        } else {
            showScreen('stage-screen');
        }
        
        saveProgress();
    } else {
        startLevel(gameState.currentLevel);
    }
}

function showSetScreen(stageId) {
    gameState.currentStage = stageId;
    const container = document.getElementById('set-container');
    container.innerHTML = '';
    
    const stage = gameStructure.stages[stageId - 1];
    
    for (let i = 1; i <= stage.numSets; i++) {
        const setButton = document.createElement('div');
        setButton.className = 'set-button active';
        setButton.textContent = `Set ${i}`;
        
        if (gameState.unlockedSets[stageId]?.has(i)) {
            setButton.onclick = () => showLevelScreen(i);
        }
        
        container.appendChild(setButton);
    }
    
    showScreen('set-screen');

    checkUserAccess().then(access => {
        if (!access) return;
        
        container.querySelectorAll('.set-button').forEach((btn, index) => {
            const i = index + 1;
            const hasAccess = access.unlockedStages[stageId] === 'full' || 
                             (access.unlockedStages[stageId] && access.unlockedStages[stageId].includes(i));
            
            if (!hasAccess) {
                btn.classList.remove('active');
                btn.classList.add('locked');
                btn.innerHTML += `<div class="lock-overlay"><i class="fas fa-lock"></i></div>`;
                btn.onclick = () => showUpgradePrompt();
            }
        });
    });
}



function hideUpgradePrompt() {
    const prompt = document.querySelector('.upgrade-prompt');
    if (prompt) {
        prompt.classList.remove('show');
        setTimeout(() => prompt.remove(), 300);
    }
}



function showUpgradePrompt(callback) {
    // Store the current screen and level info
    const gameContext = {
        screen: document.querySelector('.screen.visible')?.id,
        stage: gameState.currentStage,
        set: gameState.currentSet,
        level: gameState.currentLevel
    };
    
    if (gameContext.screen) {
        localStorage.setItem('gameContext', JSON.stringify(gameContext));
    }

    if (!currentUser) {
        showUnregisteredWarning(() => {
            if (callback) callback();
        });
    } else if (!checkUpgradeStatus()) {
        showUpgradeScreen();
    } else {
        // Already requested upgrade, continue with game
        if (callback) callback();
    }
}

function hideUpgradePromptAndContinue() {
    // Hide upgrade screen
    const upgradeScreen = document.getElementById('upgrade-screen');
    if (upgradeScreen) {
        upgradeScreen.classList.remove('visible');
    }
    
    // Reset any frozen state
    isFrozen = false;
    clearTimer();
    
    // Continue to the next level using the current level as reference
    if (gameState.currentLevel) {
        proceedWithLevel(gameState.currentLevel);
    } else {
        showScreen('welcome-screen');
    }
}

function handleUpgradeClick() {
    hideUpgradePrompt();
    showPaymentScreen();
}


async function checkUserAccess() {
    if (!currentUser) {
        return {
            fullAccess: false,
            unlockedStages: {
                1: [1],     // Only set 1 of stage 1
                2: [1],     // Only set 1 of stage 2
                3: [1],     // Only set 1 of stage 3
                4: [1],     // Only set 1 of stage 4
                5: [1]      // Only set 1 of stage 5
            },
            defaultUnlockedLevels: {
                1: true,    // Level 1 always unlocked in set 1
            }
        };
    }

    // Check user access level
    const { data, error } = await supabaseClient
        .from('user_profiles')
        .select('status, payment_pending')
        .eq('id', currentUser.id)
        .single();

    if (error) return null;

    // Free/Pending/Unregistered users
    if (data.payment_pending || data.status === 'free' || data.status === 'pending') {
        return {
            fullAccess: false,
            unlockedStages: {
                1: [1],     // Only set 1 of stage 1
                2: [1],     // Only set 1 of stage 2
                3: [1],     // Only set 1 of stage 3
                4: [1],     // Only set 1 of stage 4
                5: [1]      // Only set 1 of stage 5
            },
            defaultUnlockedLevels: {
                1: true,    // Level 1 always unlocked in set 1
            }
        };
    }

    // Premium users
    if (data.status === 'premium') {
        return {
            fullAccess: true,
            unlockedStages: {
                1: [1],     // Only set 1 initially unlocked
                2: [1],     // Only set 1 initially unlocked
                3: [1],     // Only set 1 initially unlocked
                4: [1],     // Only set 1 initially unlocked
                5: [1]      // Only set 1 initially unlocked
            },
            defaultUnlockedLevels: {
                1: true,    // Level 1 always unlocked in set 1
            }
        };
    }
}

async function showSetScreen(stageId) {
    gameState.currentStage = stageId;
    const container = document.getElementById('set-container');
    container.innerHTML = '';
    
    const stage = gameStructure.stages[stageId - 1];
    
    const access = await checkUserAccess();
    if (!access) return;

    for (let i = 1; i <= stage.numSets; i++) {
        const setButton = document.createElement('div');
        
        // Determine if set is accessible
        const isSetAccessible = (
            (access.unlockedStages[stageId] && access.unlockedStages[stageId].includes(i)) ||
            (i === 1)  // First set always accessible
        );
        
        // Determine if user is premium
        const isPremium = currentUser && currentUser.status === 'premium';
        
        // Set button classes
        setButton.className = `set-button ${isSetAccessible ? 'active' : 'locked'}`;
        setButton.textContent = `Set ${i}`;
        
        if (isSetAccessible) {
            // Always allow clicking on first set
            if (i === 1 || gameState.unlockedSets[stageId]?.has(i)) {
                setButton.onclick = () => showLevelScreen(i);
            }
        } else {
            // Add lock overlay for non-accessible sets
            setButton.innerHTML += `<div class="lock-overlay"><i class="fas fa-lock"></i></div>`;
            
            // For non-premium users, show upgrade prompt
            if (!isPremium && i !== 1) {
                setButton.onclick = () => showUpgradePrompt();
            }
        }
        
        container.appendChild(setButton);
    }
    
    showScreen('set-screen');
}


function toggleAuthMode() {
    const loginForm = document.getElementById('loginForm');
    const signupForm = document.getElementById('signupForm');
    
    loginForm.classList.toggle('hidden');
    signupForm.classList.toggle('hidden');
}

function showUnregisteredWarning(callback) {
    // Prevent multiple popups in the same page load
    if (window.unregisteredWarningShown) {
        if (callback) callback();
        return;
    }

    // Mark that the warning has been shown
    window.unregisteredWarningShown = true;

    const prompt = document.createElement('div');
    prompt.className = 'upgrade-prompt';
    prompt.innerHTML = `
        <div class="upgrade-prompt-content">
            <h2>Save Your Progress!</h2>
            <p>Create a free account to save your progress and unlock more content!</p>
            <div class="upgrade-prompt-buttons">
                <button class="start-button signup-now">Sign Up</button>
                <button class="start-button secondary">Continue Playing</button>
            </div>
        </div>
    `;

    document.body.appendChild(prompt);
    
    // Use requestAnimationFrame to ensure smooth animation
    requestAnimationFrame(() => {
        prompt.classList.add('show');
    });

    function hidePrompt(continueCallback) {
        prompt.classList.remove('show');
        setTimeout(() => {
            document.body.removeChild(prompt);
            if (continueCallback) continueCallback();
        }, 300);
    }

    prompt.querySelector('.signup-now').onclick = () => {
    hidePrompt(() => {
        // First make sure we're on welcome screen
        showScreen('welcome-screen');
        
        // Then show auth modal
        const authModal = document.getElementById('authModal');
        if (authModal) {
            authModal.classList.add('show');
            
            // Switch to signup form
            const signupForm = document.getElementById('signupForm');
            const loginForm = document.getElementById('loginForm');
            if (signupForm && loginForm) {
                signupForm.classList.remove('hidden');
                loginForm.classList.add('hidden');
            }
            
            // Add highlight animation
            const authContainer = document.querySelector('.auth-container');
            if (authContainer) {
                authContainer.classList.add('highlight');
                setTimeout(() => {
                    authContainer.classList.remove('highlight');
                }, 5000);
            }
        }
    });
};

    prompt.querySelector('.secondary').onclick = () => {
        hidePrompt(callback);
    };
}

function handleCustomPracticeCompletion() {
    const completedPerfectly = currentGame.streakBonus && 
        currentGame.correctAnswers === currentGame.words.length;

    if (completedPerfectly) {
        // Award coins
        if (currentGame.firstAttempt) {
            gameState.coins += 3;
            pulseCoins(3);
        } else {
            gameState.coins += 1;
            pulseCoins(1);
        }

        // Add completion bonus
        gameState.coins += 5;
        pulseCoins(5);
        
        updateAllCoinDisplays();
        saveProgress();
        
        const nextLevel = currentGame.currentCustomLevel + 1;
        if (nextLevel <= 10) {
            currentGame.practiceState.unlockedLevels.add(nextLevel);
            currentGame.practiceState.progress[currentGame.currentCustomLevel] = true;
            
            // Show completion curtain before next level
            showLevelIntro(nextLevel, () => {
                startCustomLevel(nextLevel, currentGame.practiceState);
            });
        } else {
            showScreen('custom-practice-screen');
            alert('Congratulations! Practice set completed!');
        }
    } else {
        startCustomLevel(currentGame.currentCustomLevel, currentGame.practiceState);
    }
}

async function processPayment(plan) {
    const plans = {
        monthly: { amount: 9.99, interval: 'month' },
        yearly: { amount: 99.99, interval: 'year' },
        lifetime: { amount: 299.99, interval: 'once' }
    };

    const { data, error } = await supabaseClient
        .from('payment_requests')
        .insert({
            user_id: currentUser.id,
            plan_type: plan,
            amount: plans[plan].amount,
            status: 'pending'
        })
        .select()
        .single();

    if (error) {
        console.error('Payment error:', error);
        return;
    }

    showPaymentMethods(plans[plan].amount, data.id);
}


async function processPayment(method) {
    const prices = {bit: 299.99, paybox: 299.99, kashkash: 299.99, bank: 299.99};
    const referenceCode = generateReferenceCode();
    
    try {
        const { data, error } = await supabaseClient
            .from('payment_requests')
            .insert({
                user_id: currentUser.id,
                payment_method: method,
                amount: prices[method],
                reference_code: referenceCode,
                status: 'pending',
                submission_time: new Date()
            })
            .select();

        if (error) throw error;
        showPaymentDetails(method, referenceCode);
    } catch (error) {
        console.error('Payment error:', error);
    }
}


function showPaymentDetails(method, referenceCode) {
   const paymentDetails = {
       bit: { recipient: "050-1234567", label: "Phone Number" },
       paybox: { recipient: "050-7654321", label: "Payment Link" },
       kashkash: { recipient: "KASHKASH-123", label: "ID" },
       bank: {
           bank: "Leumi",
           branch: "123",
           account: "45678",
           label: "Bank Details"
       }
   };

   const details = paymentDetails[method];
   
   document.querySelector('.payment-container').innerHTML = `
       <h2 class="welcome-title">Payment Details</h2>
       <div class="payment-info">
           <p class="reference">Reference Code: <strong>${referenceCode}</strong></p>
           <p>Amount: â‚ª299.99</p>
           ${method === 'bank' ? `
               <p>Bank: ${details.bank}</p>
               <p>Branch: ${details.branch}</p>
               <p>Account: ${details.account}</p>
           ` : `
               <p>${details.label}: ${details.recipient}</p>
           `}
           <p>Please save your reference code and send payment confirmation via WhatsApp</p>
           <button class="start-button" onclick="openWhatsApp('${referenceCode}')">
               <i class="fab fa-whatsapp"></i> Send Via WhatsApp
           </button>
           <button class="back-button" onclick="showPaymentScreen()">
               <i class="fas fa-arrow-left"></i> Back
           </button>
       </div>
   `;
}

function openWhatsApp(referenceCode) {
   const message = encodeURIComponent(
       `Payment confirmation for reference: ${referenceCode}\n` +
       `Email: ${currentUser.email}`
   );
   window.open(`https://wa.me/972545996417?text=${message}`);
}

// Admin verification interface
function createAdminVerificationInterface() {
    return `
        <div class="admin-verification">
            <h2>Payment Verification Dashboard</h2>
            <div class="pending-payments"></div>
        </div>
    `;
}

// Function to load pending payments
async function loadPendingPayments() {
    const { data, error } = await supabaseClient
        .from('payment_requests')
        .select(`
            id,
            user_id,
            payment_method,
            amount,
            reference_code,
            created_at,
            user_profiles (
                username,
                email
            )
        `)
        .eq('status', 'pending')
        .order('created_at', { ascending: false });

    if (error) {
        console.error('Error loading payments:', error);
        return;
    }

    const container = document.querySelector('.pending-payments');
    container.innerHTML = data.map(payment => `
        <div class="payment-request" data-id="${payment.id}">
            <div class="payment-info">
                <p>Reference: ${payment.reference_code}</p>
                <p>User: ${payment.user_profiles.username}</p>
                <p>Amount: $${payment.amount}</p>
                <p>Method: ${payment.payment_method}</p>
                <p>Date: ${new Date(payment.created_at).toLocaleString()}</p>
            </div>
            <div class="verification-actions">
                <button onclick="verifyPayment('${payment.id}', '${payment.user_id}')">
                    Verify Payment
                </button>
                <button onclick="rejectPayment('${payment.id}')" class="reject">
                    Reject
                </button>
            </div>
        </div>
    `).join('');
}

// Verify payment and upgrade user
async function verifyPayment(paymentId, userId) {
    const { error: updateError } = await supabaseClient
        .from('payment_requests')
        .update({
            status: 'verified',
            verification_time: new Date(),
            admin_verified_by: currentUser.id
        })
        .eq('id', paymentId);

    if (updateError) {
        console.error('Error updating payment:', updateError);
        return;
    }

    const { error: profileError } = await supabaseClient
        .from('user_profiles')
        .update({
            status: 'premium',
            payment_pending: false
        })
        .eq('id', userId);

    if (profileError) {
        console.error('Error updating user profile:', profileError);
        return;
    }

    loadPendingPayments();
}

// Reject payment
async function rejectPayment(paymentId) {
    const { error } = await supabaseClient
        .from('payment_requests')
        .update({
            status: 'rejected',
            verification_time: new Date(),
            admin_verified_by: currentUser.id
        })
        .eq('id', paymentId);

    if (error) {
        console.error('Error rejecting payment:', error);
        return;
    }

    loadPendingPayments();
}

function toggleParentPhone() {
    const isAdult = document.getElementById('isAdult').checked;
    const parentPhoneGroup = document.getElementById('parentPhoneGroup');
    const parentPhoneInput = document.getElementById('parentPhone');
    
    parentPhoneGroup.style.display = isAdult ? 'none' : 'block';
    parentPhoneInput.required = !isAdult;
}

function showUpgradeScreen() {
    // Check if user already submitted upgrade request
    if (localStorage.getItem(`upgradeRequested_${currentUser.id}`)) {
        hideUpgradePromptAndContinue();
        return;
    }
    
    showScreen('upgrade-screen');
}

class RateLimiter {
    constructor(maxRequests = 100, timeWindow = 60000) {
        this.requests = new Map();
    }
    
    checkLimit(userId) {
        const now = Date.now();
        const userRequests = this.requests.get(userId) || [];
        const recentRequests = userRequests.filter(time => now - time < this.timeWindow);
        
        if (recentRequests.length >= this.maxRequests) {
            return false;
        }
        
        recentRequests.push(now);
        this.requests.set(userId, recentRequests);
        return true;
    }
}

function sanitizeInput(input) {
    return input
        .replace(/[<>]/g, '') // Remove potential HTML
        .trim()
        .slice(0, 500); // Reasonable length limit
}


const SessionManager = {
    maxInactiveTime: 30 * 60 * 1000, // 30 minutes
    lastActivity: Date.now(),
    
    init() {
        document.addEventListener('click', () => this.updateActivity());
        document.addEventListener('keypress', () => this.updateActivity());
        setInterval(() => this.checkSession(), 60000);
    },
    
    updateActivity() {
        this.lastActivity = Date.now();
    },
    
    async checkSession() {
        if (Date.now() - this.lastActivity > this.maxInactiveTime) {
            await handleLogout();
            modalSystem.show('timeout', {
                title: "Session Expired",
                message: "Please log in again"
            });
        }
    }
};

const DataValidator = {
    validateGameProgress(progress) {
        const maxAllowedCoins = 100000;
        const maxAllowedPerks = 100;
        
        return {
            ...progress,
            coins: Math.min(progress.coins, maxAllowedCoins),
            perks: Object.fromEntries(
                Object.entries(progress.perks).map(([key, value]) => 
                    [key, Math.min(value, maxAllowedPerks)]
                )
            )
        };
    },
    
    validateCustomList(list) {
        return {
            ...list,
            words: list.words.slice(0, 1000).map(sanitizeInput),
            translations: list.translations.slice(0, 1000).map(sanitizeInput)
        };
    }
};

function escapeHTML(str) {
    return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}

function createListItem(list) {
    return `
        <div class="list-item">
            <h3>${escapeHTML(list.name)}</h3>
            <p>${escapeHTML(list.description)}</p>
        </div>
    `;
}

const ErrorHandler = {
    async logError(error, context) {
        if (currentUser) {
            await supabaseClient
                .from('error_logs')
                .insert([{
                    user_id: currentUser.id,
                    error: error.message,
                    stack: error.stack,
                    context,
                    timestamp: new Date()
                }]);
        }
        console.error(`${context}:`, error);
    },
    
    handleError(error, context) {
        this.logError(error, context);
        modalSystem.show('error', {
            title: "Oops!",
            message: "Something went wrong. Please try again."
        });
    }
};

function toggleParentFields() {
    const isAdult = document.getElementById('isAdult').checked;
    const parentSection = document.getElementById('parentInfoSection');
    const adultSection = document.getElementById('adultInfoSection');
    
    // Get input elements
    const parentInputs = parentSection.querySelectorAll('input');
    const adultInputs = adultSection.querySelectorAll('input');
    
    if (isAdult) {
        parentSection.style.display = 'none';
        adultSection.style.display = 'block';
        
        // Toggle required attributes
        parentInputs.forEach(input => input.required = false);
        adultInputs.forEach(input => input.required = true);
    } else {
        parentSection.style.display = 'block';
        adultSection.style.display = 'none';
        
        // Toggle required attributes
        parentInputs.forEach(input => input.required = true);
        adultInputs.forEach(input => input.required = false);
    }
}

async function handleUpgradeSubmit(event) {
    event.preventDefault();
    const isAdult = document.getElementById('isAdult').checked;
    
    try {
        // First get user profile details
        const { data: userProfile } = await supabaseClient
            .from('user_profiles')
            .select('username, created_at')
            .eq('id', currentUser.id)
            .single();

        let formData = {
            user_id: currentUser.id,
            is_adult: isAdult,
            full_name: isAdult ? document.getElementById('fullName').value : document.getElementById('parentName').value,
            phone: isAdult ? document.getElementById('phone').value : document.getElementById('parentPhone').value,
            parent_name: !isAdult ? document.getElementById('parentName').value : null,
            parent_phone: !isAdult ? document.getElementById('parentPhone').value : null,
            referral_source: document.getElementById('referralSource').value
        };

        if (!validateForm(isAdult)) {
            alert('Please fill in all required fields');
            return;
        }

        const { data, error } = await supabaseClient
            .from('upgrade_requests')
            .insert([formData])
            .select();

        if (error) throw error;

        // Update user profile status to pending
        const { error: profileError } = await supabaseClient
            .from('user_profiles')
            .update({ status: 'pending' })
            .eq('id', currentUser.id);

        if (profileError) throw profileError;

        // Store in localStorage to prevent repeated prompts
        localStorage.setItem(`upgradeRequested_${currentUser.id}`, 'true');

        // Show confirmation popup
        const popup = document.createElement('div');
        popup.className = 'confirmation-popup';
        popup.innerHTML = `
            <h2>Thank You!</h2>
            <p>We've received your upgrade request. We'll contact you soon with payment details.</p>
            <button onclick="continueAfterUpgrade()">Continue Playing</button>
        `;
        document.body.appendChild(popup);
        
        // Show popup with animation
        setTimeout(() => popup.classList.add('show'), 100);

    } catch (error) {
        console.error('Upgrade Request Error:', error);
        alert('Error processing request. Please try again.');
    }
}

function continueAfterUpgrade() {
    // Remove popup
    const popup = document.querySelector('.confirmation-popup');
    if (popup) {
        popup.classList.remove('show');
        setTimeout(() => popup.remove(), 300);
    }
    
    // Hide upgrade screen
    const upgradeScreen = document.getElementById('upgrade-screen');
    if (upgradeScreen) {
        upgradeScreen.classList.remove('visible');
    }
    
    // Clear form
    const form = document.getElementById('upgradeForm');
    if (form) form.reset();
    
    // Update the display manually
    if (currentUser) {
        updateUserStatusDisplay('pending');
    }
    
    // Continue game
    hideUpgradePromptAndContinue();
}

function validateForm(isAdult) {
    if (isAdult) {
        return document.getElementById('fullName').value && 
               document.getElementById('phone').value;
    } else {
        return document.getElementById('parentName').value && 
               document.getElementById('parentPhone').value;
    }
}

function skipUpgrade() {
    hideUpgradePromptAndContinue();
}

function updateUserStatusDisplay(status) {
    const userProfileSection = document.querySelector('.user-profile-section');
    const statusBadge = document.getElementById('userTierText');
    
    if (!userProfileSection || !statusBadge) {
        console.warn('User profile elements not found');
        return;
    }
    
    // Clear existing classes
    statusBadge.className = 'status-badge';
    
    if (!currentUser) {
        statusBadge.classList.add('unregistered');
        statusBadge.textContent = 'Unregistered';
        userProfileSection.style.display = 'none';
    } else {
        userProfileSection.style.display = 'block';
        
        switch(status) {
            case 'free':
                statusBadge.classList.add('trial');
                statusBadge.textContent = 'Trial Account';
                break;
            case 'pending':
                statusBadge.classList.add('pending');
                statusBadge.textContent = 'Premium Pending';
                break;
            case 'premium':
                statusBadge.classList.add('premium');
                statusBadge.textContent = 'Premium';
                break;
            default:
                statusBadge.classList.add('trial');
                statusBadge.textContent = 'Trial Account';
        }
    }
    
    // Update stats if available
    if (currentUser) {
        updateUserStats();
    }
}

async function updateUserStats() {
    try {
        const { data: progress } = await supabaseClient
            .from('game_progress')
            .select('coins')
            .eq('user_id', currentUser.id)
            .single();
            
        const { data: stats } = await supabaseClient
            .from('player_stats')
            .select('unique_words_practiced')
            .eq('user_id', currentUser.id)
            .single();
            
        if (progress) {
            document.getElementById('totalCoins').textContent = progress.coins || 0;
        }
        
        if (stats) {
            document.getElementById('totalWords').textContent = stats.unique_words_practiced || 0;
        }
    } catch (error) {
        console.error('Error updating user stats:', error);
    }
}


function setupUserStatusSubscription() {
    if (!currentUser) return;

    const subscription = supabaseClient
        .channel('user-status-' + currentUser.id)  // Unique channel per user
        .on('postgres_changes', {
            event: 'UPDATE',
            schema: 'public',
            table: 'user_profiles',
            filter: `id=eq.${currentUser.id}`
        }, 
        payload => {
            console.log('Profile update received:', payload.new); // Debug log
            if (payload.new && payload.new.status) {
                updateUserStatusDisplay(payload.new.status);
                
                // If status changed to premium, trigger celebration
                if (payload.new.status === 'premium') {
                    showPremiumCelebration();
                }
            }
        })
        .subscribe(status => {
            console.log('Subscription status:', status); // Debug log
        });

    return subscription;
}

function restoreGameContext() {
    const savedContext = localStorage.getItem('gameContext');
    if (savedContext) {
        const context = JSON.parse(savedContext);
        gameState.currentStage = context.stage || 1;
        gameState.currentSet = context.set || 1;
        gameState.currentLevel = context.level;
        
        // Clear the saved context
        localStorage.removeItem('gameContext');
        
        return true;
    }
    return false;
}

function checkUpgradeStatus() {
    if (!currentUser) return false;
    
    const hasRequestedUpgrade = localStorage.getItem(`upgradeRequested_${currentUser.id}`);
    const isPremium = currentUser.status === 'premium';
    const isPending = currentUser.status === 'pending';
    
    return hasRequestedUpgrade || isPremium || isPending;
}

function navigateHome() {
    console.log('Navigating home with full refresh');
    saveProgress();  // Ensure current state is saved
    window.location.reload(true);
}

function forceReload() {
    console.log('Force Reload Initiated');
    
    // Multiple reload strategies
    if (window.location) {
        window.location.href = window.location.href;  // Reload current page
    }
    
    if (window.location.reload) {
        window.location.reload(true);  // Hard reload with cache bypass
    }
    
    // Fallback reload method
    window.location.replace(window.location.pathname);
}

// Replace ALL home button onclick events with this
document.querySelectorAll('.home-button').forEach(button => {
    button.onclick = function() {
        console.log('Home button clicked');
        forceReload();
    };
});

async function showLeaderboard() {
    showScreen('leaderboard-screen');
    const entriesContainer = document.getElementById('leaderboard-entries');
    
    try {
        async function fetchAndRenderLeaderboard() {
            const { data: leaderboard, error } = await supabaseClient
                .from('player_leaderboard')
                .select('*');
                    
            if (error) {
                console.error('Leaderboard fetch error:', error);
                return;
            }

            const currentEntries = entriesContainer.children;
            
            // Store current positions
            const oldPositions = {};
            Array.from(currentEntries).forEach(entry => {
                const username = entry.querySelector('[data-username]').dataset.username;
                oldPositions[username] = entry.getBoundingClientRect();
            });

            // Render new entries
            entriesContainer.innerHTML = leaderboard.map((entry, index) => `
                <div class="leaderboard-entry ${entry.username === currentUser?.user_metadata?.username ? 'you' : ''} ${index < 3 ? `rank-${index + 1}` : ''}"
                     data-rank="${index + 1}">
                    <div>${entry.player_rank}</div>
                    <div data-username="${entry.username}">${entry.username || 'Anonymous'}</div>
                    <div>${entry.total_levels_completed}</div>
                    <div>${entry.total_words_learned}</div>
                </div>
            `).join('');

            // Apply animations
            const newEntries = entriesContainer.children;
            Array.from(newEntries).forEach(entry => {
                const username = entry.querySelector('[data-username]').dataset.username;
                if (oldPositions[username]) {
                    const oldPos = oldPositions[username];
                    const newPos = entry.getBoundingClientRect();
                    const diff = oldPos.top - newPos.top;
                    
                    if (diff > 0) {
                        entry.classList.add('moving-up');
                    } else if (diff < 0) {
                        entry.classList.add('moving-down');
                    }
                    
                    // Remove animation classes after completion
                    entry.addEventListener('animationend', () => {
                        entry.classList.remove('moving-up', 'moving-down');
                    }, { once: true });
                }
            });
        }

        // Initial load
        await fetchAndRenderLeaderboard();

        // Set up polling
        const pollInterval = setInterval(fetchAndRenderLeaderboard, 10000);

        // Store interval for cleanup
        const leaderboardScreen = document.getElementById('leaderboard-screen');
    if (leaderboardScreen) {
        if (leaderboardScreen.dataset.pollInterval) {
            clearInterval(parseInt(leaderboardScreen.dataset.pollInterval));
        }
        leaderboardScreen.dataset.pollInterval = pollInterval;
    }
    } catch (error) {
        console.error('Detailed leaderboard error:', error);
        entriesContainer.innerHTML = `<p>Error loading leaderboard: ${error.message}</p>`;
    }
}

function cleanupLeaderboard() {
    const leaderboardScreen = document.getElementById('leaderboard-screen');
    if (leaderboardScreen) {
        // Cleanup channel
        if (leaderboardScreen.dataset.channel) {
            supabaseClient.removeChannel(leaderboardScreen.dataset.channel);
            delete leaderboardScreen.dataset.channel;
        }
        // Cleanup interval
        if (leaderboardScreen.dataset.pollInterval) {
            clearInterval(parseInt(leaderboardScreen.dataset.pollInterval));
            delete leaderboardScreen.dataset.pollInterval;
        }
    }
}

async function updatePlayerStats(levelTime, mistakes, currentStreak) {
    if (!currentUser) return;

    console.log('Updating stats:', {
        levelTime,
        mistakes,
        currentStreak,
        words: currentGame.words.length
    });

    try {
        const { data: currentStats, error: fetchError } = await supabaseClient
            .from('player_stats')
            .select('*')
            .eq('user_id', currentUser.id)
            .single();

        if (fetchError && fetchError.code !== 'PGRST116') {
            throw fetchError;
        }

        const updateData = {
            user_id: currentUser.id,
            total_levels_completed: ((currentStats?.total_levels_completed || 0) + 1),
            unique_words_practiced: currentStats?.unique_words_practiced 
                ? currentStats.unique_words_practiced + currentGame.words.length
                : currentGame.words.length,
            last_updated: new Date().toISOString()
        };

        console.log('Sending update with data:', updateData);

        const { error: updateError } = await supabaseClient
            .from('player_stats')
            .upsert(updateData, {
                onConflict: 'user_id',
                returning: 'minimal' // For faster response
            });

        if (updateError) throw updateError;

        console.log('Stats update successful');

    } catch (error) {
        console.error('Error updating player stats:', error);
    }
}

async function checkExistingSession() {
    try {
        const { data: { session } } = await supabaseClient.auth.getSession();
        
        if (session) {
            currentUser = session.user;
            
            // Get initial status
            const { data: profile } = await supabaseClient
                .from('user_profiles')
                .select('status')
                .eq('id', currentUser.id)
                .single();
                
            if (profile) {
                currentUser.status = profile.status; // Store status in user object
                updateUserStatusDisplay(profile.status);
            }
            
            // Initialize real-time updates and periodic check
            initializeStatusCheck();
            
            await Promise.all([
                loadUserGameProgress(currentUser.id),
                loadCustomLists()
            ]);
            updateAuthUI();
            updateGuestPlayButton(); // Add this line
        } else {
            // Explicitly reset user and UI
            currentUser = null;
            updateAuthUI();
            updateUserStatusDisplay(null);
            updateGuestPlayButton(); // Add this line
        }
    } catch (error) {
        console.error('Session check error:', error);
        currentUser = null;
        updateAuthUI();
        updateUserStatusDisplay(null);
        updateGuestPlayButton(); // Add this line
    }
}

function showPremiumCelebration() {
    // Create the celebration overlay
    const celebrationOverlay = document.createElement('div');
    celebrationOverlay.className = 'premium-celebration';
    
    celebrationOverlay.innerHTML = `
        <div class="celebration-content">
            <h1 class="celebration-title">Congratulations!</h1>
            <p class="celebration-message">You've unlocked Premium Access!</p>
            <button class="celebration-button" onclick="handlePremiumCelebrationComplete()">
                Continue
            </button>
        </div>
    `;
    
    // Add to body
    document.body.appendChild(celebrationOverlay);
    
    // Trigger show animation
    setTimeout(() => {
        celebrationOverlay.classList.add('show');
    }, 100);
}

function handlePremiumCelebrationComplete() {
    const overlay = document.querySelector('.premium-celebration');
    if (overlay) {
        overlay.classList.remove('show');
        setTimeout(() => {
            overlay.remove();
            // Optionally refresh the screen or update UI
            showScreen('welcome-screen');
        }, 500);
    }
}

function handlePremiumCelebrationComplete() {
    const overlay = document.querySelector('.premium-celebration');
    if (overlay) {
        overlay.classList.remove('show');
        setTimeout(() => {
            overlay.remove();
            // Refresh game state with new premium access
            showScreen('welcome-screen');
        }, 500);
    }
}

function initializeStatusCheck() {
    // Clear any existing interval
    if (window.statusCheckInterval) {
        clearInterval(window.statusCheckInterval);
    }

    // Only set up interval if user is logged in
    if (currentUser) {
        const statusCheckInterval = setInterval(async () => {
            try {
                // Check if currentUser is still valid
                if (!currentUser || !currentUser.id) {
                    clearInterval(window.statusCheckInterval);
                    return;
                }

                const { data, error } = await supabaseClient
                    .from('user_profiles')
                    .select('status')
                    .eq('id', currentUser.id)
                    .single();
                    
                if (error || !data) {
                    // If no user found, clear interval and reset
                    clearInterval(window.statusCheckInterval);
                    currentUser = null;
                    updateAuthUI();
                    return;
                }
                    
                // Update status display if needed
                updateUserStatusDisplay(data.status);
                
                // If status changes to premium, show celebration
                if (data.status === 'premium' && currentUser.status !== 'premium') {
                    currentUser.status = 'premium';
                    showPremiumCelebration();
                }
            } catch (error) {
                console.error('Status check error:', error);
                // Clear interval on any unexpected error
                clearInterval(window.statusCheckInterval);
                currentUser = null;
                updateAuthUI();
            }
        }, 3000); // Check every 30 seconds
        
        // Store interval ID for cleanup
        window.statusCheckInterval = statusCheckInterval;
    }
}

// ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE





document.addEventListener('DOMContentLoaded', () => {
    const otpInput = document.getElementById('otpInput');
    if (otpInput) {
        otpInput.addEventListener('input', function(e) {
            // Remove any non-numeric characters
            this.value = this.value.replace(/[^0-9]/g, '');
            
            // Limit to 4 digits
            if (this.value.length > 4) {
                this.value = this.value.slice(0, 4);
            }
        });
    }
});

let currentArcadeSession = {
    eventId: null,
    otp: null,
    wordPool: [],
    participants: [],
    teacherId: null,
    wordGoal: 50,
    state: 'pre-start',  // 'pre-start', 'started', 'active', 'ended'
    completedPlayers: [],  // To track players who already completed
    playerRank: null,      // Current player's rank if completed
    winnerScreenShown: false, // Flag to prevent multiple winner screens
    startTime: null,       // When the session started
    endTime: null          // When the session ended
};


async function showArcadeModal() {
    const modal = document.getElementById('arcade-modal');
    const teacherView = document.getElementById('teacher-view');
    const playerView = document.getElementById('player-view');
    const usernameField = document.getElementById('arcadeUsername');
    const usernameGroup = usernameField ? usernameField.closest('.input-group') : null;

    try {
        if (currentUser) {
            const { data: profile } = await supabaseClient
                .from('user_profiles')
                .select('role')
                .eq('id', currentUser.id)
                .single();

            if (profile?.role === 'teacher') {
                // Generate OTP
                const otp = Math.floor(1000 + Math.random() * 9000).toString();

                // Store in session
                currentArcadeSession.otp = otp;
                currentArcadeSession.teacherId = currentUser.id;
                currentArcadeSession.participants = [];
                currentArcadeSession.isInitialized = false;

                // Create channel
                window.arcadeChannel = supabaseClient.channel(`arcade:${otp}`, {
                    config: { broadcast: { self: true } }
                });

                // Set up channel listeners
                window.arcadeChannel
                    .on('broadcast', { event: 'player_join' }, ({ payload }) => {
                        console.log('Player join event received:', payload);
                        if (!currentArcadeSession.participants.find(p => p.username === payload.username)) {
                            currentArcadeSession.participants.push({
                                username: payload.username,
                                wordsCompleted: 0,
                                coins: 0
                            });

                            // Update both player count and leaderboard
                            document.getElementById('player-count').textContent = 
                                currentArcadeSession.participants.length;

                            // Update leaderboard if visible
                            const leaderboard = document.getElementById('arcade-leaderboard');
                            if (leaderboard && leaderboard.offsetParent !== null) {
                                updateAllPlayersProgress();
                            }
                        }
                    })
                    .subscribe();

                // Add custom lists section before displaying teacher view
                const customListsSection = document.createElement('div');
                customListsSection.className = 'custom-lists-selector';
                customListsSection.innerHTML = `
                    <div class="section-header">
                        <h3>Add Custom Lists (Optional)</h3>
                        <button class="add-list-button">+ Add List</button>
                    </div>
                    <div class="selected-lists"></div>
                    <div class="stage-requirement">
                        <div class="requirement-note">* Selecting a stage is required</div>
                    </div>
                `;

                // Insert before stage selector
                const stageSelector = teacherView.querySelector('.stage-selector');
                if (stageSelector) {
                    teacherView.insertBefore(customListsSection, stageSelector);
                    
                    // Handle add list button
                    const addListButton = customListsSection.querySelector('.add-list-button');
                    if (addListButton) {
                        addListButton.onclick = showCustomListDropdown;
                    }
                }

                document.getElementById('otp').textContent = otp;
                teacherView.style.display = 'block';
                playerView.style.display = 'none';

            } else {
                // For registered non-teacher users, auto-fill username and hide that field
                teacherView.style.display = 'none';
                playerView.style.display = 'block';
                
                if (usernameField && usernameGroup) {
                    const username = currentUser.user_metadata?.username || 
                                    currentUser.email.split('@')[0];
                    usernameField.value = username;
                    usernameField.readOnly = true;
                    usernameField.style.display = 'none';
                    
                    // Add a placeholder to show the username
                    const usernamePlaceholder = document.createElement('div');
                    usernamePlaceholder.className = 'username-display';
                    usernamePlaceholder.textContent = `Joining as: ${username}`;
                    usernameGroup.insertBefore(usernamePlaceholder, usernameField);
                }
            }
        } else {
            // For unregistered users, show both username and OTP fields
            teacherView.style.display = 'none';
            playerView.style.display = 'block';
            
            if (usernameField) {
                usernameField.readOnly = false;
                usernameField.style.display = 'block';
                
                // Remove any existing username display
                const existingDisplay = usernameGroup?.querySelector('.username-display');
                if (existingDisplay) existingDisplay.remove();
            }
        }

        modal.style.display = 'block';

    } catch (error) {
        console.error('Arcade setup error:', error);
        alert('Failed to initialize arcade');
    }
}

function showCustomListDropdown() {
    // Debug logs
    console.log('Current user:', currentUser);
    console.log('All custom lists:', customPracticeLists.lists);
    
    // Get teacher's lists, including both owned and shared
    const lists = customPracticeLists.lists.filter(list => 
        list.user_id === currentUser.id || 
        (list.shared_with && list.shared_with.includes(currentUser.id))
    );
    
    console.log('Filtered lists for teacher:', lists);
    
    // First load lists from Supabase
    supabaseClient
        .from('custom_lists')
        .select('*')
        .or(`user_id.eq.${currentUser.id},shared_with.cs.{${currentUser.id}}`)
        .then(({ data, error }) => {
            if (error) {
                console.error('Error fetching lists:', error);
                return;
            }
            
            console.log('Lists from database:', data);
            
            const availableLists = data || [];
            showListsDropdown(availableLists);
        });
}

function showListsDropdown(lists) {
    // Remove any existing dropdowns
    const existingDropdown = document.querySelector('.custom-list-dropdown');
    if (existingDropdown) {
        existingDropdown.remove();
    }
    
    const dropdown = document.createElement('div');
    dropdown.className = 'custom-list-dropdown';
    
    if (!lists || lists.length === 0) {
        dropdown.innerHTML = `
            <div class="list-item">
                <span>No custom lists available</span>
            </div>
        `;
    } else {
        dropdown.innerHTML = `
            <div class="dropdown-content">
                ${lists.map(list => `
                    <div class="list-item" data-id="${list.id}">
                        <span>${list.name}</span>
                        <span class="word-count">(${Array.isArray(list.words) ? list.words.length : 0} words)</span>
                    </div>
                `).join('')}
            </div>
        `;
    }

    const customListsSelector = document.querySelector('.custom-lists-selector');
    customListsSelector.appendChild(dropdown);

    // Add click handlers
    dropdown.querySelectorAll('.list-item[data-id]').forEach(item => {
        item.onclick = (e) => {
            e.stopPropagation();
            const listId = item.dataset.id;
            const list = lists.find(l => l.id == listId);
            if (list) {
                addSelectedList(list);
                dropdown.remove();
            }
        };
    });
}

function addSelectedList(list) {
    const selectedLists = document.querySelector('.selected-lists');
    const listElement = document.createElement('div');
    listElement.className = 'selected-list';
    listElement.dataset.id = list.id;
    listElement.innerHTML = `
        <span>${list.name} (${list.words.length} words)</span>
        <button class="remove-list" onclick="this.parentElement.remove()">Ã—</button>
    `;
    selectedLists.appendChild(listElement);
}

function startPlayerCounting(teacherId) {
    if (window.countInterval) clearInterval(window.countInterval);
    
    async function updateCount() {
        try {
            const { data } = await supabaseClient
                .from('game_progress')
                .select('arcade_session')
                .eq('user_id', teacherId)
                .single();
                
            if (data?.arcade_session?.participants) {
                document.getElementById('player-count').textContent = 
                    data.arcade_session.participants.length;
            }
        } catch (error) {
            console.error('Count update error:', error);
        }
    }
    
    updateCount();
    window.countInterval = setInterval(updateCount, 2000);
}

async function joinArcade() {
    const otp = document.getElementById('otpInput').value.trim().toUpperCase();
    
    try {
        window.arcadeChannel = supabaseClient.channel(`arcade:${otp}`);
        
        const playerName = currentUser ? 
            currentUser.user_metadata?.username : 
            getRandomSimploName();
            
        currentArcadeSession.playerName = playerName;
        
        // Set up state polling
        let stateCheckInterval;
        
        window.arcadeChannel
        .on('broadcast', { event: 'game_end' }, ({ payload }) => {
            handleGameEnd(payload);
                currentArcadeSession.state = payload.state;
                
                if (payload.state === 'active') {
                    currentArcadeSession.wordPool = payload.wordPool;
                    currentArcadeSession.wordGoal = payload.wordGoal;
                    startArcadeGame();
                    if (stateCheckInterval) clearInterval(stateCheckInterval);
                }
            })
            .on('broadcast', { event: 'game_playing' }, ({ payload }) => {
                if (payload.state === 'active') {
                    currentArcadeSession.wordPool = payload.wordPool;
                    currentArcadeSession.wordGoal = payload.wordGoal;
                    startArcadeGame();
                    if (stateCheckInterval) clearInterval(stateCheckInterval);
                }
            })
            .subscribe();

        // Broadcast join
        await window.arcadeChannel.send({
            type: 'broadcast',
            event: 'player_join',
            payload: {
                username: playerName,
                joinedAt: new Date().toISOString()
            }
        });

        // Hide arcade modal and show waiting screen
        document.getElementById('arcade-modal').style.display = 'none';
        showWaitingScreen();

        // Start state polling for late joiners
        stateCheckInterval = setInterval(async () => {
            await window.arcadeChannel.send({
                type: 'broadcast',
                event: 'check_game_status'
            });
        }, 2000);

        // Clear interval after 5 minutes to prevent indefinite polling
        setTimeout(() => {
            if (stateCheckInterval) clearInterval(stateCheckInterval);
        }, 300000);

    } catch (error) {
        console.error('Join error:', error);
        alert('Failed to join arcade');
    }
}

function showJoinButton() {
    const joinButton = document.getElementById('joinGameButton');
    if (joinButton) {
        joinButton.style.display = 'block';
        joinButton.textContent = 'Join Active Game';
    }
}

async function getCurrentCoins() {
    if (!currentUser) return 0;
    
    const { data } = await supabaseClient
        .from('game_progress')
        .select('coins')
        .eq('user_id', currentUser.id)
        .single();
        
    return data?.coins || 0;
}

function getRandomSimploName() {
    const names = [
        'Simplosaurus', 'Simplodian', 'Simpleton', 'Simplonius', 'Simplomancer',
        'Simplonaut', 'Simplobot', 'Simplozilla', 'Simplopedia', 'Simplotron',
        'Simplodex', 'Simplomatic', 'Simplomobile', 'Simplocopter', 'Simplonium',
        'Simplotastic', 'Simplominator', 'Simploverse', 'Simplonado', 'Simplophant',
        'Simplowizard', 'Simplodragon', 'Simplosapien', 'Simploninja', 'Simplowarrior'
    ];
    return names[Math.floor(Math.random() * names.length)];
}

function showWaitingScreen() {
    // First check if game is already active
    if (currentArcadeSession.state === 'active') {
        startArcadeGame();
        return;
    }

    document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('visible');
    });
    
    const waitingScreen = document.getElementById('waiting-screen');
    waitingScreen.classList.add('visible');
    
    const joinButton = document.getElementById('joinGameButton');
    if (joinButton) {
        joinButton.style.display = currentArcadeSession.state === 'active' ? 'block' : 'none';
    }
}

async function initializeArcade() {
    try {
        const initButton = document.querySelector('.initialize-button');
        const endButton = document.querySelector('.end-arcade-button');
        
        initButton.style.display = 'none';
        endButton.classList.add('visible');
        
        // Update session state
        currentArcadeSession.state = 'active';
        
        // Initialize all players with 0 words and their starting coins
        currentArcadeSession.participants = currentArcadeSession.participants.map(player => ({
            ...player,
            wordsCompleted: 0,
            coins: player.coins || 0
        }));
        
        // Update moderator UI immediately
        updateAllPlayersProgress();
        
        // Signal all participants to start
        await window.arcadeChannel.send({
            type: 'broadcast',
            event: 'game_playing',
            payload: {
                wordPool: currentArcadeSession.wordPool,
                wordGoal: currentArcadeSession.wordGoal,
                state: 'active'
            }
        });

    } catch (error) {
        console.error('Initialize error:', error);
        alert('Failed to start game');
    }
}

function showModeratorScreen() {
    // Hide all screens
    document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('visible');
    });
    
    // Show moderator screen
    const moderatorScreen = document.getElementById('moderator-screen');
    moderatorScreen.classList.add('visible');
    
    // Display OTP and generate QR
    const otpDisplay = document.getElementById('moderatorOtp');
    if (otpDisplay && currentArcadeSession.otp) {
        otpDisplay.textContent = currentArcadeSession.otp;
        
        // Generate QR code with proper URL construction
        const currentUrl = window.location.origin + window.location.pathname;
        const joinUrl = `${currentUrl}#join=${currentArcadeSession.otp}`;
        console.log('QR URL generated:', joinUrl);
        
        new QRious({
            element: document.getElementById('qrCode'),
            value: joinUrl,
            size: 200,
            backgroundAlpha: 1,
            foreground: '#16213e',
            background: '#ffffff',
            level: 'H'
        });
        
        // Update all session info at once
        const now = new Date();
        const sessionInfo = {
            'sessionDate': now.toLocaleDateString(),
            'sessionStartTime': now.toLocaleTimeString(),
            'sessionWordGoal': currentArcadeSession.wordGoal,
            'activeParticipantCount': currentArcadeSession.participants.length
        };
        
        Object.entries(sessionInfo).forEach(([id, value]) => {
            const element = document.getElementById(id);
            if (element) element.textContent = value;
        });
    }
    
    initializeLeaderboard();
}

function initializeLeaderboard() {
    const leaderboard = document.getElementById('arcade-leaderboard');
    
    // Add header
    leaderboard.innerHTML = `
        <div class="leaderboard-header">
            <div>Rank</div>
            <div>Player</div>
            <div>Words</div>
            <div>Coins</div>
        </div>
    `;
    
    // Show any existing participants
    if (currentArcadeSession.participants.length > 0) {
        updateAllPlayersProgress();
    }
}


const readyPhrases = [
    "Born Ready!",
    "Ready to Roll!",
    "All Set!",
    "Locked & Loaded!",
    "Ready Player!",
    "Game Face On!",
    "In Position!",
    "Ready to Rock!",
    "Standing By!",
    "Powered Up!",
    "Challenge Ready!",
    "Mission Ready!",
    "Ready to Shine!",
    "Bring it On!",
    "Ready to Rumble!",
    "Set for Success!",
    "Level Ready!",
    "Shields Up!",
    "Word Warrior Ready!",
    "Let's Do This!"
];

const shineColors = [
    '#1E90FF',  // Blue
    '#FF1493',  // Deep Pink
    '#00CED1',  // Dark Turquoise
    '#9370DB',  // Medium Purple
    '#FFD700',  // Gold
    '#FF4500',  // Orange Red
    '#32CD32',  // Lime Green
    '#FF69B4',  // Hot Pink
    '#4169E1',  // Royal Blue
    '#8A2BE2'   // Blue Violet
];


function updateAllPlayersProgress() {
    // Sort by words completed
    const sortedPlayers = [...currentArcadeSession.participants]
        .sort((a, b) => {
            if (b.wordsCompleted !== a.wordsCompleted) {
                return b.wordsCompleted - a.wordsCompleted;
            }
            return b.coins - a.coins;
        });
    
    const getRandomColor = () => shineColors[Math.floor(Math.random() * shineColors.length)];
    const getReadyPhrase = () => readyPhrases[Math.floor(Math.random() * readyPhrases.length)];

    const entries = sortedPlayers.map((player, index) => {
        if (currentArcadeSession.state === 'active' && player.username) {
            // For active players (after game has started)
            return `
                <div class="leaderboard-entry ${index < 3 ? `rank-${index + 1}` : ''}"
                     data-rank="${index + 1}">
                    <div class="rank">${index + 1}</div>
                    <div data-username="${player.username}" class="player-name">${player.username}</div>
                    <div data-words="${player.wordsCompleted || 0}" class="words">${player.wordsCompleted || 0}</div>
                    <div data-coins="${player.coins || 0}" class="coins">${player.coins || 0}</div>
                </div>
            `;
        } else {
            // For waiting players
            return `
                <div class="leaderboard-entry waiting ${index < 3 ? `rank-${index + 1}` : ''}"
                     data-rank="${index + 1}">
                    <div class="rank">${index + 1}</div>
                    <div data-username="${player.username}" class="player-name">${player.username}</div>
                    <div class="player-status-waiting">
                        <span class="status-text" style="color: ${getRandomColor()}">${getReadyPhrase()}</span>
                    </div>
                    <div class="waiting-indicator">
                        <span class="dot"></span>
                        <span class="dot"></span>
                        <span class="dot"></span>
                    </div>
                </div>
            `;
        }
    }).join('');
    
    // Always show the header with all columns
    const leaderboardHTML = `
        <div class="leaderboard-header">
            <div>Rank</div>
            <div>Player</div>
            <div>Words</div>
            <div>Coins</div>
        </div>
        ${entries}
    `;
    
    const leaderboard = document.getElementById('arcade-leaderboard');
    leaderboard.innerHTML = leaderboardHTML;
    
    // Update session metadata
    document.getElementById('activeParticipantCount').textContent = sortedPlayers.length;
    document.getElementById('sessionDate').textContent = new Date().toLocaleDateString();
    document.getElementById('sessionStartTime').textContent = new Date().toLocaleTimeString();
    document.getElementById('sessionWordGoal').textContent = currentArcadeSession.wordGoal;
}

async function startArcade() {
    const selectedStages = Array.from(document.querySelectorAll('.stage-checkboxes input:checked'))
        .map(cb => parseInt(cb.value));
        
    if (selectedStages.length === 0) {
        document.querySelector('.stage-warning').style.display = 'block';
        return;
    }

    currentArcadeSession.wordPool = generateWordPool(selectedStages);
    currentArcadeSession.wordGoal = parseInt(document.getElementById('wordGoal').value);
    currentArcadeSession.state = 'started';  // Update state

    // Add channel subscriptions for progress updates
    window.arcadeChannel
        .on('broadcast', { event: 'progress_update' }, ({ payload }) => {
            updatePlayerProgress(payload);
            checkGameEnd();
        })
        .on('broadcast', { event: 'check_game_status' }, async ({ payload }) => {
            // Respond with current state
            await window.arcadeChannel.send({
                type: 'broadcast',
                event: 'game_state_response',
                payload: {
                    state: currentArcadeSession.state,
                    wordPool: currentArcadeSession.wordPool,
                    wordGoal: currentArcadeSession.wordGoal
                }
            });
        });

    // Hide modal, show moderator screen
    document.getElementById('arcade-modal').style.display = 'none';
    showModeratorScreen();
}

function generateWordPool(stages) {
    let pool = [];
    
    stages.forEach(stage => {
        Object.keys(vocabularySets).forEach(key => {
            if (key.startsWith(`${stage}_`)) {
                const set = vocabularySets[key];
                set.words.forEach((word, index) => {
                    pool.push({
                        word: word,
                        translation: set.translations[index]
                    });
                });
            }
        });
    });
    
    return pool.sort(() => Math.random() - 0.5);
}

function cleanupModeratorScreen() {
    const moderatorScreen = document.getElementById('moderator-screen');
    if (moderatorScreen && moderatorScreen.dataset.channelSubscription) {
        supabaseClient.removeChannel(moderatorScreen.dataset.channelSubscription);
        delete moderatorScreen.dataset.channelSubscription;
    }
}

async function startArcadeGame() {
   const questionScreen = document.getElementById('question-screen');
   questionScreen.classList.add('visible');
   document.getElementById('waiting-screen').classList.remove('visible');
   
   // Determine player username more robustly
   const playerUsername = currentArcadeSession.playerName || 
       (currentUser?.user_metadata?.username || getRandomSimploName());
   
   // Initialize coins
   document.querySelectorAll('.coin-count').forEach(display => {
       display.textContent = currentGame.coins || 0;
       display.style.display = 'flex';
   });
   
   document.querySelectorAll('.coins-container').forEach(container => {
       container.style.display = 'flex';
   });

   // Toggle menus for arcade mode
   const perksContainer = document.querySelector('.perks-container');
   const powerupsContainer = document.querySelector('.powerups-container');
   
   perksContainer.style.display = 'none';
   powerupsContainer.style.display = 'flex';
   
   let initialCoins = 0;
   
   // For premium users, get current coins from game progress
   if (currentUser && currentUser.status === 'premium') {
       try {
           const { data, error } = await supabaseClient
               .from('game_progress')
               .select('coins')
               .eq('user_id', currentUser.id)
               .single();
               
           if (!error && data) {
               initialCoins = data.coins;
               console.log('Loaded initial coins:', initialCoins);
               
               // Immediately update UI and broadcast initial state
               currentGame.coins = initialCoins;
               updateAllCoinDisplays();
               
               // Store initial coins value for final calculations
               currentArcadeSession.initialCoins = initialCoins;
               
               // Broadcast initial coin state
               await window.arcadeChannel.send({
                   type: 'broadcast',
                   event: 'progress_update',
                   payload: {
                       username: playerUsername,
                       wordsCompleted: 0,
                       coins: initialCoins,
                       timestamp: Date.now()
                   }
               });
           }
       } catch (error) {
           console.error('Failed to load coins:', error);
       }
   }
   
   // Mark session start time
   currentArcadeSession.startTime = Date.now();
   
   // Reset game state with additional properties
   currentGame = {
       currentIndex: 0,
       correctStreak: 0,
       wrongStreak: 0,
       words: currentArcadeSession.wordPool,
       wordsCompleted: 0,
       coins: initialCoins,
       lastBroadcast: Date.now(),
       initialCoinsLoaded: true,
       playerUsername: playerUsername
   };

   // Broadcast player initialization BEFORE first question
   try {
       await window.arcadeChannel.send({
           type: 'broadcast',
           event: 'player_initialized',
           payload: {
               username: playerUsername,
               initialCoins: initialCoins,
               wordsCompleted: 0,
               timestamp: Date.now()
           }
       });
   } catch (error) {
       console.error('Initialization broadcast failed:', error);
   }

   // Initialize powerups
   initializePowerups();

   // Set up Supabase real-time leaderboard channel
   const leaderboardChannel = supabaseClient
       .channel('arcade_leaderboard')
       .on('postgres_changes', { 
           event: '*', 
           schema: 'public', 
           table: 'arcade_participants' 
       }, payload => {
           console.log('Direct DB Change:', payload);
           updateAllPlayersProgress();
       })
       .subscribe();

   // Store channel reference for cleanup
   currentArcadeSession.leaderboardChannel = leaderboardChannel;

   // Set up broadcast channel listeners
   window.arcadeChannel
       .on('broadcast', { event: 'player_initialized' }, ({ payload }) => {
           console.log('Player Initialization Received:', payload);
           
           const existingPlayerIndex = currentArcadeSession.participants.findIndex(
               p => p.username === payload.username
           );
           
           const playerEntry = {
               username: payload.username,
               wordsCompleted: 0,
               coins: payload.initialCoins || 0
           };
           
           if (existingPlayerIndex === -1) {
               currentArcadeSession.participants.push(playerEntry);
           } else {
               currentArcadeSession.participants[existingPlayerIndex] = playerEntry;
           }
           
           updateAllPlayersProgress();
           updateArcadeProgress();
       })
       .on('broadcast', { event: 'progress_update' }, ({ payload }) => {
           console.log('Progress update received:', payload);
           if (payload.username !== currentArcadeSession.playerName) {
               const existingPlayerIndex = currentArcadeSession.participants.findIndex(
                   p => p.username === payload.username
               );
               
               if (existingPlayerIndex !== -1) {
                   currentArcadeSession.participants[existingPlayerIndex] = {
                       ...currentArcadeSession.participants[existingPlayerIndex],
                       ...payload
                   };
               } else {
                   currentArcadeSession.participants.push({
                       username: payload.username,
                       wordsCompleted: payload.wordsCompleted || 0,
                       coins: payload.coins || 0
                   });
               }
               
               updatePlayerProgress({
                   username: payload.username,
                   wordsCompleted: payload.wordsCompleted,
                   coins: payload.coins
               });
           }
       })
       .on('broadcast', { event: 'player_completed' }, ({ payload }) => {
           console.log('Player completed event:', payload);
           
           // If this player has completed, add to completed players list
           if (!currentArcadeSession.completedPlayers.includes(payload.username)) {
               currentArcadeSession.completedPlayers.push(payload.username);
           }
           
           // Update player UI
           updatePlayerProgress(payload);
           
           // If 3 players have completed, end the game (failsafe for non-moderator)
           if (currentArcadeSession.completedPlayers.length >= 3) {
               endArcadeForAll();
           }
       })
       .on('broadcast', { event: 'powerup_effect' }, ({ payload }) => {
           if (payload.targetUser === currentArcadeSession.playerName) {
               const powerup = payload.powerup;
               
               // Show notification
               showNotification(
                   `${payload.fromUser} ${powerup.message} you!`,
                   powerup.type
               );

               // Apply effect based on powerup type
               switch (powerup.name) {
                   case 'High Five':
                   case 'Fist Bump':
                       const oldCoins = currentGame.coins;
                       currentGame.coins += powerup.effect;
                       document.querySelectorAll('.coin-count').forEach(display => {
                           animateNumber(display, oldCoins, currentGame.coins);
                       });
                       break;

                   case 'Energy Boost':
                       currentGame.coinMultiplier = 2;
                       currentGame.boostedAnswersLeft = 3;
                       break;

                   case 'Freeze':
                       const buttons = document.querySelectorAll('.buttons button');
                       buttons.forEach(btn => btn.disabled = true);
                       setTimeout(() => {
                           buttons.forEach(btn => btn.disabled = false);
                       }, powerup.duration);
                       break;

                   case 'Coin Storm':
                       currentGame.coinBlockedAnswers = 3;
                       break;

                   case 'Screen Shake':
                       const questionScreen = document.getElementById('question-screen');
                       questionScreen.classList.add('screen-shake');
                       setTimeout(() => {
                           questionScreen.classList.remove('screen-shake');
                       }, powerup.duration);
                       break;
               }

               updatePlayerProgress({
                   username: currentArcadeSession.playerName,
                   coins: currentGame.coins,
                   wordsCompleted: currentGame.wordsCompleted
               });
           }
       })
       .on('broadcast', { event: 'coin_effect' }, ({ payload }) => {
            if (payload.targetUser === currentArcadeSession.playerName) {
                const oldCoins = currentGame.coins;
                currentGame.coins += payload.amount;
                
                // Animate coin changes
                document.querySelectorAll('.coin-count').forEach(display => {
                    animateNumber(display, oldCoins, currentGame.coins);
                });
                
                // Immediately update moderator leaderboard
                const participantIndex = currentArcadeSession.participants.findIndex(
                    p => p.username === currentArcadeSession.playerName
                );
                
                if (participantIndex !== -1) {
                    currentArcadeSession.participants[participantIndex].coins = currentGame.coins;
                    updateModeratorLeaderboard();
                }
                
                // Show notification
                if (payload.type === 'blessing') {
                    showNotification(`${payload.fromUser} high-fived you!`, 'blessing');
                } else if (payload.type === 'curse') {
                    showNotification(`${payload.fromUser} poisoned you!`, 'curse');
                }
                
                // Update leaderboard
                updatePlayerProgress({
                    username: currentArcadeSession.playerName,
                    coins: currentGame.coins,
                    wordsCompleted: currentGame.wordsCompleted
                });
            }
        })
        .on('broadcast', { event: 'game_end' }, ({ payload }) => {
            handleGameEnd(payload);
        });

   // Update UI elements
   updateAllCoinDisplays();
   
   // Start first question
   loadNextArcadeQuestion();
   
   // Initialize arrays to track timers and intervals
   window.arcadeTimeouts = [];
   window.arcadeIntervals = [];
}

async function updateArcadeCoins(amount) {
    const oldCoins = currentGame.coins;
    currentGame.coins += amount;

    // For registered users, update their game_progress
    if (currentUser) {
        try {
            const { error } = await supabaseClient
                .from('game_progress')
                .update({ coins: currentGame.coins })
                .eq('user_id', currentUser.id);

            if (error) throw error;
        } catch (error) {
            console.error('Failed to update coins in database:', error);
            currentGame.coins = oldCoins; // Rollback on error
        }
    }

    // Update displays with animation
    const displays = document.querySelectorAll('.coin-count');
    displays.forEach(display => {
        animateCoinsChange(display, oldCoins, currentGame.coins);
    });

    return currentGame.coins;
}

async function getCurrentCoinsForArcade() {
    if (!currentUser) {
        // For guest users, use localStorage or default
        return parseInt(localStorage.getItem('simploxCustomCoins') || '0');
    }

    // For logged-in users, especially premium
    try {
        const { data, error } = await supabaseClient
            .from('game_progress')
            .select('coins')
            .eq('user_id', currentUser.id)
            .single();

        if (error) console.error('Coin retrieval error:', error);
        return data?.coins || 0;
    } catch (error) {
        console.error('Unexpected coin retrieval error:', error);
        return 0;
    }
}

function loadNextArcadeQuestion() {
    if (!currentGame.words.length) return;
    
    const questionWord = document.getElementById('question-word');
    const buttonsDiv = document.getElementById('buttons');
    
    // Get random word from pool
    const currentIndex = Math.floor(Math.random() * currentGame.words.length);
    const currentWord = currentGame.words[currentIndex];
    
    // 50% chance for Hebrew to English
    const isHebrewToEnglish = Math.random() < 0.5;
    
    questionWord.textContent = isHebrewToEnglish ? 
        currentWord.translation : currentWord.word;
    
    // Generate options
    let options = [isHebrewToEnglish ? currentWord.word : currentWord.translation];
    while (options.length < 3) {
        const randomWord = currentGame.words[Math.floor(Math.random() * currentGame.words.length)];
        const option = isHebrewToEnglish ? randomWord.word : randomWord.translation;
        if (!options.includes(option)) {
            options.push(option);
        }
    }
    
    // Shuffle options
    options = options.sort(() => Math.random() - 0.5);
    
    // Create buttons
    buttonsDiv.innerHTML = '';
    options.forEach(option => {
        const button = document.createElement('button');
        button.textContent = option;
        button.onclick = () => handleArcadeAnswer(
            option === (isHebrewToEnglish ? currentWord.word : currentWord.translation)
        );
        buttonsDiv.appendChild(button);
    });
    
    // Remove used word from pool
    currentGame.words.splice(currentIndex, 1);
}


function updateArcadeProgress() {
    const circle = document.querySelector('.progress-circle .progress');
    const radius = 54;
    const circumference = 2 * Math.PI * radius;
    
    // Default to 0 for initial state
    const progress = currentGame.wordsCompleted 
        ? currentGame.wordsCompleted / currentArcadeSession.wordGoal 
        : 0;
    
    circle.style.strokeDasharray = `${circumference} ${circumference}`;
    circle.style.strokeDashoffset = circumference * (1 - progress);
}

function showArcadeCompletionScreen(playerData) {
    const overlay = document.createElement('div');
    overlay.className = 'arcade-completion-modal';
    overlay.innerHTML = `
        <div class="completion-modal-content">
            <h2>Arcade Complete!</h2>
            <div class="completion-stats">
                <div class="stat-item">
                    <i class="fas fa-book"></i>
                    <span>Words: ${playerData.wordsCompleted}</span>
                </div>
                <div class="stat-item">
                    <i class="fas fa-coins"></i>
                    <span>Coins: ${playerData.coins}</span>
                </div>
                <div class="stat-item">
                    <i class="fas fa-trophy"></i>
                    <span>Rank: ${playerData.rank}</span>
                </div>
            </div>
            <button onclick="exitArcade()" class="start-button">Exit</button>
        </div>
    `;
    
    document.body.appendChild(overlay);
    requestAnimationFrame(() => overlay.classList.add('show'));
}

function exitArcadeCompletion() {
    const modal = document.querySelector('.arcade-completion-modal');
    if (modal) {
        modal.classList.remove('show');
        setTimeout(() => {
            document.body.removeChild(modal);
            showScreen('welcome-screen');
        }, 300);
    }
}

function exitArcade() {
    // Clean up
    if (window.arcadeChannel) {
        window.arcadeChannel.unsubscribe();
    }
    currentArcadeSession = {
        eventId: null,
        otp: null,
        wordPool: [],
        participants: [],
        teacherId: null,
        wordGoal: 50
    };
    
    // Return to welcome screen
    showScreen('welcome-screen');
    document.querySelector('.completion-overlay')?.remove();
}

function handleArcadeAnswer(isCorrect) {
    const now = Date.now();
    const lastAnswerTime = currentGame.lastAnswerTime || 0;
    
    // Enforce 1-second cooldown between answers
    if (now - lastAnswerTime < 1000) {
        return;
    }
    
    currentGame.lastAnswerTime = now;
    
    const playerUsername = currentArcadeSession.playerName || 
        (currentUser?.user_metadata?.username || getRandomSimploName());
    
    if (isCorrect) {
        currentGame.wordsCompleted++;
        currentGame.correctStreak++;
        currentGame.wrongStreak = 0;
        
        // Award coins with streak bonus
        let coinsEarned = 5;
        if (currentGame.correctStreak >= 3) {
            coinsEarned += 5;
        }
        
        CoinsManager.updateCoins(coinsEarned).then(() => {
            // Broadcast progress with updated coins
            if (window.arcadeChannel) {
                window.arcadeChannel.send({
                    type: 'broadcast',
                    event: 'progress_update',
                    payload: {
                        username: playerUsername,
                        wordsCompleted: currentGame.wordsCompleted,
                        coins: gameState.coins,
                        timestamp: Date.now()
                    }
                });
            }
        });
        
        updateArcadeProgress();
        
        // Check if player reached word goal
        if (currentGame.wordsCompleted >= currentArcadeSession.wordGoal) {
            handlePlayerCompletedGoal(playerUsername);
        }
        
    } else {
        currentGame.wrongStreak++;
        currentGame.correctStreak = 0;
        
        // Lose coins with streak penalty
        let coinsLost = 2;
        if (currentGame.wrongStreak >= 3) {
            coinsLost += 3;
        }
        
        CoinsManager.updateCoins(-coinsLost).then(() => {
            // Broadcast progress with updated coins
            if (window.arcadeChannel) {
                window.arcadeChannel.send({
                    type: 'broadcast',
                    event: 'progress_update',
                    payload: {
                        username: playerUsername,
                        wordsCompleted: currentGame.wordsCompleted,
                        coins: gameState.coins,
                        timestamp: Date.now()
                    }
                });
            }
        });
    }
    
    loadNextArcadeQuestion();
}

function checkGameEnd() {
    const completedPlayers = currentArcadeSession.participants
        .filter(p => p.wordsCompleted >= currentArcadeSession.wordGoal)
        .length;
        
    if (completedPlayers >= 3) {
        window.arcadeChannel.send({
            type: 'broadcast',
            event: 'game_end'
        });
    }
}

async function endArcade() {
    try {
        // Mark session as ended
        currentArcadeSession.state = 'ended';
        currentArcadeSession.endTime = Date.now();
        
        // Get final player rankings based on word completion
        const finalRankings = [...currentArcadeSession.participants]
            .sort((a, b) => {
                if (b.wordsCompleted !== a.wordsCompleted) {
                    return b.wordsCompleted - a.wordsCompleted;
                }
                return b.coins - a.coins;
            })
            .map((player, index) => ({
                ...player,
                rank: index + 1 // Assign final rank
            }));
        
        // Broadcast end game event with forcedEnd flag
        await window.arcadeChannel.send({
            type: 'broadcast',
            event: 'game_end',
            payload: {
                state: 'ended',
                allPlayers: finalRankings,
                teacherId: currentUser.id,
                duration: currentArcadeSession.endTime - (currentArcadeSession.startTime || currentArcadeSession.endTime),
                forcedEnd: true
            }
        });
        
        // Show final results for teacher
        showModeratorVictoryScreen(finalRankings);
        
    } catch (error) {
        console.error('End game error:', error);
        alert('Failed to end game');
    }
}

function handleGameEnd(payload) {
    console.log('Game End Payload:', payload);

    // If no payload, exit
    if (!payload) return;
    
    // Use allPlayers if available, otherwise use participants
    let finalPlayers = payload.allPlayers || 
                    payload.participants || 
                    currentArcadeSession.participants || [];
                    
    if (finalPlayers.length === 0) {
        console.warn('No player data found in game end payload');
        showScreen('welcome-screen');
        return;
    }

    // For data consistency, take only top 3 players
    finalPlayers = finalPlayers
        .sort((a, b) => {
            if (a.rank && b.rank) return a.rank - b.rank;
            if (b.wordsCompleted !== a.wordsCompleted) return b.wordsCompleted - a.wordsCompleted;
            return b.coins - a.coins;
        })
        .slice(0, 3)
        .map((player, index) => ({
            ...player,
            rank: player.rank || (index + 1)
        }));

    // Store podium ranks
    if (payload.podiumRanks) {
        currentArcadeSession.podiumRanks = payload.podiumRanks;
    } else {
        // Create podium ranks if not provided
        const podiumRanks = {};
        finalPlayers.forEach(player => {
            if (player.username) {
                podiumRanks[player.username] = player.rank;
            }
        });
        currentArcadeSession.podiumRanks = podiumRanks;
    }

    // If forcibly ended by moderator, just go back to welcome
    if (payload.forcedEnd) {
        showScreen('welcome-screen');
        return;
    }

    // If this is the moderator, show victory screen
    if (currentUser?.id === payload.teacherId) {
        showModeratorVictoryScreen(finalPlayers);
        return;
    }

    // Normal end for players - show final results
    showFinalResultsForPlayer(finalPlayers);
}

function showFinalResultsForPlayer(players) {
    const playerUsername = currentArcadeSession.playerName;
    
    // If player already saw their victory screen (top 3), don't show another
    if (currentArcadeSession.winnerScreenShown && 
        currentArcadeSession.podiumRanks && 
        currentArcadeSession.podiumRanks[playerUsername]) {
        return;
    }
    
    // Ensure we have only top 3 players with ranks properly assigned
    const top3 = players
        .filter(p => p.rank && p.rank <= 3)
        .sort((a, b) => a.rank - b.rank);
    
    // Fill any missing ranks if we don't have 3 players
    while (top3.length < 3) {
        const nextRank = top3.length + 1;
        top3.push({
            username: '---',
            wordsCompleted: 0,
            coins: 0,
            rank: nextRank
        });
    }
    
    // Get current player's rank from podiumRanks if they're in top 3
    let playerRank = currentArcadeSession.podiumRanks?.[playerUsername] || 0;
    const isOnPodium = playerRank > 0 && playerRank <= 3;
    
    // Find current player's stats
    const currentPlayerStats = currentArcadeSession.participants.find(p => p.username === playerUsername);
    
    // Calculate earned coins
    const startingCoins = currentArcadeSession.initialCoins || 0;
    const currentCoins = gameState.coins || currentGame.coins || 0;
    const coinsEarned = currentCoins - startingCoins;
    
    // Create results modal
    const overlay = document.createElement('div');
    overlay.className = 'arcade-completion-modal';
    
    overlay.innerHTML = `
        <div class="completion-modal-content">
            <h2>Arcade Game Complete!</h2>
            ${isOnPodium ? 
                `<p class="personal-result">Congratulations! You finished in ${getOrdinal(playerRank)} place!</p>` : 
                `<p class="personal-result">Better luck next time!</p>`
            }
            <div class="leaderboard-preview">
                <h3>Winners</h3>
                ${top3.map((player) => `
                    <div class="podium-player rank-${player.rank} ${player.username === playerUsername ? 'current-player' : ''}"
                         style="display: flex; justify-content: space-between; padding: 0.75rem 1rem; margin: 0.5rem 0; 
                                background: ${getPlayerBackground(player.rank, player.username === playerUsername)};
                                border-radius: 10px; color: ${player.rank === 1 ? '#000' : '#fff'};">
                        <div class="player-rank">${player.rank}</div>
                        <div class="player-name">${player.username}</div>
                        <div class="player-stats">
                            <span class="player-words">${player.wordsCompleted || 0} words</span>
                            <span class="player-coins">${player.coins || 0} coins</span>
                        </div>
                    </div>
                `).join('')}
            </div>
            <div class="your-stats">
                <h3>Your Results</h3>
                <div class="completion-stats" style="display: flex; justify-content: space-around; margin: 1.5rem 0;">
                    <div class="stat-item" style="text-align: center;">
                        <i class="fas fa-language" style="font-size: 2rem; color: var(--gold); display: block; margin-bottom: 0.5rem;"></i>
                        <span style="display: block; margin-bottom: 0.25rem;">Words Learned</span>
                        <strong style="font-size: 1.5rem;">${currentPlayerStats?.wordsCompleted || currentGame.wordsCompleted || 0}</strong>
                    </div>
                    <div class="stat-item" style="text-align: center;">
                        <i class="fas fa-coins" style="font-size: 2rem; color: var(--gold); display: block; margin-bottom: 0.5rem;"></i>
                        <span style="display: block; margin-bottom: 0.25rem;">Coins Earned</span>
                        <strong style="font-size: 1.5rem;">${coinsEarned}</strong>
                    </div>
                    <div class="stat-item" style="text-align: center;">
                        <i class="fas fa-trophy" style="font-size: 2rem; color: var(--gold); display: block; margin-bottom: 0.5rem;"></i>
                        <span style="display: block; margin-bottom: 0.25rem;">Your Rank</span>
                        <strong style="font-size: 1.5rem;">${isOnPodium ? playerRank : '---'}</strong>
                    </div>
                </div>
            </div>
            <button onclick="exitArcadeCompletion()" class="start-button">
                Return to Welcome
            </button>
        </div>
    `;
    
    document.body.appendChild(overlay);
    requestAnimationFrame(() => overlay.classList.add('show'));
    
    // Helper function for podium background colors
    function getPlayerBackground(rank, isCurrentPlayer) {
        const backgrounds = {
            1: 'linear-gradient(135deg, #FFD700 0%, #FFC800 100%)', // 1st place - gold
            2: 'linear-gradient(135deg, #C0C0C0 0%, #A9A9A9 100%)', // 2nd place - silver
            3: 'linear-gradient(135deg, #CD7F32 0%, #B87333 100%)'  // 3rd place - bronze
        };
        
        if (isCurrentPlayer) {
            return (backgrounds[rank] || 'rgba(255,255,255,0.1)') + 
                   '; border: 2px solid white; box-shadow: 0 0 15px rgba(255,255,255,0.5)';
        }
        
        return backgrounds[rank] || 'rgba(255,255,255,0.1)';
    }
}

function showPersonalVictoryScreen(rank) {
    if (currentArcadeSession.winnerScreenShown) return;
    currentArcadeSession.winnerScreenShown = true;
    
    console.log(`Showing victory screen with rank: ${rank}`);
    
    // Create a personalized victory overlay
    const overlay = document.createElement('div');
    overlay.className = 'arcade-completion-modal';
    
    // Different messages based on rank
    const rankMessages = {
        1: {
            title: "ðŸ† FIRST PLACE! ðŸ†",
            message: "Incredible! You've claimed the top spot!",
            color: "var(--gold)"
        },
        2: {
            title: "ðŸ¥ˆ SECOND PLACE! ðŸ¥ˆ",
            message: "Amazing job! You've secured second place!",
            color: "var(--silver)"
        },
        3: {
            title: "ðŸ¥‰ THIRD PLACE! ðŸ¥‰",
            message: "Well done! You've earned third place!",
            color: "var(--bronze)"
        }
    };
    
    const message = rankMessages[rank] || {
        title: "Game Complete!",
        message: "You've reached the word goal!",
        color: "var(--accent)"
    };
    
    // Calculate coins earned during this arcade session
    const startingCoins = currentArcadeSession.initialCoins || 0;
    const currentCoins = gameState.coins || currentGame.coins || 0;
    const coinsEarned = currentCoins - startingCoins;
    
    overlay.innerHTML = `
        <div class="completion-modal-content">
            <h2 style="color: ${message.color}">${message.title}</h2>
            <p>${message.message}</p>
            <div class="completion-stats">
                <div class="stat-item">
                    <i class="fas fa-language"></i>
                    <span>Words Learned</span>
                    <strong>${currentGame.wordsCompleted}</strong>
                </div>
                <div class="stat-item">
                    <i class="fas fa-coins"></i>
                    <span>Coins Earned</span>
                    <strong>${coinsEarned}</strong>
                </div>
                <div class="stat-item">
                    <i class="fas fa-trophy"></i>
                    <span>Your Rank</span>
                    <strong>${rank}</strong>
                </div>
            </div>
            <button onclick="exitArcadeCompletion()" class="start-button">
                Return to Welcome
            </button>
        </div>
    `;
    
    document.body.appendChild(overlay);
    requestAnimationFrame(() => overlay.classList.add('show'));
}

function showModeratorVictoryScreen(players) {
    // First clean up any existing screens
    const existingOverlay = document.querySelector('.arcade-completion-modal');
    if (existingOverlay) existingOverlay.remove();
    
    // Hide moderator screen
    document.getElementById('moderator-screen').classList.remove('visible');
    
    // Create dramatic victory screen
    const victoryScreen = document.createElement('div');
    victoryScreen.className = 'screen visible';
    victoryScreen.id = 'victory-screen';
    victoryScreen.style.cssText = `
        background: radial-gradient(circle at center, var(--secondary) 0%, var(--primary-dark) 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        width: 100%;
        position: fixed;
        top: 0;
        left: 0;
        z-index: 2000;
    `;
    
    // Get top 3 players
    const top3 = players.slice(0, 3).reverse(); // Reverse so we can reveal 3rd->2nd->1st
    
    victoryScreen.innerHTML = `
        <h1 class="victory-title" style="color: var(--gold); font-size: 3rem; margin-bottom: 2rem; text-align: center;">
            Arcade Champions
        </h1>
        <div class="podium-container" style="display: flex; flex-direction: column; align-items: center; margin: 2rem 0; width: 100%;">
            <div id="winners-reveal" style="display: flex; flex-direction: column; align-items: center; width: 100%;"></div>
        </div>
        <div class="victory-button-container" style="margin-top: 3rem; display: flex; gap: 2rem;">
            <button class="start-button back-button" onclick="showScreen('welcome-screen')">
                Back to Welcome
            </button>
            <button class="start-button play-again-button" onclick="restartArcade()">
                Play Again
            </button>
        </div>
    `;
    
    document.body.appendChild(victoryScreen);
    
    // Dramatic reveal of winners (3rd, 2nd, then 1st place)
    const revealWinners = async () => {
        const winnersContainer = document.getElementById('winners-reveal');
        
        // Function to create confetti
        const createConfetti = () => {
            const colors = ['#FFD700', '#FFA500', '#1E90FF', '#ff1f5a', '#4CAF50'];
            const confettiCount = 200;
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti-piece';
                
                // Random position, color, and animation delay
                const xPos = Math.random() * 100;
                const color = colors[Math.floor(Math.random() * colors.length)];
                const delay = Math.random() * 3;
                const duration = 3 + Math.random() * 2;
                
                confetti.style.cssText = `
                    position: fixed;
                    width: 10px;
                    height: 10px;
                    background-color: ${color};
                    left: ${xPos}vw;
                    top: -5vh;
                    opacity: 0;
                    border-radius: ${Math.random() > 0.5 ? '50%' : '0'};
                    animation: confettiFall ${duration}s ease-in ${delay}s forwards;
                    z-index: 1500;
                `;
                
                document.body.appendChild(confetti);
                
                // Remove after animation completes
                setTimeout(() => {
                    confetti.remove();
                }, (duration + delay) * 1000);
            }
        };
        
        // Define keyframes for confetti animation if not already defined
        if (!document.getElementById('confetti-keyframes')) {
            const keyframes = document.createElement('style');
            keyframes.id = 'confetti-keyframes';
            keyframes.textContent = `
                @keyframes confettiFall {
                    0% { transform: translateY(0) rotate(0deg); opacity: 1; }
                    100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
                }
                @keyframes winnerReveal {
                    0% { transform: translateY(50px); opacity: 0; }
                    100% { transform: translateY(0); opacity: 1; }
                }
                @keyframes spotlight {
                    0%, 100% { box-shadow: 0 0 30px 15px rgba(255, 215, 0, 0.3); }
                    50% { box-shadow: 0 0 50px 25px rgba(255, 215, 0, 0.5); }
                }
                .winner-card {
                    animation: winnerReveal 1s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
                    opacity: 0;
                }
                .first-place {
                    animation: spotlight 2s infinite, winnerReveal 1.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
                }
            `;
            document.head.appendChild(keyframes);
        }
        
        // Reveal 3rd place after a delay
        await new Promise(resolve => setTimeout(resolve, 1000));
        if (top3[0]) {
            const thirdPlace = document.createElement('div');
            thirdPlace.className = 'winner-card';
            thirdPlace.innerHTML = createWinnerCard(top3[0], 3);
            winnersContainer.appendChild(thirdPlace);
        }
        
        // Reveal 2nd place after another delay
        await new Promise(resolve => setTimeout(resolve, 2000));
        if (top3[1]) {
            const secondPlace = document.createElement('div');
            secondPlace.className = 'winner-card';
            secondPlace.innerHTML = createWinnerCard(top3[1], 2);
            winnersContainer.appendChild(secondPlace);
        }
        
        // Reveal 1st place with confetti effect
        await new Promise(resolve => setTimeout(resolve, 3000));
        if (top3[2]) {
            createConfetti(); // Start confetti before revealing 1st place
            const firstPlace = document.createElement('div');
            firstPlace.className = 'winner-card first-place';
            firstPlace.innerHTML = createWinnerCard(top3[2], 1);
            winnersContainer.appendChild(firstPlace);
        }
    };
    
    // Helper to create winner cards
    function createWinnerCard(player, place) {
        const medals = {
            1: 'ðŸ†',
            2: 'ðŸ¥ˆ',
            3: 'ðŸ¥‰'
        };
        
        const colors = {
            1: 'linear-gradient(135deg, #FFD700 0%, #FFC800 100%)',
            2: 'linear-gradient(135deg, #C0C0C0 0%, #A9A9A9 100%)',
            3: 'linear-gradient(135deg, #CD7F32 0%, #B87333 100%)'
        };
        
        const titles = {
            1: 'CHAMPION',
            2: 'RUNNER-UP',
            3: 'HONORABLE MENTION'
        };
        
        return `
            <div class="place-${place}" style="
                background: ${colors[place]};
                padding: 1.5rem;
                border-radius: 20px;
                margin: 1rem 0;
                display: flex;
                align-items: center;
                width: 80%;
                max-width: 500px;
                justify-content: space-between;
                position: relative;
                overflow: hidden;
                box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            ">
                <div class="medal" style="font-size: 3rem; margin-right: 1.5rem;">${medals[place]}</div>
                <div class="player-info" style="flex: 1; color: ${place === 1 ? '#000' : '#fff'};">
                    <div class="player-title" style="font-size: 0.9rem; opacity: 0.8;">${titles[place]}</div>
                    <div class="player-name" style="font-size: 1.8rem; font-weight: bold; margin: 0.5rem 0;">
                        ${player.username}
                    </div>
                    <div class="player-stats" style="display: flex; gap: 1.5rem; margin-top: 0.5rem;">
                        <div class="stat">
                            <span style="opacity: 0.8;">Words:</span>
                            <strong>${player.wordsCompleted || 0}</strong>
                        </div>
                        <div class="stat">
                            <span style="opacity: 0.8;">Coins:</span>
                            <strong>${player.coins || 0}</strong>
                        </div>
                    </div>
                </div>
                <div class="place-number" style="
                    font-size: 5rem;
                    font-weight: bold;
                    opacity: 0.2;
                    position: absolute;
                    right: 20px;
                    top: 50%;
                    transform: translateY(-50%);
                ">${place}</div>
            </div>
        `;
    }
    
    // Start the dramatic reveal
    revealWinners();
}

function showPlayerFinalResults(players) {
    // Find current player's data and rank
    const playerUsername = currentArcadeSession.playerName;
    const currentPlayer = players.find(p => p.username === playerUsername);
    
    // Get player's rank - should be explicitly set in the players array
    const currentPlayerRank = currentPlayer?.rank || 
                            players.findIndex(p => p.username === playerUsername) + 1;
    
    // If we've already shown a victory screen for this player, don't show results
    if (currentArcadeSession.winnerScreenShown && currentPlayerRank <= 3) {
        return;
    }
    
    // Create final results overlay
    const overlay = document.createElement('div');
    overlay.className = 'arcade-completion-modal';
    
    // Get the top 3 players
    const top3 = players
        .filter(p => p.rank <= 3)
        .sort((a, b) => a.rank - b.rank);
    
    // Calculate coins earned during this arcade session
    const startingCoins = currentArcadeSession.initialCoins || 0;
    const currentCoins = gameState.coins || currentGame.coins || 0;
    const coinsEarned = currentCoins - startingCoins;
    
    overlay.innerHTML = `
        <div class="completion-modal-content">
            <h2>Arcade Game Complete!</h2>
            ${currentPlayerRank <= 3 ? 
                `<p class="personal-result">Congratulations! You finished in ${getOrdinal(currentPlayerRank)} place!</p>` : 
                `<p class="personal-result">You earned ${getOrdinal(currentPlayerRank)} place. Better luck next time!</p>`
            }
            <div class="leaderboard-preview">
                <h3>Top Players</h3>
                ${top3.map((player) => `
                    <div class="podium-player rank-${player.rank} ${player.username === playerUsername ? 'current-player' : ''}"
                         style="display: flex; justify-content: space-between; padding: 0.75rem 1rem; margin: 0.5rem 0; 
                                background: ${getPlayerBackground(player.rank, player.username === playerUsername)};
                                border-radius: 10px; color: ${player.rank === 1 ? '#000' : '#fff'};">
                        <div class="player-rank">${player.rank}</div>
                        <div class="player-name">${player.username}</div>
                        <div class="player-stats">
                            <span class="player-words">${player.wordsCompleted || 0} words</span>
                            <span class="player-coins">${player.coins || 0} coins</span>
                        </div>
                    </div>
                `).join('')}
                
                ${currentPlayerRank > 3 ? `
                    <div class="divider" style="border-top: 1px dashed rgba(255,255,255,0.2); margin: 1rem 0;"></div>
                    <div class="current-player-row podium-player"
                         style="display: flex; justify-content: space-between; padding: 0.75rem 1rem; margin: 0.5rem 0; 
                                background: rgba(255,255,255,0.1); border: 1px solid var(--accent);
                                border-radius: 10px; color: var(--text);">
                        <div class="player-rank">${currentPlayerRank}</div>
                        <div class="player-name">${playerUsername}</div>
                        <div class="player-stats">
                            <span class="player-words">${currentPlayer?.wordsCompleted || 0} words</span>
                            <span class="player-coins">${currentPlayer?.coins || 0} coins</span>
                        </div>
                    </div>
                ` : ''}
            </div>
            <div class="your-stats">
                <h3>Your Results</h3>
                <div class="completion-stats" style="display: flex; justify-content: space-around; margin: 1.5rem 0;">
                    <div class="stat-item" style="text-align: center;">
                        <i class="fas fa-language" style="font-size: 2rem; color: var(--gold); display: block; margin-bottom: 0.5rem;"></i>
                        <span style="display: block; margin-bottom: 0.25rem;">Words Learned</span>
                        <strong style="font-size: 1.5rem;">${currentPlayer?.wordsCompleted || 0}</strong>
                    </div>
                    <div class="stat-item" style="text-align: center;">
                        <i class="fas fa-coins" style="font-size: 2rem; color: var(--gold); display: block; margin-bottom: 0.5rem;"></i>
                        <span style="display: block; margin-bottom: 0.25rem;">Coins Earned</span>
                        <strong style="font-size: 1.5rem;">${coinsEarned}</strong>
                    </div>
                    <div class="stat-item" style="text-align: center;">
                        <i class="fas fa-trophy" style="font-size: 2rem; color: var(--gold); display: block; margin-bottom: 0.5rem;"></i>
                        <span style="display: block; margin-bottom: 0.25rem;">Your Rank</span>
                        <strong style="font-size: 1.5rem;">${currentPlayerRank}</strong>
                    </div>
                </div>
            </div>
            <button onclick="exitArcadeCompletion()" class="start-button">
                Return to Welcome
            </button>
        </div>
    `;
    
    document.body.appendChild(overlay);
    requestAnimationFrame(() => overlay.classList.add('show'));
    
    // Helper function for podium background colors
    function getPlayerBackground(rank, isCurrentPlayer) {
        const backgrounds = {
            1: 'linear-gradient(135deg, #FFD700 0%, #FFC800 100%)', // 1st place - gold
            2: 'linear-gradient(135deg, #C0C0C0 0%, #A9A9A9 100%)', // 2nd place - silver
            3: 'linear-gradient(135deg, #CD7F32 0%, #B87333 100%)'  // 3rd place - bronze
        };
        
        if (isCurrentPlayer) {
            return (backgrounds[rank] || 'rgba(255,255,255,0.1)') + 
                   '; border: 2px solid white; box-shadow: 0 0 15px rgba(255,255,255,0.5)';
        }
        
        return backgrounds[rank] || 'rgba(255,255,255,0.1)';
    }
}

function removePlayer(username) {
    // Remove player from current arcade session
    currentArcadeSession.participants = currentArcadeSession.participants.filter(
        player => player.username !== username
    );
    
    // Broadcast player removal
    if (window.arcadeChannel) {
        window.arcadeChannel.send({
            type: 'broadcast',
            event: 'player_removed',
            payload: { username }
        });
    }
    
    // Update leaderboard
    updateAllPlayersProgress();
}

function toggleSidePanel() {
    const sidePanel = document.querySelector('.side-panel');
    const hamburgerButton = document.querySelector('.hamburger-button');
    const modalOverlay = document.querySelector('.modal-overlay');
    
    if (sidePanel.classList.contains('open')) {
        sidePanel.classList.remove('open');
        hamburgerButton.classList.remove('open');
        if (modalOverlay) modalOverlay.classList.remove('open');
    } else {
        sidePanel.classList.add('open');
        hamburgerButton.classList.add('open');
        if (modalOverlay) modalOverlay.classList.add('open');
    }
}

function showAuthModal() {
    const modal = document.getElementById('authModal');
    if (modal) {
        modal.classList.add('open');
    }
}

function hideAuthModal() {
    const modal = document.getElementById('authModal');
    if (modal) {
        modal.classList.remove('open');
    }
}

function updateAuthUI() {
    const sidePanel = document.querySelector('.side-panel');
    const userProfileSection = document.querySelector('.user-profile-section');
    const userEmailElement = document.getElementById('userEmail');
    const logoutButton = document.querySelector('.logout-button');
    const mainLoginButton = document.querySelector('.main-button');

    if (currentUser) {
        // Show side panel elements
        if (userProfileSection) userProfileSection.style.display = 'block';
        if (logoutButton) logoutButton.style.display = 'block';
        
        // Update username/email display
        if (userEmailElement) {
            userEmailElement.textContent = currentUser.user_metadata?.username || currentUser.email;
        }
        
        // Hide main login button
        if (mainLoginButton) {
            mainLoginButton.style.display = 'none';
        }
        
        // Update stats
        updateUserStats();
    } else {
        // Hide user info and logout in side panel
        if (userProfileSection) userProfileSection.style.display = 'none';
        if (logoutButton) logoutButton.style.display = 'none';
        
        // Show main login button
        if (mainLoginButton) {
            mainLoginButton.style.display = 'block';
        }
    }
}

function showAuthModal() {
    const modal = document.getElementById('authModal');
    if (modal) {
        modal.classList.add('show');
    }
}

function hideAuthModal() {
    const modal = document.getElementById('authModal');
    if (modal) {
        modal.classList.remove('show');
    }
}

// Add click outside handler for auth modal
document.addEventListener('click', (e) => {
    const authModal = document.getElementById('authModal');
    const authContent = authModal?.querySelector('.auth-modal-content');
    const arcadeModal = document.getElementById('arcade-modal');
    const arcadeContent = arcadeModal?.querySelector('.modal-content');
    
    // Handle auth modal
    if (authModal?.classList.contains('show') && 
        !authContent.contains(e.target) && 
        !e.target.matches('.main-button')) {
        hideAuthModal();
    }
    
    // Handle arcade modal
    if (arcadeModal?.style.display === 'block' && 
        !arcadeContent.contains(e.target) && 
        !e.target.matches('.arcade-button')) {
        arcadeModal.style.display = 'none';
    }
});

// Update toggle auth mode function
function toggleAuthMode() {
    const loginForm = document.getElementById('loginForm');
    const signupForm = document.getElementById('signupForm');
    
    loginForm.classList.toggle('hidden');
    signupForm.classList.toggle('hidden');
}

function updateGuestPlayButton() {
    const guestPlayButton = document.querySelector('.guest-play-button');
    
    if (!currentUser || (currentUser && currentUser.status === 'unregistered')) {
        guestPlayButton.textContent = 'Play as Guest';
    } else {
        guestPlayButton.textContent = 'Start Game';
    }
}

function showPricesScreen() {
    // TODO: Implement prices screen
    alert('Prices screen coming soon!');
}

function showRightsAndPolicies() {
    // TODO: Implement rights and policies page
    alert('Rights & Policies page coming soon!');
}

function showAboutPage() {
    // TODO: Implement about page
    alert('About page coming soon!');
}

function showContactUs() {
    // TODO: Implement contact us functionality
    alert('Contact Us page coming soon!');
}

function animateNumber(element, start, end, duration = 500) {
    // Ensure start and end are numbers
    start = Number(start);
    end = Number(end);
    
    // If start and end are the same, just set the value
    if (start === end) {
        element.textContent = end;
        return;
    }

    const difference = end - start;
    const frames = 30; // Increased for smoother animation
    const step = difference / frames;
    let current = start;
    let frameCount = 0;
    
    function updateNumber() {
        current += step;
        frameCount++;
        
        // Round to handle floating point imprecision
        if (frameCount >= frames || 
            (step > 0 && current >= end) || 
            (step < 0 && current <= end)) {
            element.textContent = Math.round(end);
            return;
        }
        
        element.textContent = Math.round(current);
        requestAnimationFrame(updateNumber);
    }
    
    requestAnimationFrame(updateNumber);
}

function showNotification(message, type) {
    const notification = document.createElement('div');
    notification.className = `game-notification ${type}`;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    setTimeout(() => notification.classList.add('show'), 10);
    
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
    }, 2000);
}

function createParticles(x, y, type) {
    const particleCount = 15;
    const colors = type === 'blessing' ? 
        ['#3498db', '#2980b9', '#1abc9c'] : 
        ['#e74c3c', '#c0392b', '#d35400'];
    
    for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = `particle ${type}`;
        
        const size = Math.random() * 8 + 4;
        const angle = (Math.random() * Math.PI * 2);
        const velocity = Math.random() * 100 + 50;
        
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.borderRadius = '50%';
        particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        particle.style.position = 'fixed';
        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;
        
        document.body.appendChild(particle);
        
        const destinationX = x + Math.cos(angle) * velocity;
        const destinationY = y + Math.sin(angle) * velocity;
        
        particle.animate([
            { transform: 'translate(0, 0) scale(1)', opacity: 1 },
            { transform: `translate(${destinationX - x}px, ${destinationY - y}px) scale(0)`, opacity: 0 }
        ], {
            duration: 1000,
            easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
        }).onfinish = () => particle.remove();
    }
}

async function joinArcadeWithUsername() {
    const usernameInput = document.getElementById('arcadeUsername');
    const otpInput = document.getElementById('otpInput');
    
    // Get username either from input or from current user
    let username;
    if (currentUser) {
        username = currentUser.user_metadata?.username || 
                  currentUser.email.split('@')[0];
    } else {
        username = usernameInput.value.trim();
        
        // Username validation for guest users
        if (!username || username.length < 2 || username.length > 15) {
            showErrorToast('Username must be between 2 and 15 characters');
            usernameInput.focus();
            return;
        }

        // Validate username characters
        const validUsernameRegex = /^[a-zA-Z0-9\u0590-\u05FF\s._-]+$/;
        if (!validUsernameRegex.test(username)) {
            showErrorToast('Username can contain letters, numbers, spaces, periods, underscores, and hyphens');
            usernameInput.focus();
            return;
        }
    }
    
    const otp = otpInput.value.trim();
    
    // OTP validation
    if (!otp || otp.length !== 4 || !/^\d+$/.test(otp)) {
        showErrorToast('Please enter a valid 4-digit game code');
        otpInput.focus();
        return;
    }

    try {
        // Get initial coins for registered users
        let initialCoins = 0;
        if (currentUser) {
            try {
                const { data, error } = await supabaseClient
                    .from('game_progress')
                    .select('coins')
                    .eq('user_id', currentUser.id)
                    .single();
                    
                if (!error && data) {
                    initialCoins = data.coins;
                    console.log('Retrieved initial coins:', initialCoins);
                }
            } catch (error) {
                console.error('Failed to load initial coins:', error);
            }
        }

        // Create Supabase channel for the specific arcade session
        window.arcadeChannel = supabaseClient.channel(`arcade:${otp}`);
        
        // Set player name and initial state
        currentArcadeSession.playerName = username;
        currentArcadeSession.initialCoins = initialCoins;
        
        // Set up channel listeners
        window.arcadeChannel
            .on('broadcast', { event: 'game_end' }, ({ payload }) => {
                handleGameEnd(payload);
                currentArcadeSession.state = 'ended';
                
                if (payload.state === 'active') {
                    currentArcadeSession.wordPool = payload.wordPool;
                    currentArcadeSession.wordGoal = payload.wordGoal;
                    startArcadeGame();
                }
            })
            .on('broadcast', { event: 'game_playing' }, ({ payload }) => {
                if (payload.state === 'active') {
                    currentArcadeSession.state = 'active';
                    currentArcadeSession.wordPool = payload.wordPool;
                    currentArcadeSession.wordGoal = payload.wordGoal;
                    startArcadeGame();
                }
            })
            .subscribe();

        // Broadcast initial join with type and coins
        await window.arcadeChannel.send({
            type: 'broadcast',
            event: 'player_join',
            payload: {
                username: username,
                type: 'initialJoin',
                coins: initialCoins,
                joinedAt: new Date().toISOString()
            }
        });

        // Hide arcade modal and show waiting screen
        document.getElementById('arcade-modal').style.display = 'none';
        showWaitingScreen();

    } catch (error) {
        console.error('Join arcade error:', error);
        showErrorToast('Failed to join arcade. Please try again.');
    }
}

const powerupPool = {
    highFive: {
        id: 'highFiveCard',
        cost: 30,
        effect: 50,
        type: 'goodie',
        icon: 'fa-hand-paper',
        name: 'High Five',
        message: 'high-fived'
    },
    fistBump: {
        id: 'fistBumpCard',
        cost: 40,
        effect: 75,
        type: 'goodie',
        icon: 'fa-fist-raised',
        name: 'Fist Bump',
        message: 'fist-bumped'
    },
    energyBoost: {
        id: 'energyBoostCard',
        cost: 45,
        type: 'goodie',
        icon: 'fa-bolt',
        name: 'Energy Boost',
        message: 'boosted'
    },
    freeze: {
        id: 'freezeCard',
        cost: 150,
        duration: 10000,
        type: 'baddie',
        icon: 'fa-snowflake',
        name: 'Freeze',
        message: 'froze'
    },
    coinStorm: {
        id: 'coinStormCard',
        cost: 160,
        duration: 3,
        type: 'baddie',
        icon: 'fa-cloud-showers-heavy',
        name: 'Coin Storm',
        message: 'cast a coin storm on'
    },
    screenShake: {
        id: 'screenShakeCard',
        cost: 130,
        duration: 5000,
        type: 'baddie',
        icon: 'fa-shake',
        name: 'Screen Shake',
        message: 'shook'
    }
};

function initializePowerups() {
    const powerupPool = {
        highFive: {
            id: 'highFiveCard',
            cost: 30,
            effect: 50,
            type: 'goodie',
            icon: 'fa-hand-paper',
            name: 'High Five',
            message: 'high-fived'
        },
        fistBump: {
            id: 'fistBumpCard',
            cost: 40,
            effect: 75,
            type: 'goodie',
            icon: 'fa-fist-raised',
            name: 'Fist Bump',
            message: 'fist-bumped'
        },
        energyBoost: {
            id: 'energyBoostCard',
            cost: 45,
            type: 'goodie',
            icon: 'fa-bolt',
            name: 'Energy Boost',
            message: 'boosted'
        },
        freeze: {
            id: 'freezeCard',
            cost: 150,
            duration: 10000,
            type: 'baddie',
            icon: 'fa-snowflake',
            name: 'Freeze',
            message: 'froze'
        },
        coinStorm: {
            id: 'coinStormCard',
            cost: 160,
            type: 'baddie',
            icon: 'fa-cloud-showers-heavy',
            name: 'Coin Storm',
            message: 'cast a coin storm on'
        },
        screenShake: {
            id: 'screenShakeCard',
            cost: 130,
            duration: 5000,
            type: 'baddie',
            icon: 'fa-shake',
            name: 'Screen Shake',
            message: 'shook'
        }
    };

    function getRandomPowerups(count = 3) {
        const powerupKeys = Object.keys(powerupPool);
        const selectedKeys = [];
        while (selectedKeys.length < count && powerupKeys.length > 0) {
            const randomIndex = Math.floor(Math.random() * powerupKeys.length);
            selectedKeys.push(powerupKeys.splice(randomIndex, 1)[0]);
        }
        return selectedKeys;
    }

    function renderPowerups() {
        const container = document.querySelector('.powerups-container');
        if (!container) return;
        
        container.innerHTML = '';
        const selectedPowerups = getRandomPowerups(3);
        
        selectedPowerups.forEach(key => {
            const powerup = powerupPool[key];
            const card = document.createElement('div');
            card.className = `powerup-card ${powerup.type}`;
            card.id = powerup.id;
            
            card.innerHTML = `
                <i class="fas ${powerup.icon} powerup-icon"></i>
                <div class="powerup-name">${powerup.name}</div>
                <div class="powerup-cost">${powerup.cost}</div>
            `;
            
            card.onclick = async () => {
                console.log('Powerup clicked:', powerup.name); // Debug log
                
                if (currentGame.coins < powerup.cost) {
                    showNotification('Not enough coins!', 'error');
                    return;
                }
                
                // Change this section in the card.onclick function:
                const otherPlayers = currentArcadeSession.participants.filter(
            p => p.username !== currentArcadeSession.playerName && 
                 p.username !== undefined && 
                 p.username !== null
        );

        if (otherPlayers.length === 0) {
            showNotification('Waiting for other players to join...', 'info');
            return;
        }
                
                const targetPlayer = otherPlayers[Math.floor(Math.random() * otherPlayers.length)];
                
                // Deduct coins immediately
                const oldCoins = currentGame.coins;
                currentGame.coins -= powerup.cost;
                
                // Update coins display
                document.querySelectorAll('.coin-count').forEach(display => {
                    display.textContent = currentGame.coins;
                });
                
                try {
                    // Send powerup effect
                    await window.arcadeChannel.send({
                        type: 'broadcast',
                        event: 'powerup_effect',
                        payload: {
                            powerupKey: key,
                            targetUser: targetPlayer.username,
                            fromUser: currentArcadeSession.playerName,
                            powerup: powerup
                        }
                    });
                    
                    // Show feedback
                    showNotification(`Used ${powerup.name} on ${targetPlayer.username}!`, powerup.type);
                    
                    // Update progress
                    await window.arcadeChannel.send({
                        type: 'broadcast',
                        event: 'progress_update',
                        payload: {
                            username: currentArcadeSession.playerName,
                            wordsCompleted: currentGame.wordsCompleted,
                            coins: currentGame.coins,
                            timestamp: Date.now()
                        }
                    });
                    
                    // Get new powerups
                    renderPowerups();
                    
                } catch (error) {
                    console.error('Powerup use error:', error);
                    // Revert coins if failed
                    currentGame.coins = oldCoins;
                    document.querySelectorAll('.coin-count').forEach(display => {
                        display.textContent = oldCoins;
                    });
                    showNotification('Failed to use powerup!', 'error');
                }
            };
            
            container.appendChild(card);
        });
        
        updatePowerupAvailability();
    }

    function updatePowerupAvailability() {
        document.querySelectorAll('.powerup-card').forEach(card => {
            const costElement = card.querySelector('.powerup-cost');
            if (!costElement) return;
            
            const cost = parseInt(costElement.textContent);
            const canAfford = currentGame.coins >= cost;
            
            card.classList.toggle('disabled', !canAfford);
            card.style.cursor = canAfford ? 'pointer' : 'not-allowed';
            card.style.opacity = canAfford ? '1' : '0.5';
        });
    }

    // Initialize first set of powerups
    renderPowerups();
    
    // Watch for coin changes
    const coinDisplay = document.querySelector('.coin-count');
    if (coinDisplay) {
        new MutationObserver(() => {
            updatePowerupAvailability();
        }).observe(coinDisplay, { childList: true, characterData: true, subtree: true });
    }
    
    // Initial availability check
    updatePowerupAvailability();
}

function requestFullscreenMode() {
    const root = document.documentElement;
    
    // Check if the device is mobile
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    
    if (!isMobile) return; // Only proceed for mobile devices
    
    // Try different fullscreen methods
    if (root.requestFullscreen) {
        root.requestFullscreen().catch(err => console.log('Fullscreen request failed:', err));
    } else if (root.webkitRequestFullscreen) {
        root.webkitRequestFullscreen().catch(err => console.log('Fullscreen request failed:', err));
    } else if (root.msRequestFullscreen) {
        root.msRequestFullscreen().catch(err => console.log('Fullscreen request failed:', err));
    }
}

function generateQRCode(otp) {
    // Get the base URL without any parameters or hash
    const baseUrl = window.location.origin + window.location.pathname;
    const joinUrl = `${baseUrl}#join=${otp}`;
    
    // Add console logging for debugging
    console.log('Generating QR code with URL:', joinUrl);
    
    new QRious({
        element: document.getElementById('qrCode'),
        value: joinUrl,
        size: 200,
        backgroundAlpha: 1,
        foreground: '#16213e',
        background: '#ffffff',
        level: 'H'
    });
}

function handleHashChange() {
    console.log('Hash change detected:', window.location.hash);
    
    if (window.location.hash.startsWith('#join=')) {
        const otp = window.location.hash.replace('#join=', '');
        console.log('Join OTP detected:', otp);
        
        // Show landing page on mobile
        if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
            const qrLanding = document.getElementById('qr-landing');
            const codeDisplay = qrLanding.querySelector('.game-code-display');
            
            // Hide all other screens
            document.querySelectorAll('.screen').forEach(screen => {
                screen.style.display = 'none';
            });
            
            // Show and populate landing page
            qrLanding.style.display = 'flex';
            codeDisplay.textContent = otp;
            
            // Store OTP for later use
            qrLanding.dataset.otp = otp;
        } else {
            // Desktop behavior
            history.pushState("", document.title, window.location.pathname);
            showJoinModal(otp);
        }
    }
}

function proceedToGame() {
    const qrLanding = document.getElementById('qr-landing');
    const otp = qrLanding.dataset.otp;
    
    // Hide landing page
    qrLanding.style.display = 'none';
    
    // Show join modal with OTP
    showJoinModal(otp);
}

function showJoinModal(otp = '') {
    console.log('Showing join modal with OTP:', otp);  // Add logging
    const modal = document.getElementById('arcade-modal');
    const teacherView = document.getElementById('teacher-view');
    const playerView = document.getElementById('player-view');
    const otpInput = document.getElementById('otpInput');
    
    if (modal) {
        modal.style.display = 'block';
        if (teacherView) teacherView.style.display = 'none';
        if (playerView) playerView.style.display = 'block';
        
        if (otpInput && otp) {
            otpInput.value = otp;
            // Focus username input if it exists
            const usernameInput = document.getElementById('arcadeUsername');
            if (usernameInput) {
                usernameInput.focus();
            }
        }
    }
}

function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `game-notification ${type}`;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    requestAnimationFrame(() => notification.classList.add('show'));
    
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
    }, 3000);
}

function switchAuthForm(type) {
    const loginForm = document.getElementById('loginForm');
    const signupForm = document.getElementById('signupForm');
    
    if (type === 'signup') {
        loginForm.classList.add('hidden');
        signupForm.classList.remove('hidden');
    } else {
        loginForm.classList.remove('hidden');
        signupForm.classList.add('hidden');
    }
}

async function combineCustomLists(listIds) {
    if (!currentUser?.role === 'teacher') return;
    
    const combinedList = {
        id: Date.now(),
        name: 'Combined List',
        words: [],
        translations: [],
        isTeacherList: true
    };
    
    // Merge selected lists
    for (const listId of listIds) {
        const list = customPracticeLists.lists.find(l => l.id === listId);
        if (list) {
            combinedList.words.push(...list.words);
            combinedList.translations.push(...list.translations);
        }
    }
    
    return combinedList;
}

async function convertListToArcade(listId) {
    if (!currentUser?.role === 'teacher') return;
    
    const list = customPracticeLists.lists.find(l => l.id === listId);
    if (!list) return;
    
    // Create arcade configuration
    const arcadeConfig = {
        wordPool: list.words.map((word, index) => ({
            word: word,
            translation: list.translations[index]
        })),
        isCustomArcade: true,
        teacherId: currentUser.id,
        listId: listId
    };
    
    return arcadeConfig;
}

function initializeBossLevel() {
    const bossContainer = document.querySelector('.question-screen');
    bossContainer.classList.add('boss-mode');
    
    // Disable perks for boss level
    document.querySelectorAll('.perk-button').forEach(button => {
        button.disabled = true;
        button.style.opacity = '0.3';
        const xMark = document.createElement('div');
        xMark.className = 'perk-disabled';
        xMark.innerHTML = 'âŒ';
        button.appendChild(xMark);
    });
}

function startBossLevel() {
    showLevelIntro(21, () => {
        initializeBossLevel();
        startTimer(currentGame.words.length * 8); // Less time per word
        loadNextBossQuestion();
    });
}

function loadNextBossQuestion() {
    // Similar to regular loadNextQuestion but with special effects
    const questionWord = document.getElementById('question-word');
    questionWord.classList.add('boss-word');
    
    // Words fade out over time
    setTimeout(() => {
        questionWord.classList.add('fading');
    }, 3000);
    
    // Answers shuffle periodically
    const buttonsDiv = document.getElementById('buttons');
    setInterval(() => {
        const buttons = Array.from(buttonsDiv.children);
        buttons.sort(() => Math.random() - 0.5).forEach(button => {
            buttonsDiv.appendChild(button);
        });
    }, 5000);
}

// Arcade Participation Management
function initializeArcadeParticipation() {
    // Set up activity tracking
    let lastActive = Date.now();
    const INACTIVE_THRESHOLD = 60000; // 1 minute

    // Heartbeat interval
    setInterval(() => {
        if (Date.now() - lastActive > INACTIVE_THRESHOLD) {
            removeInactivePlayer();
        }
    }, 10000); // Check every 10 seconds

    // Track user activity
    ['mousemove', 'keypress', 'click'].forEach(event => {
        document.addEventListener(event, () => {
            lastActive = Date.now();
        });
    });

    // Handle page refresh/close
    window.addEventListener('beforeunload', () => {
        if (window.arcadeChannel) {
            window.arcadeChannel.send({
                type: 'broadcast',
                event: 'player_left',
                payload: {
                    username: currentArcadeSession.playerName
                }
            });
        }
    });
}

function removeInactivePlayer() {
    window.arcadeChannel.send({
        type: 'broadcast',
        event: 'player_inactive',
        payload: {
            username: currentArcadeSession.playerName
        }
    });
}

// Arcade Completion Handling
function handleArcadeCompletion(playerData) {
    const completionRank = currentArcadeSession.participants
        .sort((a, b) => b.wordsCompleted - a.wordsCompleted)
        .findIndex(p => p.username === playerData.username) + 1;

    if (completionRank <= 3) {
        showPersonalizedCompletion(completionRank);
        
        if (completionRank === 3) {
            // End game for all players
            window.arcadeChannel.send({
                type: 'broadcast',
                event: 'game_complete',
                payload: {
                    topThree: currentArcadeSession.participants
                        .sort((a, b) => b.wordsCompleted - a.wordsCompleted)
                        .slice(0, 3)
                }
            });
        }
    }
}

async function handlePlayerCompletedGoal(playerUsername) {
    if (currentArcadeSession.completedPlayers.includes(playerUsername)) {
        return; // Player already completed
    }
    
    // Add player to completed list
    currentArcadeSession.completedPlayers.push(playerUsername);
    
    // Determine player rank based on completion order
    // ONLY the first 3 completions get ranks 1, 2, 3
    let playerRank = 0;
    const completionIndex = currentArcadeSession.completedPlayers.indexOf(playerUsername);
    
    if (completionIndex < 3) {
        // First 3 players get podium ranks
        playerRank = completionIndex + 1;
        
        // Store this podium assignment permanently in the session
        if (!currentArcadeSession.podiumRanks) {
            currentArcadeSession.podiumRanks = {};
        }
        currentArcadeSession.podiumRanks[playerUsername] = playerRank;
        
        console.log(`Player ${playerUsername} earned podium rank ${playerRank}`);
    }
    
    // Update player's data in participants array
    const playerEntry = currentArcadeSession.participants.find(p => p.username === playerUsername);
    if (playerEntry) {
        // Only set rank for podium players (1-3)
        if (playerRank > 0) {
            playerEntry.rank = playerRank;
        }
        playerEntry.wordsCompleted = currentGame.wordsCompleted;
        playerEntry.coins = gameState.coins || currentGame.coins || 0;
        playerEntry.completed = true;
    }
    
    // Broadcast completion 
    await window.arcadeChannel.send({
        type: 'broadcast',
        event: 'player_completed',
        payload: {
            username: playerUsername,
            rank: playerRank,
            wordsCompleted: currentGame.wordsCompleted,
            coins: gameState.coins || currentGame.coins || 0,
            timestamp: Date.now(),
            completed: true
        }
    });
    
    // If current player is the one who completed and earned a podium rank,
    // show personal victory screen
    if (playerUsername === currentArcadeSession.playerName && playerRank > 0) {
        showPersonalVictoryScreen(playerRank);
    }
    
    // If this was the third player to complete, end the game for everyone
    if (currentArcadeSession.completedPlayers.length === 3) {
        await endArcadeForAll();
    }
}

// REPLACE function showPersonalVictoryScreen
function showPersonalVictoryScreen(rank) {
    if (currentArcadeSession.winnerScreenShown) return;
    currentArcadeSession.winnerScreenShown = true;
    
    console.log(`Showing personal victory screen with rank: ${rank}`);
    
    // Create a personalized victory overlay
    const overlay = document.createElement('div');
    overlay.className = 'arcade-completion-modal';
    
    // Different messages based on rank
    const rankMessages = {
        1: {
            title: "ðŸ† FIRST PLACE! ðŸ†",
            message: "Incredible! You've claimed the top spot!",
            color: "var(--gold)"
        },
        2: {
            title: "ðŸ¥ˆ SECOND PLACE! ðŸ¥ˆ",
            message: "Amazing job! You've secured second place!",
            color: "var(--silver)"
        },
        3: {
            title: "ðŸ¥‰ THIRD PLACE! ðŸ¥‰",
            message: "Well done! You've earned third place!",
            color: "var(--bronze)"
        }
    };
    
    const message = rankMessages[rank] || {
        title: "Game Complete!",
        message: "You've reached the word goal!",
        color: "var(--accent)"
    };
    
    // Calculate coins earned during this arcade session
    const startingCoins = currentArcadeSession.initialCoins || 0;
    const currentCoins = gameState.coins || currentGame.coins || 0;
    const coinsEarned = currentCoins - startingCoins;
    
    overlay.innerHTML = `
        <div class="completion-modal-content">
            <h2 style="color: ${message.color}">${message.title}</h2>
            <p>${message.message}</p>
            <div class="completion-stats">
                <div class="stat-item">
                    <i class="fas fa-language"></i>
                    <span>Words Learned</span>
                    <strong>${currentGame.wordsCompleted}</strong>
                </div>
                <div class="stat-item">
                    <i class="fas fa-coins"></i>
                    <span>Coins Earned</span>
                    <strong>${coinsEarned}</strong>
                </div>
                <div class="stat-item">
                    <i class="fas fa-trophy"></i>
                    <span>Your Rank</span>
                    <strong>${rank}</strong>
                </div>
            </div>
            <button onclick="exitArcadeCompletion()" class="start-button">
                Return to Welcome
            </button>
        </div>
    `;
    
    document.body.appendChild(overlay);
    requestAnimationFrame(() => overlay.classList.add('show'));
}

function hidePersonalVictoryScreen() {
    const modal = document.querySelector('.arcade-completion-modal');
    if (modal) {
        modal.classList.remove('show');
        setTimeout(() => {
            document.body.removeChild(modal);
        }, 300);
    }
}

async function endArcadeForAll() {
    currentArcadeSession.state = 'ended';
    currentArcadeSession.endTime = Date.now();
    
    // Create a copy of participants sorted by words completed
    const sortedParticipants = [...currentArcadeSession.participants]
        .sort((a, b) => {
            // Primary sort: words completed (descending)
            if (b.wordsCompleted !== a.wordsCompleted) {
                return b.wordsCompleted - a.wordsCompleted;
            }
            // Secondary sort: coins (descending)
            return b.coins - a.coins;
        });
    
    // Take only top 3 players and assign ranks
    const topThree = sortedParticipants.slice(0, 3).map((player, index) => ({
        ...player,
        rank: index + 1
    }));
    
    // Store podium ranks
    const podiumRanks = {};
    topThree.forEach(player => {
        if (player.username) {
            podiumRanks[player.username] = player.rank;
        }
    });
    
    currentArcadeSession.podiumRanks = podiumRanks;
    
    console.log('Final top three:', topThree.map(p => ({
        username: p.username,
        rank: p.rank,
        wordsCompleted: p.wordsCompleted
    })));
    
    // Broadcast final rankings with only top three players
    await window.arcadeChannel.send({
        type: 'broadcast',
        event: 'game_end',
        payload: {
            state: 'ended',
            allPlayers: topThree,
            podiumRanks: podiumRanks,
            teacherId: currentArcadeSession.teacherId,
            duration: currentArcadeSession.endTime - (currentArcadeSession.startTime || currentArcadeSession.endTime)
        }
    });
    
    // Show final results based on role
    if (currentUser?.id === currentArcadeSession.teacherId) {
        showModeratorVictoryScreen(topThree);
    } else {
        showFinalResultsForPlayer(topThree);
    }
}

function showFinalResults(players) {
    // Different behavior for moderator vs player
    if (currentUser?.id === currentArcadeSession.teacherId) {
        showModeratorVictoryScreen(players);
    } else {
        showPlayerFinalResults(players);
    }
}

function getOrdinal(n) {
    const s = ["th", "st", "nd", "rd"];
    const v = n % 100;
    return n + (s[(v - 20) % 10] || s[v] || s[0]);
}

</script>
</body>
</html>