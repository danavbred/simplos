<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">    <title>Simplos</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    
    <style>
@import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600;700&display=swap');

:root {
  --primary-dark: #1a1a2e;
  --primary: #16213e;
  --secondary: #0f3460;
  --accent: #e94560;
  --text: #ffffff;
  --gold: #ffd700;
  --silver: #c0c0c0;
  --bronze: #cd7f32;
  --success: #4CAF50;
  --error: #f44336;
  --gradient: linear-gradient(135deg, var(--secondary), var(--primary-dark));
  --glass: rgba(255, 255, 255, 0.1);
  --locked: #808080;

  /* Stage-specific themes */
  --stage1-primary: #2c3e50;
  --stage1-secondary: #34495e;
  --stage1-accent: #3498db;

  --stage2-primary: #27ae60;
  --stage2-secondary: #2ecc71;
  --stage2-accent: #16a085;

  --stage3-primary: #8e44ad;
  --stage3-secondary: #9b59b6;
  --stage3-accent: #6c3483;

  --stage4-primary: #c0392b;
  --stage4-secondary: #e74c3c;
  --stage4-accent: #922b21;

  --stage5-primary: #f39c12;
  --stage5-secondary: #f1c40f;
  --stage5-accent: #d35400;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Montserrat', sans-serif;
}

body {
  margin: 0;
  padding: 0;
  min-height: 100vh;
  background: var(--gradient);
  color: var(--text);
  overflow-x: hidden;
}

.screen {
  display: none;
  min-height: 100vh;
  padding: 2rem;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  background: radial-gradient(circle at center, var(--secondary) 0%, var(--primary-dark) 100%);
}

.screen.visible {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.5s ease-in-out;
}

.welcome-title {
  font-size: 4rem;
  font-weight: 700;
  margin-bottom: 2rem;
  background: linear-gradient(to right, var(--gold), var(--accent));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  text-shadow: 0 2px 10px rgba(0,0,0,0.2);
  animation: shimmer 2s infinite;
  font-size: 2.5rem;
  margin-bottom: 1.5rem;
}

.welcome-buttons {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  align-items: center;
  width: 100%;
    padding: 0 1rem;
}

@media (max-width: 768px) {
    .welcome-buttons {
        width: 100%;
        padding: 0 1rem;
    }
    
    .start-button, .reset-button, .shop-button {
        width: 100%;
        max-width: 280px;
        padding: 0.75rem 1.5rem;
    }
}

.start-button, .reset-button, .shop-button {
  padding: 1rem 3rem;
  font-size: 1.5rem;
  font-weight: 600;
  color: var(--text);
  background: var(--accent);
  border: none;
  border-radius: 50px;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 10px 20px rgba(233, 69, 96, 0.3);
  position: relative;
  overflow: hidden;
  width: 100%;
    max-width: 300px;
    padding: 0.875rem 2rem;
    font-size: 1.25rem;
}

.start-button::before, .reset-button::before, .shop-button::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
  transform: rotate(45deg);
  transition: all 0.3s ease;
  opacity: 0;
}

.start-button:hover, .reset-button:hover, .shop-button:hover {
  transform: translateY(-5px);
  box-shadow: 0 15px 30px rgba(233, 69, 96, 0.4);
}

.start-button:hover::before, .reset-button:hover::before, .shop-button:hover::before {
  opacity: 1;
  animation: shine 1s forwards;
}



.coins-header {
  position: fixed;
  top: 2rem;
  right: 2rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  background: var(--glass);
  padding: 0.75rem 1.5rem;
  border-radius: 25px;
  backdrop-filter: blur(10px);
  z-index: 100;
}

.coins-header .coin-icon {
  color: var(--gold);
  font-size: 1.5rem;
  filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.3));
}

.coins-header .coin-count {
  font-size: 1.2rem;
  font-weight: bold;
  color: var(--text);
}

.coin-count {
    transition: none; /* Remove any existing transitions */
}

.coin-count.animating {
    transition: content 1s ease-out;
}


.stage-container, .set-container, .level-selection {
  display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 2rem;
    width: 100%;
    max-width: 1200px;
    padding: 2rem;
    z-index: 1;
}



.stage-button, .set-button, .level {
  aspect-ratio: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--text);
    background: var(--glass);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    position: relative;
    overflow: hidden;
    flex-direction: column;
}

.stage-name {
  font-size: 1.2rem;
    margin-bottom: 0.5rem;
    color: var(--text);
    text-transform: uppercase;
    letter-spacing: 1px;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.stage-button::before, .set-button.active::before, .level.blue::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.2) 0%, transparent 70%);
  opacity: 0;
  transition: opacity 0.3s ease;
}

.stage-button:hover, .set-button.active:hover, .level.blue:hover {
  transform: translateY(-10px) scale(1.05);
  box-shadow: 0 20px 40px rgba(0,0,0,0.2);
}

.stage-button:hover::before, .set-button.active:hover::before, .level.blue:hover::before {
  opacity: 1;
}

.set-button {
  cursor: not-allowed;
    opacity: 0.5;
    background: var(--locked);
    transition: all 0.5s ease;
}

.set-button.active {
  opacity: 1;
    cursor: pointer;
    background: linear-gradient(135deg, var(--gold), #ffa500);
    box-shadow: 0 10px 20px rgba(255, 215, 0, 0.3);
}

.level {
    position: relative; /* Ensure proper positioning of the lock */
}

/* Lock icon styling */
.level:not(.blue):not(.green)::before {
    content: '\f023'; /* Font Awesome lock icon */
    font-family: 'Font Awesome 6 Free';
    font-weight: 900;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 1.5rem;
    color: rgba(255, 255, 255, 0.5);
    z-index: 1;
    pointer-events: none;
}

/* Optional hover effect for locked levels */
.level:not(.blue):not(.green):hover::before {
    color: rgba(255, 255, 255, 0.7);
    transform: translate(-50%, -50%) scale(1.1);
    transition: all 0.3s ease;
}

/* Ensure the level number stays visible */
.level {
    display: flex;
    align-items: center;
    justify-content: center;
    color: rgba(255, 255, 255, 0.5); /* Dim the number on locked levels */
}

.level.blue, .level.green {
    color: rgba(255, 255, 255, 1); /* Full opacity for unlocked levels */
}


.level.completing {
    animation: completeLevel 1.5s forwards;
}

.level.unlocking {
    animation: unlockLevel 1.5s forwards;
}

@keyframes completeLevel {
    0% {
        transform: scale(1);
        background: linear-gradient(135deg, var(--accent), #1E90FF);
    }
    50% {
        transform: scale(1.1);
        background: var(--success);
        box-shadow: 0 0 30px var(--gold);
    }
    100% {
        transform: scale(1);
        background: var(--success);
        border: 2px solid var(--gold);
        box-shadow: 0 0 20px var(--gold);
    }
}

/* Animation for unlocking next level */
@keyframes unlockLevel {
    0% { 
        transform: scale(1);
        background: var(--locked);
    }
    40% { 
        transform: scale(1.1);
    }
    50% { 
        transform: scale(1.1);
        background: var(--gold);
        box-shadow: 0 0 30px var(--gold);
    }
    60% {
        transform: scale(1.1);
    }
    100% { 
        transform: scale(1);
        background: linear-gradient(135deg, var(--accent), #ff1f5a);
        box-shadow: 0 10px 20px rgba(233, 69, 96, 0.3);
    }
}

/* Update the unlocking animation to handle the lock icon */
.level.unlocking::before {
    animation: fadeLockOut 0.5s forwards;
}

@keyframes fadeLockOut {
    0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0);
    }
}

.level.blue {
  background: linear-gradient(135deg, var(--accent), #1E90FF);
  cursor: pointer;
  box-shadow: 0 10px 20px rgba(233, 69, 96, 0.3);
}

.level.unlocking {
  animation: unlockLevel 1s forwards;
}

.level.green {
  background: linear-gradient(135deg, var(--success), #45b649);
  border: 2px solid var(--gold);
  box-shadow: 0 0 30px var(--gold);
  animation: pulse 2s infinite;
}

/* Question screen specific styles */
.question-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1.5rem;
  height: 100vh;
  padding: 1rem 1rem 2rem;
    min-height: 100vh;
    height: auto;
    justify-content: space-between;
    gap: 0.5rem;
    justify-content: space-between;
    padding: 1rem 1rem 2rem;
    overflow: hidden;
}

.question-word {
  font-size: 4rem;
  font-weight: 700;
  color: var(--gold);
  text-shadow: 0 2px 10px rgba(255,215,0,0.3);
  animation: float 3s ease-in-out infinite;
  margin: 0;
  padding: 1rem;
}

.progress-circle {
    width: 200px;
    height: 200px;
    position: relative;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 1rem 0;
}

.progress-circle svg {
    position: absolute;
    width: 100%;
    height: 100%;
    transform: rotate(-90deg);
}

.progress-circle circle {
    fill: none;
    stroke-linecap: round;
}

.progress-circle .bg {
    stroke: rgba(255, 255, 255, 0.1);
}

.progress-circle .progress {
    stroke: var(--gold);
    transition: stroke-dashoffset 0.5s ease;
}


.progress-circle.completed {
  animation: progressPulsate 2s ease-in-out 3;
}

@keyframes pulseGrow {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.3); }
}

@keyframes goldGreenPulse {
    0%, 100% { 
        stroke: var(--gold);
        filter: brightness(1.5) drop-shadow(0 0 10px var(--gold));
    }
    50% { 
        stroke: var(--gold);
        filter: brightness(1.2) drop-shadow(0 0 5px var(--gold));
    }
}

.progress-circle.completed {
    animation: pulseGrow 0.4s ease-in-out infinite;
}

.progress-circle.completed circle.progress {
    animation: goldGreenPulse 0.4s ease-in-out infinite;
    transition: stroke 0.3s linear;
}

.progress-circle[data-progress="low"] .progress {
    stroke: var(--gold);
}

.progress-circle[data-progress="medium"] .progress {
    stroke: #FFA500; /* Orange */
}

.progress-circle[data-progress="high"] .progress {
    stroke: var(--success);
}

.progress-circle[data-progress="complete"] .progress {
    stroke: #1E90FF; /* Lapiz Lazuli */
}

.perks-container {
  display: flex;
  gap: 1rem;
  margin: 1rem 0;
  background: var(--glass);
  padding: 0.75rem;
  border-radius: 25px;
  backdrop-filter: blur(10px);
}

.perk-button {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.25rem;
  padding: 0.5rem;
  border-radius: 15px;
  cursor: pointer;
  transition: all 0.3s ease;
  background: rgba(255, 255, 255, 0.1);
  border: none;
  color: var(--text);
}

.perk-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.perk-button:not(:disabled):hover {
  background: rgba(255, 255, 255, 0.2);
  transform: translateY(-2px);
}

.perk-icon {
  font-size: 1.5rem;
  color: var(--gold);
}

.perk-count {
  font-size: 0.8rem;
  font-weight: bold;
}

.timer-container {
    position: absolute;
    visibility: hidden;
    opacity: 0;
    pointer-events: none;
    height: 0;
    margin: 0;
}

.timer-value {
    font-size: 0;
    padding: 0;
}

.timer-value.warning {
  color: var(--error);
  text-shadow: 0 0 15px rgba(244, 67, 54, 0.5);
  animation: warningPulse 1s infinite;
}

.buttons {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
  max-width: 800px;
  width: 100%;
  margin: 1rem auto;
  margin-bottom: 0rem;
  padding: 0 1rem;
}

.buttons button {
  padding: 1rem 2rem;
  font-size: 1.2rem;
  font-weight: 600;
  color: var(--primary);
  background: var(--text);
  border: none;
  border-radius: 15px;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 5px 15px rgba(0,0,0,0.1);
}

.buttons button:hover {
  transform: translateY(-5px);
  box-shadow: 0 10px 20px rgba(0,0,0,0.2);
}

.buttons button.correct {
  background: var(--success);
  color: var(--text);
  animation: correctAnswer 0.5s ease;
}

.buttons button.wrong {
  background: var(--error);
  color: var(--text);
  animation: wrongAnswer 0.5s ease;
}

.failure-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background 1s ease;
  z-index: 1000;
}

.failure-overlay.show {
  background: rgba(0, 0, 0, 0.9);
}

.failure-content {
  text-align: center;
  transform: translateY(50px);
  opacity: 0;
  transition: all 1s ease;
}

.failure-overlay.show .failure-content {
  transform: translateY(0);
  opacity: 1;
}

.failure-title {
  font-size: 3rem;
  color: var(--error);
  margin-bottom: 2rem;
  text-shadow: 0 2px 10px rgba(244, 67, 54, 0.3);
}

.failure-buttons {
  display: flex;
  gap: 2rem;
  justify-content: center;
}

.restart-button, .home-button {
  padding: 1rem;
  width: 80px;
  height: 80px;
  font-size: 2rem;
  color: var(--text);
  background: var(--accent);
  border: none;
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 10px 20px rgba(233, 69, 96, 0.3);
}

.restart-button:hover, .home-button:hover {
  transform: translateY(-5px);
  box-shadow: 0 15px 30px rgba(233, 69, 96, 0.4);
}

.coins-container {
  position: absolute;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 2;
}

.coins-container .coin-icon {
  color: var(--gold);
  font-size: 2rem;
  filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.5));
}

.coins-container .coin-count {
  font-size: 1.2rem;
  font-weight: bold;
  color: var(--text);
  text-shadow: 0 2px 4px rgba(0,0,0,0.5);
}

.coin-pulse {
  animation: coinPulse 0.5s ease-in-out 3;
}

/* Shop Styles */
.shop-container {
  display: flex;
  flex-direction: column;
  gap: 2rem;
  max-width: 800px;
  width: 100%;
  padding: 1rem;
}

.shop-title {
  font-size: 3rem;
  font-weight: 700;
  text-align: center;
  color: var(--gold);
  margin-bottom: 2rem;
}

.shop-items {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
}

.shop-item {
  background: var(--glass);
  border-radius: 20px;
  padding: 2rem;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1.5rem;
  backdrop-filter: blur(10px);
  transition: all 0.3s ease;
  cursor: pointer;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.shop-item:hover {
  transform: translateY(-5px);
  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
}

.shop-item.disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.shop-item-title {
  font-size: 1.5rem;
  font-weight: 600;
  color: var(--text);
}

.shop-item-icon {
  font-size: 2.5rem;
  color: var(--gold);
}

.shop-item-description {
  color: var(--text);
  opacity: 0.8;
  font-size: 0.9rem;
  line-height: 1.4;
}

.shop-item-price {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  color: var(--gold);
  font-size: 1.2rem;
  font-weight: 600;
}

.shop-item-price i {
  font-size: 1.5rem;
}

/* Animations */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes shimmer {
  0% { background-position: -200% center; }
  100% { background-position: 200% center; }
}

@keyframes shine {
  to { transform: rotate(45deg) translate(100%, 100%); }
}

@keyframes pulse {
  0% { box-shadow: 0 0 30px var(--gold); }
  50% { box-shadow: 0 0 50px var(--gold); }
  100% { box-shadow: 0 0 30px var(--gold); }
}

@keyframes float {
  0% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
  100% { transform: translateY(0); }
}

@keyframes correctAnswer {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

@keyframes wrongAnswer {
  0%, 100% { transform: translateX(0); }
  20%, 60% { transform: translateX(-5px); }
  40%, 80% { transform: translateX(5px); }
}

@keyframes unlockSet {
  0% { 
    transform: scale(1);
    background: var(--locked);
  }
  50% { 
    transform: scale(1.1);
    background: var(--gold);
    box-shadow: 0 0 50px var(--gold);
  }
  100% { 
    transform: scale(1);
    background: linear-gradient(135deg, var(--gold), #ffa500);
  }
}

@keyframes unlockLevel {
  0% { 
    transform: scale(1);
    background: var(--locked);
  }
  50% { 
    transform: scale(1.1);
    background: var(--accent);
    box-shadow: 0 0 50px var(--accent);
  }
  100% { 
    transform: scale(1);
    background: linear-gradient(135deg, var(--accent), #1E90FF);
  }
}

@keyframes progressPulsate {
  0% { transform: scale(1); filter: brightness(1); }
  50% { transform: scale(1.1); filter: brightness(1.5); }
  100% { transform: scale(1); filter: brightness(1); }
}

@keyframes warningPulse {
  0% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.8; transform: scale(1.05); }
  100% { opacity: 1; transform: scale(1); }
}

@keyframes coinPulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.2); filter: drop-shadow(0 0 20px var(--gold)); }
  100% { transform: scale(1); }
}

/* Media Queries */
@media (max-width: 768px) {
  .question-screen {
    padding-top: 2rem;
    gap: 1rem;
  }

  .welcome-title {
    font-size: 3rem;
  }
  
  .stage-container {
    grid-template-columns: repeat(2, 1fr);
    padding: 1rem;
    gap: 1rem;
  }
  
  .set-container {
    grid-template-columns: repeat(3, 1fr);
    gap: 0.75rem;
    padding: 0.75rem;
  }
  
  .level-selection {
    grid-template-columns: repeat(5, 1fr);
    gap: 0.5rem;
    padding: 0.5rem;
  }
  
  .level {
    max-width: none;
    aspect-ratio: 1;
    font-size: 1.5rem;
  }
  
  .question-word {
    font-size: 2.5rem;
    margin: 0.5rem 0;
  }

  .progress-circle {
    width: 150px;
    height: 150px;
    margin: 0.5rem 0;
  }
  
  .progress-circle .timer-progress.warning {
    stroke: #f44336; /* This is the --error color */
    filter: drop-shadow(0 0 5px rgba(244, 67, 54, 0.5));
    transition: stroke 0.3s ease, stroke-dashoffset 1s linear;
}


  .timer-value {
    font-size: 2.5rem;
  }
  
  .buttons {
    grid-template-columns: 1fr;
    gap: 0.75rem;
  }
  
  .buttons button {
    min-height: 3.5rem;
    font-size: 1rem;
    padding: 0.75rem;
    line-height: 1.2;
  }

  .coins-header {
    top: 1rem;
    right: 1rem;
    padding: 0.5rem 1rem;
  }

  .perks-container {
    padding: 0.5rem;
    gap: 0.5rem;
    margin: 0.5rem 0;
  }

  .perk-button {
    padding: 0.35rem;
  }

  .perk-icon {
    font-size: 1.2rem;
  }

  .perk-count {
    font-size: 0.7rem;
  }
}

@media (max-width: 480px) {
  .welcome-title {
    font-size: 2.5rem;
    text-align: center;
    padding: 0 1rem;
  }
  
  .start-button, .reset-button, .shop-button {
    padding: 0.75rem 2rem;
    font-size: 1.25rem;
  }
  
  
  .stage-container {
    grid-template-columns: 1fr;
  }
  
  .set-container {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .level-selection {
    grid-template-columns: repeat(4, 1fr);
  }

  .question-word {
    font-size: 2rem;
  }

  .progress-circle {
    width: 120px;
    height: 120px;
    margin: 0.5rem 0;
  }

  .timer-value {
    font-size: 2rem;
  }
}

/* Touch Optimizations */
@media (hover: none) {
  .buttons button,
  .stage-button,
  .set-button,
  .level {
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    -webkit-user-select: none;
  }

  .stage-button:hover,
  .set-button:hover,
  .level:hover,
  .buttons button:hover {
    transform: none;
    box-shadow: none;
  }
  
  .buttons button:active,
  .stage-button:active,
  .set-button:active,
  .level:active {
    transform: scale(0.95);
    transition: transform 0.1s;
  }
}

@supports(padding: max(0px)) {
  .screen {
    padding-left: max(2rem, env(safe-area-inset-left));
    padding-right: max(2rem, env(safe-area-inset-right));
    padding-bottom: max(2rem, env(safe-area-inset-bottom));
  }
}

/* Stage-specific themes */
.stage-1 {
  background: linear-gradient(135deg, var(--stage1-primary), var(--stage1-secondary));
}

.stage-1 .stage-button, .stage-1 .set-button.active {
  background: var(--stage1-accent);
}

.stage-2 {
  background: linear-gradient(135deg, var(--stage2-primary), var(--stage2-secondary));
}

.stage-2 .stage-button, .stage-2 .set-button.active {
  background: var(--stage2-accent);
}

.stage-3 {
  background: linear-gradient(135deg, var(--stage3-primary), var(--stage3-secondary));
}

.stage-3 .stage-button, .stage-3 .set-button.active {
  background: var(--stage3-accent);
}

.stage-4 {
  background: linear-gradient(135deg, var(--stage4-primary), var(--stage4-secondary));
}

.stage-4 .stage-button, .stage-4 .set-button.active {
  background: var(--stage4-accent);
}

.stage-5 {
  background: linear-gradient(135deg, var(--stage5-primary), var(--stage5-secondary));
}

.stage-5 .stage-button, .stage-5 .set-button.active {
  background: var(--stage5-accent);
}
  .screen {
    padding-left: max(2rem, env(safe-area-inset-left));
    padding-right: max(2rem, env(safe-area-inset-right));
    padding-bottom: max(2rem, env(safe-area-inset-bottom));
  }

  @keyframes goldGreenPulse {
    0%, 100% { 
        stroke: var(--gold);
        filter: brightness(1.5);
    }
    50% { 
        stroke: #1E90FF; /* Lapiz Lazuli */
        filter: brightness(1.2);
    }
}

@keyframes particleBurst {
    0% { transform: translate(0, 0); opacity: 1; }
    100% { transform: translate(var(--x), var(--y)); opacity: 0; }
}

.particle {
    position: absolute;
    width: 12px; /* Increased from 8px */
    height: 12px; /* Increased from 8px */
    border-radius: 50%;
    pointer-events: none;
    z-index: 1000;
    animation: particleBurst 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
}

@keyframes particleBurst {
    0% { 
        transform: translate(0, 0) scale(1); 
        opacity: 1; 
    }
    100% { 
        transform: translate(var(--x), var(--y)) scale(0.5); 
        opacity: 0; 
    }
}

.progress-circle.completed {
    animation: pulseGrow 0.4s ease-in-out infinite;
}

.progress-circle.completed circle.progress {
    animation: colorShift 0.4s ease-in-out infinite;
    transition: stroke 0.3s linear;
}

@keyframes particleBurst {
    0% { 
        transform: translate(0, 0) scale(1); 
        opacity: 1; 
    }
    100% { 
        transform: translate(var(--x), var(--y)) scale(0); 
        opacity: 0; 
    }
}

/* Add to the existing CSS, preferably in the level-related section */
.level {
    transition: 
        background-color 0.5s ease, 
        box-shadow 0.5s ease, 
        transform 0.5s ease;
}

.level.unlocking {
    animation: unlockLevel 1s forwards;
}

@keyframes unlockLevel {
    0% { 
        transform: scale(1);
        background: var(--locked);
        box-shadow: none;
    }
    50% { 
        transform: scale(1.1);
        background: var(--gold);
        box-shadow: 0 0 30px var(--gold);
    }
    100% { 
        transform: scale(1);
        background: linear-gradient(135deg, var(--accent), #1E90FF);
        box-shadow: 0 10px 20px rgba(233, 69, 96, 0.3);
    }
}

.particle-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

.letter-particle {
    position: absolute;
    font-size: 16px;
    color: rgba(255,255,255,0.2);
    user-select: none;
    pointer-events: none;
    opacity: 0;
    font-weight: bold;
    text-shadow: 0 0 3px rgba(255,255,255,0.1);
}

@keyframes letterFloat {
    0% {
        transform: translate(0, 0) rotate(0deg);
        opacity: 0;
    }
    10% {
        opacity: var(--opacity);
    }
    90% {
        opacity: var(--opacity);
    }
    100% {
        transform: translate(var(--moveX), var(--moveY)) rotate(var(--rotate));
        opacity: 0;
    }
}

/* Timer circle styles */
.progress-circle .timer-bg {
    stroke: rgba(255, 255, 255, 0.1);
    fill: none;
}

.progress-circle .timer-progress {
    stroke: rgba(255, 255, 255, 0.9);
    fill: none;
    transform-origin: center;
    transform: rotate(-180deg);
    transition: stroke-dashoffset 1s linear, stroke 0.3s ease;
}

.progress-circle .timer-progress.warning {
    stroke: #f44336;
    filter: drop-shadow(0 0 5px rgba(244, 67, 54, 0.5));
}

/* Initialize the circle properties */
.progress-circle circle.timer-bg,
.progress-circle circle.timer-progress {
    stroke-linecap: round;
}

/* Ensure inner circle doesn't get affected by outer circle animations */
.progress-circle.completed circle.timer-progress {
    animation: none;
}

/* Override any inherited animations for timer circles */
.progress-circle.completed .timer-bg,
.progress-circle.completed .timer-progress {
    animation: none !important;
}



.home-button i, .back-button i {
    color: var(--text);
    font-size: 1.5rem;
}

.home-button:hover, .back-button:hover {
    background: var(--accent);
    transform: scale(1.1);
}

.perk-button.disabled {
    opacity: 0.3;
    cursor: not-allowed;
}

.reset-button i {
    color: var(--text);
    font-size: 1.5rem;
}

.reset-button.warning {
    animation: blinkRed 0.2s linear 5;
}

@keyframes blinkRed {
    0%, 100% { background-color: transparent; }
    50% { background-color: var(--error); }
}



.navigation-container {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    margin: 1rem 0;
    background: var(--glass);
    padding: 0.75rem;
    border-radius: 25px;
    backdrop-filter: blur(10px);
    position: fixed;
    top: 1rem;
    left: 1rem;
    z-index: 100;
}

.navigation-button {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    padding: 0;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    border: none;
    cursor: pointer;
    transition: background-color 0.3s ease;
    box-shadow: none;
}

.navigation-button:hover {
    background: transparent !important;
    box-shadow: none !important;
    transform: none !important;
}

.navigation-button:hover svg {
    fill: var(--text) !important;
    stroke: var(--text) !important;
}

.navigation-icon {
    font-size: 1.5rem;
    color: var(--text);
}

/* Override any glow effects */
.navigation-button.restart-level {
    color: var(--text);
    animation: none;
}

.navigation-button.restart-level:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-2px);
}

.navigation-button.disabled {
    cursor: pointer;
    opacity: 0.3;
}

@keyframes particleBurst {
    0% { 
        transform: translate(0, 0) scale(1); 
        opacity: 1; 
    }
    100% { 
        transform: translate(var(--x), var(--y)) scale(0.5); 
        opacity: 0; 
    }
}

.menu-button {
    position: fixed;
    top: 2rem;
    right: 2rem;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: var(--glass);
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
    z-index: 100;
}

.menu-button:hover {
    transform: scale(1.1);
    background: rgba(255, 255, 255, 0.2);
}

.menu-button .navigation-icon {
    color: var(--text);
    font-size: 1.5rem;
}

.curtain-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, var(--primary-dark), var(--secondary));
    z-index: 9999;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transform: translateY(-100%);
    /* Transition is now set in JavaScript for different speeds up/down */
    box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}

.curtain-overlay.show {
    transform: translateY(0);  /* Move into view */
}

.curtain-overlay.hide {
    transform: translateY(-100%);  /* Move back up */
}

.curtain-title {
    color: var(--gold);
    text-align: center;
    opacity: 0;
    transform: translateY(20px);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);  /* Faster title animation */
    padding: 2rem;
    background: var(--glass);
    border-radius: 20px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.curtain-title.show {
    opacity: 1;
    transform: translateY(0);
}

.curtain-title h1 {
    font-size: 3rem;
    margin-bottom: 1rem;
    background: linear-gradient(to right, var(--gold), var(--accent));
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
}

.curtain-title h2 {
    font-size: 2rem;
    color: var(--text);
}

@media (max-width: 768px) {
    .curtain-title h1 {
        font-size: 2rem;
    }
    
    .curtain-title h2 {
        font-size: 1.5rem;
    }
}

/* Core Game Variables - PRESERVE */
:root {
  --primary-dark: #1a1a2e;
  --primary: #16213e;
  --secondary: #0f3460;
  --accent: #e94560;
  --text: #ffffff;
  --gold: #ffd700;
  --silver: #c0c0c0;
  --bronze: #cd7f32;
  --success: #4CAF50;
  --error: #f44336;
  --gradient: linear-gradient(135deg, var(--secondary), var(--primary-dark));
  --glass: rgba(255, 255, 255, 0.1);
}

/* Core Screen Structure - PRESERVE */
.screen {
  display: none;
  min-height: 100vh;
  padding: 2rem;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  background: radial-gradient(circle at center, var(--secondary) 0%, var(--primary-dark) 100%);
}

.screen.visible {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.5s ease-in-out;
}

/* Core Title Styles - PRESERVE */
.welcome-title {
  font-size: 2.5rem;
  margin-bottom: 1.5rem;
  background: linear-gradient(to right, var(--gold), var(--accent));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  text-shadow: 0 2px 10px rgba(0,0,0,0.2);
}

/* Core Button Styles - PRESERVE */
.start-button, .reset-button, .shop-button {
  padding: 0.875rem 2rem;
  font-size: 1.25rem;
  font-weight: 600;
  color: var(--text);
  background: var(--accent);
  border: none;
  border-radius: 50px;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 10px 20px rgba(233, 69, 96, 0.3);
  position: relative;
  overflow: hidden;
  width: 100%;
  max-width: 300px;
}

.start-button::before, .reset-button::before, .shop-button::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
  transform: rotate(45deg);
  transition: all 0.3s ease;
  opacity: 0;
}

.start-button:hover, .reset-button:hover, .shop-button:hover {
  transform: translateY(-5px);
  box-shadow: 0 15px 30px rgba(233, 69, 96, 0.4);
}

.start-button:hover::before, .reset-button:hover::before, .shop-button:hover::before {
  opacity: 1;
  animation: shine 1s forwards;
}

/* Navigation Elements - PRESERVE */
.navigation-container {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  margin: 1rem 0;
  background: var(--glass);
  padding: 0.75rem;
  border-radius: 25px;
  backdrop-filter: blur(10px);
  position: fixed;
  top: 1rem;
  left: 1rem;
  z-index: 100;
}

.navigation-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  padding: 0;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.1);
  border: none;
  cursor: pointer;
  transition: all 0.3s ease;
}

.navigation-icon {
  font-size: 1.5rem;
  color: var(--text);
}

/* Core Animations - PRESERVE */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes shine {
  to { transform: rotate(45deg) translate(100%, 100%); }
}

/* Core Media Queries - PRESERVE */
@media (max-width: 768px) {
  .welcome-title {
    font-size: 2rem;
    text-align: center;
    padding: 0 1rem;
  }
  
  .start-button, .reset-button, .shop-button {
    padding: 0.75rem 1.5rem;
    font-size: 1.15rem;
  }
  
  .navigation-container {
    padding: 0.5rem;
  }
  
  .navigation-button {
    width: 36px;
    height: 36px;
  }
}

@media (max-width: 480px) {
  .welcome-title {
    font-size: 1.75rem;
  }
  
  .screen {
    padding: 1rem;
  }
}

/* Safe Area Insets - PRESERVE */
@supports(padding: max(0px)) {
  .screen {
    padding-left: max(2rem, env(safe-area-inset-left));
    padding-right: max(2rem, env(safe-area-inset-right));
    padding-bottom: max(2rem, env(safe-area-inset-bottom));
  }
}

/* Main Custom Practice Container */

/* Custom Practice Screen Enhancements */
#custom-practice-screen .list-name-section input,
#custom-practice-screen #custom-word-input,
#custom-practice-screen .word-translation-item .source-word,
#custom-practice-screen .word-translation-item .target-word {
    background: rgba(0, 0, 0, 0.2);
    border: 2px solid rgba(255, 215, 0, 0.5); /* Gold-like glow */
    color: var(--text);
    border-radius: 8px;
    transition: all 0.3s ease;
    outline: none;
}

#custom-practice-screen .list-name-section input:focus,
#custom-practice-screen #custom-word-input:focus,
#custom-practice-screen .word-translation-item .source-word:focus,
#custom-practice-screen .word-translation-item .target-word:focus {
    border-color: var(--gold);
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
}

#custom-practice-screen #custom-word-input {
    width: 100%;
    min-height: 150px;
    padding: 1rem;
    font-size: 1rem;
    resize: vertical;
}

#custom-practice-screen .list-name-section input {
    width: 100%;
    padding: 0.75rem;
    font-size: 1.2rem;
}

#custom-practice-screen .word-translation-item {
    display: grid;
    grid-template-columns: auto 1fr 1fr auto;
    gap: 0.5rem;
    align-items: center;
    margin-bottom: 0.5rem;
}

#custom-practice-screen .word-translation-item .source-word,
#custom-practice-screen .word-translation-item .target-word {
    padding: 0.5rem;
    font-size: 1rem;
}

#custom-practice-screen .word-translation-item .source-word {
    display: block;
}

#custom-practice-screen .custom-practice-buttons {
    display: flex;
    gap: 1rem;
    margin-top: 1rem;
}

#custom-practice-screen .custom-practice-buttons .start-button {
    flex: 1;
    padding: 1rem;
    font-size: 1rem;
    background: var(--accent);
    color: var(--text);
    border: none;
    border-radius: 8px;
    transition: background 0.3s ease;
}

#custom-practice-screen .custom-practice-buttons .start-button:hover {
    background: var(--gold);
}

#custom-practice-screen .word-translation-item .delete-word-btn {
    background: var(--error);
    color: var(--text);
    border: none;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.3s ease;
}

#custom-practice-screen .word-translation-item .delete-word-btn:hover {
    background: #ff6b6b;
}

/* Drag handle styling */
#custom-practice-screen .drag-handle {
    cursor: move;
    color: var(--text);
    opacity: 0.5;
    transition: opacity 0.3s ease;
}

#custom-practice-screen .drag-handle:hover {
    opacity: 1;
}

#custom-practice-screen .custom-outline-btn {
    padding: 0.625rem 1rem;
    border: 2px solid rgba(255, 215, 0, 0.7); /* Gold color with some transparency */
    color: var(--gold);
    background: transparent;
    border-radius: 8px;
    font-size: 0.9rem;
    font-weight: 600;
    transition: all 0.3s ease;
    cursor: pointer;
    outline: none;
}

#custom-practice-screen .custom-outline-btn:hover {
    background: rgba(255, 215, 0, 0.1); /* Subtle gold background on hover */
    border-color: var(--gold);
    color: var(--text);
    transform: translateY(-2px);
    box-shadow: 0 4px 6px rgba(255, 215, 0, 0.2);
}

#custom-practice-screen .custom-outline-btn:focus {
    outline: none;
    border-color: var(--gold);
    box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.3);
}

#custom-practice-screen .list-actions button {
    border: 2px solid rgba(255, 215, 0, 0.7);
    color: var(--gold);
    background: transparent;
    border-radius: 8px;
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
    transition: all 0.3s ease;
    cursor: pointer;
}

#custom-practice-screen .list-actions button:hover {
    background: rgba(255, 215, 0, 0.1);
    color: var(--text);
    transform: translateY(-2px);
    box-shadow: 0 4px 6px rgba(255, 215, 0, 0.2);
}

#custom-practice-screen .global-list-actions {
    display: flex;
    justify-content: center;
    margin-bottom: 1rem;
}

#custom-practice-screen .global-buttons {
    display: flex;
    gap: 1rem;
}

#custom-practice-screen .list-selection-container {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 1rem;
    max-height: 60vh;
    overflow-y: auto;
}

#custom-practice-screen .custom-list-item {
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
}

#custom-practice-screen .custom-list-item.selected {
    border: 2px solid var(--gold);
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
}

#custom-practice-screen .global-buttons .custom-outline-btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
}

/* Adjust for mobile */
@media (max-width: 768px) {
    #custom-practice-screen .word-translation-item {
        grid-template-columns: 1fr 1fr auto;
        grid-template-areas: 
            "source target delete";
        align-items: center;
        gap: 0.5rem;
    }

    #custom-practice-screen .word-translation-item .source-word {
        grid-area: source;
        font-size: 0.9rem;
        padding: 0.3rem;
    }

    #custom-practice-screen .word-translation-item .target-word {
        grid-area: target;
        font-size: 0.9rem;
        padding: 0.3rem;
    }

    #custom-practice-screen .word-translation-item .delete-word-btn {
        grid-area: delete;
        width: 25px;
        height: 25px;
        font-size: 0.8rem;
        padding: 0;
    }

    #custom-practice-screen .word-translation-item .drag-handle {
        display: none; /* Remove drag handle on mobile to save space */
    }
}


@keyframes float {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-20px); }
}

/* Remove any existing .auth-form styles */

.auth-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2rem;
    width: 100%;
    max-width: 400px;
    margin: 0 auto;
}

.auth-form {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    width: 100%;
    padding: 2rem;
    background: var(--glass);
    border-radius: 20px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.auth-subtitle {
    color: var(--gold);
    text-align: center;
    font-size: 1.5rem;
    margin-bottom: 1rem;
}

.auth-input {
    padding: 1rem;
    border: 2px solid rgba(255, 215, 0, 0.3);
    border-radius: 12px;
    background: rgba(0, 0, 0, 0.2);
    color: var(--text);
    font-size: 1rem;
    transition: all 0.3s ease;
}

.auth-input:focus {
    border-color: var(--gold);
    outline: none;
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
}

.auth-input::placeholder {
    color: rgba(255, 255, 255, 0.5);
}

.auth-switch {
    text-align: center;
    color: var(--text);
    margin-top: 0.5rem;
    font-size: 0.9rem;
}

.auth-switch span {
    color: var(--gold);
    cursor: pointer;
    text-decoration: underline;
    transition: color 0.3s ease;
}

.auth-switch span:hover {
    color: var(--accent);
}

.auth-skip-button {
    margin-top: 2rem;
    padding: 0.75rem 1.5rem;
    background: transparent;
    border: 2px solid rgba(255, 255, 255, 0.2);
    color: var(--text);
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 0.9rem;
}

.auth-skip-button:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.3);
}

@media (max-width: 768px) {
    .auth-container {
        padding: 0 1rem;
    }
    
    .auth-form {
        padding: 1.5rem;
    }
}

.user-sign-in-marker {
    position: absolute;
    top: 1rem;
    left: 1rem;
    background: var(--glass);
    backdrop-filter: blur(10px);
    border-radius: 25px;
    padding: 0.75rem 1rem;
    z-index: 10;
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.user-sign-in-marker .user-info-container {
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.user-sign-in-marker .user-icon {
    font-size: 2rem;
    color: var(--gold);
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
}

.user-sign-in-marker .user-details {
    display: flex;
    flex-direction: column;
}

.user-sign-in-marker .user-email {
    font-size: 0.9rem;
    color: var(--text);
    max-width: 150px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.user-sign-in-marker .user-status {
    font-size: 0.7rem;
    color: var(--success);
    text-transform: uppercase;
    letter-spacing: 1px;
}

.user-email-display {
    position: fixed; /* Change from absolute to fixed for consistent positioning */
    top: 1rem;
    left: 50%;
    transform: translateX(-50%); /* Center horizontally */
    background: var(--glass);
    backdrop-filter: blur(10px);
    border-radius: 25px;
    padding: 0.75rem 1.5rem;
    font-size: 1.2rem;
    color: var(--gold);
    text-align: center;
    z-index: 100; /* Ensure it stays above other elements */
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

    </style>
</head>
<body>

  <div class="curtain-overlay">
    <div class="curtain-title">
      <h1></h1>
      <h2></h2>
    </div>
  </div>

  <div id="welcome-screen" class="screen visible">
    <div class="particle-container" id="particleContainer"></div>    
    <button class="menu-button" onclick="showStagesFromMenu()">
        <i class="fas fa-bars navigation-icon"></i>
    </button>
    <div class="user-email-display"></div>  <!-- Add this line -->
    <h1 class="welcome-title">Simplos</h1>
    <div class="welcome-buttons">
        <button class="start-button" onclick="startGame()">Start Game</button>
        <button class="start-button custom-lists-button" onclick="showCustomListsManager()">Custom Practice</button>
        <button class="auth-skip-button" onclick="handleLogout()">Logout</button>
    </div>
</div>

<!-- Add this after your other screen divs -->
<div id="auth-screen" class="screen">
    <div class="particle-container"></div>
    <h1 class="welcome-title">Simplos</h1>
    
    <div class="auth-container">
        <!-- Login Form -->
        <div id="login-form" class="auth-form">
            <h2 class="auth-subtitle">Login</h2>
            <input type="email" id="login-email" placeholder="Email" class="auth-input">
            <input type="password" id="login-password" placeholder="Password" class="auth-input">
            <button class="start-button" onclick="handleLogin()">Login</button>
            <div class="auth-switch">
                Don't have an account? 
                <span onclick="toggleAuthForm('signup')">Sign Up</span>
            </div>
        </div>

        <!-- Signup Form -->
        <div id="signup-form" class="auth-form">
            <h2 class="auth-subtitle">Sign Up</h2>
            <input type="email" id="signup-email" placeholder="Email" class="auth-input">
            <input type="password" id="signup-password" placeholder="Password" class="auth-input">
            <select id="signup-role" class="auth-input">
                <option value="" disabled selected>Select Role</option>
                <option value="student">Student</option>
                <option value="teacher">Teacher</option>
            </select>
            <button class="start-button" onclick="handleSignup()">Sign Up</button>
            <div class="auth-switch">
                Already have an account? 
                <span onclick="toggleAuthForm('login')">Login</span>
            </div>
        </div>
    </div>

    <!-- Skip Auth Button -->
    <button class="auth-skip-button" onclick="handleSkipAuth()">
        Continue as Guest
    </button>
</div>

<div id="stage-screen" class="screen">
    <div class="particle-container"></div>
    <div class="navigation-container" style="position: fixed; top: 1rem; left: 50%; transform: translateX(-50%); flex-direction: row; gap: 0.75rem; background: none; margin: 0;">
        <button class="navigation-button home-button" onclick="showScreen('welcome-screen')">
        <i class="fas fa-home navigation-icon"></i>
    </button>
    <button class="navigation-button reset-button" onclick="handleResetProgress()">
        <i class="fas fa-trash-alt navigation-icon"></i>
    </button>
</div>
    <div class="stage-container">
        <div class="stage-button junior-level" onclick="showSetScreen(1)">
            <div class="stage-name">מתחילים</div>
            Stage 1
        </div>
        <div class="stage-button bronze-level" onclick="showSetScreen(2)">
            <div class="stage-name">יסודי</div>
            Stage 2
        </div>
        <div class="stage-button silver-level" onclick="showSetScreen(3)">
            <div class="stage-name">חטיבת ביניים</div>
            Stage 3
        </div>
        <div class="stage-button gold-level" onclick="showSetScreen(4)">
            <div class="stage-name">תיכון</div>
            Stage 4
        </div>
        <div class="stage-button diamond-level" onclick="showSetScreen(5)">
            <div class="stage-name">אוניברסיטה</div>
            Stage 5
        </div>
    </div>
</div>

<div id="set-screen" class="screen">
    <div class="particle-container"></div>
    <div class="navigation-container" style="position: fixed; top: 1rem; left: 50%; transform: translateX(-50%); flex-direction: row; gap: 0.75rem; background: none; margin: 0;">
        <button class="navigation-button home-button" onclick="showScreen('welcome-screen')">
          <i class="fas fa-home navigation-icon"></i>
      </button>
      <button class="navigation-button reset-button" onclick="handleResetProgress()">
          <i class="fas fa-trash-alt navigation-icon"></i>
      </button>
  </div>
    <div class="set-container" id="set-container"></div>
</div>

<div id="level-screen" class="screen">
    <div class="particle-container"></div>
    <div class="navigation-container" style="position: fixed; top: 1rem; left: 50%; transform: translateX(-50%); flex-direction: row; gap: 0.75rem; background: none; margin: 0;">      <button class="navigation-button home-button" onclick="showScreen('welcome-screen')">
          <i class="fas fa-home navigation-icon"></i>
      </button>
      <button class="navigation-button reset-button" onclick="handleResetProgress()">
          <i class="fas fa-trash-alt navigation-icon"></i>
      </button>
  </div>
    <div class="level-selection" id="level-container"></div>
</div>

<div id="question-screen" class="screen">
    <div class="particle-container"></div>
<div class="navigation-container" style="position: fixed; top: 1rem; left: 50%; transform: translateX(-50%); flex-direction: row; gap: 0.75rem; background: none; margin: 0;">      <button class="navigation-button home-button" onclick="showScreen('welcome-screen')">
          <i class="fas fa-home navigation-icon"></i>
      </button>
      <button class="navigation-button reset-button" onclick="handleResetProgress()">
          <i class="fas fa-trash-alt navigation-icon"></i>
      </button>
      <button class="navigation-button restart-level" onclick="handleRestartLevel()">
          <i class="fas fa-redo navigation-icon"></i>
      </button>
  </div>
    <div class="question-word" id="question-word"></div>
    <div class="progress-circle">
        <svg width="100%" height="100%" viewBox="0 0 120 120">
            <circle class="bg" cx="60" cy="60" r="54" stroke-width="8"/>
            <circle class="progress" cx="60" cy="60" r="54" stroke-width="8"/>
            <circle class="timer-bg" cx="60" cy="60" r="40" stroke-width="4"/>
            <circle class="timer-progress" cx="60" cy="60" r="40" stroke-width="4"/>
        </svg>
        <div class="coins-container">
            <i class="fas fa-coins coin-icon"></i>
            <span class="coin-count">0</span>
        </div>
    </div>
    <div class="perks-container">
        <button class="perk-button" id="timeFreezePerk">
            <i class="fas fa-clock perk-icon"></i>
            <span class="perk-count">0</span>
        </button>
        <button class="perk-button" id="skipPerk">
            <i class="fas fa-forward perk-icon"></i>
            <span class="perk-count">0</span>
        </button>
        <button class="perk-button" id="cluePerk">
            <i class="fas fa-lightbulb perk-icon"></i>
            <span class="perk-count">0</span>
        </button>
        <button class="perk-button" id="revealPerk">
            <i class="fas fa-eye perk-icon"></i>
            <span class="perk-count">0</span>
        </button>
    </div>
    <div class="timer-container">
        <div class="timer-value">00:00</div>
    </div>
    <div class="buttons" id="buttons"></div>
</div>

<div class="failure-overlay" style="display: none;">
    <div class="failure-content">
        <h2 class="failure-title">Time's Up!</h2>
        <div class="failure-buttons">
            <button class="restart-button">
                <i class="fas fa-redo"></i>
            </button>
            <button class="home-button">
                <i class="fas fa-home"></i>
            </button>
        </div>
    </div>
</div>

<div id="custom-practice-screen" class="screen">
    <div class="navigation-container">
        <button class="navigation-button home-button" onclick="showScreen('welcome-screen')">
            <i class="fas fa-home navigation-icon"></i>
        </button>
    </div>

    <div class="custom-practice-container">
        <div class="lists-section">
            <h2 class="welcome-title">My Word Lists</h2>
            <div id="custom-lists-container" class="custom-lists-container">
                <!-- Lists will be dynamically populated here -->
            </div>
        </div>
        
        <div class="practice-section">
            <h2 class="welcome-title">Add</h2>
            <div class="list-name-section">
                <input 
                    type="text" 
                    id="custom-list-name" 
                    class="list-name-input" 
                    placeholder="List Name"
                >
            </div>
            <textarea 
                id="custom-word-input" 
                placeholder="Enter words, separated by commas or newlines"
            ></textarea>
            <div class="custom-practice-buttons">
                <button 
                    onclick="processCustomWords()" 
                    class="custom-outline-btn make-btn"
                >
                    Make
                </button>
                <button 
                    onclick="addNewWord()" 
                    class="custom-outline-btn add-btn"
                >
                    Add
                </button>
                <button 
                    onclick="saveCurrentList()" 
                    class="custom-outline-btn save-btn"
                >
                    Save
                </button>
            </div>
            <div class="translation-results" id="translation-results">
                <div class="word-translation-list" id="word-translation-list">
                    <!-- Processed words will appear here -->
                </div>
            </div>
        </div>

        <script type="module">
            import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
            
            const supabase = createClient(
              'https://mczfgzffyyyacisrccqb.supabase.co',
              'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1jemZnemZmeXl5YWNpc3JjY3FiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzczNzY5NDYsImV4cCI6MjA1Mjk1Mjk0Nn0.iTvzt-vkFP7rLn5-FHztMEzkF6DMqMh5zcKJzgyvUfo'
            );
          
            window.supabase = supabase; // Make it available globally
          </script>


<script>

const vocabularySets = {

"1_1": { words: ["pizza", "soup", "omelette", "chocolate", "rice", "muffins", "eggs", "lentils", "yogurt", "carrot", "sushi", "pasta", "cookies", "coffee", "grapes", "water", "potatoes", "pancake", "onion", "tea", "noodles", "chicken", "cheese", "sandwich", "hot dogs", "butter", "tomato", "lettuce", "salad", "milk", "banana", "fish", "hamburger", "orange", "croissant", "beans", "bread", "juice", "kebab", "cucumber", "ice cream", "french fries", "beef", "apple", "popsicle", "pepper", "popcorn", "cake", "garlic", "salt", "sauce", "ketchup", "mustard"], translations: ["פיצה", "מרק", "חביתה", "שוקולד", "אורז", "מאפינס", "ביצים", "עדשים", "יוגורט", "גזר", "סושי", "פסטה", "עוגיות", "קפה", "ענבים", "מים", "תפוחי אדמה", "פנקייק", "בצל", "תה", "נודלס", "עוף", "גבינה", "כריך", "נקניקיות", "חמאה", "עגבנייה", "חסה", "סלט", "חלב", "בננה", "דג", "המבורגר", "תפוז", "קרואסון", "שעועית", "לחם", "מיץ", "קבב", "מלפפון", "גלידה", "צ'יפס", "בקר", "תפוח", "ארטיק", "פלפל", "פופקורן", "עוגה", "שום", "מלח", "רוטב", "קטשופ", "חרדל"] },
"1_2": { words: ["forehead", "eyebrow", "chin", "tongue", "ribs", "toe", "back", "head", "nail", "ear", "abdomen", "lip", "hair", "mouth", "hip", "sole", "eye", "stomach", "calf", "heart", "shoulder", "kidney", "spine", "liver", "bone", "chest", "elbow", "nose", "knee", "intestine", "waist", "hand", "lung", "neck", "ankle", "muscle", "nostril", "skull", "thigh", "arm", "heel", "brain", "wrist", "thumb", "eyelash", "finger", "tooth", "cheek", "foot", "navel"], translations: ["מצח", "גבה", "סנטר", "לשון", "צלעות", "בוהן", "גב", "ראש", "ציפורן", "אוזן", "חלל הבטן", "שפה", "שיער", "פה", "מותן", "כף הרגל", "עין", "בטן", "שוק", "לב", "כתף", "כליה", "עמוד השדרה", "כבד", "עצם", "חזה", "מרפק", "אף", "ברך", "מעיים", "אגן הירכיים", "יד", "ריאה", "צוואר", "קרסול", "שריר", "נחיר", "גולגולת", "ירך", "זרוע", "עקב", "מוח", "פרק כף היד", "אגודל", "ריס", "אצבע", "שן", "לחי", "כף רגל", "טבור"] },
"1_3": { words: ["peacock", "crocodile", "goat", "bat", "shark", "eagle", "snake", "whale", "fox", "owl", "lion", "pig", "hawk", "penguin", "koala", "sparrow", "elephant", "camel", "deer", "mouse", "chicken", "bear", "wolf", "sheep", "pigeon", "fish", "rabbit", "frog", "parrot", "cow", "zebra", "cat", "giraffe", "dolphin", "turtle", "tiger", "rhinoceros", "rat", "hippopotamus", "squirrel", "alligator", "lizard", "gecko", "goose", "horse", "kangaroo", "dog", "duck", "chimpanzee"], translations: ["טווס", "תנין", "עז", "עטלף", "כריש", "נשר", "נחש", "לוויתן", "שועל", "ינשוף", "אריה", "חזיר", "נץ", "פינגווין", "קואלה", "דרור", "פיל", "גמל", "צבי", "עכבר", "עוף", "דוב", "זאב", "כבשה", "יונה", "דג", "ארנב", "צפרדע", "תוכי", "פרה", "זברה", "חתול", "ג'ירפה", "דולפין", "צב", "נמר", "קרנף", "עכברוש", "היפופוטם", "סנאי", "תנין", "לטאה", "חרדון", "אווז", "סוס", "קנגרו", "כלב", "ברווז", "שימפנזה"] },
"1_4": { words: ["musician", "photographer", "programmer", "athlete", "carpenter", "writer", "chef", "waiter", "pharmacist", "waitress", "baker", "gardener", "tailor", "dentist", "dancer", "clown", "construction worker", "barber", "taxi driver", "hairdresser", "astronaut", "actor", "doctor", "news reporter", "magician", "nurse", "factory worker", "firefighter", "receptionist", "soldier", "teacher", "sailor", "lifeguard", "farmer", "bus driver", "plumber", "postman", "mechanic", "librarian", "fisherman", "scientist", "artist", "coach", "policeman", "pilot", "fashion designer", "veterinarian", "painter", "lawyer"], translations: ["מוזיקאי", "צלם", "מתכנת", "אתלט", "נגר", "סופר", "שף", "מלצר", "רוקח", "מלצרית", "אופה", "גנן", "חייט", "רופא שיניים", "רקדן", "ליצן", "עובד בניין", "ספר גברים", "נהג מונית", "מעצב שיער", "אסטרונאוט", "שחקן", "דוקטור", "כתב חדשות", "קוסם", "אחות", "עובד מפעל", "כבאי", "פקיד קבלה", "לוחם", "מורה", "מלח", "מציל", "חקלאי", "נהג אוטובוס", "שרברב", "דוור", "מכונאי", "ספרן", "דיג", "מדען", "אמן", "מאמן", "שוטר", "טיס", "מעצב אופנה", "וטרינר", "צייר", "עורך דין"] },
"1_5": { words: ["house", "home", "room", "kitchen", "bathroom", "bedroom", "living room", "dining room", "garage", "basement", "attic", "hallway", "stairs", "door", "window", "floor", "ceiling", "wall", "roof", "bed", "table", "chair", "sofa", "couch", "television", "radio", "mirror", "clock", "lamp", "light", "carpet", "rug", "curtain", "blind", "shelf", "cabinet", "drawer", "refrigerator", "freezer", "oven", "stove", "microwave", "toaster", "dishwasher", "sink", "toilet", "bathtub", "shower"], translations: ["בית מגורים", "בית", "חדר", "מטבח", "חדר אמבטיה", "חדר שינה", "סלון", "חדר אוכל", "מוסך", "מרתף", "עלית גג", "מסדרון", "מדרגות", "דלת", "חלון", "קומה", "תקרה", "קיר", "גג", "מיטה", "שולחן", "כסא", "ספה", "כורסה", "טלוויזיה", "רדיו", "מראה", "שעון", "מנורה", "אור", "שטיח", "וילון", "תריסים", "מדף", "ארון", "מגירה", "מקרר", "פריזר", "תנור", "מיקרוגל", "טוסטר", "מדיח כלים", "כיור", "שירותים", "אמבטיה", "מקלחת"] },
"1_6": { words: ["twenty", "twenty-five", "twenty-one", "eleven", "thirty-four", "forty-one", "forty-four", "twenty-two", "forty-two", "thirty-two", "one", "forty", "eighteen", "twelve", "twenty-four", "five", "thirty-seven", "fifty forty-five", "seventeen", "forty-three", "three", "forty-nine", "forty-six", "sixteen", "thirty", "fifteen", "thirty-five", "forty-seven", "twenty-six", "ten", "four", "nineteen", "thirty-eight", "nine", "thirteen", "two", "forty-eight", "eight", "thirty-six", "seven", "twenty-seven", "twenty-eight", "thirty-nine", "twenty-nine", "twenty-three", "six", "thirty-one", "thirty-three", "fourteen"], translations: ["עשרים", "עשרים וחמש", "עשרים ואחת", "אחת עשרה", "שלושים וארבע", "ארבעים ואחת", "ארבעים וארבע", "עשרים ושתיים", "ארבעים ושתיים", "שלושים ושתיים", "אחד", "ארבעים", "שמונה עשרה", "שתים עשרה", "עשרים וארבע", "חמש", "שלושים ושבע", "חמישים", "ארבעים וחמש", "שבע עשרה", "ארבעים ושלוש", "שלוש", "ארבעים ותשע", "ארבעים ושש", "שש עשרה", "שלושים", "חמש עשרה", "שלושים וחמש", "ארבעים ושבע", "עשרים ושש", "עשר", "ארבע", "תשע עשרה", "שלושים ושמונה", "תשע", "שלוש עשרה", "שתיים", "ארבעים ושמונה", "שמונה", "שלושים ושש", "שבע", "עשרים ושבע", "עשרים ושמונה", "שלושים ותשע", "עשרים ותשע", "עשרים ושלוש", "שש", "שלושים ואחת", "שלושים ושלוש", "ארבע עשרה"] },
"1_7": { words: ["big", "small", "tall", "short", "long", "fast", "slow", "hot", "cold", "happy", "sad", "funny", "serious", "nice", "mean", "good", "bad", "clean", "dirty", "old", "young", "hard", "soft", "loud", "quiet", "easy", "difficult", "beautiful", "ugly", "hungry", "full", "thirsty", "wet", "dry", "heavy", "light", "busy", "lazy", "strong", "weak", "healthy", "sick", "tired", "awake", "asleep", "messy", "open", "closed"], translations: ["גדול", "קטן", "גבוה", "קצר", "ארוך", "מהיר", "איטי", "חם", "קר", "שמח", "עצוב", "מצחיק", "רציני", "נחמד", "מרושע", "טוב", "רע", "נקי", "מלוכלך", "ישן", "צעיר", "קשה", "רך", "קולני", "שקט", "קל", "קשה", "יפה", "מכוער", "רעב", "שבע", "צמא", "רטוב", "יבש", "כבד", "קל", "עסוק", "עצלן", "חזק", "חלש", "בריא", "חולה", "עייף", "ער", "ישן", "מבולגן", "פתוח", "סגור"] },
"1_8": { words: ["autumn", "future", "morning", "noon", "October", "calendar", "dusk", "week", "spring", "August", "watch", "hour", "period", "Tuesday", "Thursday", "sunday", "minute", "present", "last", "midnight", "winter", "yesterday", "millennium", "December", "month", "ago", "Monday", "night", "Saturday", "past", "January", "April", "summer", "second", "September", "today", "sunrise", "Friday", "century", "sunset", "July", "February", "next", "November", "decade", "June", "Wednesday", "daylight", "tomorrow", "holiday", "year", "day", "clock", "May", "evening", "March", "afternoon", "now", "dawn"], translations: ["סתיו", "עתיד", "בוקר", "צהריים", "אוקטובר", "לוח שנה", "שעת ערב", "שבוע", "אביב", "אוגוסט", "שעון", "שעה", "תקופה", "יום שלישי", "יום חמישי", "יום ראשון", "דקה", "ההווה", "אחרון", "חצות", "חורף", "אתמול", "אלף שנה", "דצמבר", "חודש", "לפני", "יום שני", "לילה", "יום שבת", "עבר", "ינואר", "אפריל", "קיץ", "שניה", "ספטמבר", "היום", "זריחה", "יום שישי", "מאה שנה", "שקיעת החמה", "יולי", "פברואר", "הבא", "נובמבר", "עשור", "יוני", "יום רביעי", "אור", "מחר", "חג", "שנה", "יום", "שעון", "מאי", "ערב", "מרץ", "אחרי הצהריים", "עכשיו", "שחר"] },
"1_9": { words: ["be", "have", "do", "say", "get", "make", "go", "know", "take", "see", "come", "think", "look", "want", "give", "use", "find", "tell", "ask", "work", "seem", "feel", "try", "leave", "call", "show", "talk", "play", "run", "move", "like", "live", "believe", "hold", "bring", "happen", "write", "provide", "sit", "stand", "lose", "pay", "meet", "include", "continue", "set", "learn", "change"], translations: ["להיות", "יש", "לעשות", "לומר", "לקבל", "לעשות", "ללכת", "לדעת", "לקחת", "לראות", "לבוא", "לחשוב", "לראות", "לרצות", "לתת", "להשתמש", "למצוא", "להגיד", "לשאול", "לעבוד", "לתת רושם", "להרגיש", "לנסות", "לעזוב", "לשוחח", "להראות", "לדבר", "לשחק", "לרוץ", "לזוז", "לאהוב", "לחיות", "להאמין", "להחזיק", "להביא", "לקרות", "לכתוב", "לספק", "לשבת", "לעמוד", "לאבד", "לשלם", "לפגוש", "לכלול", "להמשיך", "לקבוע", "ללמוד", "לשנות"] },
    
"2_1": { words: ["hope", "get", "beside", "sad", "important", "pick", "fair", "computer", "place", "together", "start", "go", "brother", "teach", "women", "of", "man", "quiet", "sentence", "enter", "news", "few", "ago", "student", "nice", "or", "course", "many", "month", "idea", "alone", "if", "happy", "smart", "until", "number", "careful", "true", "practice", "grade", "under", "exercise", "bag", "fact", "clean", "dad", "now", "classroom", "cold", "hang"], translations: ["לקוות", "לקבל", "בצד", "עצוב", "חשוב", "לבחור", "הוגן", "מחשב", "מקום", "יחד", "התחלה", "ללכת", "אח", "ללמד", "נשים", "של", "איש", "שקט", "משפט", "להיכנס", "חדשות", "מעט", "לפני", "סטודנט", "נחמד", "או", "קורס", "הרבה", "חודש", "רעיון", "לבד", "אם", "שמח", "חכם", "עד", "מספר", "זהיר", "אמיתי", "לתרגל", "ציון", "מתחת", "תרגיל", "תיק", "עובדה", "לנקות", "אבא", "עכשיו", "כיתה", "קר", "לתלות"] },
"2_2": { words: ["song", "walk", "above", "test", "kind", "baby", "well", "what", "job", "wonderful", "room", "young", "live", "look", "high", "half", "another", "life", "everything", "read", "milk", "real", "easy", "too", "glad", "world", "center", "interested", "want", "can", "breakfast", "closed", "class", "bring", "picture", "run", "beautiful", "box", "far", "draw", "bus", "better", "watch", "anyone", "feet", "great", "never", "again", "way"], translations: ["שיר", "ללכת", "מעל", "מבחן", "אדיב", "תינוק", "ובכן", "מה", "עבודה", "נהדר", "חדר", "צעיר", "לחיות", "להסתכל", "גבוה", "חצי", "אחר", "חיים", "הכל", "לקרוא", "חלב", "אמיתי", "קל", "גם", "שמח", "עולם", "מרכז", "מעוניין", "לרצות", "יכול", "ארוחת בוקר", "סגור", "כיתה", "להביא", "תמונה", "לרוץ", "יפה", "קופסא", "רחוק", "לצייר", "אוטובוס", "טוב יותר", "שעון", "כל אחד", "רגליים", "מעולה", "לעולם לא", "שוב", "דרך"] },
"2_3": { words: ["cut", "action", "while", "ready", "lesson", "please", "cool", "large", "rich", "item", "call", "down", "tomorrow", "inside", "every", "body", "tree", "yes", "different", "always", "face", "often", "believe", "sorry", "it", "tea", "count", "straight", "after", "perhaps", "more", "cost", "pay", "worst", "shout", "answer", "vacation", "rest", "television", "name", "right", "dear", "game", "special", "final", "most", "wear", "mom"], translations: ["לחתוך", "פעולה", "בזמן ש", "מוכן", "שיעור", "בבקשה", "מגניב", "גדול", "עשיר", "פריט", "לקרוא", "למטה", "מחר", "בתוך", "כל", "גוף", "עץ", "כן", "שונה", "תמיד", "פנים", "לעתים קרובות", "להאמין", "סליחה", "זה", "תה", "לספור", "ישר", "אחרי", "אולי", "יותר", "מחיר", "לשלם", "הכי גרוע", "לצעוק", "לענות", "חופשה", "מנוחה", "טלויזיה", "שם", "ימין", "יקר", "משחק", "מיוחד", "אחרון", "רוב", "ללבוש", "אמא"] },
"2_4": { words: ["soon", "cry", "trip", "including", "okay", "sick", "wall", "cross", "welcome", "good", "girl", "page", "give", "lots", "poor", "week", "road", "street", "left", "late", "school", "child", "sing", "return", "thanks", "only", "woman", "end", "friend", "grow", "dry", "before", "love", "boring", "smile", "car", "glass", "for", "dress", "hot", "door", "side", "pen", "by", "hard", "paper", "appear", "here", "meet", "example"], translations: ["בקרוב", "לבכות", "טיול", "לרבות", "בסדר", "חולה", "קיר", "לחצות", "ברוך הבא", "טוב", "ילדה", "עמוד", "לתת", "הרבה", "עני", "שבוע", "כביש", "רחוב", "שמאל", "מאוחר", "בית ספר", "ילד", "לשיר", "לחזור", "תודה", "רק", "אשה", "סוף", "חבר", "לגדול", "יבש", "לפני", "אהבה", "משעמם", "חיוך", "מכונית", "זכוכית", "ל", "להתלבש", "חם", "דלת", "צד", "עט", "על ידי", "קשה", "נייר", "להופיע", "כאן", "לפגוש", "דוגמא"] },
"2_5": { words: ["know", "window", "very", "close", "mistake", "say", "old", "almost", "part", "size", "sometimes", "without", "fine", "this", "board", "film", "everyone", "book", "thing", "break", "fire", "once", "goodbye", "movie", "story", "coffee", "pencil", "meeting", "nobody", "parents", "hand", "time", "chair", "copy", "study", "people", "enjoy", "afraid", "how", "turn", "care", "bored", "problem", "immediately", "keep", "write", "strong", "moment", "neighbor", "cheap"], translations: ["לדעת", "חלון", "מאוד", "סגור", "טעות", "לאמר", "ישן", "כמעט", "חלק", "גודל", "לפעמים", "ללא", "בסדר גמור", "זה", "לוח", "סרט צילום", "כולם", "ספר", "דבר", "לשבור", "אש", "פעם אחת", "ביי", "סרט", "סיפור", "קפה", "עפרון", "פגישה", "אף אחד", "הורים", "יד", "זמן", "כסא", "להעתיק", "ללמוד", "אנשים", "להנות", "לחשוש", "איך", "לפנות", "לטפל", "משועמם", "בעיה", "מיד", "לשמור", "לכתוב", "חזק", "רגע", "שכן", "זול"] },
"2_6": { words: ["maybe", "short", "family", "change", "hold", "memory", "interesting", "wash", "a lot", "person", "costs", "father", "which", "new", "come", "food", "make", "early", "money", "hour", "notebook", "year", "day", "forget", "listen", "somebody", "long", "own", "need", "least", "think", "work", "pity", "any", "play", "cousin", "just", "message", "done", "understand", "word", "question", "sun", "no-one", "lie", "autumn", "hello", "anything", "send"], translations: ["אולי", "קצר", "משפחה", "לשנות", "להחזיק", "זיכרון", "מעניין", "לשטוף", "הרבה", "בן אדם", "עלויות", "אבא", "איזה", "חדש", "לבוא", "אוכל", "לעשות", "מוקדם", "כסף", "שעה", "מחברת", "שנה", "יום", "לשכוח", "להקשיב", "מישהו", "ארוך", "שייך", "צורך", "הכי פחות", "לחשוב", "לעבוד", "רחמים", "כל", "לשחק", "בן דוד", "רק", "הודעה", "נעשה", "להבין", "מילה", "שאלה", "שמש", "אף אחד", "לשקר", "סתיו", "שלום", "כל דבר", "לשלוח"] },
"2_7": { words: ["wait", "drive", "touch", "all", "plan", "still", "because", "light", "doctor", "children", "begin", "nothing", "like", "funny", "past", "with", "leave", "away", "winter", "garden", "flower", "show", "when", "town", "these", "enough", "put", "do", "back", "decide", "water", "slow", "less", "extra", "in", "shut", "bit", "chocolate", "find", "foot", "quick", "clear", "best", "so", "busy", "push", "house", "bad", "telephone", "near"], translations: ["לחכות", "לנהוג", "לגעת", "הכל", "לתכנן", "עדיין", "כי", "אור", "רופא", "ילדים", "להתחיל", "שום דבר", "כמו", "מצחיק", "עבר", "עם", "לעזוב", "רחוק", "חורף", "גן", "פרח", "להראות", "מתי", "עיר", "אלה", "מספיק", "לשים", "לעשות", "בחזרה", "להחליט", "מים", "לאט", "פחות", "תוספת", "בתוך", "סגור", "קצת", "שוקולד", "למצוא", "כף רגל", "מהר", "ברור", "הטוב ביותר", "אם כן", "עסוק", "לדחוף", "בית", "רע", "טלפון", "ליד"] },
"2_8": { words: ["other", "hat", "capital", "sit", "alphabet", "summer", "across", "little", "then", "angry", "animal", "mean", "talk", "sport", "guess", "home", "sign", "age", "into", "possible", "some", "and", "why", "today", "sky", "those", "learn", "agree", "bed", "meaning", "front", "fly", "catch", "remember", "lost", "expensive", "evening", "son", "men", "build", "take", "minute", "wrong", "excuse", "piece"], translations: ["אחר", "כובע", "עיר בירה", "לשבת", "אלפבית", "קיץ", "ברחבי", "קטן", "אז", "כועס", "בעל חיים", "להתכוון", "לדבר", "ספורט", "לנחש", "בית", "סימן", "גיל", "לתוך", "אפשרי", "קצת", "ו", "למה", "היום", "שמים", "אלו", "ללמוד", "להסכים", "מיטה", "משמעות", "חזית", "לטוס", "לתפוס", "לזכור", "אבוד", "יקר", "ערב", "בן", "גברים", "לבנות", "לקחת", "דקה", "טעות", "חתיכה"] },
"2_9": { words: ["country", "not", "last", "color", "hungry", "simple", "each", "where", "big", "dark", "between", "middle", "project", "have", "bottle", "who", "mix", "pupil", "alright", "music", "lunch", "morning", "happen", "night", "kid", "finish", "sure", "mother", "same", "but", "email", "letter", "buy", "free", "matter", "invite", "already", "tell", "much", "about", "afternoon", "sleep", "dictionary", "supper", "impossible", "drink", "hair", "out", "up"], translations: ["מדינה", "לא", "אחרון", "צבע", "רעב", "פשוט", "כל אחד", "איפה", "גדול", "כהה", "בין", "אמצע", "פרויקט", "יש", "בקבוק", "מי", "לערבב", "תלמיד", "בסדר", "מוזיקה", "ארוחת צהריים", "בוקר", "לקרות", "לילה", "ילד", "לסיים", "בטוח", "אמא", "אותו דבר", "אבל", "אימייל", "מכתב", "לקנות", "חינם", "חומר", "להזמין", "כבר", "להגיד", "הרבה", "לגבי", "אחרי הצהריים", "לישון", "מילון", "ארוחת ערב", "בלתי אפשרי", "לשתות", "שיער", "החוצה", "למעלה"] },
"2_10": { words: ["daughter", "round", "behind", "eat", "ask", "open", "address", "everybody", "suddenly", "from", "try", "truck", "shame", "boy", "small", "feel", "moon", "move", "hear", "usually", "yesterday", "difficult", "birthday", "thank", "mind", "tall", "knowledge", "sister", "spell", "as", "tonight", "arrive", "help", "over", "wish", "fast", "see", "second", "radio", "that", "spring", "first", "fall", "head", "favorite", "use"], translations: ["בת", "עגול", "מאחורה", "לאכול", "לשאול", "לפתוח", "כתובת", "כולם", "פתאום", "מ", "לנסות", "משאית", "בושה", "ילד", "קטן", "להרגיש", "ירח", "לזוז", "לשמוע", "בדרך כלל", "אתמול", "קשה", "יום הולדת", "להודות", "נפש", "גבוה", "ידע", "אחות", "לאיית", "כמו ש", "הלילה", "להגיע", "לעזור", "מעל", "משאלה", "מהיר", "לראות", "שניה", "רדיו", "זה", "אביב", "ראשון", "סתיו", "ראש", "מועדף", "להשתמש"] },

"3_1": { words: ["occur", "math", "translate", "desk", "used", "follow", "certain", "unless", "advertise", "stage", "holiday", "society", "receive", "rid", "process", "scientist", "point", "arrangement", "order", "rain", "pressure", "traffic", "individual", "beat", "though", "border", "technology", "nature", "machine", "police", "ought", "useful", "director", "imagine", "forest", "taste", "previous", "laugh", "material", "powerful", "international", "either...", "or...", "pair", "shape", "remind", "library"], translations: ["להתרחש", "מתמטיקה", "לתרגם", "שולחן כתיבה", "משומש", "לעקוב", "מסוים", "אלא אם", "לפרסם", "במה", "חג", "חברה", "לקבל", "להיפטר", "תהליך", "מדען", "נקודה", "סידור", "להזמין", "גשם", "לחץ", "תנועה", "אישי", "פעימה", "למרות זאת", "גבול", "טכנולוגיה", "טבע", "מכונה", "משטרה", "נדרש", "שימושי", "מנהל", "לדמיין", "יער", "טעם", "קודם", "לצחוק", "חומר", "חזק", "בינלאומי", "או... או...", "זוג", "צורה", "להזכיר", "ספרייה"] },
"3_2": { words: ["smell", "tradition", "amount", "predict", "both", "born", "village", "boat", "line", "except", "weight", "wake", "site", "even", "identify", "effect", "graph", "wonder", "treasure", "healthy", "choice", "independent", "service", "self", "title", "sugar", "climb", "role", "soft", "prefer", "crazy", "time", "silent", "wind", "collect", "recognize", "similar", "stick", "huge", "map", "oil", "along", "bottom", "couple", "based", "flat", "trust", "tool"], translations: ["להריח", "מסורת", "כמות", "לנבא", "גם וגם", "נולד", "כפר", "סירה", "קו", "מלבד", "משקל", "להתעורר", "אתר", "אפילו", "לזהות", "השפעה", "גרף", "לתהות", "אוצר", "בריא", "בחירה", "עצמאי", "שירות", "עצמי", "כותרת", "סוכר", "לטפס", "תפקיד", "רך", "להעדיף", "מטורף", "זמן", "שקט", "רוח", "לאסוף", "לזהות", "דומה", "מקל", "ענק", "מפה", "שמן", "לאורך", "תחתית", "זוג", "מבוסס", "שטוח", "לבטוח", "כלי"] },
"3_3": { words: ["prize", "may", "festival", "passenger", "repeat", "label", "earth", "energy", "total", "limited", "character", "mad", "cancel", "speed", "complete", "blood", "invent", "coat", "following", "accept", "advertisement", "apartment", "frequently", "should", "expert", "record", "detail", "hide", "translation", "difference", "east", "exactly", "culture", "celebration", "mention", "cover", "crowd", "sale", "equal", "report", "trouble", "appearance", "honest", "below", "minimum", "arrange", "noise", "trash", "odd", "let"], translations: ["פרס", "ייתכן", "פסטיבל", "נוסע", "לחזור שנית", "תווית", "אדמה", "אנרגיה", "סך הכל", "מוגבל", "אופי", "מטורף", "לבטל", "מהירות", "להשלים", "דם", "להמציא", "מעיל", "הבא", "לקבל", "פרסומת", "דירה", "לעיתים קרובות", "צריך", "מומחה", "שיא", "פרט", "להתחבא", "תרגום", "הבדל", "מזרח", "בדיוק", "תרבות", "חגיגה", "לציין", "לכסות", "קהל", "מכירה", "שווה", "לדווח", "צרה", "מראה חיצוני", "כנה", "מתחת", "מינימום", "לארגן", "רעש", "אשפה", "מוזר", "לאפשר"] },
"3_4": { words: ["advice", "reach", "season", "comfortable", "choose", "bother", "conversation", "lucky", "suit", "power", "fit", "state", "heavy", "argument", "accident", "statement", "vegetable", "forward", "experience", "art", "headache", "cook", "since", "encourage", "south", "dangerous", "risk", "travel", "blame", "opportunity", "wood", "forgive", "support", "meal", "clue", "weather", "empty", "purpose", "fill", "electric", "treat", "fix", "railway", "throw", "lose", "reason", "especially"], translations: ["לייעץ", "להגיע", "עונה", "נוח", "לבחור", "להטריד", "שיחה", "בר מזל", "חליפה", "כוח", "להתאים", "מדינה", "כבד", "טענה", "תאונה", "הצהרה", "ירק", "קדימה", "חוויה", "אומנות", "כאב ראש", "לבשל", "מאז", "לעודד", "דרום", "מסוכן", "סיכון", "לנסוע", "אשמה", "הזדמנות", "עץ", "לסלוח", "לתמוך", "ארוחה", "רמז", "מזג אוויר", "ריק", "מטרה", "למלא", "חשמלי", "לטפל", "לתקן", "מסילת רכבת", "לזרוק", "לאבד", "סיבה", "במיוחד"] },
"3_5": { words: ["ride", "circle", "examination", "general", "joke", "camera", "ahead", "switch", "original", "seat", "for example", "hardly", "ring", "serve", "furniture", "spend", "chapter", "railroad", "Jewish", "museum", "discussion", "credit", "manage", "shopping", "carry", "excellent", "request", "club", "digital", "apart", "knife", "false", "army", "team", "chance", "explanation", "respect", "marry", "print", "present", "continue", "afford", "deal", "check", "drop", "worth", "fear", "definition", "crime", "north"], translations: ["נסיעה", "מעגל", "בדיקה", "כללי", "בדיחה", "מצלמה", "מקדימה", "להחליף", "מקורי", "מושב", "לדוגמא", "בקושי", "טבעת", "לשרת", "רהיטים", "לבזבז", "פרק", "פסי רכבת", "יהודי", "מוזיאון", "דיון", "אשראי", "לנהל", "קניות", "לשאת", "מעולה", "בקשה", "מועדון", "דיגיטלי", "מלבד", "סכין", "שגוי", "צבא", "צוות", "הזדמנות", "הסבר", "כבוד", "להתחתן", "להדפיס", "מתנה", "להמשיך", "להרשות לעצמו", "עסקה", "לבדוק", "להפיל", "ערך", "לפחד", "הגדרה", "פשע", "צפון"] },
"3_6": { words: ["interview", "add", "partner", "altogether", "disappointed", "however", "absent", "score", "serious", "main", "park", "ability", "waste", "explain", "provide", "intelligent", "deliver", "fat", "century", "therefore", "responsibility", "dream", "belong", "dinner", "secret", "calendar", "horrible", "floor", "proper", "single", "blow", "notice", "disappear", "heat", "dig", "photo", "seem", "depends", "actually", "type", "local", "forever", "silly", "thought", "plenty", "control"], translations: ["ראיון", "להוסיף", "שותף", "לגמרי", "מאוכזב", "למרות זאת", "נעדר", "ציון", "רציני", "עיקרי", "פארק", "יכולת", "בזבוז", "להסביר", "לספק", "אינטליגנטי", "למסור", "שמן", "מאה", "לכן", "אחריות", "חלום", "להשתייך", "ארוחת ערב", "סוד", "לוח שנה", "מחריד", "קומה", "תקין", "יחיד", "לנשוף", "הודעה", "להיעלם", "חום", "לחפור", "תצלום", "נראה", "תלוי", "למעשה", "סוג", "מקומי", "לנצח", "מטופש", "מחשבה", "בשפע", "לשלוט"] },
"3_7": { words: ["dance", "although", "made of", "sweet", "due to", "feed", "visit", "coast", "air", "behave", "store", "opinion", "camp", "wife", "organize", "effort", "information", "maximum", "member", "river", "regular", "dramatic", "improve", "hospital", "increase", "famous", "discuss", "indeed", "space", "engine", "alive", "compare", "doubt", "responsible", "education", "consider", "million", "active", "argue", "deep", "stay", "usual", "birth", "extremely", "able", "link", "relax", "religion"], translations: ["לרקוד", "למרות ש", "עשוי מ", "מתוק", "מפני ש", "להאכיל", "לבקר", "חוף", "אוויר", "להתנהג", "לאגור", "דעה", "מחנה", "אשה", "לארגן", "מאמץ", "מידע", "מקסימום", "חבר", "נהר", "קבוע", "דרמטי", "לשפר", "בית חולים", "להגביר", "מפורסם", "לדון", "אכן", "חלל", "מנוע", "בחיים", "להשוות", "ספק", "אחראי", "חינוך", "לשקול", "מיליון", "פעיל", "לטעון", "עמוק", "להישאר", "רגיל", "לידה", "מאוד", "מסוגל", "קישור", "להירגע", "דת"] },
"3_8": { words: ["position", "alphabetical", "code", "strike", "broad", "raise", "term", "cake", "aware", "magazine", "operation", "save", "involved", "corner", "terrible", "specific", "price", "prove", "hit", "available", "step", "expect", "sort", "program", "in", "quite", "exciting", "warn", "else", "exact", "frightening", "public", "lady", "case", "low", "base", "depend", "schedule", "contact", "shirt", "guy", "might", "ground", "announcement", "become", "several", "introduce", "clever", "modern"], translations: ["עמדה", "אלפביתי", "קוד", "שביתה", "רחב", "העלאה", "טווח", "עוגה", "מודע", "מגזין", "מבצע", "להציל", "מעורב", "פינה", "נורא", "ספציפי", "מחיר", "להוכיח", "להכות", "זמין", "צעד", "לצפות", "לסווג", "תכנית", "ב", "די", "מרגש", "להזהיר", "אחר", "מדויק", "מפחיד", "פומבי", "גברת", "מקרה", "נמוך", "בסיס", "לסמוך", "לוח זמנים", "קשר", "חולצה", "בחור", "אולי", "קרקע", "הכרזה", "להפוך ל", "כמה", "להציג", "נבון", "מודרני"] },
"3_9": { words: ["absolutely", "perfect", "this", "standard", "nervous", "include", "correct", "strange", "garbage", "activity", "salt", "wave", "particular", "yet", "rather", "join", "assessment", "describe", "bird", "result", "load", "fight", "around", "history", "grammar", "search", "tidy", "race", "strangely", "station", "invitation", "death", "description", "stupid", "advise", "surprise", "win", "bridge", "act", "tune", "advantage", "account", "create", "alternative", "cupboard", "aim", "complain", "form", "topic"], translations: ["בהחלט", "מושלם", "זה", "סטנדרט", "עצבני", "לכלול", "נכון", "מוזר", "אשפה", "פעילות", "מלח", "גל", "מיוחד", "עדיין", "על פני", "להצטרף", "הערכה", "לתאר", "ציפור", "תוצאה", "להטעין", "מאבק", "סביב", "היסטוריה", "דקדוק", "לחפש", "מסודר", "גזע", "באופן מוזר", "תחנה", "הזמנה", "מוות", "תיאור", "מטופש", "לייעץ", "הפתעה", "לנצח", "גשר", "לפעול", "מנגינה", "יתרון", "חשבון", "ליצור", "חלופה", "ארון", "מטרה", "להתלונן", "טופס", "נושא"] },
"3_10": { words: ["content", "realize", "note", "delete", "science", "basis", "ill", "apply", "fortunately", "in addition", "religious", "singer", "worked", "photograph", "transport", "lead", "cloud", "must", "express", "hotel", "private", "card", "health", "height", "quarter", "field", "thick", "husband", "reply", "ugly", "danger", "fresh", "land", "none", "unit", "finally", "cause", "sell", "environment", "mail", "mark", "enormous", "common", "tend", "suggest", "behavior", "safe", "divide", "relation", "market"], translations: ["תוכן", "לקלוט", "הערה", "למחוק", "מדע", "בסיס", "חולה", "להגיש מועמדות", "למרבה המזל", "בנוסף", "דתי", "תצלום", "תחבורה", "להנהיג", "ענן", "חייב", "אקספרס", "מלון", "פרטי", "כרטיס", "בריאות", "גובה", "רובע", "שדה", "עבה", "בעל", "לענות", "מכוער", "סכנה", "טרי", "ארץ", "שום דבר", "יחידה", "לבסוף", "לגרום", "למכור", "סביבה", "דואר", "סימן", "עצום", "נפוץ", "נוטה ל", "להציע", "התנהגות", "בטוח", "לחלק", "יחס", "שוק העבודה"] },
"3_11": { words: ["teenager", "file", "west", "among", "object", "government", "party", "fun", "necessary", "instead", "admit", "hurt", "article", "condition", "stuff", "area", "asleep", "social", "clothes", "subject", "cash", "wide", "popular", "shoot", "words", "anywhere", "identity", "limit", "ticket", "silence", "charge", "loud", "celebrate", "city", "worry", "thin", "future", "suppose", "neat", "shop", "direction", "office", "communication", "cream", "smoke"], translations: ["מתבגר", "קובץ", "מערב", "בקרב", "אובייקט", "ממשלה", "מפלגה", "כיף", "נחוץ", "במקום", "להודות", "לכאוב", "מאמר", "מצב", "דברים", "איזור", "ישן", "חברתי", "בגדים", "נושא", "כסף מזומן", "רחב", "פופולרי", "לירות", "מילים", "בכל מקום", "זהות", "להגביל", "כרטיס", "שתיקה", "לחייב", "קולני", "לחגוג", "עיר", "דאגה", "רזה", "עתיד", "נניח ש", "מסודר", "חנות", "כיוון", "משרד", "תקשורת", "קרם", "עשן"] },
"3_12": { words: ["addition", "leader", "climate", "likely", "offer", "foreign", "connection", "mountain", "trick", "toward", "lock", "succeed", "within", "relate", "mainly", "beyond", "text", "through", "protect", "discover", "warm", "dead", "ever", "connect", "operate", "key", "worried", "landscape", "suggestion", "newspaper", "pass", "issue", "recently", "company", "during", "island", "branch", "sound", "nation", "train", "definitely", "fruit", "gas", "shoes", "match", "against", "apologize", "fail"], translations: ["חיבור", "מנהיג", "אקלים", "סביר", "להציע", "זר", "חיבור", "הר", "טריק", "לקראת", "לנעול", "להצליח", "בתוך", "להתייחס", "בעיקר", "מעבר", "טקסט", "דרך", "להגן", "לגלות", "חמים", "מת", "אי פעם", "לחבר", "להפעיל", "מפתח", "מודאג", "נוף", "הצעה", "עיתון", "לעבור", "נושא", "לאחרונה", "חברה", "במהלך", "אי", "ענף", "קול", "אומה", "רכבת", "בהחלט", "פרי", "גז", "נעליים", "להתאים", "נגד", "להתנצל", "להיכשל"] },

"4_1": { words: ["mobile", "stimulate", "offense", "ocean", "aggressive", "substance", "implication", "prison", "lawyer", "anxious", "consensus", "highly", "approval", "immoral", "severe", "attract", "flow", "response", "radical", "net", "correspond", "racial", "absence", "proportion", "anyway", "billion", "intellectual", "perspective", "bold", "volume", "obtain", "guidance", "directly", "motive", "natural", "major", "otherwise", "probability", "lean", "efficient", "efficiently", "duty", "guide", "consequence", "recommend­", "settle", "exist­", "survey", "client", "expertise"], translations: ["נייד", "לעורר", "עבירה", "אוקיינוס", "תוקפני", "חומר", "משמעות", "בית כלא", "עורך דין", "חרד", "קונסנזוס", "מאוד", "הסכמה", "לא מוסרי", "חמור", "למשוך", "לזרום", "תגובה", "קיצוני", "רשת", "להתכתב", "גזעני", "העדרות", "פרופורציה", "בכל מקרה", "מיליארד", "אינטלקטואלי", "נקודת מבט", "נועז", "כרך", "להשיג", "הדרכה", "באופן ישיר", "מניע", "טבעי", "גדול", "אחרת", "הסתברות", "רזה", "יעיל", "ביעילות", "חובה", "להדריך", "תוצאה", "ממליץ", "להשתקע", "להיות קיים", "סקר", "לקוח", "מומחיות"] },
"4_2": { words: ["mirror", "barrier", "summary", "press", "fuel", "contrast", "damage", "ancient", "initiative", "appreciate", "drug", "bind", "intervention", "urban", "tie", "journal", "furthermore", "thousand", "persuasion", "finance", "facility", "vote", "next-door", "deny", "promise", "daily", "rationale", "accurately", "analogy", "exclusively", "remove", "instrument", "establish", "consumer", "generation", "king", "agreement", "miss", "review", "double", "accompany", "combine­", "capture", "evident", "existing", "guard", "iceberg"], translations: ["מראה", "מחסום", "סיכום", "ללחוץ", "דלק", "ניגוד", "נזק", "עתיק", "יוזמה", "להעריך", "סם", "לקשור", "התערבות", "עירוני", "קשר", "כתב עת", "בנוסף", "אלף", "שיכנוע", "כספים", "מתקן", "הצבעה", "דלת ליד", "להכחיש", "להבטיח", "יומיומי", "רציונל", "במדויק", "אנלוגיה", "באופן בלעדי", "להסיר", "כלי", "להקים", "צרכן", "דור", "מלך", "הסכם", "להתגעגע", "סקירה", "כפול", "ללוות", "לשלב", "לתפוס", "ברור", "קיים", "שומר", "קרחון"] },
"4_3": { words: ["illegal", "ritual", "ship", "moreover", "depressing", "law", "clarification", "assignment", "inherent", "obvious", "signal", "voluntary", "model", "mutual", "fee", "proposal", "troops", "relief", "considerable", "mankind", "origin", "senior", "planning", "differentiation", "reject", "effective", "coordinate", "coordination", "kitchen", "afterwards", "adopt", "adoption", "extension", "distant", "biological", "reveal", "quantity", "offended", "speech", "economic", "lack", "option", "criticize", "aspire", "aspiration", "traditional", "everywhere"], translations: ["בלתי חוקי", "טקס", "ספינה", "יתר על כן", "מדכא", "חוק", "הבהרה", "משימה", "טבוע", "ברור", "אות", "התנדבותי", "דגם", "הדדי", "תשלום", "הצעה", "חיילים", "הקלה", "משמעותי", "האנושות", "מקור", "בכיר", "תכנון", "בידול", "לדחות", "יעיל", "לתאם", "תיאום", "מטבח", "לאחר מכן", "לאמץ", "אימוץ", "המשך", "מרוחק", "ביולוגי", "לגלות", "כמות", "פגוע", "נאום", "כלכלי", "מחסור", "אופציה", "למתוח ביקורת", "לשאוף", "שאיפה", "מסורתי", "בכל מקום"] },
"4_4": { words: ["hopefully", "intelligence", "college", "mile", "southern", "concentrate", "farmer", "location", "virtual", "varied", "granted", "sunrise", "cellphone", "debate", "jump", "partial", "population", "variety", "soul", "earn", "dispose", "spot", "trend", "threaten", "image", "profit", "fender", "poverty", "full-time", "incident", "creation", "stone", "chief", "human", "iron", "basically", "conference", "trial", "attraction", "mere", "increasingly", "discipline", "occupied", "nonsense", "folk", "large-scale", "expectation", "capability", "balance"], translations: ["בתקווה", "אינטליגנציה", "מכללה", "מייל", "דרומי", "להתרכז", "חקלאי", "מיקום", "וירטואלי", "מגוון", "ניתן", "זריחה", "טלפון נייד", "עימות", "לקפוץ", "חלקי", "אוכלוסיה", "מגוון", "נפש", "להרוויח", "להיפטר", "לזהות", "מגמה", "לאיים", "תמונה", "רווח", "פגוש", "עוני", "משרה מלאה", "תקרית", "יצירה", "אבן", "מנהיג", "אנושי", "ברזל", "בעיקרון", "ועידה", "ניסוי", "משיכה", "רק", "יותר ויותר", "משמעת", "כבוש", "שטויות", "עם", "בקנה מידה גדול", "ציפיה", "מסוגלות", "איזון"] },
"4_5": { words: ["recruitment", "threat", "juice", "on", "behalf", "minority", "frequency", "certainly", "crucial", "investigation", "decline", "judgment", "engagement", "regulation", "audience", "depressed", "spiritual", "equally", "software", "violence", "exhibition", "calculation", "skill", "assist", "percent", "agriculture", "refer", "enquire", "production", "originally", "task", "ethnic", "modification", "hence", "beneficial", "neighbour", "adequate", "adequately", "truth", "security", "precisely", "illness", "spread", "naturally", "tone", "gate", "consideration", "contemporary", "accordingly"], translations: ["גיוס", "איום", "מיץ", "על", "בשם", "מיעוט", "תדירות", "בהחלט", "מכריע", "חקירה", "ירידה", "משפט", "אירוסין", "תקנה", "קהל", "מדוכא", "רוחני", "באופן שווה", "תוכנה", "אלימות", "תערוכה", "חישוב", "מיומנות", "לסייע", "אחוז", "חקלאות", "להתייחס", "לברר", "הפקה", "במקור", "משימה", "אתני", "שינוי", "לכן", "מועיל", "שכן", "ראוי", "באופן ראוי", "אמת", "בטחון", "בדיוק", "מחלה", "להתפשט", "באופן טבעי", "טון", "שער", "שיקול", "עכשווי", "בהתאם"] },
"4_6": { words: ["possess", "user", "agent", "illustration", "feature", "vary", "upper", "inaccurate", "surgery", "participate", "differentiate", "entire", "permit", "fashion", "prevention", "row", "somewhat", "capacity", "commitment", "dominant", "instantly", "profile", "exploitation", "political", "obligation", "occupation", "revised", "rights", "elect", "fashioned", "sequence", "offend", "subsequent", "announce", "target", "rarily", "inquire", "stretch", "amazing", "era", "weak", "context", "heaven", "satisfy", "anxiety", "subsequently", "develop"], translations: ["להחזיק בבעלות", "משתמש", "סוכן", "איור", "תכונה", "להשתנות", "עליון", "לא מדויק", "ניתוח", "להשתתף", "להבדיל", "כל", "להתיר", "אופנה", "מניעה", "שורה", "במידה מסוימת", "קיבולת", "מחויבות", "דומיננטי", "באופן מיידי", "פרופיל", "ניצול", "פוליטי", "חובה", "מקצוע", "מעודכן", "זכויות", "לבחור", "מעוצב", "סדר פעולות", "לפגוע", "הבא", "להודיע", "מטרה", "לעיתים רחוקות", "לברר", "למתוח", "מדהים", "תקופה", "חלש", "הקשר", "גן עדן", "לספק", "חרדה", "כתוצאה מכך", "לפתח"] },
"4_7": { words: ["fundamental", "fan", "language", "version", "respond", "sensitivity", "vision", "resolution", "idealism", "transmit", "measure", "mission", "pride", "primary", "fond of", "physics", "acceptance", "democracy", "impression", "gun", "servant", "stairs", "university", "complex", "enterprise", "advocate", "approve", "means", "shorten", "ministry", "accuracy", "chain", "rational", "decision", "elected", "nerves", "inform", "domination", "internal", "tough", "mass", "implementation", "annual", "contribution", "instant", "historical", "theme", "gender"], translations: ["בסיסי", "אוהד", "שפה", "גרסה", "להגיב", "רגישות", "חזון", "פתרון", "אידיאליזם", "להעביר", "מידה", "משימה", "גאווה", "יסודי", "מחבב", "פיזיקה", "קבלה", "דמוקרטיה", "רושם", "אקדח", "משרת", "מדרגות", "אוניברסיטה", "מורכב", "מפעל", "עורך דין", "לאשר", "אמצעים", "לקצר", "משרד", "דיוק", "שרשרת", "רציונלי", "החלטה", "נבחר", "עצבים", "ליידע", "שליטה", "פנימי", "קשוח", "מסה", "יישום", "שנתי", "תרומה", "מיידי", "היסטורי", "נושא", "מין"] },
"4_8": { words: ["refuse", "allow", "outline", "association", "exclude", "background", "manners", "aspect", "consume", "tears", "adaptation", "madam", "ignore", "scheme", "receipt", "edge", "various", "reflect", "guidelines", "network", "weekend", "hero", "unique", "youth", "amongst", "contrary", "competition", "shake", "successful", "hierarchy", "somewhere", "interact", "familiar", "neutral", "research", "industry", "symbol", "comment", "commander", "strategic", "leadership", "list", "aid", "recover", "offence", "minimize", "commerce", "establishment", "crisis"], translations: ["לסרב", "להרשות", "מתווה", "ארגון", "להוציא", "רקע", "נימוסים", "היבט", "לצרוך", "דמעות", "הסתגלות", "גברת", "להתעלם", "תכנית", "קבלה", "קצה", "מגוון", "לשקף", "הנחיות", "רשת", "סוף שבוע", "גיבור", "ייחודי", "נוער", "בקרב", "בניגוד ל", "תחרות", "לנער", "מוצלח", "היררכיה", "איפשהו", "לתקשר", "מוכר", "נייטרלי", "מחקר", "תעשייה", "סמל", "להגיב", "מפקד", "אסטרטגי", "מנהיגות", "רשימה", "סיוע", "להחלים", "עבירה", "לצמצם", "מסחר", "מוסד", "משבר"] },
"4_9": { words: ["quickly", "grounds", "resolve", "consistent", "integrate", "concerned", "constant", "universe", "universal", "career", "maintenance", "factory", "regardless", "demand", "broke", "inevitable", "journey", "aggression", "citizenship", "restriction", "convert", "investigate­", "spelling", "convention", "stranger", "roll", "region", "beneath", "derive", "skilled", "curriculum", "paid", "setting", "justify", "require", "required", "labor", "exhibit", "difficulty", "rapidly", "certificates", "unlikely", "unite", "concern", "practically"], translations: ["במהירות", "שטח", "לפתור", "עקבי", "לשלב", "מודאג", "קבוע", "יקום", "אוניברסלי", "קריירה", "תחזוקה", "בית חרושת", "בלי קשר", "ביקוש", "תפרן", "בלתי נמנע", "מסע", "תוקפנות", "אזרחות", "הגבלה", "להמיר", "לחקור", "איות", "מוסכמה", "זר", "גליל", "איזור", "מתחת", "להפיק", "מיומן", "תכנית לימודים", "שולם", "הגדרה", "להצדיק", "לדרוש", "נדרש", "עבודה", "להציג", "קושי", "מהר", "תעודות", "לא סביר", "להתאחד", "דאגה", "למעשה"] },
"4_10": { words: ["external", "sense", "expression", "abstract", "insurance", "funded", "territory", "relatively", "media", "slight", "factor", "democratic", "storm", "unable", "restaurant", "declined", "minor", "western", "positive", "formal", "impose", "resist", "personally", "attitude", "formally", "fully", "expense", "defense", "recovery", "entirely", "tendency", "evolution", "resource", "regime", "agricultural", "constantly", "evidently", "event", "breathe", "emphasis", "track", "instruction", "debt", "negotiation", "conclusion", "individually"], translations: ["חיצוני", "חוש", "ביטוי", "תקציר", "ביטוח", "ממומן", "טריטוריה", "יחסית", "תקשורת", "קלוש", "גורם", "דמוקרטי", "סערה", "לא מסוגל", "מסעדה", "קטין", "מערבי", "חיובי", "רשמי", "לאכוף", "להתנגד", "באופן אישי", "גישה", "באופן רשמי", "לחלוטין", "הוצאה", "הגנה", "התאוששות", "לגמרי", "נטייה", "אבולוציה", "משאב", "משטר", "חקלאי", "בקביעות", "ברור", "מקרה", "לנשום", "דגש", "מסלול", "הנחייה", "חוב", "משא ומתן", "סיכום", "בנפרד"] },
"4_11": { words: ["firm", "painting", "ongoing", "judge", "requirement", "table", "alter", "truly", "priority", "organization", "avoid", "personal", "practical", "mutually", "emphasize", "details", "plant", "generally", "application", "formality", "majority", "period", "proceed", "highlight", "maintain", "municipal", "hypothesis", "engaged", "not anymore", "authority", "revise", "military", "ensure", "incentive", "employee", "debts", "exclusion", "dissatisfied", "confirm", "discriminate", "conduct", "value", "elsewhere", "battery", "owner", "boundary"], translations: ["פירמה", "ציור", "מתמשך", "לשפוט", "דרישה", "שולחן", "לשנות", "באמת", "עדיפות", "ארגון", "להימנע", "אישי", "מעשי", "הדדי", "להדגיש", "פרטים", "צמח", "בדרך כלל", "יישום", "רשמיות", "רוב", "תקופה", "להמשיך", "דגש", "לתחזק", "עירוני", "השערה", "מאורס", "כבר לא", "רשות", "לשנות", "צבא", "לאשר", "תמריץ", "עובד", "חובות", "הוצאה מן הכלל", "לא מרוצה", "לאשר", "להפלות", "לערוך", "ערך", "במקום אחר", "סוללה", "בעלים", "גבול"] },
"4_12": { words: ["eliminate", "notion", "insist", "belief", "leaf", "cooperate", "domestic", "stable", "virtue", "supplies", "mentally", "tip", "principle", "comparative", "react", "temperature", "technological", "breath", "extended", "clarify", "completely", "myth", "entry", "current", "currently", "mode", "flexibility", "flight", "competitive", "pour", "caught", "president", "immigration", "confidence", "resident", "steel", "prepare", "officially", "transform", "totally", "novel", "regional", "weakness", "historical", "diminish", "revision", "safety", "extend", "positively"], translations: ["לחסל", "רעיון", "להתעקש", "אמונה", "עלה", "לשתף פעולה", "ביתי", "יציב", "מעלה", "אספקה", "מבחינה נפשית", "עצה", "עקרון", "יחסי", "להגיב", "טמפרטורה", "טכנולוגי", "נשימה", "מורחב", "להבהיר", "לחלוטין", "מיתוס", "כניסה", "נוכחי", "כיום", "מצב", "גמישות", "טיסה", "תחרותי", "לשפוך", "נתפס", "נשיא", "הגירה", "אמון", "תושב", "פלדה", "להכין", "רשמית", "לשנות", "לחלוטין", "רומן", "איזורי", "חולשה", "להפחית", "חידוש", "בטיחות", "להאריך", "באופן חיובי"] },
"4_13": { words: ["reside", "sensitive", "refugee", "pattern", "variation", "ideal", "racism", "regard", "immigrant", "suitable", "brilliant", "disturb", "civilization", "contradict", "theory", "morality", "product", "element", "volunteer", "cell", "appreciation", "principal", "merely", "related", "continuously", "achieve", "enable", "group", "rural", "seek", "economy", "normally", "destroy", "recall", "nearly", "campaign", "opening", "eventually", "achievement", "dozen", "colleague", "shadow", "commit", "traditionally", "profitable", "statistics", "experiment"], translations: ["להתגורר", "רגיש", "פליט", "תבנית", "וריאציה", "אידאלי", "לעקוב", "גזענות", "להתייחס", "מהגר", "מתאים", "מבריק", "להפריע", "תרבות", "לסתור", "תאוריה", "מוסריות", "מוצר", "אלמנט", "להתנדב", "תא", "הערכה", "עיקרון", "רק", "קשור ל", "ברציפות", "להשיג", "לאפשר", "קבוצה", "כפרי", "לחפש", "כלכלה", "בדרך כלל", "להרוס", "להיזכר", "כמעט", "קמפיין", "פתיחה", "לבסוף", "הישג", "תריסר", "עמית", "צל", "לבצע", "באופן מסורתי", "משתלם", "סטטיסטיקה", "להתנסות"] },
"4_14": { words: ["declaration", "disturbance", "benefit", "rush", "interpret", "briefly", "handle", "retain", "enquiry", "union", "department", "indicate", "access", "capable", "explicitly", "voice", "probably", "rise", "opposite", "awful", "star", "solve", "bright", "proud", "normal", "hate", "tour", "basic", "force", "ordinary", "adult", "business", "according", "date", "something", "speak", "also", "really", "there", "rule", "exploit"], translations: ["הצהרה", "הפרעה", "תועלת", "למהר", "לפרש", "בקצרה", "לטפל", "לשמור", "חקירה", "איחוד", "מחלקה", "להצביע", "גישה", "מסוגל", "במפורש", "קול", "כנראה", "להתרומם", "כנגד", "נורא", "כוכב", "לפתור", "בהיר", "גאה", "נורמלי", "שנאה", "סיור", "בסיסי", "כוח", "רגיל", "מבוגר", "עסק", "לפי", "תאריך", "משהו", "לדבר", "גם", "באמת", "שם", "כלל", "לנצל"] },
"4_15": { words: ["anybody", "demonstration", "satisfaction", "outcome", "relevant", "separate", "additional", "integrity", "faith", "emergence", "employer", "expenses", "movement", "die", "numerous", "settlement", "violent", "essentially", "council", "hire", "district", "exposed", "design", "magnetic", "management", "response", "visible", "moral", "massive", "adjustment", "academic", "informal", "horizontal", "easily", "approximately", "Christmas", "politician", "comprehension", "observe", "thereby", "contain", "finished", "properly", "institution", "global", "theatre", "system", "preparation", "vital"], translations: ["כל אחד", "הדגמה", "שביעות רצון", "תוצאה", "רלוונטי", "נפרד", "נוסף", "יושרה", "אמונה", "התהוות", "מעסיק", "הוצאות", "תנועה", "למות", "רבים", "הסדר", "אלים", "בעיקרון", "מועצה", "לשכור", "מחוז", "חשוף", "עיצוב", "מגנטי", "הנהלה", "תגובה", "גלוי", "מוסר השכל", "מסיבי", "התאמה", "אקדמי", "לא רשמי", "אופקי", "בקלות", "פחות או יותר", "חג המולד", "פוליטיקאי", "הבנה", "לצפות", "על ידי כך", "להכיל", "גמור", "כראוי", "מוסד", "גלובלי", "תיאטרון", "מערכת", "הכנה", "חיוני"] },
"4_16": { words: ["loss", "release", "sum", "propose", "rate", "efficiency", "perception", "protection", "reality", "rhythm­", "sector", "logic", "bill", "immigrate", "frequent", "pain", "established", "committed", "emotional", "bone", "accurate", "respectively", "plane", "pool", "elimination", "occasion", "bank", "educate", "necessity", "tourist", "interpretation­", "identification", "planet", "oblige", "psychology", "typical", "typically", "winner", "prep", "attached", "part-time", "analysis", "output", "progressive", "relevance", "hopeful", "supposed"], translations: ["הפסד", "לשחרר", "סכום", "להציע", "עלות", "יעילות", "תפיסה", "הגנה", "מציאות", "קצב", "מגזר", "הגיון", "שטר", "להגר", "תכוף", "כאב", "מבוסס", "מחויב", "רגשי", "עצם", "מדויק", "בהתאמה", "מטוס", "בריכה", "חיסול", "הזדמנות", "בנק", "לחנך", "כורח", "תייר", "פרשנות", "זיהוי", "כוכב לכת", "לחייב", "פסיכולוגיה", "טיפוסי", "בדרך כלל", "זוכה", "הכנה", "מצורף", "משרה חלקית", "ניתוח", "תפוקה", "פרוגרסיבי", "רלוונטיות", "מלא תקווה", "אמור"] },
"4_17": { words: ["via", "witness", "initially", "prose", "promotion", "flu", "cage", "length", "church", "evidence", "evolve", "importance", "authentic", "estimation", "interaction", "metal", "channel", "battle", "goal", "worker", "specialize", "locate", "sole", "solely", "criticism", "rock", "welfare", "apparently", "bond", "integration", "advanced", "claim", "construction", "relations", "scenery", "headlines", "income", "employ", "literature", "figure", "stare", "such as", "prior", "globally", "mostly", "workshop", "exclusive"], translations: ["באמצעות", "עד", "בהתחלה", "סיפורת", "קידום", "שפעת", "כלוב", "אורך", "כנסיה", "ראיה", "להתפתח", "חשיבות", "אותנטי", "אומדן", "יחסי גומלין", "מתכת", "ערוץ", "קרב", "מטרה", "עובד", "להתמחות", "לאתר", "בלעדי", "באופן בלעדי", "ביקורת", "סלע", "רווחה", "ככל הנראה", "קשר", "שילוב", "מתקדם", "לטעון", "בניה", "יחסים", "נוף", "כותרות", "הכנסה", "להעסיק", "ספרות", "דמות", "לבהות", "כגון", "קודם", "ברחבי העולם", "בעיקר", "סדנה", "בלעדי"] },
"4_18": { words: ["distinction", "identical", "supply", "beginning", "strategy", "caring", "essay", "legal", "impressive", "procedure", "despite", "functional", "drawing", "entitled", "engage", "explore", "delegation", "resolved", "latter", "ignorant", "indirect", "distribute", "distribution", "consequences", "weapon", "generate", "objection", "quality", "visitor", "container", "attention", "share", "impact", "select", "acquire", "acquisition", "executive", "mechanism", "consult", "appropriate", "nurse", "candidate", "acknowledge", "exams", "bias", "division", "vertical", "economically", "legally", "export", "unfortunately"], translations: ["הבחנה", "זהה", "לספק", "התחלה", "אסטרטגיה", "אכפתי", "חיבור", "משפטי", "מרשים", "תהליך", "למרות", "פונקציונלי", "ציור", "רשאי", "לחתור למגע", "לחקור", "משלחת", "פתור", "אחרון", "חסר ידע", "עקיף", "להפיץ", "הפצה", "השלכות", "נשק", "לייצר", "התנגדות", "איכות", "אורח", "כלי קיבול", "תשומת לב", "לחלוק", "פגיעה", "לבחור", "לרכוש", "רכישה", "מנהל", "מנגנון", "להתייעץ", "ראוי", "אחות", "מועמד", "להכיר ב", "בחינות", "דעה קדומה", "חלוקה", "אנכי", "מבחינה כלכלית", "מבחינה חוקית", "ייצוא", "למרבה הצער"] },
"4_19": { words: ["marriage", "sustain", "suspect", "possession", "separation", "highlighted", "inevitably", "profes­sion", "criterion", "investment", "level", "emerge", "surround­", "handful", "progress", "award", "facts", "arrangements", "degrees", "presence", "degree", "dialogue", "rating", "invention", "budget", "discovery", "produce", "desire", "gentleman", "infrastructure", "teaching", "inactive", "actor", "series", "civilian", "goods", "exceed", "range", "permission", "concentrated", "pretty", "geography­", "gentle", "policy", "convey", "community", "engineering", "scenario"], translations: ["נישואים", "לקיים", "חשוד", "החזקה", "הפרדה", "מודגש", "באופן בלתי נמנע", "מקצוע", "קריטריון", "השקעה", "רמה", "להופיע", "להקיף", "קומץ", "התקדמות", "פרס", "עובדות", "סידורים", "מעלות", "נוכחות", "תואר", "דיאלוג", "דירוג", "המצאה", "תקציב", "תגלית", "לייצר", "חשק", "ג'נטלמן", "תשתית", "הוראה", "לא פעיל", "שחקן", "סדרה", "אזרחי", "סחורות", "להתעלות מעל", "טווח", "רשות", "מרוכז", "יפה", "גיאוגרפיה", "עדין", "מדיניות", "להעביר", "קהילה", "הנדסה", "תרחיש"] },
"4_20": { words: ["unemployed", "lexical", "customer", "negative", "entrance", "pursue", "roof", "faithfully", "specify", "sample", "ball", "agency", "involvement", "draft", "medical", "temporary", "explicit", "pocket", "sir", "favor", "video", "brief", "sight", "distin­guished", "medicine", "carefully", "wild", "potential", "peace", "formulate", "confident", "centrally", "irresponsible", "hall", "trek", "interactive", "united", "burn", "tiny", "perceive", "root", "independence", "associate", "gain", "influence", "electronic", "necessarily", "withdraw", "essential", "cancer"], translations: ["מובטל", "לקסיקלי", "צרכן", "שלילי", "כניסה", "לרדוף", "גג", "בנאמנות", "לפרט", "דוגמא", "כדור", "סוכנות", "מעורבות", "טיוטה", "רפואי", "זמני", "מפורש", "כיס", "אדוני", "טובה", "וידאו", "קצר", "מראה", "מובהק", "תרופה", "בזהירות", "פראי", "פוטנציאל", "שלום", "לגבש", "בטוח", "באופן מרכזי", "לא אחראי", "אולם", "מסלול", "אינטראקטיבי", "מאוחד", "לשרוף", "זעיר", "לתפוס", "שורש", "עצמאות", "לקשר", "להשיג", "להשפיע", "אלקטרוני", "בהכרח", "לסגת", "חיוני", "סרטן"] },
"4_21": { words: ["coopera­tion", "scientific", "govern", "stress", "constitution", "marketing", "profession", "literary", "screen", "resistance", "reliable", "motivation", "charged", "reference", "salary", "conclude", "rely", "laughter", "presentation", "stressful", "desert", "absolute", "ratio", "airport", "expand", "prediction", "failure", "framework", "post", "declare", "disease", "immediate", "long-term", "facilitate", "construct", "category", "criminal", "direct", "studio", "detailed", "document", "negotiate", "manner", "suffering", "denial", "disagreement", "detect", "reform", "exit"], translations: ["שיתוף פעולה", "מדעי", "למשול", "לחץ", "חוקה", "שיווק", "מקצוע", "ספרותי", "מסך", "התנגדות", "אמין", "מוטיבציה", "טעון", "התייחסות", "שכר", "להסיק", "לסמוך", "צחוק", "הצגה", "מלחיץ", "מדבר", "מוחלט", "יחס", "שדה תעופה", "להרחיב", "חיזוי", "כשלון", "מסגרת", "דואר", "להכריז", "מחלה", "מיידי", "ארוך-טווח", "לקיים", "לבנות", "קטגוריה", "פלילי", "ישיר", "סטודיו", "מפורט", "מסמך", "לקיים משא ומתן", "אופן", "סבל", "הכחשה", "חוסר הסכמה", "לאתר", "רפורמה", "יציאה"] },
"4_22": { words: ["membership", "optional", "intend", "multiply", "imply", "conventional", "attractive", "stand", "prevent", "directions", "possibly", "evaluate", "representative", "reaction", "faithful", "previously", "strengthen", "elementary", "fairly", "norm", "needed", "landscape", "block", "partly", "perform", "invested", "package", "slightly", "injured", "minimal", "innovation", "obliged", "self-confidence", "detective", "auditions", "criteria", "improvement", "alteration", "equality", "short-term", "barely", "represent", "excessive", "comprehend", "tear", "dynamite", "sentence", "hearing", "revolutionary"], translations: ["חברות", "אפשרי", "להתכוון", "להכפיל", "לרמוז", "מקובל", "מושך", "לעמוד", "למנוע", "הוראות", "יתכן", "להעריך", "נציג", "תגובה", "נאמן", "לפני כן", "לחזק", "יסודי", "למדי", "נורמה", "נחוץ", "נוף", "לחסום", "באופן חלקי", "לבצע", "מושקע", "חבילה", "מעט", "פצוע", "מינימלי", "חדשנות", "מחויב", "ביטחון עצמי", "בלש", "אודישנים", "קריטריונים", "שיפור", "שינוי", "שוויון", "טווח קצר", "בקושי", "לייצג", "מופרז", "להבין", "דמעה", "דינמיט", "משפט", "שמיעה", "מהפכני"] },
"4_23": { words: ["nevertheless", "escape", "writer", "scene", "circumstances", "problematic", "equivalent", "housewife", "intense", "humanity", "minister", "considerably", "secure", "function", "attempt", "beauty", "oriental", "expansion", "nuclear", "relief", "modify", "stereotype", "promote", "focus", "impress", "committee", "eastern", "personality", "reduce", "comparison", "regarding", "demonstrate", "points", "Judaism", "etc.", "steal", "consist", "interest", "rapid", "creative", "estimate", "male", "additionally", "clearly", "feminine", "monitor", "attend", "industrial"], translations: ["בכל מקרה", "לברוח", "סופר", "סצינה", "נסיבות", "בעייתי", "שווה ערך", "עקרת בית", "אינטנסיבי", "אנושות", "שר ממשלה", "במידה ניכרת", "בטוח", "פונקציה", "לנסות", "יופי", "מזרחי", "התרחבות", "גרעיני", "הקלה", "לשנות", "סטראוטיפ", "לקדם", "פוקוס", "להרשים", "ועדה", "מזרחי", "אישיות", "להפחית", "השוואה", "לגבי", "להפגין", "נקודות", "יהדות", "וכו'", "לגנוב", "להכיל", "עניין", "מהיר", "יצירתי", "להעריך", "זכר", "בנוסף", "בבירור", "נשי", "לפקח על", "להיות נוכח", "תעשייתי"] },
"4_24": { words: ["dimension", "hell", "initial", "prone to", "mental", "technical", "victory", "protest", "cube", "manager", "kingdom", "implicit", "expected", "peacefully", "growth", "random", "error", "representation", "diverse", "diversity", "decade", "incidentally", "selection", "publication", "characteristic", "environmental", "administration", "soldier", "farm", "submit", "transfer", "greatly", "passive", "performance", "overnight", "largely", "lovely", "cope", "flexible", "expose", "oppose", "multiple", "female", "determination", "paint", "guest"], translations: ["מימד", "גיהנום", "ראשוני", "נוטה ל", "נפשי", "טכני", "ניצחון", "למחות", "קוביה", "מנהל", "ממלכה", "משתמע", "צפוי", "בשלווה", "צמיחה", "אקראי", "שגיאה", "ייצוג", "מגוון גיוון", "עשור", "במקרה", "בחירה", "פירסום", "מאפיין", "סביבתי", "הנהלה", "חייל", "חווה", "להגיש", "להעביר", "במידה רבה", "פסיבי", "ביצוע", "בין לילה", "בעיקר", "חביב", "להתמודד", "גמיש", "לחשוף", "להתנגד", "מרובות", "נקבה", "נחישות", "לצבוע", "אורח"] },
"4_25": { words: ["civilized", "snow", "resources", "ethical", "valuable", "particularly", "illustrate", "wicked", "manufacture", "humanities", "invest", "significance", "subjective", "prisoner", "vehicle", "section", "participation", "cite", "route", "approach", "master", "depression", "data", "significant", "assistance", "successfully", "device", "ban", "detection", "recruit", "so-called", "joint", "statistical", "autonomy", "passage", "civil", "reading", "respect", "indication", "confirmation", "freedom", "citizen", "diagram"], translations: ["תרבותי", "שלג", "משאבים", "מוסרי", "בעל ערך", "באופן מיוחד", "להמחיש", "מרושע", "ייצור", "מדעי הרוח", "להשקיע", "משמעות", "סובייקטיבי", "אסיר", "כלי רכב", "סעיף", "השתתפות", "לצטט", "מסלול", "גישה", "לשלוט", "דיכאון", "נתונים", "משמעותי", "סיוע", "באופן מוצלח", "מכשיר", "לאסור", "איתור", "לגייס", "כמו שנקרא", "משותף", "סטטיסטי", "אוטונומיה", "מעבר", "אזרחי", "קריאה", "כבוד", "סימן", "אישור", "חופש", "אזרח", "תרשים"] },
"4_26": { words: ["building", "specifically", "display", "reasons", "define", "host", "ice", "autonomous", "affair", "frame", "globalization", "phase", "classify", "formula", "willing", "attack", "journalism", "commercial", "concept", "gym", "official", "severely", "twice", "compete", "peaceful", "inadequate", "width", "tired", "survival", "advanced", "insure", "input", "make-up", "encounter", "reception", "physical", "provision", "opposition", "engineer", "well-being", "dynamics", "solution", "source", "rejection", "structure", "motor", "implement", "inherently"], translations: ["בנין", "באופן ספציפי", "להציג", "סיבות", "להגדיר", "מארח", "קרח", "אוטונומי", "פרשה", "מסגרת", "גלובליזציה", "שלב", "לסווג", "נוסחה", "מוכן", "לתקוף", "עיתונאות", "מסחרי", "מושג", "חדר כושר", "רשמי", "בחומרה", "פעמיים", "להתחרות", "שקט", "לא ראוי", "רוחב", "עייף", "הישרדות", "להבטיח", "קלט", "להשלים", "מפגש", "קבלה", "גופני", "אספקה", "התנגדות", "מהנדס", "רווחה", "דינמיקה", "פתרון", "מקור", "דחיה", "מבנה", "מנוע", "לשלב", "ביסודו"] },
"4_27": { words: ["recognition", "strength", "author", "devise", "significantly", "satisfied", "election", "jouralism", "critical", "survive", "efforts", "calculate", "departure", "secondly", "restrict", "agreed", "optionally", "unexpectedly", "collection", "obviously", "equip", "justice", "plastic", "chemistry", "editorial", "evaluation", "fraction", "e.g.", "success", "somehow", "findings", "nonetheless", "residence", "injury", "consistency", "dual", "affect", "zone", "chemical", "witch", "intensive", "occasionally", "grant", "biology", "invisible", "comprehensive", "youngsters", "comprised"], translations: ["הכרה", "כוח", "מחבר", "להמציא", "באופן משמעותי", "מרוצה", "בחירות", "עיתונאות", "קריטי", "לשרוד", "מאמצים", "לחשב", "עזיבה", "שנית", "להגביל", "מוסכם", "אפשרי", "באופן בלתי צפוי", "אוסף", "ברור", "לצייד", "צדק", "פלסטיק", "כימיה", "עריכה", "הערכה", "שבריר", "למשל", "הצלחה", "איכשהו", "ממצאים", "בכל זאת", "מגורים", "פציעה", "עקביות", "כפול", "להשפיע", "איזור", "כימי", "מכשפה", "אינטנסיבי", "לפעמים", "מענק", "ביולוגיה", "בלתי נראה", "מקיף", "צעירים", "מורכב"] },
"4_28": { words: ["murder", "boss", "phenomenon", "permanently", "percentage", "import", "equipment", "insight", "overall", "cabinet", "contribute", "meantime", "possibility", "occupy", "considered", "intention", "approve", "assume", "assumption", "grading", "inquiry", "adjust", "comprise", "offender", "objective", "suffer", "imagination", "exploration", "distance", "revolution", "classical", "hardware", "acceptable", "employment", "average", "sanctions", "former", "dominate", "status", "hole", "edit", "component", "summarize", "widely", "affordable", "property", "compose", "composi­tion", "exchange"], translations: ["רצח", "בוס", "תופעה", "באופן קבוע", "אחוזים", "יבוא", "ציוד", "תובנה", "באופן כללי", "קבינט", "לתרום", "בינתיים", "אפשרות", "לכבוש", "נחשב", "כוונה", "לאשר", "להניח", "הנחה", "דירוג", "חקירה", "להתאים", "להוות", "עבריין", "מטרה", "לסבול", "דמיון", "חקירה", "מרחק", "מהפיכה", "קלאסי", "חומרה", "מקובל", "תעסוקה", "ממוצע", "סנקציות", "לשעבר", "לשלוט", "סטטוס", "חור", "לערוך", "רכיב", "לסכם", "באופן נרחב", "במחיר סביר", "רכוש", "לחבר", "חיבור", "להחליף"] },
"4_29": { words: ["decrease", "favorable", "stock", "method", "valid", "depart", "feeling", "psychological", "relative", "yard", "sociology", "forum", "sufficient", "concentration", "politics", "challenge", "domain", "fund", "publish", "painful", "surface", "reinforce", "understood", "format", "sufficiently", "luckily", "spatial", "seriously", "conflict", "ideally", "motivate", "payment", "emotion", "kill", "continuous", "masculine", "staff", "hill", "whereas", "distinguish", "defend", "development", "remark", "abuse", "persuade", "analyze", "observation", "disappointment", "educational", "reduction"], translations: ["להוריד", "מועדף", "מניה", "שיטה", "בתוקף", "לעזוב", "הרגשה", "פסיכולוגי", "קרוב משפחה", "חצר", "סוציולוגיה", "פורום", "מספיק", "ריכוז", "פוליטיקה", "אתגר", "תחום", "קרן", "לפרסם", "כואב", "משטח", "לחזק", "מובן", "פורמט", "באופן מספק", "למרבה המזל", "מרחבי", "ברצינות", "קונפליקט", "באופן אידיאלי", "לעודד", "תשלום", "רגש", "להרוג", "רציף", "גברי", "צוות", "גבעה", "בעוד ש", "להבחין", "להגן", "התפתחות", "הערה", "התעללות", "לשכנע", "לנתח", "אבחנה", "אכזבה", "חינוכי", "צמצום"] },
"4_30": { words: ["central", "refusal", "financial", "cycle", "inferior", "strongly", "northern", "institute", "idealist", "permanent", "relationship", "struggle", "reasonable", "terms", "victim", "furthermore", "acknowledge", "logical", "probable", "determine", "Easter", "surely", "small-scale", "igno­re", "index", "substantial", "checklist", "enhance", "lift", "married", "depressive", "attendance", "destruction", "im­possible", "technique", "spirit", "precise", "dilemma", "adapt", "attachment", "reflection", "acknowledgment", "emergency", "pull", "enemy", "actual", "beach"], translations: ["מרכזי", "סירוב", "כספי", "מעגל", "נחות", "בכוח", "צפוני", "מכון", "אידיאליסט", "קבוע", "מערכת יחסים", "להיאבק", "סביר", "תנאים", "קורבן", "בנוסף", "להכיר ב", "הגיוני", "סביר", "לקבוע", "חג הפסחא", "בוודאות", "קנה מידה קטן", "להתעלם", "אינדקס", "ממשי", "רשימה", "להגביר", "מעלית", "נשוי", "מדכא", "נוכחות", "הרס", "בלתי אפשרי", "טכניקה", "רוח", "מדויק", "דילמה", "להסתגל", "התקשרות", "השתקפות", "הכרה", "חירום", "למשוך", "אויב", "ממשי", "חוף"] },

  };

// Game Constants & State Management
const gameStructure = {
    stages: [
        { id: 1, numSets: 9, levelsPerSet: 20 },
        { id: 2, numSets: 10, levelsPerSet: 20 },
        { id: 3, numSets: 12, levelsPerSet: 20 },
        { id: 4, numSets: 30, levelsPerSet: 20 },
        { id: 5, numSets: 14, levelsPerSet: 20 }
    ]
};

const gameState = {
    currentStage: null,
    currentSet: null,
    currentLevel: null,
    unlockedSets: {},
    unlockedLevels: {},
    levelScores: {},
    completedLevels: new Set(),
    perfectLevels: new Set(),
    coins: 0,
    perks: {
        timeFreeze: 0,
        skip: 0,
        clue: 0,
        reveal: 0
    }
};

let currentGame = {
    words: [],
    translations: [],
    currentIndex: 0,
    correctAnswers: 0,
    firstAttempt: true,
    isHebrewToEnglish: false,
    mixed: false,
    speedChallenge: false,
    startTime: 0,
    levelStartTime: 0,
    timeBonus: 0,
    streakBonus: true,
    questionStartTime: 0,
    wrongStreak: 0,
    progressLost: 0
};

let timer = null;
let timeRemaining = 0;
let isFrozen = false;

let resetProgressTimeout = null;
let isFirstResetAttempt = true;


function initializeGame() {
    const saved = localStorage.getItem('simploxProgress');
    if (!saved) {
        // Only initialize first stage/set/level if no saved progress
        gameState.unlockedSets[1] = new Set([1]);
        gameState.unlockedLevels['1_1'] = new Set([1]);
    } else {
        loadProgress();
    }
    updateAllCoinDisplays();
}

// Progress Management
async function saveProgress() {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
        console.log('No active session, progress not saved');
        return;
    }
    
    try {
        const gameStateForStorage = {
            unlockedSets: Object.fromEntries(
                Object.entries(gameState.unlockedSets)
                    .map(([k, v]) => [k, Array.from(v)])
            ),
            unlockedLevels: Object.fromEntries(
                Object.entries(gameState.unlockedLevels)
                    .map(([k, v]) => [k, Array.from(v)])
            ),
            perfectLevels: Array.from(gameState.perfectLevels),
            completedLevels: Array.from(gameState.completedLevels),
            coins: gameState.coins,
            perks: gameState.perks,
            statistics: {
                totalPlayed: gameState.statistics?.totalPlayed || 0,
                perfectScores: gameState.statistics?.perfectScores || 0,
                totalCoinsEarned: gameState.statistics?.totalCoinsEarned || 0,
                streakDays: gameState.statistics?.streakDays || 0,
                lastPlayedAt: new Date().toISOString()
            }
        };

        const { error } = await supabase
            .from('user_progress')
            .upsert({
                user_id: session.user.id,  // Matches SQL schema
                game_state: gameStateForStorage
            }, {
                onConflict: 'user_id'  // Matches unique constraint in SQL
            });

        if (error) throw error;
        console.log('Progress saved successfully');

    } catch (error) {
        console.error('Error saving progress:', error);
        if (error.code === 'NETWORK_ERROR') {
            alert('Failed to save progress. Please check your connection.');
        }
    }
}

async function loadProgress() {
    const { data: { session } } = await supabase.auth.getSession();
    
    if (!session) {
        console.log('No active session, using default state');
        return initializeDefaultGameState();
    }
    
    try {
        const { data, error } = await supabase
            .from('user_progress')
            .select('game_state')
            .eq('user_id', session.user.id)
            .single();

        if (error) throw error;

        if (data?.game_state) {
            return {
                unlockedSets: Object.fromEntries(
                    Object.entries(data.game_state.unlockedSets)
                        .map(([k, v]) => [k, new Set(v)])
                ),
                unlockedLevels: Object.fromEntries(
                    Object.entries(data.game_state.unlockedLevels)
                        .map(([k, v]) => [k, new Set(v)])
                ),
                perfectLevels: new Set(data.game_state.perfectLevels),
                completedLevels: new Set(data.game_state.completedLevels),
                coins: data.game_state.coins,
                perks: data.game_state.perks,
                statistics: data.game_state.statistics || {
                    totalPlayed: 0,
                    perfectScores: 0,
                    totalCoinsEarned: 0,
                    streakDays: 0,
                    lastPlayedAt: null
                }
            };
        }
    } catch (error) {
        console.error('Error loading progress:', error);
    }
    
    return initializeDefaultGameState();
}

function initializeDefaultGameState() {
    return {
        unlockedSets: { 1: new Set([1]) },
        unlockedLevels: { '1_1': new Set([1]) },
        perfectLevels: new Set(),
        completedLevels: new Set(),
        coins: 0,
        perks: {
            timeFreeze: 0,
            skip: 0,
            clue: 0,
            reveal: 0
        },
        statistics: {
            totalPlayed: 0,
            perfectScores: 0,
            totalCoinsEarned: 0,
            streakDays: 0,
            lastPlayedAt: null
        }
    };
}

function convertArraysToSets(obj) {
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
        result[key] = new Set(value);
    }
    return result;
}

function resetProgress() {
    if (confirm('Are you sure you want to reset all progress? This cannot be undone.')) {
        localStorage.removeItem('simploxProgress');
        gameState.coins = 0;
        gameState.unlockedSets = {};
        gameState.unlockedLevels = {};
        gameState.perfectLevels = new Set();
        gameState.completedLevels = new Set();
        gameState.perks = {
            timeFreeze: 0,
            skip: 0,
            clue: 0,
            reveal: 0
        };
        
        // Update UI
        updatePerkCounts();
        updateAllCoinDisplays();
        
        initializeGame();
        showScreen('welcome-screen');
    }
}

// Timer Functions
// Replace the startTimer function:
function startTimer(questionCount) {
    clearTimer();
    if (currentGame.currentIndex >= currentGame.words.length) return;
    
    // Set initial time only if not already set
    if (!currentGame.initialTimeRemaining) {
        currentGame.initialTimeRemaining = currentGame.words.length * 10;
        timeRemaining = currentGame.initialTimeRemaining;
        currentGame.totalTime = timeRemaining; // Store the initial total time
    } else {
        // Use the remaining time from the previous interval
        timeRemaining = currentGame.initialTimeRemaining;
    }
    
    console.log('Starting timer with:', timeRemaining, 'seconds');
    currentGame.questionStartTime = Date.now();
    updateTimerDisplay();
    updateTimerCircle(timeRemaining, currentGame.totalTime); // Use stored total time
    
    timer = setInterval(() => {
        if (!isFrozen) {
            timeRemaining = Math.max(0, timeRemaining - 1);
            updateTimerDisplay();
            updateTimerCircle(timeRemaining, currentGame.totalTime); // Use stored total time
            
            // Update the initialTimeRemaining to track remaining time
            currentGame.initialTimeRemaining = timeRemaining;
            
            if (timeRemaining <= 10) {
                document.querySelector('.timer-value').classList.add('warning');
            }
            
            if (timeRemaining <= 0) {
                handleTimeUp();
            }
        }
    }, 1000);
}

function updateTimerDisplay() {
    const minutes = Math.floor(timeRemaining / 60);
    const seconds = timeRemaining % 60;
    const timerElement = document.querySelector('.timer-value');
    timerElement.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    
    if (timeRemaining <= 10) {
        timerElement.classList.add('warning');
    } else {
        timerElement.classList.remove('warning');
    }
}

function clearTimer() {
    if (timer) {
        clearInterval(timer);
        timer = null;
    }
    timeRemaining = 0;
    isFrozen = false;
    
    const timerProgress = document.querySelector('.timer-progress');
    if (timerProgress) {
        timerProgress.classList.remove('warning');
    }
    
    updateTimerCircle(0, 1); // This will empty the circle
}

function createParticles(x, y) {
    // Detect mobile device
    const isMobile = window.matchMedia("(max-width: 768px)").matches;
    
    // Define particle parameters based on device type
    const particleConfig = isMobile 
        ? {
            count: 10,      // Fewer particles on mobile
            size: 6,        // Smaller particles
            distance: 50,   // Shorter spread
            opacity: 0.7,   // Lower opacity
            duration: 1000  // Shorter animation
        }
        : {
            count: 40,      // More particles on desktop
            size: 10,       // Standard particle size
            distance: 150,  // Wider spread
            opacity: 1,     // Full opacity
            duration: 1500  // Longer animation
        };

    const colors = ['#ffd700', '#FFA500', '#4CAF50', '#FFD700'];
    const container = document.body;
    
    for (let i = 0; i < particleConfig.count; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        
        // Position relative to click point
        particle.style.position = 'fixed';
        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;
        
        // Randomize particle properties
        const angle = (Math.random() * Math.PI * 2);
        const distance = particleConfig.distance + (Math.random() * 50);
        
        particle.style.width = `${particleConfig.size}px`;
        particle.style.height = `${particleConfig.size}px`;
        particle.style.opacity = `${particleConfig.opacity}`;
        
        particle.style.setProperty('--x', `${Math.cos(angle) * distance}px`);
        particle.style.setProperty('--y', `${Math.sin(angle) * distance}px`);
        
        // Create adaptive animation
        particle.style.animation = `particleBurst ${particleConfig.duration / 1000}s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards`;
        
        container.appendChild(particle);
        
        // Remove particle after animation completes
        setTimeout(() => {
            container.removeChild(particle);
        }, particleConfig.duration);
    }
}

function animateCoinsChange(element, startValue, endValue) {
    if (!element) return;
    
    const duration = 1000; // 1 second
    const frameRate = 60;
    const frames = duration / (1000 / frameRate);
    const increment = (endValue - startValue) / frames;
    let currentFrame = 0;
    let currentValue = startValue;

    function updateFrame() {
        currentFrame++;
        currentValue += increment;
        
        if (currentFrame <= frames) {
            element.textContent = Math.round(currentValue);
            requestAnimationFrame(updateFrame);
        } else {
            element.textContent = endValue;
        }
    }

    updateFrame();
}

function handleTimeUp() {
    if (currentGame.currentIndex >= currentGame.words.length) return; // Don't show if level is complete
    
    clearTimer();
    const overlay = document.querySelector('.failure-overlay');
    overlay.style.display = 'flex';
    setTimeout(() => {
        overlay.classList.add('show');
    }, 100);
    
    // Update home button functionality
    document.querySelector('.failure-overlay .home-button').onclick = () => {
        overlay.classList.remove('show');
        setTimeout(() => {
            overlay.style.display = 'none';
            showScreen('welcome-screen');
        }, 1000);
    };
    
    // Keep restart functionality
    document.querySelector('.failure-overlay .restart-button').onclick = () => {
        overlay.classList.remove('show');
        setTimeout(() => {
            overlay.style.display = 'none';
            startLevel(gameState.currentLevel);
        }, 1000);
    };
}

// Screen Management
function showScreen(screenId) {
    console.log('Showing screen:', screenId); // Debug log
    
    // First, hide all screens and cleanup
    document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('visible');
        screen.style.display = 'none';
    });

    // Show the requested screen
    const screenElement = document.getElementById(screenId);
    if (screenElement) {
        screenElement.style.display = 'flex';
        screenElement.classList.add('visible');
        
        if (screenId === 'auth-screen') {
            // Make sure login form is visible initially in auth screen
            document.getElementById('login-form').style.display = 'flex';
            document.getElementById('signup-form').style.display = 'none';
        }

        if (['welcome-screen', 'stage-screen', 'set-screen', 'level-screen'].includes(screenId)) {
            loadUserData();
        }
        
        // Initialize particles for non-auth screens
        if (screenId !== 'auth-screen') {
            initializeParticles(screenElement);
        }
    }
}

// Add full-screen event listener
document.addEventListener('fullscreenchange', function() {
    if (!document.fullscreenElement) {
        console.log('Exited full-screen');
    }
});

function showSetScreen(stageId) {
    gameState.currentStage = stageId;
    const container = document.getElementById('set-container');
    container.innerHTML = '';
    
    const stage = gameStructure.stages[stageId - 1];
    for (let i = 1; i <= stage.numSets; i++) {
        const setButton = document.createElement('div');
        setButton.className = `set-button ${gameState.unlockedSets[stageId].has(i) ? 'active' : ''}`;
        setButton.textContent = `Set ${i}`;
        if (gameState.unlockedSets[stageId].has(i)) {
            setButton.onclick = () => showLevelScreen(i);
        }
        container.appendChild(setButton);
    }
    
    showScreen('set-screen');
}

function showLevelScreen(setId) {
    requestFullScreen(); // Ensure full-screen mode
    gameState.currentSet = setId;
    const container = document.getElementById('level-container');
    container.innerHTML = '';
    
    const stage = gameStructure.stages[gameState.currentStage - 1];
    for (let i = 1; i <= stage.levelsPerSet; i++) {
        const levelDiv = document.createElement('div');
        const levelKey = `${gameState.currentStage}_${setId}_${i}`;
        const isUnlocked = gameState.unlockedLevels[`${gameState.currentStage}_${setId}`]?.has(i);
        const isPerfect = gameState.perfectLevels.has(levelKey);
        
        levelDiv.className = `level ${isUnlocked ? 'blue' : ''} ${isPerfect ? 'green' : ''}`;
        levelDiv.textContent = i;
        
        if (isUnlocked) {
            levelDiv.onclick = () => startLevel(i);
        }
        
        container.appendChild(levelDiv);
    }
    
    showScreen('level-screen');
}

// Level Logic
function calculateWordsForLevel(level, vocabulary) {
    const totalWords = vocabulary.words.length;
    const wordSurplus = totalWords - 50;

    // Level 1-2: Choose 3 new words
    if (level === 1 || level === 2) {
        return {
            startIndex: (level - 1) * 3,
            count: 3,
            testLevels: [3, 10, 21]
        };
    }

    // Level 3: Test words from levels 1-2
    if (level === 3) {
        return {
            startIndex: 0,
            count: 6,
            isTestLevel: true
        };
    }

    // Level 4-5: Choose 3 new words
    if (level === 4 || level === 5) {
        return {
            startIndex: 6 + (level - 4) * 3,
            count: 3,
            testLevels: [6, 10, 21]
        };
    }

    // Level 6: Test words from levels 4-5
    if (level === 6) {
        return {
            startIndex: 6,
            count: 6,
            isTestLevel: true
        };
    }

    // Level 7-8: Choose 4 new words
    if (level === 7 || level === 8) {
        return {
            startIndex: 12 + (level - 7) * 4,
            count: 4,
            testLevels: [9, 10, 21]
        };
    }

    // Level 9: Test words from levels 7-8
    if (level === 9) {
        return {
            startIndex: 12,
            count: 8,
            isTestLevel: true
        };
    }

    // Level 10: Test words from levels 1,2,4,5,7,8
    if (level === 10) {
        return {
            startIndex: 0,
            count: 20,
            isTestLevel: true
        };
    }

    // Level 11-12: Choose 4 new words
    if (level === 11 || level === 12) {
        return {
            startIndex: 20 + (level - 11) * 4,
            count: 4,
            testLevels: [13, 20, 21]
        };
    }

    // Level 13: Test words from levels 11-12
    if (level === 13) {
        return {
            startIndex: 20,
            count: 8,
            isTestLevel: true
        };
    }

    // Level 14-15: Choose 5-6 new words
    if (level === 14 || level === 15) {
        return {
            startIndex: 28 + (level === 14 ? 0 : 5),
            count: level === 14 ? 5 : 6,
            testLevels: [16, 20, 21]
        };
    }

    // Level 16: Test words from levels 14-15
    if (level === 16) {
        return {
            startIndex: 28,
            count: 11,
            isTestLevel: true
        };
    }

    // Level 17-18: Flexible word count based on total vocabulary
    if (level === 17 || level === 18) {
        const baseCount = level === 17 ? 5 : 6;
        const adjustedCount = baseCount + (wordSurplus > 0 ? wordSurplus : 0);
        return {
            startIndex: 39 + (level === 17 ? 0 : adjustedCount),
            count: adjustedCount,
            testLevels: [19, 20, 21]
        };
    }

    // Level 19: Test words from levels 17-18
    if (level === 19) {
        return {
            startIndex: 39,
            count: 11,
            isTestLevel: true
        };
    }

    // Level 20: Test words from levels 11,12,14,15,17,18
    if (level === 20) {
        return {
            startIndex: 20,
            count: 30,
            isTestLevel: true
        };
    }

    // Level 21: Boss level - all words
    if (level === 21) {
        return {
            startIndex: 0,
            count: totalWords,
            isBossLevel: true
        };
    }
}

function startLevel(levelId) {
    if (!currentGame.restartsRemaining) {
        currentGame.restartsRemaining = 2;
    }
    gameState.currentLevel = levelId;
    const setKey = `${gameState.currentStage}_${gameState.currentSet}`;
    const vocabulary = vocabularySets[setKey];

    // Prepare all game state first
    currentGame.startingCoins = gameState.coins;
    currentGame.startingPerks = { ...gameState.perks };
    currentGame.timeBonus = 0;
    currentGame.initialTimeRemaining = null;
    currentGame.streakBonus = true;
    currentGame.levelStartTime = Date.now();
    
    // Show intro, but prepare the level during the curtain-down moment
    showLevelIntro(levelId, () => {
        // Setup all game state while curtain is down
        const levelConfig = calculateWordsForLevel(levelId, vocabulary);
        if (typeof levelConfig === 'object') {
            const { startIndex, count, isHebrewToEnglish, mixed, speedChallenge } = levelConfig;
            currentGame = {
                ...currentGame,
                words: vocabulary.words.slice(startIndex, startIndex + count),
                translations: vocabulary.translations.slice(startIndex, startIndex + count),
                currentIndex: 0,
                correctAnswers: 0,
                firstAttempt: true,
                isHebrewToEnglish: isHebrewToEnglish || false,
                mixed: mixed || false,
                speedChallenge: speedChallenge || false
            };
        } else {
            currentGame = {
                ...currentGame,
                words: vocabulary.words.slice(0, levelConfig),
                translations: vocabulary.translations.slice(0, levelConfig),
                currentIndex: 0,
                correctAnswers: 0,
                firstAttempt: true,
                isHebrewToEnglish: false,
                mixed: false,
                speedChallenge: false
            };
        }
        
        // Prepare the question screen while curtain is still down
        showScreen('question-screen');
        updateProgressCircle();
        loadNextQuestion();
        
        // Only start the timer after curtain is fully up
        setTimeout(() => {
            startTimer(currentGame.words.length);
        }, 200);
    });
}

function updateNavigationIcons(screenId) {
    // Remove existing navigation containers
    
    // Screens that should have navigation
    const screensWithNav = ['stage-screen', 'set-screen', 'level-screen', 'question-screen'];
    
    if (screensWithNav.includes(screenId)) {
        const navContainer = document.createElement('div');
        navContainer.className = 'screen-nav';
        
        // Home button (always present)
        const homeButton = document.createElement('button');
        homeButton.className = 'home-button';
        homeButton.innerHTML = '<i class="fas fa-home"></i>';
        homeButton.onclick = () => showScreen('welcome-screen');
        navContainer.appendChild(homeButton);
        
        // Back button (not for stage screen)
        if (screenId !== 'stage-screen') {
            const backButton = document.createElement('button');
            backButton.className = 'back-button';
            backButton.innerHTML = '<i class="fas fa-arrow-left"></i>';
            
            // Determine back navigation based on current screen
            switch(screenId) {
                case 'set-screen':
                    backButton.onclick = () => showScreen('stage-screen');
                    break;
                case 'level-screen':
                    backButton.onclick = () => showSetScreen(gameState.currentStage);
                    break;
                case 'question-screen':
                    backButton.onclick = () => stopLevelAndGoBack();
                    break;
            }
            
            navContainer.appendChild(backButton);
        }
        
        // Add navigation to the current screen
        const currentScreen = document.getElementById(screenId);
        currentScreen.appendChild(navContainer);
    }
}

// Visual Updates
function updateProgressCircle() {
    const progress = (currentGame.currentIndex / currentGame.words.length);
    const circle = document.querySelector('.progress-circle .progress');
    const progressCircle = document.querySelector('.progress-circle');
    
    const radius = 54;
    const circumference = 2 * Math.PI * radius;
    
    circle.style.strokeDasharray = `${circumference} ${circumference}`;
    circle.style.strokeDashoffset = circumference * (1 - progress);
    
    // Advanced color progression
    let hue, saturation, lightness;
    
    if (progress <= 0.2) {
        // 0-20%: Dark Red
        hue = 0; // Red hue
        saturation = 100;
        lightness = 20; // Very dark red
    } else if (progress <= 0.4) {
        // 20-40%: Bright Red
        hue = 0; // Red hue
        saturation = 100;
        lightness = 50; // Brighter red
    } else if (progress <= 0.6) {
        // 40-60%: Orange
        hue = 30; // Orange hue
        saturation = 100;
        lightness = 50;
    } else if (progress <= 0.8) {
        // 60-80%: Bright Green
        hue = 120; // Green hue
        saturation = 100;
        lightness = 40;
    } else {
        // 80-100%: Transition from Green to Gold
        const greenToGoldProgress = (progress - 0.8) * 5; // Normalize to 0-1
        hue = 120 * (1 - greenToGoldProgress) + 60 * greenToGoldProgress; // Interpolate between green (120) and gold (60)
        saturation = 100;
        lightness = 40 + (20 * greenToGoldProgress); // Lighten as it approaches gold
    }
    
    circle.style.stroke = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    
    if (progress >= 1) {
        progressCircle.classList.add('completed');
        // Get the viewport-relative position of the progress circle
        const rect = progressCircle.getBoundingClientRect();
        // Calculate the absolute position in the viewport
        const viewportX = window.innerWidth / 2;
        const viewportY = rect.top + (rect.height / 2);
        
        // Create multiple bursts of particles with delay
        for (let i = 0; i < 5; i++) {
            setTimeout(() => createParticles(viewportX, viewportY), i * 300);
        }
        
        setTimeout(() => {
            progressCircle.classList.remove('completed');
        }, 2000);
    }
}

// Question Management
function loadNextQuestion() {
    if (currentGame.currentIndex >= currentGame.words.length) {
        handleLevelCompletion();
        return;
    }

    currentGame.questionStartTime = Date.now();
    currentGame.firstAttempt = true;

    let questionWord, options, correctAnswer;
    const currentDirection = currentGame.mixed ? 
        Math.random() < 0.5 : currentGame.isHebrewToEnglish;

    if (currentDirection) {
        questionWord = currentGame.translations[currentGame.currentIndex];
        options = new Set([currentGame.words[currentGame.currentIndex]]);
        while (options.size < 3) {
            const randomIndex = Math.floor(Math.random() * currentGame.words.length);
            options.add(currentGame.words[randomIndex]);
        }
        correctAnswer = currentGame.words[currentGame.currentIndex];
    } else {
        questionWord = currentGame.words[currentGame.currentIndex];
        options = new Set([currentGame.translations[currentGame.currentIndex]]);
        while (options.size < 3) {
            const randomIndex = Math.floor(Math.random() * currentGame.translations.length);
            options.add(currentGame.translations[randomIndex]);
        }
        correctAnswer = currentGame.translations[currentGame.currentIndex];
    }
    
    document.getElementById('question-word').textContent = questionWord;
    
    const buttonsDiv = document.getElementById('buttons');
    buttonsDiv.innerHTML = '';

    Array.from(options)
        .sort(() => Math.random() - 0.5)
        .forEach(option => {
            const button = document.createElement('button');
            button.textContent = option;
            button.onclick = () => handleAnswer(option === correctAnswer);
            buttonsDiv.appendChild(button);
        });
}

function handleAnswer(isCorrect, fromPerk = false) {
    console.log('Before handleAnswer:', {
        timeRemaining, 
        initialTimeRemaining: currentGame.initialTimeRemaining,
        currentIndex: currentGame.currentIndex
    });

    const levelKey = `${gameState.currentStage}_${gameState.currentSet}_${gameState.currentLevel}`;
    const isLevelCompleted = gameState.perfectLevels.has(levelKey);

    if (!isCorrect) {
        currentGame.firstAttempt = false;
        currentGame.streakBonus = false;
        currentGame.wrongStreak++;
        
        // Deduct coins and update perks
        gameState.coins = Math.max(0, gameState.coins - 3);
        updateAllCoinDisplays();
        updatePerkCounts(); // Update perk availability after coin deduction

        // Move progress bar backwards
        if (currentGame.currentIndex > 0) {
            currentGame.progressLost++;
            currentGame.currentIndex = Math.max(0, currentGame.currentIndex - 1);
        }

        // Check for game over condition
        if (currentGame.wrongStreak >= 3) {
    if (currentGame.isCustomPractice) {
        showGameOverOverlay();
        document.querySelector('.restart-button').onclick = () => {
            document.querySelector('.failure-overlay').style.display = 'none';
            // Use the stored currentCustomLevel instead of resetting to 1
            startCustomLevel(currentGame.currentCustomLevel, {
                ...currentGame.practiceState,
                currentLevel: currentGame.currentCustomLevel
            });
        };
        return;
    } else {
        showGameOverOverlay();
        return;
    }
}
        if (currentGame.isCustomPractice) {
    if (!isCorrect) {
        currentGame.firstAttempt = false;
        currentGame.streakBonus = false;
        gameState.coins = Math.max(0, gameState.coins - 3);
        updateAllCoinDisplays();
        updatePerkCounts();
    } else if (!fromPerk) {
        const timeBonus = awardTimeBonus();
        if (timeBonus > 0) {
            gameState.coins += timeBonus;
            pulseCoins(timeBonus);
        }
        if (currentGame.firstAttempt) {
            gameState.coins += 3;
            pulseCoins(3);
        } else {
            gameState.coins += 1;
            pulseCoins(1);
        }
        updateAllCoinDisplays();
        updatePerkCounts();
    }
}
    } else {
        currentGame.wrongStreak = 0; // Reset wrong streak on correct answer
    }

    const correctAnswer = currentGame.isHebrewToEnglish ? 
        currentGame.words[currentGame.currentIndex] : 
        currentGame.translations[currentGame.currentIndex];

    if (isCorrect && !isLevelCompleted && !fromPerk) {
        // Award time bonus and update perks
        const timeBonus = awardTimeBonus();
        if (timeBonus > 0) {
            gameState.coins += timeBonus;
            pulseCoins(timeBonus);
            updatePerkCounts(); // Update perk availability after bonus coins
        }

        // Award coins based on first attempt and update perks
        if (currentGame.firstAttempt) {
            gameState.coins += 3;
            pulseCoins(3);
        } else {
            gameState.coins += 1;
            pulseCoins(1);
        }
       
        currentGame.correctAnswers++;
        updateAllCoinDisplays();
        updatePerkCounts(); // Update perk availability after answer coins
    } else if (isCorrect) {
        currentGame.correctAnswers++;
    }

    document.querySelectorAll('.buttons button').forEach(btn => {
        if (btn.textContent === correctAnswer) {
            btn.classList.add('correct');
        } else if (!isCorrect && btn.textContent === event.target.textContent) {
            btn.classList.add('wrong');
        }
    });

    if (isCorrect) {
        currentGame.currentIndex++;
    }
    
    updateProgressCircle();
    saveProgress();
    
   
    // Use a promise-based delay for better timing control
    const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
    
    delay(333).then(() => {
        if (currentGame.currentIndex < currentGame.words.length) {
            console.log('Restarting timer:', currentGame.initialTimeRemaining);
            startTimer(currentGame.words.length - currentGame.currentIndex);
            loadNextQuestion();
            updatePerkCounts(); // Ensure perks are up to date after state changes
        } else {
            handleLevelCompletion();
        }
    });
}

function awardTimeBonus() {
   const timeSpent = (Date.now() - currentGame.questionStartTime) / 1000;
   const maxTime = 10; // Maximum time allowed per question
   if (timeSpent < maxTime) {
       const bonusCoins = Math.floor(maxTime - timeSpent);
       currentGame.timeBonus += bonusCoins;
       return bonusCoins;
   }
   return 0;
}

function pulseCoins(times = 1) {
    // Update both the header coin icon and the in-game coin icon
    const coinIcons = document.querySelectorAll('.coin-icon');
    
    coinIcons.forEach(coinIcon => {
        let pulseCount = 0;
        const doPulse = () => {
            coinIcon.classList.add('coin-pulse');
            setTimeout(() => {
                coinIcon.classList.remove('coin-pulse');
                pulseCount++;
                if (pulseCount < times) {
                    setTimeout(doPulse, 100);
                }
            }, 500);
        };
        
        doPulse();
    });
}

function updateAllCoinDisplays() {
    // Get all coin displays, including both header and in-game displays
    const displays = document.querySelectorAll('.coin-count');
    
    displays.forEach(display => {
        const currentValue = parseInt(display.textContent) || 0;
        if (currentValue !== gameState.coins) {
            animateCoinsChange(display, currentValue, gameState.coins);
        }
    });

    // Handle visibility of coins header based on screen
    const questionScreenCoins = document.querySelector('#question-screen .coins-header');
    const otherScreenCoins = document.querySelectorAll('#welcome-screen .coins-header, #stage-screen .coins-header, #set-screen .coins-header, #level-screen .coins-header');
    
    otherScreenCoins.forEach(coinHeader => coinHeader.style.display = 'none');
    if (questionScreenCoins) {
        questionScreenCoins.style.display = 'flex';
    }
}
function usePerk(perkType) {
    if (gameState.perks[perkType] <= 0) return;

    switch (perkType) {
        case 'timeFreeze':
            isFrozen = true;
            gameState.perks.timeFreeze--;
            setTimeout(() => {
                isFrozen = false;
            }, 5000);
            break;
        case 'skip':
        case 'reveal':
            if (perkType === 'skip') gameState.perks.skip--;
            if (perkType === 'reveal') gameState.perks.reveal--;
            handleAnswer(true, true);
            // The streak is maintained as handleAnswer with fromPerk=true
            // doesn't affect streakBonus
            break;
        case 'clue':
            gameState.perks.clue--;
            eliminateWrongAnswer();
            break;
    }

    updatePerkCounts();
    saveProgress();
}


function eliminateWrongAnswer() {
   const buttons = document.querySelectorAll('.buttons button');
   const correctAnswer = currentGame.isHebrewToEnglish ? 
       currentGame.words[currentGame.currentIndex] : 
       currentGame.translations[currentGame.currentIndex];
   
   const wrongButtons = Array.from(buttons).filter(btn => 
       btn.textContent !== correctAnswer
   );
   
   if (wrongButtons.length > 0) {
       const buttonToDisable = wrongButtons[Math.floor(Math.random() * wrongButtons.length)];
       buttonToDisable.disabled = true;
       buttonToDisable.style.opacity = '0.5';
   }
}

function revealCorrectAnswer() {
   const correctAnswer = currentGame.isHebrewToEnglish ? 
       currentGame.words[currentGame.currentIndex] : 
       currentGame.translations[currentGame.currentIndex];
   
   document.querySelectorAll('.buttons button').forEach(btn => {
       if (btn.textContent === correctAnswer) {
           btn.classList.add('correct');
           setTimeout(() => {
               currentGame.correctAnswers++;
               currentGame.currentIndex++;
               loadNextQuestion();
           }, 1000);
       } else {
           btn.disabled = true;
           btn.style.opacity = '0.5';
       }
   });
}

function updatePerkCounts() {
    const perkCosts = {
        'timeFreeze': 15,
        'skip': 50,
        'clue': 25,
        'reveal': 200
    };

    for (const [perkType, cost] of Object.entries(perkCosts)) {
        const button = document.getElementById(`${perkType}Perk`);
        if (button) {
            const countElement = button.querySelector('.perk-count');
            const availablePurchases = Math.floor(gameState.coins / cost);
            
            // Update button state based on current coins
            if (availablePurchases > 0) {
                button.disabled = false;
                button.classList.remove('disabled');
                countElement.textContent = availablePurchases;
                button.onclick = () => activatePerk(perkType, cost);
            } else {
                button.disabled = true;
                button.classList.add('disabled');
                countElement.textContent = '0';
            }
        }
    }
}

function startCustomListPractice(listId) {
    const list = customPracticeLists.lists.find(l => l.id === listId);
    if (!list) return;

    currentGame = {
        words: list.words,
        translations: list.translations,
        currentIndex: 0,
        correctAnswers: 0,
        firstAttempt: true,
        isCustomPractice: true,
        startingCoins: gameState.coins,
        startingPerks: { ...gameState.perks }
    };

    startCustomLevel(1, {
        currentLevel: 1,
        words: list.words,
        translations: list.translations,
        unlockedLevels: new Set([1]),
        progress: {},
        maxLevel: 10,
        listId: listId  // Store the list ID for reference
    });
}

function handleLevelCompletion() {
    clearTimer();
    const levelKey = `${gameState.currentStage}_${gameState.currentSet}_${gameState.currentLevel}`;
    const isLevelCompleted = gameState.perfectLevels.has(levelKey);
    
    // Handle custom practice mode
    if (currentGame.isCustomPractice) {
        if (!isLevelCompleted && currentGame.streakBonus && currentGame.correctAnswers === currentGame.words.length) {
            gameState.coins += 5;
            pulseCoins(5);
            
            const nextLevel = currentGame.practiceState.currentLevel + 1;
            if (nextLevel <= currentGame.practiceState.maxLevel) {
                currentGame.practiceState.unlockedLevels.add(nextLevel);
                currentGame.practiceState.progress[currentGame.currentCustomLevel] = true;
                setTimeout(() => {
                    startCustomLevel(nextLevel, currentGame.practiceState);
                }, 1500);
            } else {
                setTimeout(() => {
                    showScreen('custom-practice-screen');
                    alert('Congratulations! You have completed this practice set!');
                }, 1500);
            }
        } else {
            setTimeout(() => {
                startCustomLevel(currentGame.currentCustomLevel, currentGame.practiceState);
            }, 1500);
        }
        return;
    }
    
    // Disable buttons
    const buttons = document.querySelectorAll('.buttons button');
    buttons.forEach(btn => {
        btn.disabled = true;
        btn.style.opacity = '0.5';
    });

    if (!isLevelCompleted && currentGame.streakBonus && currentGame.correctAnswers === currentGame.words.length) {
        // Perfect streak bonus
        gameState.coins += 5;
        pulseCoins(5);
        gameState.perfectLevels.add(levelKey);

        // Create completion particles
        const questionScreen = document.getElementById('question-screen');
        const rect = questionScreen.getBoundingClientRect();
        const viewportX = rect.left + (rect.width / 2);
        const viewportY = rect.top + (rect.height / 2);
        
        for (let i = 0; i < 5; i++) {
            setTimeout(() => createParticles(viewportX, viewportY), i * 300);
        }

        // Ensure current level is marked as unlocked
        const setKey = `${gameState.currentStage}_${gameState.currentSet}`;
        if (!gameState.unlockedLevels[setKey]) {
            gameState.unlockedLevels[setKey] = new Set();
        }
        gameState.unlockedLevels[setKey].add(gameState.currentLevel);

        // Only unlock next level if current level is completed perfectly
        const currentStageConfig = gameStructure.stages[gameState.currentStage - 1];
        const isLastLevelInSet = gameState.currentLevel === currentStageConfig.levelsPerSet;
        const isLastSetInStage = gameState.currentSet === currentStageConfig.numSets;

        if (!isLastLevelInSet) {
            // Unlock next level in current set
            gameState.unlockedLevels[setKey].add(gameState.currentLevel + 1);
        } else if (!isLastSetInStage) {
            // Unlock first level of next set
            const nextSetKey = `${gameState.currentStage}_${gameState.currentSet + 1}`;
            if (!gameState.unlockedSets[gameState.currentStage]) {
                gameState.unlockedSets[gameState.currentStage] = new Set();
            }
            gameState.unlockedSets[gameState.currentStage].add(gameState.currentSet + 1);
            if (!gameState.unlockedLevels[nextSetKey]) {
                gameState.unlockedLevels[nextSetKey] = new Set([1]);
            }
        } else if (gameState.currentStage < 5) {
            // Unlock first set of next stage
            const nextStage = gameState.currentStage + 1;
            if (!gameState.unlockedSets[nextStage]) {
                gameState.unlockedSets[nextStage] = new Set([1]);
            }
            gameState.unlockedLevels[`${nextStage}_1`] = new Set([1]);
        }

        // Save progress and update displays
        saveProgress();
        updateAllCoinDisplays();

        // Animate completion
        requestAnimationFrame(() => {
            const levelElements = document.querySelectorAll('.level');
            const currentLevelElement = levelElements[gameState.currentLevel - 1];
            const nextLevelElement = levelElements[gameState.currentLevel];

            if (currentLevelElement) {
                currentLevelElement.classList.add('completing');
                setTimeout(() => {
                    currentLevelElement.classList.add('green');
                }, 500);
            }

            if (nextLevelElement && !isLastLevelInSet) {
                setTimeout(() => {
                    nextLevelElement.classList.add('unlocking', 'blue');
                    nextLevelElement.onclick = () => startLevel(gameState.currentLevel + 1);
                }, 1000);
            }
        });

        // Add progress check and level transition
        setTimeout(() => {
            if (isLastLevelInSet) {
                if (!isLastSetInStage) {
                    gameState.currentSet++;
                    startLevel(1);
                } else if (gameState.currentStage < 5) {
                    gameState.currentStage++;
                    gameState.currentSet = 1;
                    startLevel(1);
                } else {
                    showScreen('stage-screen');
                }
            } else {
                startLevel(gameState.currentLevel + 1);
            }
        }, 1500);
    } else {
        // If level wasn't completed perfectly, restart the same level
        setTimeout(() => {
            startLevel(gameState.currentLevel);
        }, 1500);
    }
}


async function activatePerk(perkType, cost) {
    if (gameState.coins >= cost) {
        gameState.coins -= cost;
        gameState.perks[perkType]++;
        saveProgress();
        updateAllCoinDisplays();
        updatePerkCounts();
        
        // Activate perk immediately
        usePerk(perkType);
    }
}
  

// Particle background initialization
function initializeParticles(container = document.body) {
    // Find or create the particle container
    let particleContainer = container.querySelector('.particle-container');
    if (!particleContainer) {
        particleContainer = document.createElement('div');
        particleContainer.classList.add('particle-container');
        container.appendChild(particleContainer);
    }
    
    // Rest of the function remains the same as before
    const characterSet = [
        ...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
        ...'ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρστυφχψω',
        ...'אבגדהוזחטיכלמנסעפצקרשת'
    ];

    function createLetterParticle() {
        const particle = document.createElement('div');
        particle.classList.add('letter-particle');
        
        particle.textContent = characterSet[Math.floor(Math.random() * characterSet.length)];
        
        const startX = Math.random() * window.innerWidth;
        const startY = Math.random() * window.innerHeight;
        
        const moveX = -100 + Math.random() * 200;
        const moveY = -100 + Math.random() * 200;
        
        const size = 12 + Math.random() * 16;
        const opacity = 0.2 + Math.random() * 0.3;
        const rotate = Math.random() * 180;
        const duration = 8 + Math.random() * 10;
        
        particle.style.cssText = `
            left: ${startX}px;
            top: ${startY}px;
            font-size: ${size}px;
            animation: letterFloat ${duration}s ease-in-out forwards;
            --moveX: ${moveX}px;
            --moveY: ${moveY}px;
            --opacity: ${opacity};
            --rotate: ${rotate}deg;
        `;
        
        particleContainer.appendChild(particle);
        
        setTimeout(() => {
            particleContainer.removeChild(particle);
        }, duration * 1000);
    }
    
    // Initial particles
    for (let i = 0; i < 50; i++) {
        createLetterParticle();
    }
    
    // Continuous particle generation
    const particleInterval = setInterval(createLetterParticle, 1000);
    
    // Optional: store the interval to clear it if needed
    particleContainer.dataset.intervalId = particleInterval;
}



function stopLevelAndGoBack() {
    clearTimer();
    isFrozen = false;
    
    // Reset restart button state
    const restartButton = document.querySelector('.navigation-button.restart-level');
    if (restartButton) {
        restartButton.classList.remove('disabled');
        restartButton.style.opacity = '1';
        restartButton.disabled = false;  // Re-enable the button
        restartButton.onclick = handleRestartLevel;  // Restore click handler
    }
    
    // Reset game state
    currentGame = {
        words: [],
        translations: [],
        currentIndex: 0,
        correctAnswers: 0,
        firstAttempt: true,
        isHebrewToEnglish: false,
        mixed: false,
        speedChallenge: false,
        timeBonus: 0,
        initialTimeRemaining: null,
        streakBonus: true,
        restartsRemaining: null
    };
    
    showSetScreen(gameState.currentStage);
}

function requestFullScreen() {
    const docElm = document.documentElement;
    if (docElm.requestFullscreen) {
        docElm.requestFullscreen();
    } else if (docElm.mozRequestFullScreen) { // Firefox
        docElm.mozRequestFullScreen();
    } else if (docElm.webkitRequestFullScreen) { // Chrome, Safari and Opera
        docElm.webkitRequestFullScreen();
    } else if (docElm.msRequestFullscreen) { // Internet Explorer/Edge
        docElm.msRequestFullscreen();
    }
}

function showGameOverOverlay() {
    clearTimer();
    const overlay = document.querySelector('.failure-overlay');
    const title = overlay.querySelector('.failure-title');
    title.textContent = 'Game Over!';
    
    overlay.style.display = 'flex';
    
    // Hide home button in custom practice
    const homeButton = overlay.querySelector('.home-button');
    if (currentGame.isCustomPractice) {
        homeButton.style.display = 'none';
    } else {
        homeButton.style.display = 'block';
    }
    
    setTimeout(() => {
        overlay.classList.add('show');
    }, 100);
    
    // Set up restart button
    document.querySelector('.restart-button').onclick = () => {
        overlay.classList.remove('show');
        setTimeout(() => {
            overlay.style.display = 'none';
            if (currentGame.isCustomPractice) {
                showScreen('custom-practice-screen');
            } else {
                startLevel(gameState.currentLevel);
            }
        }, 1000);
    };
}

function enforceFullscreen() {
    if (!document.fullscreenElement) {
        requestFullScreen();
    }
}


function updateTimerCircle(timeRemaining, totalTime) {
    const timerProgress = document.querySelector('.timer-progress');
    if (!timerProgress) return;

    const radius = 40;
    const circumference = 2 * Math.PI * radius;
    
    timerProgress.style.strokeDasharray = `${circumference} ${circumference}`;
    
    const percentage = timeRemaining / totalTime;
    const dashoffset = circumference * (1 - percentage);
    timerProgress.style.strokeDashoffset = dashoffset;

    // Add warning state when time is low
    if (timeRemaining <= 10) {
        timerProgress.classList.add('warning');
    } else {
        timerProgress.classList.remove('warning');
    }
}

function handleResetProgress() {
    const resetButton = document.querySelector('.reset-button');
    
    if (isFirstResetAttempt) {
        // First attempt: Blink red and set timeout
        resetButton.classList.add('warning');
        
        resetProgressTimeout = setTimeout(() => {
            resetButton.classList.remove('warning');
            isFirstResetAttempt = true;
        }, 10000);  // 10 seconds window
        
        isFirstResetAttempt = false;
    } else {
        // Second attempt within 10 seconds: Actually reset progress
        clearTimeout(resetProgressTimeout);
        resetButton.classList.remove('warning');
        
        // Actual reset logic
        localStorage.removeItem('simploxProgress');
        gameState.coins = 0;
        gameState.unlockedSets = {};
        gameState.unlockedLevels = {};
        gameState.perfectLevels = new Set();
        gameState.completedLevels = new Set();
        gameState.perks = {
            timeFreeze: 0, 
            skip: 0, 
            clue: 0, 
            reveal: 0
        };
        
        initializeGame();
        isFirstResetAttempt = true;
        
        // Automatically redirect to welcome screen
        showScreen('welcome-screen');
    }
}


function handleRestartLevel() {
    // If no restarts remaining, ignore the click entirely
    if (currentGame.restartsRemaining <= 0) {
        return;
    }
    
    const restartButton = document.querySelector('.navigation-button.restart-level');
    
    // Update the restarts counter
    currentGame.restartsRemaining--;
    
    // Show visual feedback of remaining restarts
    if (currentGame.restartsRemaining === 1) {
        restartButton.style.opacity = '0.7';
    } else if (currentGame.restartsRemaining === 0) {
        restartButton.classList.add('disabled');
        
        // Remove the click handler when out of restarts
        restartButton.onclick = null;
        // Additional safety: explicitly disable the button
        restartButton.disabled = true;
    }
    
    // Restore initial state
    gameState.coins = currentGame.startingCoins;
    gameState.perks = { ...currentGame.startingPerks };
    
    // Update UI
    updatePerkCounts();
    updateAllCoinDisplays();
    
    // Save current state
    saveProgress();
    
    // Restart the level
    startLevel(gameState.currentLevel);
}

function showStagesFromMenu() {
    requestFullScreen();
    showScreen('stage-screen');
}

function findFurthestProgression() {
    // Look through all stages
    for (let stage = 1; stage <= 5; stage++) {
        if (!gameState.unlockedSets[stage]) continue;
        
        const sets = Array.from(gameState.unlockedSets[stage]).sort((a, b) => b - a); // Sort in descending order
        
        // For each set in the stage
        for (const set of sets) {
            const setKey = `${stage}_${set}`;
            const levels = gameState.unlockedLevels[setKey];
            
            if (!levels) continue;
            
            // Get all levels in ascending order
            const levelArray = Array.from(levels).sort((a, b) => a - b);
            const maxLevel = Math.max(...levelArray);
            
            // Find the first incomplete level in this set
            for (let level = 1; level <= maxLevel + 1; level++) {
                if (!gameState.perfectLevels.has(`${stage}_${set}_${level}`)) {
                    return {
                        stage: stage,
                        set: set,
                        level: level
                    };
                }
            }
        }
    }
    
    // If no incomplete level found, return stage 1, set 1, level 1
    return { stage: 1, set: 1, level: 1 };
}

function handleLevelCompletion() {
    clearTimer();
    const levelKey = `${gameState.currentStage}_${gameState.currentSet}_${gameState.currentLevel}`;
    const isLevelCompleted = gameState.perfectLevels.has(levelKey);
    
    // Handle custom practice mode
    if (currentGame.isCustomPractice) {
        if (!isLevelCompleted && currentGame.streakBonus && currentGame.correctAnswers === currentGame.words.length) {
            gameState.coins += 5;
            pulseCoins(5);
            
            const nextLevel = currentGame.currentCustomLevel + 1;
            if (nextLevel <= 10) {
                currentGame.practiceState.unlockedLevels.add(nextLevel);
                currentGame.practiceState.progress[currentGame.currentCustomLevel] = true;
                setTimeout(() => {
                    startCustomLevel(nextLevel, currentGame.practiceState);
                }, 1500);
            } else {
                setTimeout(() => {
                    showScreen('custom-practice-screen');
                    alert('Congratulations! You have completed this practice set!');
                }, 1500);
            }
        } else {
            setTimeout(() => {
                startCustomLevel(currentGame.currentCustomLevel, currentGame.practiceState);
            }, 1500);
        }
        return;
    }
    
    // Disable buttons
    const buttons = document.querySelectorAll('.buttons button');
    buttons.forEach(btn => {
        btn.disabled = true;
        btn.style.opacity = '0.5';
    });

    if (!isLevelCompleted && currentGame.streakBonus && currentGame.correctAnswers === currentGame.words.length) {
        // Perfect streak bonus
        gameState.coins += 5;
        pulseCoins(5);
        gameState.perfectLevels.add(levelKey);

        // Create completion particles
        const questionScreen = document.getElementById('question-screen');
        const rect = questionScreen.getBoundingClientRect();
        const viewportX = rect.left + (rect.width / 2);
        const viewportY = rect.top + (rect.height / 2);
        
        for (let i = 0; i < 5; i++) {
            setTimeout(() => createParticles(viewportX, viewportY), i * 300);
        }

        // Ensure current level is marked as unlocked
        const setKey = `${gameState.currentStage}_${gameState.currentSet}`;
        if (!gameState.unlockedLevels[setKey]) {
            gameState.unlockedLevels[setKey] = new Set();
        }
        gameState.unlockedLevels[setKey].add(gameState.currentLevel);

        // Only unlock next level if current level is completed perfectly
        const currentStageConfig = gameStructure.stages[gameState.currentStage - 1];
        const isLastLevelInSet = gameState.currentLevel === currentStageConfig.levelsPerSet;
        const isLastSetInStage = gameState.currentSet === currentStageConfig.numSets;

        if (!isLastLevelInSet) {
            // Unlock next level in current set
            gameState.unlockedLevels[setKey].add(gameState.currentLevel + 1);
        } else if (!isLastSetInStage) {
            // Unlock first level of next set
            const nextSetKey = `${gameState.currentStage}_${gameState.currentSet + 1}`;
            if (!gameState.unlockedSets[gameState.currentStage]) {
                gameState.unlockedSets[gameState.currentStage] = new Set();
            }
            gameState.unlockedSets[gameState.currentStage].add(gameState.currentSet + 1);
            if (!gameState.unlockedLevels[nextSetKey]) {
                gameState.unlockedLevels[nextSetKey] = new Set([1]);
            }
        } else if (gameState.currentStage < 5) {
            // Unlock first set of next stage
            const nextStage = gameState.currentStage + 1;
            if (!gameState.unlockedSets[nextStage]) {
                gameState.unlockedSets[nextStage] = new Set([1]);
            }
            gameState.unlockedLevels[`${nextStage}_1`] = new Set([1]);
        }

        // Save progress and update displays
        saveProgress();
        updateAllCoinDisplays();

        // Animate completion
        requestAnimationFrame(() => {
            const levelElements = document.querySelectorAll('.level');
            const currentLevelElement = levelElements[gameState.currentLevel - 1];
            const nextLevelElement = levelElements[gameState.currentLevel];

            if (currentLevelElement) {
                currentLevelElement.classList.add('completing');
                setTimeout(() => {
                    currentLevelElement.classList.add('green');
                }, 500);
            }

            if (nextLevelElement && !isLastLevelInSet) {
                setTimeout(() => {
                    nextLevelElement.classList.add('unlocking', 'blue');
                    nextLevelElement.onclick = () => startLevel(gameState.currentLevel + 1);
                }, 1000);
            }
        });

        // Add progress check and level transition
        setTimeout(() => {
            if (isLastLevelInSet) {
                if (!isLastSetInStage) {
                    gameState.currentSet++;
                    startLevel(1);
                } else if (gameState.currentStage < 5) {
                    gameState.currentStage++;
                    gameState.currentSet = 1;
                    startLevel(1);
                } else {
                    showScreen('stage-screen');
                }
            } else {
                startLevel(gameState.currentLevel + 1);
            }
        }, 1500);
    } else {
        // If level wasn't completed perfectly, restart the same level
        setTimeout(() => {
            startLevel(gameState.currentLevel);
        }, 1500);
    }
}

function startGame() {
    requestFullScreen();
    
    // Initialize first level if no progress
    if (!gameState.unlockedSets[1] || !gameState.unlockedLevels['1_1']) {
        gameState.unlockedSets[1] = new Set([1]);
        gameState.unlockedLevels['1_1'] = new Set([1]);
        gameState.currentStage = 1;
        gameState.currentSet = 1;
        startLevel(1);  // This will now show the intro first
        return;
    }
    
    // Find furthest incomplete level
    const furthestPoint = findFurthestProgression();
    gameState.currentStage = furthestPoint.stage;
    gameState.currentSet = furthestPoint.set;
    startLevel(furthestPoint.level);  // This will now show the intro first
}

function showLevelIntro(levelId, setupCallback) {
    const curtain = document.querySelector('.curtain-overlay');
    const titleContainer = document.querySelector('.curtain-title');
    const stageTitle = titleContainer.querySelector('h1');
    const levelTitle = titleContainer.querySelector('h2');
    
    // Set the titles
    stageTitle.textContent = `Stage ${gameState.currentStage}`;
    levelTitle.textContent = `Level ${gameState.currentSet}-${levelId}`;
    
    // Drop curtain quickly
    curtain.style.transition = 'transform 0.3s cubic-bezier(0.2, 0, 0.4, 1)';
    curtain.style.transform = 'translateY(0)';
    
    // Show the titles quickly after curtain drops
    setTimeout(() => {
        titleContainer.classList.add('show');
        
        // IMPORTANT: Prepare the next screen while curtain is down
        setupCallback();
        
        // After holding for a moment, hide title and pull up curtain rapidly
        setTimeout(() => {
            titleContainer.classList.remove('show');
            curtain.style.transition = 'transform 0.2s cubic-bezier(0.6, 0, 0.8, 1)';
            curtain.style.transform = 'translateY(-100%)';
        }, 1200); // Slightly shorter hold time
    }, 200);
}

const customPracticeLists = {
    lists: [],
    currentList: null,
    maxLists: 5
};

// Function to add a new word list
function addCustomWordList(name = null) {
    // Check if we've reached the maximum number of lists
    if (customPracticeLists.lists.length >= customPracticeLists.maxLists) {
        alert(`You can only create up to ${customPracticeLists.maxLists} custom lists.`);
        return null;
    }

    // Generate a default name if not provided
    if (!name) {
        name = `List ${customPracticeLists.lists.length + 1}`;
    }

    const newList = {
        id: Date.now(),
        name: name,
        words: [],
        translations: []
    };

    customPracticeLists.lists.push(newList);
    saveCustomLists();
    return newList;
}

// Function to translate a single word using MyMemory Translation API
function translateWord(word) {
    const apiUrl = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(word)}&langpair=en|he`;
    
    return fetch(apiUrl)
        .then(response => response.json())
        .then(data => {
            // Extract translation, fallback to original word if translation fails
            return data.responseData.translatedText || word;
        })
        .catch(() => word);
}



// Function to delete a word from the translation list
function deleteWord(button) {
    button.closest('.word-translation-item').remove();
}



function addNewWord() {
    const wordList = document.getElementById('word-translation-list');
    if (!wordList) return;
    
    const wordItem = document.createElement('div');
    wordItem.className = 'word-translation-item';
    wordItem.draggable = true;
    
    wordItem.innerHTML = `
        <div class="drag-handle">
            <i class="fas fa-grip-vertical"></i>
        </div>
        <span class="source-word" contenteditable="true"></span>
        <input type="text" class="target-word" placeholder="Hebrew translation">
        <button class="delete-word-btn" onclick="deleteWord(this)">❌</button>
    `;
    
    wordList.appendChild(wordItem);
    
    // Focus on the new source word field
    const sourceWord = wordItem.querySelector('.source-word');
    sourceWord.focus();
    
    // Initialize drag functionality for the new item
    initializeDragAndDrop(wordItem);
}

function makeWordListDraggable(listId) {
    const wordList = document.getElementById(`list-${listId}`);
    if (!wordList) return;
    
    // Add dragover event listener to the container
    wordList.addEventListener('dragover', e => {
        e.preventDefault();
        const draggable = wordList.querySelector('.dragging');
        if (!draggable) return;
        
        const afterElement = getDragAfterElement(wordList, e.clientY);
        if (afterElement) {
            wordList.insertBefore(draggable, afterElement);
        } else {
            wordList.appendChild(draggable);
        }
    });

    wordList.addEventListener('drop', e => {
        e.preventDefault();
        const draggingElement = document.querySelector('.dragging');
        if (draggingElement) {
            draggingElement.style.opacity = '1';
            draggingElement.classList.remove('dragging');
        }
    });

    // Initialize drag events for all items
    const items = wordList.querySelectorAll('.word-translation-item');
    items.forEach(item => initializeDragAndDrop(item));
}

function createWordTranslationItem(word = '', translation = '', isEditable = false) {
    const wordList = document.getElementById('word-translation-list');
    const wordItem = document.createElement('div');
    wordItem.className = 'word-translation-item';
    wordItem.draggable = true;
    wordItem.innerHTML = `
        <div class="drag-handle">
            <i class="fas fa-grip-vertical"></i>
        </div>
        <span class="source-word ${isEditable ? 'editable' : ''}" 
              contenteditable="${isEditable}">${word}</span>
        <input 
            type="text" 
            class="target-word ${isEditable ? 'editable' : ''}"
            value="${translation}" 
            data-original="${translation}"
            ${isEditable ? '' : 'readonly'}
            placeholder="Hebrew translation"
        >
        <button class="delete-word-btn" onclick="deleteWord(this)">❌</button>
    `;
    wordList.appendChild(wordItem);
}


async function saveCustomList() {
    console.log('Saving custom list...'); // Debug log
    
    const session = await supabase.auth.getSession();
    if (!session.data.session) {
        alert('Please log in to save lists');
        return;
    }

    const userId = session.data.session.user.id;
    const listNameInput = document.getElementById('custom-list-name');
    const name = listNameInput.value.trim();
    
    if (!name) {
        alert('Please enter a list name');
        return;
    }

    const wordItems = document.querySelectorAll('.word-translation-item');
    const words = [];
    const translations = [];
    
    wordItems.forEach(item => {
        const word = item.querySelector('.source-word').textContent.trim();
        const translation = item.querySelector('.target-word').value.trim();
        if (word && translation) {
            words.push(word);
            translations.push(translation);
        }
    });

    if (words.length === 0) {
        alert('Please add at least one word');
        return;
    }

    try {
        console.log('Saving list with data:', { name, words, translations });

        const { data, error } = await supabase
            .from('custom_lists')
            .upsert({
                id: customPracticeLists.currentList?.id || undefined,
                created_by: userId,
                name: name,
                words: words,
                translations: translations
            });

        if (error) throw error;

        console.log('List saved successfully:', data);
        
        await loadCustomLists();
        showCustomListsManager();
        alert('List saved successfully!');

    } catch (error) {
        console.error('Error saving list:', error);
        alert('Failed to save list: ' + error.message);
    }
}

async function loadCustomLists() {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
        customPracticeLists.lists = [];
        updateListsDisplay();
        return;
    }

    try {
        const { data, error } = await supabase
            .from('custom_lists')
            .select('*')
            .eq('created_by', session.user.id)
            .order('created_at', { ascending: false });

        if (error) throw error;

        customPracticeLists.lists = data || [];
        updateListsDisplay();
        
    } catch (error) {
        console.error('Error loading lists:', error);
        customPracticeLists.lists = [];
        updateListsDisplay();
    }
}

async function initializeGame() {
    // Clear any existing state first
    gameState = initializeDefaultGameState();
    
    const { data: { session } } = await supabase.auth.getSession();
    
    if (session) {
        try {
            const loadedState = await loadProgress();
            // Only update state if we successfully loaded
            if (loadedState) {
                gameState = loadedState;
            }
        } catch (error) {
            console.error('Error initializing game:', error);
        }
    }
    
    updateAllCoinDisplays();
}

function processCustomWords() {
    const wordInput = document.getElementById('custom-word-input');
    const translationResults = document.getElementById('translation-results');
    const wordList = document.getElementById('word-translation-list');
    
    // Split and clean input words
    const words = wordInput.value
        .split(/[,\s\n]+/)
        .map(word => word.trim())
        .filter(word => word.length > 0);

    if (words.length === 0) {
        alert('Please enter at least one word.');
        return;
    }

    // Clear previous results
    wordList.innerHTML = '';
    translationResults.style.display = 'none';

    // Process each word
    words.forEach(word => {
        const wordItem = document.createElement('div');
        wordItem.className = 'word-translation-item';
        wordItem.draggable = true;
        
        wordItem.innerHTML = `
            <div class="drag-handle">
                <i class="fas fa-grip-vertical"></i>
            </div>
            <span class="source-word" contenteditable="true">${word}</span>
            <input type="text" class="target-word" placeholder="Hebrew translation">
            <button class="delete-word-btn" onclick="deleteWord(this)">❌</button>
        `;
        
        wordList.appendChild(wordItem);
    });
    
    translationResults.style.display = 'block';
    makeWordListDraggable();
}

async function deleteCustomList(listId) {
    if (!confirm('Are you sure you want to delete this list?')) return;

    try {
        const { error } = await supabase
            .from('custom_lists')
            .delete()
            .eq('id', listId);

        if (error) throw error;

        await loadCustomLists(); // Reload after deletion
        
    } catch (error) {
        console.error('Error deleting list:', error);
        alert('Failed to delete list');
    }
}

function initializeDragAndDrop(item) {
    const dragHandle = item.querySelector('.drag-handle');
    
    dragHandle.addEventListener('mousedown', () => {
        item.draggable = true;
    });
    
    dragHandle.addEventListener('mouseup', () => {
        item.draggable = false;
    });
    
    item.addEventListener('dragstart', () => {
        item.classList.add('dragging');
        item.style.opacity = '0.5';
    });
    
    item.addEventListener('dragend', () => {
        item.classList.remove('dragging');
        item.style.opacity = '1';
        item.draggable = false;
        
        // Save the new order immediately
        const listId = item.closest('.word-translation-list').id.split('-')[1];
        const listItem = document.querySelector(`.custom-list-item:has([data-list-id="${listId}"])`);
        const wordList = document.getElementById(`list-${listId}`);
        
        // Only save if in edit mode
        if (listItem.getAttribute('data-in-edit-mode') === 'true') {
            saveListChanges(listId, wordList, listItem, false);
        }
    });
}


async function saveCurrentList() {
    // ... previous validation code ...

    try {
        // First, check if a list with the same name already exists
        const { data: existingLists, error: checkError } = await supabase
            .from('custom_lists')
            .select('id')
            .eq('created_by', session.user.id)
            .eq('name', name);

        if (checkError) throw checkError;

        if (existingLists && existingLists.length > 0) {
            // List with this name already exists
            const confirmOverwrite = confirm('A list with this name already exists. Do you want to replace it?');
            if (!confirmOverwrite) return;

            // Delete existing list
            const { error: deleteError } = await supabase
                .from('custom_lists')
                .delete()
                .eq('created_by', session.user.id)
                .eq('name', name);

            if (deleteError) throw deleteError;
        }

        // Insert the new list
        const { data, error } = await supabase
            .from('custom_lists')
            .insert({
                created_by: session.user.id,
                name: name,
                words: words,
                translations: translations,
                is_public: false  // Default to private
            });

        if (error) throw error;

        // ... rest of the success handling code ...

    } catch (error) {
        console.error('Error saving list:', error);
        alert('Failed to save list: ' + error.message);
    }
}

function updateListsDisplay() {
    const container = document.getElementById('custom-lists-container');
    if (!container) return;

    container.innerHTML = '';

    if (customPracticeLists.lists.length === 0) {
        container.innerHTML = '<p style="color: white; text-align: center;">No custom lists created yet. Create your first list!</p>';
        return;
    }

    customPracticeLists.lists.forEach(list => {
        const listItem = document.createElement('div');
        listItem.className = 'custom-list-item';
        listItem.innerHTML = `
            <h3>${list.name}</h3>
            <p>${list.words.length} words</p>
            <div class="list-actions">
                <button onclick="startCustomListPractice(${list.id})">Practice</button>
                <button onclick="editCustomList(${list.id})">Edit</button>
                <button onclick="deleteCustomList(${list.id})">Delete</button>
            </div>
        `;
        container.appendChild(listItem);
    });
}

function startCustomListPractice(listId) {
    const list = customPracticeLists.lists.find(l => l.id === listId);
    if (!list) return;

    currentGame = {
        words: list.words,
        translations: list.translations,
        currentIndex: 0,
        correctAnswers: 0,
        firstAttempt: true,
        isCustomPractice: true,
        startingCoins: gameState.coins,
        startingPerks: { ...gameState.perks },
        practiceState: {
            currentLevel: 1,
            words: list.words,
            translations: list.translations,
            unlockedLevels: new Set([1]),
            progress: {},
            maxLevel: 10,
            listId: listId
        }
    };

    startCustomLevel(1, currentGame.practiceState);
}




function calculateCustomLevelWords(level, practiceState) {
    const { words, translations } = practiceState;
    
    const levelConfigs = {
        1: { start: 0, count: 3, isTest: false },
        2: { start: 3, count: 3, isTest: false },
        3: { start: 0, count: 6, isTest: true },
        4: { start: 6, count: 3, isTest: false },
        5: { start: 9, count: 3, isTest: false },
        6: { start: 6, count: 6, isTest: true },
        7: { start: 12, count: 4, isTest: false },
        8: { start: 16, count: 4, isTest: false },
        9: { start: 12, count: 8, isTest: true },
        10: { start: 0, count: 20, isTest: true, isFinal: true }
    };

    const config = levelConfigs[level];
    if (!config) return null;

    return {
        words: words.slice(config.start, config.start + config.count),
        translations: translations.slice(config.start, config.start + config.count),
        isTest: config.isTest,
        isFinal: config.isFinal
    };
}

function startCustomLevel(levelId, practiceState) {
    const levelData = calculateCustomLevelWords(levelId, practiceState);
    if (!levelData) return;

    currentGame = {
        words: levelData.words,
        translations: levelData.translations,
        currentIndex: 0,
        correctAnswers: 0,
        firstAttempt: true,
        isHebrewToEnglish: levelData.isTest ? Math.random() < 0.5 : false,
        mixed: levelData.isTest,
        speedChallenge: false,
        practiceState: practiceState,
        currentCustomLevel: levelId,
        isCustomPractice: true,
        startingCoins: gameState.coins,
        startingPerks: { ...gameState.perks },
        timeBonus: 0,
        initialTimeRemaining: null,
        streakBonus: true,
        levelStartTime: Date.now(),
        questionStartTime: 0,
        wrongStreak: 0,
        progressLost: 0
    };

    showLevelIntro(levelId, () => {
        showScreen('question-screen');
        updateProgressCircle();
        loadNextQuestion();
        startTimer(currentGame.words.length * 10); // 10 seconds per word
    });
}

function showCustomListsManager() {
    if (window.innerWidth <= 768) {
        return;
    }

    showScreen('custom-practice-screen');
    
    const container = document.getElementById('custom-lists-container');
    if (!container) return;
    
    container.innerHTML = '';
    loadCustomLists();
    
    if (customPracticeLists.lists.length === 0) {
        container.innerHTML = '<p style="color: white; text-align: center;">No custom lists created yet. Create your first list!</p>';
        return;
    }

    // Global action buttons
    const globalActions = document.createElement('div');
    globalActions.className = 'global-list-actions';
    globalActions.innerHTML = `
        <div class="global-buttons">
            <button id="practice-selected-btn" class="custom-outline-btn" onclick="practiceSelectedList()" disabled>Practice</button>
            <button id="edit-selected-btn" class="custom-outline-btn" onclick="editSelectedList()" disabled>Edit</button>
            <button id="delete-selected-btn" class="custom-outline-btn" onclick="deleteSelectedList()" disabled>Delete</button>
        </div>
    `;
    container.appendChild(globalActions);

    // List selection container
    const listSelectionContainer = document.createElement('div');
    listSelectionContainer.className = 'list-selection-container';

    customPracticeLists.lists.forEach(list => {
        const listItem = document.createElement('div');
        listItem.className = 'custom-list-item';
        listItem.dataset.listId = list.id;
        listItem.innerHTML = `
            <div class="list-content">
                <h3 class="list-name">${list.name}</h3>
                <div class="list-summary">
                    <span>${list.words.length} words</span>
                    <p class="word-preview">${list.words.join(', ')}</p>
                </div>
            </div>
        `;
        
        listItem.addEventListener('click', () => selectList(list.id));
        listSelectionContainer.appendChild(listItem);
    });

    container.appendChild(listSelectionContainer);
}

function hideMobileBlock() {
    const mobileBlockOverlay = document.getElementById('mobile-block-overlay');
    mobileBlockOverlay.style.display = 'none';
}

let selectedListId = null;

function selectList(listId) {
    // Remove selection from all lists
    document.querySelectorAll('.custom-list-item').forEach(item => {
        item.classList.remove('selected');
    });

    // Select the clicked list
    const selectedListElement = document.querySelector(`.custom-list-item[data-list-id="${listId}"]`);
    selectedListElement.classList.add('selected');
    selectedListId = listId;

    // Enable global action buttons
    const practiceBtn = document.getElementById('practice-selected-btn');
    const editBtn = document.getElementById('edit-selected-btn');
    const deleteBtn = document.getElementById('delete-selected-btn');

    practiceBtn.disabled = false;
    editBtn.disabled = false;
    deleteBtn.disabled = false;
}

function practiceSelectedList() {
    if (!selectedListId) return;
    startCustomListPractice(selectedListId);
}

function editSelectedList() {
    if (!selectedListId) return;
    editCustomList(selectedListId);
}

function deleteSelectedList() {
    if (!selectedListId) return;
    
    if (confirm('Are you sure you want to delete this list?')) {
        customPracticeLists.lists = customPracticeLists.lists.filter(l => l.id !== selectedListId);
        saveCustomLists();
        showCustomListsManager();
        selectedListId = null;
    }
}


function toggleListCollapse(listId) {
    const listItem = document.querySelector(`.custom-list-item:has([data-list-id="${listId}"])`);
    const editButton = listItem.querySelector('.edit-button');
    
    if (editButton.textContent === 'Save') {
        // Don't toggle if in edit mode
        return;
    }
    
    listItem.classList.toggle('collapsed');
}

function toggleEditMode(listId) {
    const listItem = document.querySelector(`.custom-list-item:has([data-list-id="${listId}"])`);
    const editButton = listItem.querySelector('.edit-button');
    const wordList = document.getElementById(`list-${listId}`);
    
    if (editButton.textContent === 'Edit') {
        // Enter edit mode
        editButton.textContent = 'Save';
        listItem.classList.remove('collapsed');
        listItem.setAttribute('data-in-edit-mode', 'true');
        
        // Load editable word list
        const list = customPracticeLists.lists.find(l => l.id === listId);
        wordList.innerHTML = '';
        
        list.words.forEach((word, index) => {
            const wordItem = document.createElement('div');
            wordItem.className = 'word-translation-item';
            wordItem.draggable = true;
            
            wordItem.innerHTML = `
                <div class="drag-handle">
                    <i class="fas fa-grip-vertical"></i>
                </div>
                <span class="source-word" contenteditable="true">${word}</span>
                <input type="text" class="target-word" value="${list.translations[index]}" placeholder="Hebrew translation">
                <button class="delete-word-btn" onclick="deleteWord(this)">❌</button>
            `;
            
            wordList.appendChild(wordItem);
        });
        
        // Initialize drag functionality
        makeWordListDraggable(listId);
    } else {
        // Save changes
        listItem.removeAttribute('data-in-edit-mode');
        saveListChanges(listId, wordList, listItem);
    }
}

function editCustomList(listId) {
    const list = customPracticeLists.lists.find(l => l.id === listId);
    if (!list) return;
    
    // Switch to custom practice screen
    showScreen('custom-practice-screen');
    
    // Set the list name
    const listNameInput = document.getElementById('custom-list-name');
    listNameInput.value = list.name;
    
    // Clear word input and translation results
    const wordInput = document.getElementById('custom-word-input');
    wordInput.value = '';
    
    // Show translation results section
    const translationResults = document.getElementById('translation-results');
    const wordList = document.getElementById('word-translation-list');
    
    // Clear previous translations
    wordList.innerHTML = '';
    
    // Create translation items for each word
    list.words.forEach((word, index) => {
        const wordItem = document.createElement('div');
        wordItem.className = 'word-translation-item';
        wordItem.draggable = true;
        
        wordItem.innerHTML = `
            <div class="drag-handle">
                <i class="fas fa-grip-vertical"></i>
            </div>
            <span class="source-word" contenteditable="true">${word}</span>
            <input type="text" class="target-word" value="${list.translations[index]}" placeholder="Hebrew translation">
            <button class="delete-word-btn" onclick="deleteWord(this)">❌</button>
        `;
        
        wordList.appendChild(wordItem);
    });
    
    translationResults.style.display = 'block';
    customPracticeLists.currentList = list;
    
    // Initialize drag functionality after adding all items
    makeWordListDraggable();
}


function loadCustomList(listId) {
    const list = customPracticeLists.lists.find(l => l.id === listId);
    if (!list) return;

    customPracticeLists.currentList = list;

    // Populate word input area
    const wordInput = document.getElementById('custom-word-input');
    wordInput.value = list.words.join(', ');

    // Populate list name
    const listNameInput = document.getElementById('custom-list-name');
    listNameInput.value = list.name;

    // Trigger translation process to show the words
    processCustomWords();

    // Show the practice screen
    showScreen('custom-practice-screen');
}

function deleteCustomList(listId) {
    // Confirmation before deletion
    if (!confirm('Are you sure you want to delete this list?')) return;

    // Immediately remove the list
    customPracticeLists.lists = customPracticeLists.lists.filter(l => l.id !== listId);
    
    // Save updated lists
    saveCustomLists();
    
    // Refresh the lists view
    showCustomListsManager();
}

// Initialize custom lists on page load
window.addEventListener('load', () => {
    loadCustomLists();
});

function addWordToList(listId) {
    const listElement = document.getElementById(`list-${listId}`);
    const listItem = document.querySelector(`.custom-list-item:has([data-list-id="${listId}"])`);
    const editButton = listItem.querySelector('.edit-button');
    
    // Only add word if in edit mode
    if (editButton.textContent !== 'Save') return;

    const wordItem = document.createElement('div');
    wordItem.className = 'word-translation-item';
    wordItem.draggable = true;
    
    wordItem.innerHTML = `
        <div class="drag-handle">
            <i class="fas fa-grip-vertical"></i>
        </div>
        <span class="source-word" contenteditable="true"></span>
        <input type="text" class="target-word" placeholder="Hebrew translation">
        <button class="delete-word-btn" onclick="deleteWord(this)">❌</button>
    `;
    
    // Add at the top of the list
    if (listElement.firstChild) {
        listElement.insertBefore(wordItem, listElement.firstChild);
    } else {
        listElement.appendChild(wordItem);
    }
    
    // Make the new item draggable
    initializeDragAndDrop(wordItem);
    
    // Focus on the new word input
    const sourceWord = wordItem.querySelector('.source-word');
    sourceWord.focus();
}

function makeWordListDraggable(listId) {
    const wordList = document.getElementById(`list-${listId}`);
    if (!wordList) return;
    
    // Clear existing listeners
    wordList.replaceWith(wordList.cloneNode(true));
    
    // Get fresh reference after clone
    const freshList = document.getElementById(`list-${listId}`);
    
    freshList.addEventListener('dragover', e => {
        e.preventDefault();
        const draggable = document.querySelector('.dragging');
        if (!draggable) return;
        
        const afterElement = getDragAfterElement(freshList, e.clientY);
        if (afterElement) {
            freshList.insertBefore(draggable, afterElement);
        } else {
            freshList.appendChild(draggable);
        }
    });
    
    // Initialize drag events for all items
    const items = freshList.querySelectorAll('.word-translation-item');
    items.forEach(item => initializeDragAndDrop(item));
}

function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.word-translation-item:not(.dragging)')];
    
    const result = draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY });

    return result ? result.element : null;
}


function toggleEditMode(listId) {
    const listItem = document.querySelector(`.custom-list-item:has([data-list-id="${listId}"])`);
    const editButton = listItem.querySelector('.edit-button');
    const wordList = document.getElementById(`list-${listId}`);
    
    if (editButton.textContent === 'Edit') {
        // Enter edit mode
        editButton.textContent = 'Save';
        listItem.classList.remove('collapsed');
        
        // Load editable word list
        const list = customPracticeLists.lists.find(l => l.id === listId);
        wordList.innerHTML = '';
        
        list.words.forEach((word, index) => {
            const wordItem = document.createElement('div');
            wordItem.className = 'word-translation-item';
            wordItem.draggable = true;
            
            wordItem.innerHTML = `
                <div class="drag-handle">
                    <i class="fas fa-grip-vertical"></i>
                </div>
                <span class="source-word" contenteditable="true">${word}</span>
                <input type="text" class="target-word" value="${list.translations[index]}" placeholder="Hebrew translation">
                <button class="delete-word-btn" onclick="deleteWord(this)">❌</button>
            `;
            
            wordList.appendChild(wordItem);
        });
        
        // Initialize drag functionality
        makeWordListDraggable(listId);
    } else {
        // Save changes
        saveListChanges(listId, wordList, listItem);
    }
}

function saveListChanges(listId, wordList, listItem, shouldCollapse = true) {
    const list = customPracticeLists.lists.find(l => l.id === parseInt(listId));
    if (!list) return;
    
    const items = wordList.querySelectorAll('.word-translation-item');
    const editButton = listItem.querySelector('.edit-button');
    
    list.words = [];
    list.translations = [];
    
    items.forEach(item => {
        const word = item.querySelector('.source-word').textContent.trim();
        const translation = item.querySelector('.target-word').value.trim();
        
        // Only save if at least one field has content
        if (word || translation) {
            list.words.push(word || '');
            list.translations.push(translation || '');
        }
    });
    
    saveCustomLists();
    
    if (editButton) {
        editButton.textContent = 'Edit';
        listItem.removeAttribute('data-in-edit-mode');
        
        if (shouldCollapse) {
            listItem.classList.add('collapsed');
        }
    }
    
    // Update summary
    const summary = listItem.querySelector('.list-summary');
    if (summary) {
        summary.innerHTML = `
            <span>${list.words.length} words</span>
            <p class="word-preview">${list.words.join(', ')}</p>
        `;
    }
}

function makeListNameEditable(listId) {
    const listItem = document.querySelector(`.custom-list-item:has([data-list-id="${listId}"])`);
    const titleH3 = listItem.querySelector('h3');
    const currentName = titleH3.textContent;
    
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'list-name-editable';
    input.value = currentName;
    
    input.onkeydown = (e) => {
        if (e.key === 'Enter') {
            saveListName(listId, input.value);
            input.blur();
        } else if (e.key === 'Escape') {
            input.value = currentName;
            input.blur();
        }
    };
    
    input.onblur = () => {
        saveListName(listId, input.value);
    };
    
    titleH3.replaceWith(input);
    input.focus();
    input.select();
}

function saveListName(listId, newName) {
    const list = customPracticeLists.lists.find(l => l.id === parseInt(listId));
    if (!list) return;
    
    const listItem = document.querySelector(`.custom-list-item:has([data-list-id="${listId}"])`);
    const input = listItem.querySelector('.list-name-editable');
    
    // Use existing name if new name is empty
    newName = newName.trim() || list.name;
    list.name = newName;
    
    // Create new h3 element
    const h3 = document.createElement('h3');
    h3.textContent = newName;
    h3.onclick = () => makeListNameEditable(listId);
    
    // Replace input with h3
    input.replaceWith(h3);
    saveCustomLists();
}

function initializeListDragging() {
    const container = document.getElementById('custom-lists-container');
    const items = container.querySelectorAll('.custom-list-item');
    
    items.forEach(item => {
        item.draggable = true;
        
        item.addEventListener('dragstart', () => {
            item.classList.add('dragging');
        });
        
        item.addEventListener('dragend', () => {
            item.classList.remove('dragging');
            saveListOrder();
        });
    });
    
    container.addEventListener('dragover', e => {
        e.preventDefault();
        const afterElement = getDragAfterList(container, e.clientY);
        const draggable = document.querySelector('.custom-list-item.dragging');
        if (draggable == null) return;
        
        if (afterElement == null) {
            container.appendChild(draggable);
        } else {
            container.insertBefore(draggable, afterElement);
        }
    });
}

function getDragAfterList(container, y) {
    const draggableElements = [...container.querySelectorAll('.custom-list-item:not(.dragging)')];
    
    const result = draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY });

    return result ? result.element : null;
}

function saveListOrder() {
    const container = document.getElementById('custom-lists-container');
    const items = container.querySelectorAll('.custom-list-item');
    const newOrder = [];
    
    items.forEach(item => {
        const listId = parseInt(item.querySelector('[data-list-id]').dataset.listId);
        const list = customPracticeLists.lists.find(l => l.id === listId);
        if (list) newOrder.push(list);
    });
    
    customPracticeLists.lists = newOrder;
    saveCustomLists();
}

// Enhance mobile interactions
function addMobileInputSupport() {
    const wordInput = document.getElementById('custom-word-input');
    const processButton = document.querySelector('.process-words-btn');
    
    // Improve mobile keyboard support
    wordInput.addEventListener('focus', () => {
        // Ensure the input is fully visible on mobile
        setTimeout(() => {
            wordInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 300);
    });

    // Add support for mobile word entry
    wordInput.addEventListener('input', (e) => {
        // Automatically resize textarea based on content
        e.target.style.height = 'auto';
        e.target.style.height = `${e.target.scrollHeight}px`;
    });
}

// Call when the page loads
window.addEventListener('load', addMobileInputSupport);

function makeNameEditable(event, listId) {
    event.stopPropagation(); // Prevent list collapse when clicking name
    const nameElement = event.target;
    const currentName = nameElement.textContent;
    
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'list-name-input';
    input.value = currentName;
    
    input.onkeydown = (e) => {
        if (e.key === 'Enter') {
            const newName = input.value.trim() || currentName;
            saveListName(listId, newName, nameElement);
        } else if (e.key === 'Escape') {
            // Restore original name without saving
            const h3 = document.createElement('h3');
            h3.textContent = currentName;
            h3.className = 'list-name';
            h3.onclick = (e) => makeNameEditable(e, listId);
            input.replaceWith(h3);
        }
        e.stopPropagation();
    };
    
    input.onblur = () => {
        const newName = input.value.trim() || currentName;
        saveListName(listId, newName, nameElement);
    };
    
    nameElement.replaceWith(input);
    input.focus();
    input.select();
}

function saveListName(listId, newName, originalElement) {
    const list = customPracticeLists.lists.find(l => l.id === listId);
    if (!list) return;
    
    if (newName) {
        list.name = newName;
        saveCustomLists();
    }
    
    const nameElement = document.createElement('h3');
    nameElement.textContent = list.name;
    nameElement.className = 'list-name';
    nameElement.onclick = (e) => makeNameEditable(e, listId);
    
    const input = document.querySelector('.list-name-input');
    if (input) {
        input.replaceWith(nameElement);
    } else {
        // Fallback to replacing the original element if input not found
        originalElement.textContent = list.name;
    }
}


function findFurthestProgression() {
    // Look through all stages
    for (let stage = 1; stage <= 5; stage++) {
        if (!gameState.unlockedSets[stage]) continue;
        
        const sets = Array.from(gameState.unlockedSets[stage]).sort((a, b) => b - a);
        if (!sets.length) continue;  // Skip if no sets found
        
        // For each set in the stage
        for (const set of sets) {
            const setKey = `${stage}_${set}`;
            const levels = gameState.unlockedLevels[setKey];
            
            if (!levels || !levels.size) continue;  // Skip if no levels or empty set
            
            // Get all levels in ascending order
            const levelArray = Array.from(levels).sort((a, b) => a - b);
            if (!levelArray.length) continue;  // Skip if no levels found
            
            const maxLevel = Math.max(...levelArray);
            
            // Find the first incomplete level in this set
            for (let level = 1; level <= maxLevel + 1; level++) {
                if (!gameState.perfectLevels.has(`${stage}_${set}_${level}`)) {
                    return {
                        stage: stage,
                        set: set,
                        level: level
                    };
                }
            }
        }
    }
    
    // If no incomplete level found, return stage 1, set 1, level 1
    return { stage: 1, set: 1, level: 1 };
}

function toggleAuthForm(type) {
    const loginForm = document.getElementById('login-form');
    const signupForm = document.getElementById('signup-form');
    
    if (type === 'login') {
        loginForm.style.display = 'flex';
        signupForm.style.display = 'none';
    } else {
        loginForm.style.display = 'none';
        signupForm.style.display = 'flex';
    }
}

function handleSkipAuth() {
    // Set user as guest in game state
    gameState.userType = 'guest';
    showScreen('welcome-screen');
}

window.onload = async () => {
    console.log('Page loaded'); // Debug log
    
    initializeGame();
    updatePerkCounts();
    
    // Check for existing session
    const { data: { session } } = await supabase.auth.getSession();
    console.log('Initial session check:', session); // Debug log
    
    if (session) {
        await loadUserData();
        showScreen('welcome-screen');
    } else {
        showScreen('auth-screen');
    }

    supabase.auth.onAuthStateChange(async (event, session) => {
    if (event === 'SIGNED_IN') {
        await initializeGame();
        showScreen('welcome-screen');
    } else if (event === 'SIGNED_OUT') {
        // Clear state on sign out
        gameState = initializeDefaultGameState();
        showScreen('auth-screen');
    }
});
};

// And modify your showScreen function to ensure it can handle the auth screen
function showScreen(screenId) {
    // Remove visible class from all screens
    document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('visible');
        
        // Remove existing particle containers
        const existingParticleContainer = screen.querySelector('.particle-container');
        if (existingParticleContainer) {
            existingParticleContainer.remove();
        }
    });

    // Get the target screen
    const screenElement = document.getElementById(screenId);
    if (screenElement) {
        screenElement.classList.add('visible');
        
        // Add particles to the current screen
        initializeParticles(screenElement);
    }
}

// Right after your supabase initialization
async function handleLogin() {
    const email = document.getElementById('login-email').value;
    const password = document.getElementById('login-password').value;
    
    try {
        const { data, error } = await supabase.auth.signInWithPassword({
            email,
            password
        });
        
        if (error) throw error;
        
        // Let the auth state listener handle the navigation
        // Do not call showScreen here
        
    } catch (error) {
        console.error('Login error:', error);
        alert('Error logging in: ' + error.message);
    }
}

async function handleSignup() {
    const email = document.getElementById('signup-email').value;
    const password = document.getElementById('signup-password').value;
    const role = document.getElementById('signup-role').value;
    
    if (!email || !password || !role) {
        alert('Please fill in all fields');
        return;
    }

    try {
        const { data, error: signupError } = await supabase.auth.signUp({
            email,
            password,
            options: {
                data: { 
                    role: role,
                    user_type: role
                }
            }
        });

        if (signupError) {
            console.error('Signup Error:', signupError);
            alert(`Signup failed: ${signupError.message}`);
            return;
        }

        if (data.user) {
            // Create profile
            const { error: profileError } = await supabase
                .from('profiles')
                .upsert({
                    id: data.user.id,
                    user_type: role
                });

            if (profileError) {
                console.error('Profile Creation Error:', profileError);
                alert(`Profile creation failed: ${profileError.message}`);
                return;
            }

            // Attempt immediate login
            const { error: loginError } = await supabase.auth.signInWithPassword({
                email,
                password
            });

            if (loginError) {
                console.error('Login Error:', loginError);
                alert(`Login failed: ${loginError.message}`);
                return;
            }

            // Success: navigate to welcome screen
            showScreen('welcome-screen');
        }
    } catch (error) {
        console.error('Unexpected Signup Error:', error);
        alert('An unexpected error occurred during signup');
    }
}

async function checkAuth() {
    try {
        const { data: { session }, error } = await supabase.auth.getSession();
        
        if (error) throw error;

        if (session) {
            return true;
        }
        
        return false;
    } catch (error) {
        console.error('Auth check error:', error);
        return false;
    }
}

async function handleLogout() {
    try {
        const { error } = await supabase.auth.signOut();
        if (error) throw error;

        // Reset gameState by modifying existing object properties
        Object.keys(gameState).forEach(key => {
            if (key === 'perks') {
                gameState.perks = {
                    timeFreeze: 0,
                    skip: 0,
                    clue: 0,
                    reveal: 0
                };
            } else if (key === 'perfectLevels' || key === 'completedLevels') {
                gameState[key] = new Set();
            } else if (key === 'unlockedSets' || key === 'unlockedLevels') {
                gameState[key] = {};
            } else {
                gameState[key] = null;
            }
        });

        // Reset to initial state
        gameState.unlockedSets[1] = new Set([1]);
        gameState.unlockedLevels['1_1'] = new Set([1]);
        gameState.coins = 0;

        // Clear custom lists state
        customPracticeLists.lists = [];
        customPracticeLists.currentList = null;

        // Show auth screen
        showScreen('auth-screen');

    } catch (error) {
        console.error('Error logging out:', error);
    }
}

function resetLogoutState() {
    // Clear local storage
    localStorage.removeItem('simploxSession');
    localStorage.removeItem('simploxProgress');
    
    // Reset current user
    currentUser = null;
    
    // Reset game state
    initializeGame();
    
    // Return to auth screen
    showScreen('auth-screen');
}


// Authentication Functions
async function handleSignup() {
    const email = document.getElementById('signup-email').value;
    const password = document.getElementById('signup-password').value;
    const role = document.getElementById('signup-role').value;
    
    if (!email || !password || !role) {
        alert('Please fill in all fields');
        return;
    }

    try {
        const { data, error: signupError } = await supabase.auth.signUp({
            email,
            password,
            options: {
                data: { 
                    role: role,
                    user_type: role
                }
            }
        });

        if (signupError) {
            console.error('Signup Error:', signupError);
            alert(`Signup failed: ${signupError.message}`);
            return;
        }

        if (data.user) {
            // Create profile
            const { error: profileError } = await supabase
                .from('profiles')
                .upsert({
                    id: data.user.id,
                    user_type: role
                });

            if (profileError) {
                console.error('Profile Creation Error:', profileError);
                alert(`Profile creation failed: ${profileError.message}`);
                return;
            }

            // Attempt immediate login
            const { error: loginError } = await supabase.auth.signInWithPassword({
                email,
                password
            });

            if (loginError) {
                console.error('Login Error:', loginError);
                alert(`Login failed: ${loginError.message}`);
                return;
            }

            // Success: navigate to welcome screen
            showScreen('welcome-screen');
        }
    } catch (error) {
        console.error('Unexpected Signup Error:', error);
        alert('An unexpected error occurred during signup');
    }
}

async function handleLogin() {
    const email = document.getElementById('login-email').value;
    const password = document.getElementById('login-password').value;
    
    try {
        const { error } = await supabase.auth.signInWithPassword({
            email,
            password
        });
        
        if (!error) {
            showScreen('welcome-screen');
        }

    } catch (error) {
        console.error('Login error:', error);
    }
}

async function handleLogout() {
    try {
        const { error } = await supabase.auth.signOut();
        if (error) throw error;

        // Clear local storage
        localStorage.removeItem('simploxSession');
        localStorage.removeItem('simploxProgress');

        // Reset game state
        initializeGame();
        
        // Return to auth screen
        showScreen('auth-screen');

    } catch (error) {
        console.error('Error logging out:', error.message);
        alert(error.message);
    }
}

async function loadUserData() {
    try {
        const { data: { session } } = await supabase.auth.getSession();
        console.log('Session data:', session); // Debug log
        
        if (session && session.user.email) {
            console.log('User email found:', session.user.email); // Debug log
            const emailDisplays = document.querySelectorAll('.user-email-display');
            emailDisplays.forEach(display => display.remove()); // Clear existing displays
            
            const emailDisplay = document.createElement('div');
            emailDisplay.className = 'user-email-display';
            emailDisplay.textContent = session.user.email;
            
            // Add to welcome screen
            const welcomeScreen = document.getElementById('welcome-screen');
            if (welcomeScreen) {
                const welcomeTitle = welcomeScreen.querySelector('.welcome-title');
                if (welcomeTitle) {
                    welcomeTitle.parentNode.insertBefore(emailDisplay, welcomeTitle);
                    console.log('Email display added to welcome screen'); // Debug log
                }
            }
        } else {
            console.log('No user email found in session'); // Debug log
        }
    } catch (error) {
        console.error('Error loading user data:', error);
    }
}

async function saveUserProgress() {
    const session = await supabase.auth.getSession();
    if (!session.data.session) return;

    try {
        const { error } = await supabase
            .from('user_progress')
            .upsert({
                user_id: session.data.session.user.id,
                coins: gameState.coins,
                unlocked_sets: gameState.unlockedSets,
                unlocked_levels: gameState.unlockedLevels,
                perfect_levels: Array.from(gameState.perfectLevels),
                completed_levels: Array.from(gameState.completedLevels),
                perks: gameState.perks,
                updated_at: new Date()
            });

        if (error) throw error;

    } catch (error) {
        console.error('Error saving progress:', error.message);
    }
}

let currentUser = null;

async function setupAuthListener() {
    supabase.auth.onAuthStateChange(async (event, session) => {
        console.log('Auth state change:', event);
        
        if (event === 'SIGNED_IN') {
            try {
                await initializeGame(); // Load game state first
                await loadCustomLists(); // Load custom lists
                showScreen('welcome-screen');
            } catch (error) {
                console.error('Error during sign in:', error);
            }
        } else if (event === 'SIGNED_OUT') {
            // Reset game state instead of reassigning gameState
            Object.assign(gameState, initializeDefaultGameState());
            customPracticeLists.lists = [];
            showScreen('auth-screen');
        }
    });
}

async function createTeacherList(name, description, words, translations) {
    try {
        const { data, error } = await supabase
            .from('teacher_lists')
            .insert([
                {
                    teacher_id: currentUser.id,
                    name,
                    description,
                    words,
                    translations
                }
            ]);

        if (error) throw error;
        return data;
    } catch (error) {
        console.error('Error creating teacher list:', error);
        throw error;
    }
}

async function assignListToStudents(listId, studentIds, dueDate) {
    try {
        const { data, error } = await supabase
            .from('class_assignments')
            .insert([
                {
                    teacher_id: currentUser.id,
                    list_id: listId,
                    student_ids: studentIds,
                    due_date: dueDate
                }
            ]);

        if (error) throw error;
        return data;
    } catch (error) {
        console.error('Error assigning list:', error);
        throw error;
    }
}

async function trackStudentProgress(assignmentId, score) {
    try {
        const { data, error } = await supabase
            .from('student_progress')
            .upsert([
                {
                    student_id: currentUser.id,
                    assignment_id: assignmentId,
                    completed: true,
                    score: score,
                    completed_at: new Date()
                }
            ]);

        if (error) throw error;
        return data;
    } catch (error) {
        console.error('Error tracking progress:', error);
        throw error;
    }
}

async function syncCustomLists() {
    if (!currentUser) return;

    try {
        // First, get all lists from Supabase
        const { data: remoteLists, error } = await supabase
            .from('teacher_lists')
            .select('*')
            .eq('teacher_id', currentUser.id);

        if (error) throw error;

        // Merge with local lists
        const localLists = JSON.parse(localStorage.getItem('simploxCustomLists') || '[]');
        
        // Create a map for quick lookup
        const remoteListMap = new Map(remoteLists.map(list => [list.id, list]));
        const localListMap = new Map(localLists.map(list => [list.id, list]));
        
        // Merge lists, preferring remote versions if they exist
        const mergedLists = [...new Set([...remoteListMap.keys(), ...localListMap.keys()])]
            .map(id => remoteListMap.get(id) || localListMap.get(id));

        // Update local storage
        localStorage.setItem('simploxCustomLists', JSON.stringify(mergedLists));
        
        return mergedLists;
    } catch (error) {
        console.error('Error syncing lists:', error);
        throw error;
    }
}

async function createUserProfile(userId, userType) {
    try {
        const { error } = await supabase
            .from('profiles')
            .insert({
                id: userId,
                user_type: userType,
                created_at: new Date(),
                updated_at: new Date()
            });

        if (error) throw error;
    } catch (error) {
        console.error('Error creating profile:', error);
        throw error;
    }
}

function updateWelcomeScreen() {
    console.log('Updating welcome screen');  // Debug log
    const welcomeScreen = document.getElementById('welcome-screen');
    
    // Remove any existing user info
    const existingUserInfo = welcomeScreen.querySelector('.user-sign-in-marker');
    if (existingUserInfo) {
        existingUserInfo.remove();
    }

    // Create and add user info if logged in
    if (currentUser && currentUser.email) {
        console.log('Current user found:', currentUser);  // Debug log
        const userMarker = document.createElement('div');
        userMarker.className = 'user-sign-in-marker';
        userMarker.innerHTML = `
            <div class="user-info-container">
                <i class="fas fa-user-circle user-icon"></i>
                <div class="user-details">
                    <span class="user-email">${currentUser.email}</span>
                    <span class="user-status">Signed In</span>
                </div>
            </div>
        `;
        
        // Add basic styling to ensure visibility
        userMarker.style.cssText = `
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: var(--glass);
            backdrop-filter: blur(10px);
            border-radius: 25px;
            padding: 0.75rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 10;
            color: var(--text);
        `;

        welcomeScreen.appendChild(userMarker);
        console.log('User marker added');  // Debug log
    } else {
        console.log('No current user found');  // Debug log
    }
}

function unlockNextLevel(isLastLevelInSet, isLastSetInStage) {
    if (!isLastLevelInSet) {
        const setKey = `${gameState.currentStage}_${gameState.currentSet}`;
        gameState.unlockedLevels[setKey].add(gameState.currentLevel + 1);
    } else if (!isLastSetInStage) {
        const nextSetKey = `${gameState.currentStage}_${gameState.currentSet + 1}`;
        if (!gameState.unlockedSets[gameState.currentStage]) {
            gameState.unlockedSets[gameState.currentStage] = new Set();
        }
        gameState.unlockedSets[gameState.currentStage].add(gameState.currentSet + 1);
        gameState.unlockedLevels[nextSetKey] = new Set([1]);
    } else if (gameState.currentStage < 5) {
        const nextStage = gameState.currentStage + 1;
        if (!gameState.unlockedSets[nextStage]) {
            gameState.unlockedSets[nextStage] = new Set([1]);
        }
        gameState.unlockedLevels[`${nextStage}_1`] = new Set([1]);
    }
}

function handleSetCompletion(isLastSetInStage) {
    if (!isLastSetInStage) {
        gameState.currentSet++;
        startLevel(1);
    } else if (gameState.currentStage < 5) {
        gameState.currentStage++;
        gameState.currentSet = 1;
        startLevel(1);
    } else {
        showScreen('stage-screen');
    }
}

</script>
</body>
</html>