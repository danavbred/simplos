<!DOCTYPE html>
<html lang="en" translate="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <title>Simplos</title>
    
    <!-- Fonts and Styles -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2.39.7"></script>
    <script src="vocabs.js"></script>
    <style>

:root {
  /* Update core color scheme */
  --primary-dark: #1a1a2e;  /* Keep dark base */
  --primary: #16213e;      /* Deep blue */
  --secondary: #0f3460;    /* Lapis lazuli */
  --accent: #1E90FF;       /* Bright lapis instead of pink */
  --text: #ffffff;         /* Keep white */
  --gold: #ffd700;        /* Keep gold */
  --silver: #c0c0c0;      /* Keep silver */
  --bronze: #cd7f32;      /* Keep bronze */
  --success: #4CAF50;     /* Keep success green */
  --error: #f44336;       /* Keep error red for warnings only */
  --gradient: linear-gradient(135deg, var(--secondary), var(--primary-dark));
  --glass: rgba(255, 255, 255, 0.1);
  --locked: #808080;

  /* New accent gradients */
  --royal-gradient: linear-gradient(135deg, var(--gold), var(--accent));
  --blue-gradient: linear-gradient(135deg, var(--secondary), var(--accent));
  --gold-gradient: linear-gradient(135deg, var(--gold), #ffa500);
}

/* Add to existing CSS, preferably in a mobile-specific section */
* {
    -webkit-tap-highlight-color: transparent; /* Removes flash on tap */
    -webkit-touch-callout: none; /* Prevents default touch actions */
    touch-action: manipulation; /* Improves touch responsiveness */
}

body, html {
    overscroll-behavior-y: contain; /* Prevents bounce effect on iOS */
    overflow-x: hidden;
    max-width: 100%;
    position: relative;
}

.screen {
    transition: opacity 0.3s ease-in-out; /* Smoother, shorter transition */
    opacity: 0;
}

.screen.visible {
    opacity: 1;
}


/* Update auth modal */
.auth-modal-content {
    background: var(--glass);
    border: 1px solid var(--accent);
}


/* Update side panel */
.side-panel {
    background: linear-gradient(135deg, 
        rgba(22, 33, 62, 0.95),
        rgba(15, 52, 96, 0.95)
    );
}

/* Update user profile section */
.user-profile-section {
    background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.05), 
        rgba(30, 144, 255, 0.05)
    );
    border: 1px solid rgba(30, 144, 255, 0.1);
}

/* Update status badges */
.status-badge.premium {
    background: var(--royal-gradient);
}

.status-badge.pending {
    background: var(--blue-gradient);
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Montserrat', sans-serif;
}

body {
  margin: 0;
  padding: 0;
  min-height: 100vh;
  background: var(--gradient);
  color: var(--text);
  overflow-x: hidden;
}

.screen {
  display: none;
  min-height: 100vh;
  padding: 2rem;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  background: radial-gradient(circle at center, var(--secondary) 0%, var(--primary-dark) 100%);
}

.screen.visible {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.5s ease-in-out;
}

.welcome-title {
  font-size: 4rem;
  font-weight: 700;
  margin-bottom: 2rem;
  background: linear-gradient(to right, var(--gold), var(--accent));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  text-shadow: 0 2px 10px rgba(0,0,0,0.2);
  animation: shimmer 2s infinite;
  font-size: 2.5rem;
  margin-bottom: 1.5rem;
}

/* Share modal styles */
.share-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--glass);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    z-index: 1000;
    width: 90%;
    max-width: 500px;
    animation: fadeIn 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
}
.share-modal-content {
    padding: 2rem;
}
.share-modal-header {
    color: var(--gold);
    margin-bottom: 1rem;
    font-size: 1.5rem;
    text-align: center;
}
.share-modal-description {
    margin-bottom: 1.5rem;
    opacity: 0.8;
    text-align: center;
}
.users-list {
    max-height: 300px;
    overflow-y: auto;
    margin: 1rem 0;
    padding-right: 5px;
}
.users-list::-webkit-scrollbar {
    width: 5px;
}
.users-list::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2);
    border-radius: 5px;
}
.user-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.75rem 1rem;
    margin: 0.5rem 0;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    transition: all 0.3s ease;
}
.user-item:hover {
    background: rgba(255, 255, 255, 0.15);
    transform: translateY(-2px);
}
.user-info {
    display: flex;
    align-items: center;
    gap: 0.75rem;
}
.user-info i {
    color: var(--gold);
    opacity: 0.8;
}
.modal-close {
    margin-top: 1.5rem;
    width: 100%;
}
.small-button {
    padding: 0.5rem 1rem;
    font-size: 0.85rem;
    min-width: 0;
    width: auto;
}
/* Updated share button style */
.start-button.share-with-user-btn {
    padding: 0.5rem 1rem;
    font-size: 0.8rem;
    background: rgba(255, 255, 255, 0.1);
    color: var(--text);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 20px;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}
.start-button.share-with-user-btn:hover {
    transform: translateY(-2px);
    background: var(--accent);
    box-shadow: 0 5px 15px rgba(30, 144, 255, 0.2);
}
.fade-out {
    opacity: 0;
    transition: opacity 0.3s ease;
}
@keyframes fadeIn {
    from { opacity: 0; transform: translate(-50%, -55%); }
    to { opacity: 1; transform: translate(-50%, -50%); }
}
@media (max-width: 768px) {
    .share-modal {
        width: 95%;
    }
    
    .user-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.75rem;
    }
    
    .user-item .main-button {
        width: 100%;
    }
}



.upgrade-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(5px);
    z-index: 1000;
}

.upgrade-form {
    width: 100%;
    max-width: 500px;
    padding: 2rem;
    background: var(--glass);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    text-align: right;
    direction: rtl;
}

.upgrade-form h2 {
    font-size: 1.5rem;
    font-weight: bold;
    text-align: center;
    margin-bottom: 1.5rem;
    background: linear-gradient(to right, var(--gold), var(--accent));
    -webkit-background-clip: text;
background-clip: text;
    -webkit-text-fill-color: transparent;
}

.form-group {
    margin-bottom: 1rem;
}

.form-group label {
    display: block;
    margin-bottom: 0.5rem;
    color: var(--text);
}

.form-group input[type="tel"],
.form-group select {
    width: 100%;
    padding: 0.75rem;
    border-radius: 25px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: var(--text);
}

.form-group input[type="checkbox"] {
    margin-right: 0.5rem;
}

.submit-button {
    width: 100%;
    padding: 1rem;
    border: 2px solid var(--accent);
    background: transparent;
    color: var(--text);
    border-radius: 25px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-top: 1rem;
}

.submit-button:hover {
    box-shadow: 0 0 15px var(--accent), 0 0 30px var(--accent);
}

.upgrade-form p {
    text-align: center;
    color: var(--text);
    margin-top: 1rem;
    font-size: 0.9rem;
    opacity: 0.8;
}

/* Maintain active state for auth tabs */
.auth-container {
    position: fixed;
    top: 20%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
    padding: 1rem 2rem;
    border-radius: 1rem;
    display: flex;
    gap: 1rem;
    align-items: center;
    z-index: 100;
    width: 90%;
    max-width: 320px; /* Added to ensure consistent width */
}


.auth-input:focus {
    border-color: var(--accent);
}

.auth-button:hover {
    background: rgba(233, 69, 96, 0.1);
}

@keyframes pulse-glow {
    0%, 100% { 
        box-shadow: 0 0 10px var(--accent), 0 0 5px var(--accent); 
        transform: translate(-50%, -50%) scale(1.02);
    }
    50% { 
        box-shadow: 0 0 20px var(--accent), 0 0 10px var(--accent); 
        transform: translate(-50%, -50%) scale(1.05);
    }
}

.auth-container.highlight {
    animation: pulse-glow 1.5s ease-in-out infinite;
    background: rgba(233, 69, 96, 0.1);
}

.auth-toggle {
    color: rgba(255, 255, 255, 0.6);
    font-size: 0.85rem;
    background: transparent;
    border: none;
    cursor: pointer;
    transition: color 0.3s ease;
}

.auth-toggle:hover {
    color: var(--text);
}

.user-info {
    position: fixed;
    top: 2rem;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    z-index: 100;
}

#userEmail {
    font-size: 1.5rem;
    color: var(--gold);
    margin-bottom: 0.5rem;
}

.student-mode {
    color: var(--text);
    font-size: 1rem;
    opacity: 0.8;
    display: block;
}


@media (max-width: 768px) {
    .auth-container {
        flex-direction: column;
        padding: 1rem;
        width: 90%;
        max-width: 320px;
    }

    .auth-input {
        width: 100%;
    }
}



.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
}

.modal-content {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--glass);
    padding: 2rem;
    border-radius: 20px;
    backdrop-filter: blur(10px);
    text-align: center;
}

#otpInput {
    padding: 1rem;
    margin: 1rem 0;
    background: rgba(255,255,255,0.1);
    border: none;
    border-radius: 10px;
    color: white;
    font-size: 1.2rem;
    text-align: center;
}

.leaderboard-entry .name {
    color: var(--gold);
}

.leaderboard-entry .words {
    color: var(--accent);
}

.leaderboard-entry .coins {
    color: var(--text);
}

.stage-selector {
    margin: 2rem 0;
    text-align: left;
    width: 100%;
}

.stage-checkboxes {
    display: flex;
    flex-wrap: wrap;
    gap: 1.5rem;
    margin: 1rem 0;
    justify-content: center;
}

.stage-checkboxes label {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    cursor: pointer;
    font-size: 1.2rem;
    padding: 1rem;
    background: rgba(255,255,255,0.1);
    border-radius: 15px;
    transition: all 0.3s ease;
}

.stage-checkboxes label:hover {
    background: rgba(255,255,255,0.2);
}

.stage-checkboxes input[type="checkbox"] {
    width: 24px;
    height: 24px;
    cursor: pointer;
}

.word-goal {
    margin: 2rem 0;
    text-align: center;
}

#wordGoal {
    padding: 0.75rem;
    border-radius: 10px;
    background: rgba(255,255,255,0.1);
    color: var(--text);
    border: 1px solid rgba(255,255,255,0.2);
    width: 120px;
    font-size: 1.1rem;
    text-align: center;
}

.navigation-button.initialize-button {
    background: var(--accent);
    color: var(--text);
}

.navigation-button.initialize-button:hover {
    filter: brightness(1.2);
}

/* Make leaderboard entries clickable for moderator */
.moderator .leaderboard-entry {
    cursor: pointer;
}

.moderator-header {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    margin-bottom: 2rem;
    padding: 2rem;
    background: var(--glass);
    border-radius: 20px;
    backdrop-filter: blur(10px);
}

.otp-display {
    font-size: 3rem;
    color: var(--gold);
    text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
    letter-spacing: 0.5rem;
    margin: 1rem 0;
    font-weight: bold;
}

.join-game-button {
    position: relative;
    padding: 0.875rem 2rem;
    border: 2px solid var(--accent);
    background: transparent;
    color: var(--text);
    border-radius: 50px;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-top: 2rem;
    animation: pulseGlow 1.5s ease-in-out infinite;
}

@keyframes pulseGlow {
    0%, 100% { 
        box-shadow: 0 0 10px var(--accent), 0 0 5px var(--accent); 
        transform: scale(1.02);
    }
    50% { 
        box-shadow: 0 0 20px var(--accent), 0 0 10px var(--accent); 
        transform: scale(1.05);
    }
}

.game-controls {
    display: flex;
    gap: 1rem;
    margin: 1rem 0;
}

.end-arcade-button {
    background: var(--error);
    color: var(--text);
    border: none;
    padding: 1rem 2rem;
    border-radius: 50px;
    font-size: 1.2rem;
    cursor: pointer;
    transition: all 0.3s ease;
    display: none;
}

.end-arcade-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(244, 67, 54, 0.4);
}

.end-arcade-button.visible {
    display: block;
    animation: fadeIn 0.3s ease-in-out;
}

.leaderboard-entry {
    display: grid;
    grid-template-columns: 1fr 3fr 1fr 1fr;
    align-items: center;
    padding: 1rem;
    margin-bottom: 0.5rem;
    background: rgba(255,255,255,0.05);
    border-radius: 10px;
    transition: all 0.3s ease;
    position: relative;
}

.leaderboard-entry > div {
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
}

.leaderboard-entry div[data-username] {
    font-weight: 600;
}

.leaderboard-entry div[data-words],
.leaderboard-entry div[data-coins] {
    justify-content: center;
    transition: color 0.3s ease;
}

.leaderboard-header {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr 1fr;
    padding: 1rem;
    background: rgba(255,255,255,0.1);
    border-radius: 10px;
    margin-bottom: 1rem;
    font-weight: bold;
    text-align: center;
}

.leaderboard-header > div {
    text-align: center;
}

/* Waiting state adjustments */
.leaderboard-entry.waiting .player-name {
    grid-column: 2;
}

.player-status-waiting {
    grid-column: 3 / span 2;
    display: flex;
    justify-content: center;
    width: 100%;
}

.player-status-waiting .status-text {
    background: rgba(30, 144, 255, 0.1);
    color: var(--accent);
    padding: 0.375rem 1rem;
    border-radius: 12px;
    font-size: 1.2rem;
    text-transform: uppercase;
    letter-spacing: 1px;
    text-align: center;
}

.waiting-indicator {
    position: absolute;
    right: 50px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    align-items: center;
    gap: 9px;
}

.waiting-indicator .dot {
    width: 6px;
    height: 6px;
    background-color: var(--accent);
    border-radius: 50%;
    opacity: 0.7;
}

.waiting-indicator .dot:nth-child(1) {
    animation: dotPulse 1.4s infinite ease-in-out;
}

.waiting-indicator .dot:nth-child(2) {
    animation: dotPulse 1.4s infinite ease-in-out 0.2s;
}

.waiting-indicator .dot:nth-child(3) {
    animation: dotPulse 1.4s infinite ease-in-out 0.4s;
}

@keyframes dotPulse {
    0%, 60%, 100% { transform: scale(1); opacity: 0.7; }
    30% { transform: scale(1.5); opacity: 1; }
}

.completion-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.completion-content {
    background: var(--glass);
    backdrop-filter: blur(10px);
    padding: 2rem;
    border-radius: 20px;
    text-align: center;
}

.completion-content h2 {
    color: var(--gold);
    margin-bottom: 1.5rem;
}

.arcade-progress {
    position: fixed;
    top: 1rem;
    left: 50%;
    transform: translateX(-50%);
    background: var(--glass);
    padding: 0.5rem 1rem;
    border-radius: 15px;
    backdrop-filter: blur(5px);
}

.leaderboard-entry.moving-up {
    background: rgba(76, 175, 80, 0.08);
    animation: moveUp 0.8s ease-in-out forwards;
    z-index: 2;
}

.leaderboard-entry.moving-down {
    background: rgba(244, 67, 54, 0.08);
    animation: moveDown 0.8s ease-in-out forwards;
    z-index: 1;
}

@keyframes moveUp {
    0% { transform: translateY(65px); }
    100% { transform: translateY(0); }
}

@keyframes moveDown {
    0% { transform: translateY(-65px); }
    100% { transform: translateY(0); }
}

.moderator-container {
    display: flex;
    height: 100vh;
    width: 100%;
}

.session-info-panel {
    width: 25%;
    background: var(--glass);
    padding: 2rem;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    backdrop-filter: blur(10px);
    border-right: 1px solid rgba(255,255,255,0.1);
}

.session-details {
    text-align: center;
}

.session-details h2 {
    color: var(--gold);
    margin-bottom: 1.5rem;
}

.otp-display {
    font-size: 3rem;
    color: var(--gold);
    margin: 1rem 0;
    text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
}

.session-metadata {
    background: rgba(255,255,255,0.05);
    border-radius: 10px;
    padding: 1rem;
    margin: 1rem 0;
    text-align: left;
}

.session-metadata p {
    margin: 0.5rem 0;
    color: var(--text);
    opacity: 0.8;
}

.leaderboard-panel {
    width: 75%;
    overflow-y: auto;
    background: var(--primary-dark);
}

.moderator-leaderboard .leaderboard-entry {
    display: grid;
    grid-template-columns: 0.5fr 2fr 1fr 1fr 1fr;
    padding: 1.5rem;
    margin: 0.5rem;
    background: var(--glass);
    border-radius: 15px;
    font-size: 1.2rem;
    align-items: center;
    transition: all 0.3s ease;
}

.moderator-leaderboard .leaderboard-entry .player-actions {
    display: flex;
    gap: 0.5rem;
}

.moderator-leaderboard .leaderboard-entry .player-actions button {
    padding: 0.5rem;
    border-radius: 5px;
    background: var(--accent);
    color: white;
    border: none;
    cursor: pointer;
}

@media (max-width: 768px) {
    .moderator-container {
        flex-direction: column;
    }
    
    .session-info-panel,
    .leaderboard-panel {
        width: 100%;
    }
}

.arcade-completion-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.arcade-completion-modal.show {
    opacity: 1;
}

.completion-modal-content {
    background: var(--glass);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 2rem;
    max-width: 500px;
    width: 90%;
    text-align: center;
    transform: scale(0.7);
    transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.arcade-completion-modal.show .completion-modal-content {
    transform: scale(1);
}

.completion-stats {
    display: flex;
    justify-content: space-around;
    margin: 2rem 0;
}

.stat-item {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.stat-item i {
    font-size: 2rem;
    color: var(--gold);
    margin-bottom: 0.5rem;
}

.stat-item strong {
    font-size: 1.5rem;
    color: var(--gold);
}

.leaderboard-preview {
    margin: 2rem 0;
    background: rgba(255,255,255,0.1);
    border-radius: 15px;
    padding: 1rem;
}

.podium-player {
    display: flex;
    justify-content: space-between;
    padding: 0.5rem;
    margin: 0.5rem 0;
    background: rgba(255,255,255,0.05);
    border-radius: 10px;
}

.podium-player.rank-1 {
    background: linear-gradient(135deg, var(--gold), #FFD700);
    color: var(--primary-dark);
}

.podium-player.rank-2 {
    background: linear-gradient(135deg, #C0C0C0, #A0A0A0);
    color: var(--primary-dark);
}

.podium-player.rank-3 {
    background: linear-gradient(135deg, #CD7F32, #B87333);
    color: var(--primary-dark);
}


.download-app-button {
    opacity: 0.7;
    font-size: 0.9rem;
    margin-top: 0.5rem;
}

.auth-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
}

.auth-modal.show {
    opacity: 1;
    visibility: visible;
}

.auth-modal-content {
    background: var(--glass);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 2rem;
    width: 90%;
    max-width: 400px;
    transform: scale(0.9);
    transition: transform 0.3s ease;
}

.auth-modal.show .auth-modal-content {
    transform: scale(1);
}

.auth-form {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.auth-input {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 25px;
    padding: 0.75rem 1rem;
    color: var(--text);
    width: 100%;
}

.auth-input:focus {
    outline: none;
    border-color: var(--accent);
}

.auth-button {
    background: var(--accent);
    color: var(--text);
    border: none;
    border-radius: 25px;
    padding: 0.75rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

.auth-toggle {
    background: none;
    border: none;
    color: var(--text);
    opacity: 0.7;
    cursor: pointer;
    transition: opacity 0.3s ease;
}

.auth-toggle:hover {
    opacity: 1;
}

.hidden {
    display: none;
}


/* Side Panel Core */
.side-panel {
    position: fixed;
    top: 0;
    right: -100%;
    width: 320px;
    height: 100vh;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(10px);
    padding: 2rem 1.5rem;
    transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    box-shadow: -5px 0 20px rgba(0, 0, 0, 0.3);
}

.side-panel.open {
    right: 0;
}

/* Navigation Links */
.side-panel .welcome-buttons {
    display: flex;
    flex-direction: column;
    margin-top: 1rem;
    gap: 0.5rem;
    align-items: stretch; /* This makes all items stretch to full width */
}

.side-panel .nav-link {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.875rem 1rem;
    transition: all 0.3s ease;
    text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
    justify-content: flex-start;
    text-align: left;
    color: var(--text); /* Ensure text color is consistent */
    text-decoration: none; /* Remove underline */
    background: transparent;
    border-radius: 10px;
    cursor: pointer;
    opacity: 0.8;
}

.side-panel .nav-link:hover {
    background: rgba(255,255,255,0.1);
    opacity: 1;
    transform: translateX(5px);
}

.side-panel .nav-link i {
    color: var(--gold);
    margin-right: 0.5rem;
    opacity: 0.7;
    transition: all 0.3s ease;
}

.side-panel .nav-link:hover i {
    opacity: 1;
    color: var(--accent);
}

.side-panel .nav-link:hover {
    opacity: 1;
    color: var(--gold);
    transform: translateX(10px);
}

.side-panel .nav-link i {
    min-width: 20px;
    text-align: center;
    opacity: 0.7;
}

.nav-link {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.875rem 1rem;
    transition: all 0.3s ease;
    text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
    justify-content: flex-start;
    text-align: left;
    color: var(--text); /* Ensure text color is consistent */
    text-decoration: none; /* Remove underline */
    background: transparent;
    border-radius: 10px;
    cursor: pointer;
    opacity: 0.8;
}

.side-panel .logout-top-button {
    display: flex;
    align-items: center;
    padding: 0.875rem 1rem;

    text-align: center;
    color: var(--text); /* Ensure text color is consistent */
    background: transparent;
    border-radius: 10px;
    cursor: pointer;
    opacity: 0.8;
}

.side-panel .logout-top-button i {
    min-width: 20px;
    text-align: center;
    color: #bbff10;
    opacity: 1;
}

.side-panel .logout-top-button:hover i {
    opacity: 1;
}

.side-panel-content {
    display: flex;
    flex-direction: column;
    height: 100%;
    align-items: center; /* Center items horizontally */
}
.user-profile-bottom {
    margin-top: auto;
    padding: 1rem;
    border-top: 1px solid rgba(255,255,255,0.1);
}

/* User Profile Section */
.user-profile-section {
    margin-top: 3rem;
    text-align: center;
    padding: 1.5rem;
    background: linear-gradient(135deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
    border-radius: 15px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.username-display {
    font-size: 1.4rem;
    color: var(--gold);
    margin-bottom: 0.5rem;
    font-weight: 600;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.status-badge {
    display: inline-block;
    padding: 0.4rem 1.2rem;
    border-radius: 50px;
    font-size: 0.9rem;
    font-weight: 500;
    margin-top: 0.5rem;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.status-badge.premium {
    background: linear-gradient(135deg, #FFD700, #FFA500);
    color: #000;
    box-shadow: 0 2px 10px rgba(255,215,0,0.3);
}

.status-badge.pending {
    background: linear-gradient(135deg, #00BCD4, #03A9F4);
    color: white;
    animation: pendingPulse 2s infinite;
}

.status-badge.trial {
    background: linear-gradient(135deg, #9C27B0, #673AB7);
    color: white;
}

@media (max-width: 768px) {
    .side-panel {
        width: 85%;
        padding: 1.5rem 1rem;
    }
    
    .hamburger-button.open {
        right: 87%;
    }
    
    .main-buttons {
        padding: 0 1rem;
    }
}

/* Small Screen Optimization */
@media (max-width: 360px) {
    .side-panel {
        width: 90%;
        padding: 1.25rem 0.75rem;
    }
}

/* Stats Section */
.user-stats {
    margin-top: 2rem;
    display: flex;
    justify-content: space-around;
    padding: 1rem 0;
    border-top: 1px solid rgba(255,255,255,0.1);
    border-bottom: 1px solid rgba(255,255,255,0.1);
}

.stat-item {
    text-align: center;
}

.stat-value {
    font-size: 1.2rem;
    color: var(--text);
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.game-notification {
    position: fixed;
    top: 15%;  /* Adjusted to be above question word */
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    background: var(--glass);
    padding: 1rem 2rem;
    border-radius: 25px;
    color: var(--text);
    backdrop-filter: blur(10px);
    z-index: 1000;
    opacity: 0;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    text-align: center;
    min-width: 200px;
}

.game-notification.blessing {
    border: 2px solid #3498db;
}

.game-notification.curse {
    border: 2px solid #e74c3c;
}

.game-notification.show {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
}

.particle {
    position: fixed;
    pointer-events: none;
    z-index: 1000;
}

.particle.blessing {
    background: #3498db;
}

.particle.curse {
    background: #e74c3c;
}

.coin-icon {
    color: var(--gold);
}

/* Hamburger Button */
.hamburger-button {
    position: fixed;
    top: 1rem;
    right: 1rem;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: var(--glass);
    border: 1px solid rgba(255, 255, 255, 0.1);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(10px);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 1001;
}

.hamburger-button:hover {
    transform: scale(1.1);
    background: rgba(255, 255, 255, 0.15);
}

.hamburger-button.open {
    right: 290px;
}

.hamburger-button i {
    color: var(--text);
    font-size: 1.25rem;
    transition: transform 0.3s ease;
}

.hamburger-button.open i {
    transform: rotate(90deg);
}


/* Welcome Screen Buttons */
.main-buttons {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1.25rem;
    width: 100%;
    max-width: 260px;
    margin: 0 auto;
}

.main-button {
    position: relative;
    padding: 0.875rem 2rem;
    background: transparent;
    color: var(--text);
    border: none;
    border-radius: 12px;
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    width: 100%;
    overflow: hidden;
    background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
    backdrop-filter: blur(5px);
    text-transform: uppercase;
    letter-spacing: 1px;
}

.main-button::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, var(--accent), #ff6b6b);
    opacity: 0;
    transition: opacity 0.3s ease;
    border-radius: inherit;
    z-index: -1;
}

.main-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(233, 69, 96, 0.2);
}

.main-button:hover::before {
    opacity: 1;
}

/* Mobile Optimization */
@media (max-width: 768px) {
    .side-panel {
        width: 85%;
        padding: 1.5rem 1rem;
    }
    
    .hamburger-button.open {
        right: 87%;
    }
    
    .main-buttons {
        padding: 0 1rem;
    }
}

/* Small Screen Optimization */
@media (max-width: 360px) {
    .side-panel {
        width: 90%;
        padding: 1.25rem 0.75rem;
    }
}

.leaderboard-entry div[data-words],
.leaderboard-entry div[data-coins] {
    transition: color 0.3s ease;
}

.leaderboard-entry.moving-up {
    animation: moveUp 0.8s ease-in-out forwards;
    z-index: 2;
}

.leaderboard-entry.moving-down {
    animation: moveDown 0.8s ease-in-out forwards;
    z-index: 1;
}

@keyframes moveUp {
    0% { transform: translateY(65px); }
    100% { transform: translateY(0); }
}

@keyframes moveDown {
    0% { transform: translateY(-65px); }
    100% { transform: translateY(0); }
}




.arcade-join-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    padding: 1rem;
}

.arcade-join-modal .modal-content {
    background: var(--glass);
    backdrop-filter: blur(10px);
    padding: 2rem;
    border-radius: 20px;
    width: 100%;
    max-width: 400px;
    text-align: center;
    position: relative;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

#player-view {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
}

#player-view h2 {
    font-size: 1.5rem;
    margin-bottom: 1rem;
    text-align: center;
    color: var(--gold);
}

.input-group {
    width: 100%;
    margin: 0;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.input-group input,
#otpInput {
    width: 100%;
    padding: 1rem;
    font-size: 1rem;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 15px;
    color: var(--text);
    text-align: center;
    transition: all 0.3s ease;
    outline: none;
}

.input-group input:focus,
#otpInput:focus {
    border-color: var(--accent);
    box-shadow: 0 0 15px rgba(233, 69, 96, 0.2);
}

#arcadeUsername {
    margin-bottom: 0.5rem;
}

#otpInput {
    margin: 0;
    letter-spacing: 0.2em;
}

.join-button {
    width: 100%;
    padding: 1rem;
    border: none;
    border-radius: 25px;
    background: var(--accent);
    color: var(--text);
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-top: 1rem;
}

.join-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(233, 69, 96, 0.4);
}

@media (max-width: 768px) {
    .arcade-join-modal {
        padding: 0.5rem;
    }

    .arcade-join-modal .modal-content {
        padding: 1.5rem;
        max-width: 350px;
    }

    #player-view h2 {
        font-size: 1.3rem;
        margin-bottom: 0.75rem;
    }

    .input-group input,
    #otpInput {
        font-size: 0.95rem;
        padding: 0.875rem;
        min-width: 250px; /* New line: ensures minimum width */
        width: 100%; /* Maintains full-width responsiveness */
    }

    #arcadeUsername {
        font-size: 1rem; /* Slightly larger font */
        letter-spacing: -0.5px; /* Tighter letter spacing to fit more text */
    }

    .join-button {
        font-size: 0.95rem;
        padding: 0.875rem;
    }
}

@media (max-width: 480px) {
    .input-group input,
    #otpInput {
        min-width: 220px; /* Slightly narrower for very small screens */
        font-size: 0.9rem;
    }

    #arcadeUsername {
        font-size: 0.95rem;
    }
}


.powerups-container {
    display: flex;
    gap: 0.5rem;
    padding: 5px;
    justify-content: center;
    width: 100%;
    margin-bottom: 1rem;
}

.powerup-card {
    position: relative;
    width: calc(33% - 10px);
    max-width: 100px;
    height: 100px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 5px;
    border-radius: 8px;
    text-align: center;
    font-size: 0.8em;
    transition: transform 0.2s ease;
}

.powerup-card.goodie {
    border: 2px solid #3498db;
    box-shadow: 0 0 15px rgba(52, 152, 219, 0.3);
}

.powerup-card.baddie {
    border: 2px solid #e74c3c;
    box-shadow: 0 0 15px rgba(231, 76, 60, 0.3);
}

.powerup-card:hover {
    transform: translateY(-2px);
}

.powerup-icon {
    font-size: 1.5rem;
    color: var(--text);
}

.powerup-name {
    font-size: 0.8rem;
    text-align: center;
    margin: 0.25rem 0;
    font-weight: bold;
}

.powerup-cost {
    position: absolute;
    top: -8px;
    right: -8px;
    background: var(--gold);
    color: var(--primary-dark);
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.7rem;
    font-weight: bold;
    border: 2px solid var(--primary-dark);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.powerup-card:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

@media (max-width: 768px) {
    .powerup-card {
        width: calc(33% - 10px);
        height: 90px;
        font-size: 0.7em;
    }
    
    .powerup-icon {
        font-size: 1.2rem;
    }
    
    .powerup-name {
        font-size: 0.7rem;
        margin: 0.2rem 0;
    }
    
    .powerup-cost {
        width: 20px;
        height: 20px;
        font-size: 0.65rem;
    }
}

.qr-section {
    background: white;
    padding: 1rem;
    border-radius: 15px;
    margin: 1rem 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
}

.qr-section canvas {
    width: 200px;
    height: 200px;
}

.qr-hint {
    color: var(--primary-dark);
    font-size: 0.9rem;
    font-weight: 600;
}

@media (max-width: 768px) {
    .qr-section canvas {
        width: 150px;
        height: 150px;
    }
}

@media (max-width: 768px) {
    .arcade-join-modal {
        padding: 0.5rem;
    }

    .arcade-join-modal .modal-content {
        padding: 1.5rem;
        max-width: 350px;
    }

    #player-view h2 {
        font-size: 1.3rem;
        margin-bottom: 0.75rem;
    }

    .input-group input,
    #otpInput {
        font-size: 0.95rem;
        padding: 0.875rem;
        min-width: 250px; /* New line: ensures minimum width */
        width: 100%; /* Maintains full-width responsiveness */
    }

    #arcadeUsername {
        font-size: 1rem; /* Slightly larger font */
        letter-spacing: -0.5px; /* Tighter letter spacing to fit more text */
    }

    .join-button {
        font-size: 0.95rem;
        padding: 0.875rem;
    }
}

@media (max-width: 480px) {
    .input-group input,
    #otpInput {
        min-width: 220px; /* Slightly narrower for very small screens */
        font-size: 0.9rem;
    }

    #arcadeUsername {
        font-size: 0.95rem;
    }
}

#qr-landing {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    background: var(--gradient);
    text-align: center;
    padding: 2rem;
}

.qr-landing-content {
    background: var(--glass);
    backdrop-filter: blur(10px);
    padding: 2rem;
    border-radius: 20px;
    width: 90%;
    max-width: 400px;
}

.qr-landing-content h2 {
    color: var(--gold);
    margin-bottom: 1.5rem;
}

.game-code-display {
    font-size: 2.5rem;
    color: var(--text);
    font-weight: bold;
    padding: 1rem;
    margin: 1rem 0;
    background: rgba(255,255,255,0.1);
    border-radius: 15px;
    letter-spacing: 0.2em;
}

#qr-landing .join-game-button {
    width: 100%;
    padding: 1rem;
    margin-top: 1.5rem;
    font-size: 1.2rem;
    animation: pulseGlow 1.5s ease-in-out infinite;
}

.waiting-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    position: relative;
    overflow: hidden;
}

.spinner-container {
    position: relative;
    width: 100px;
    height: 100px;
    margin-bottom: 2rem;
}

.spinner {
    position: absolute;
    width: 100%;
    height: 100%;
    border: 4px solid rgba(255,255,255,0.1);
    border-top-color: var(--gold);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.waiting-title {
    font-size: 2rem;
    color: var(--gold);
    margin-bottom: 1rem;
    text-shadow: 0 2px 10px rgba(255,215,0,0.3);
}

.player-count {
    font-size: 1.2rem;
    color: var(--text);
    opacity: 0.8;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* Floating particles */
.floating-particles {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    pointer-events: none;
}

.floating-particle {
    position: absolute;
    width: 10px;
    height: 10px;
    background: var(--gold);
    border-radius: 50%;
    opacity: 0.3;
    animation: float 3s infinite ease-in-out;
}

.slide-transition {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 9999;
    pointer-events: none;
    display: flex;
    justify-content: center;
    align-items: center;
    background: transparent;
}

.slide-panel-left, .slide-panel-right {
    position: absolute;
    width: 50%;
    height: 100%;
    background: linear-gradient(135deg, var(--primary-dark), var(--secondary));
    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.slide-panel-left {
    left: 0;
    transform: translateX(-100%);
    border-right: 2px solid var(--gold);
}

.slide-panel-right {
    right: 0;
    transform: translateX(100%);
    border-left: 2px solid var(--gold);
}

.slide-transition.show .slide-panel-left {
    transform: translateX(0);
    box-shadow: 5px 0 15px rgba(0,0,0,0.3);
}

.slide-transition.show .slide-panel-right {
    transform: translateX(0);
    box-shadow: -5px 0 15px rgba(0,0,0,0.3);
}

.level-announcement {
    position: absolute;
    z-index: 10000;
    color: var(--text);
    text-align: center;
    opacity: 0;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    transform: scale(0.9);
    background: rgba(0, 0, 0, 0.3);
    padding: 2rem 3rem;
    border-radius: 20px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}

.level-announcement.show {
    opacity: 1;
    transform: scale(1);
}

.level-announcement h1 {
    font-size: 2.5rem;
    background: linear-gradient(to right, var(--gold), #FFA500);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    margin-bottom: 1rem;
    position: relative;
    text-transform: uppercase;
    letter-spacing: 2px;
    font-weight: 700;
}

.level-announcement h1::after {
    content: '';
    position: absolute;
    bottom: -5px;
    left: 50%;
    transform: translateX(-50%);
    width: 50px;
    height: 2px;
    background: var(--gold);
    box-shadow: 0 0 10px var(--gold);
}

.level-announcement h2 {
    font-size: 2rem;
    color: var(--text);
    font-weight: 500;
    opacity: 0.9;
    letter-spacing: 1px;
}

/* Add subtle edge glow */
.slide-panel-left::after,
.slide-panel-right::after {
    content: '';
    position: absolute;
    top: 0;
    width: 2px;
    height: 100%;
    background: linear-gradient(to bottom, transparent, var(--gold), transparent);
    opacity: 0.5;
}

.slide-panel-left::after {
    right: 0;
}

.slide-panel-right::after {
    left: 0;
}

/* Add subtle animated line at the bottom */
.level-announcement::before {
    content: '';
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    height: 1px;
    background: linear-gradient(to right, transparent, var(--gold), transparent);
    animation: lineWidth 2s ease-in-out infinite;
}

@keyframes lineWidth {
    0%, 100% { width: 60%; opacity: 0.3; }
    50% { width: 80%; opacity: 0.7; }
}

.leaderboard-entry {
    display: grid;
    grid-template-columns: 1fr 5fr 3fr;
    align-items: center;
    padding: 1rem;
    margin-bottom: 0.5rem;
    background: rgba(255,255,255,0.05);
    border-radius: 10px;
    transition: background-color 0.3s ease;
    position: relative;
}

.leaderboard-entry > div:first-child {
    text-align: center;
    font-weight: bold;
    color: var(--gold);
}

.leaderboard-entry > div:nth-child(2) {
    text-align: center;
    font-weight: 500;
}


.leaderboard-entry div[data-words],
.leaderboard-entry div[data-coins] {
    transition: color 0.3s ease;
}

.leaderboard-entry.moving-up {
    background: rgba(76, 175, 80, 0.08);
    animation: moveUp 0.8s ease-in-out forwards;
    z-index: 2;
}

.leaderboard-entry.moving-down {
    background: rgba(244, 67, 54, 0.08);
    animation: moveDown 0.8s ease-in-out forwards;
    z-index: 1;
}

@keyframes moveUp {
    0% { transform: translateY(65px); }
    100% { transform: translateY(0); }
}

@keyframes moveDown {
    0% { transform: translateY(-65px); }
    100% { transform: translateY(0); }
}


.coins-header .coin-icon {
  color: var(--gold);
  font-size: 1.5rem;
  filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.3));
}

.coins-header .coin-count {
  font-size: 1.2rem;
  font-weight: bold;
  color: var(--text);
}

.coin-count {
    transition: none; /* Remove any existing transitions */
}

.coin-count.animating {
    transition: content 1s ease-out;
}


.stage-container, .set-container {
  display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 2rem;
    width: 100%;
    max-width: 1200px;
    padding: 2rem;
    z-index: 1;
}





.stage-name {
  font-size: 1.2rem;
    margin-bottom: 0.5rem;
    color: var(--text);
    text-transform: uppercase;
    letter-spacing: 1px;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}




.test-badge {
    background: rgba(255, 255, 255, 0.1);
    padding: 0.5rem 1rem;
    border-radius: 15px;
    margin-top: 1rem;
    font-size: 0.9rem;
    animation: pulse 2s infinite;
}

@keyframes rotate {
    from { transform: translate(-50%, -50%) rotate(0deg); }
    to { transform: translate(-50%, -50%) rotate(360deg); }
}

@keyframes pulse {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 1; }
}

/* Level announcement styles */
.level-announcement.test-level h1 {
    color: #4facfe;
    text-shadow: 0 0 10px rgba(79, 172, 254, 0.5);
}

.level-announcement.boss-level {
    background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%);
}

@keyframes switchDirection {
    0%, 100% { transform: scaleX(1); }
    50% { transform: scaleX(-1); }
}

/* Boss Level Styles */
.boss-mode {
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    animation: pulseBg 4s infinite;
}

.boss-word {
    color: #ffd700;
    text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    animation: pulseWord 2s infinite;
}

.boss-word.fading {
    animation: fadeWord 5s forwards;
}

@keyframes pulseBg {
    0%, 100% { filter: brightness(1); }
    50% { filter: brightness(1.2); }
}

@keyframes pulseWord {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

@keyframes fadeWord {
    0% { opacity: 1; }
    100% { opacity: 0.3; }
}

.perk-disabled {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 1.5em;
    color: red;
    pointer-events: none;
}

/* New Level Selection Screen */
.level-container {
    width: 100%;
    max-width: 1200px;
    padding: 2rem;
    display: flex;
    flex-direction: column;
    gap: 2rem;
}

.level-header {
    background: var(--glass);
    backdrop-filter: blur(10px);
    border-radius: 16px;
    padding: 1.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.level-title-area {
    display: flex;
    align-items: center;
    gap: 1.25rem;
}

.set-icon {
    width: 64px;
    height: 64px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.75rem;
    background: linear-gradient(135deg, var(--accent), rgba(30, 144, 255, 0.7));
    border-radius: 12px;
    box-shadow: 0 5px 15px rgba(30, 144, 255, 0.3);
}

.set-details {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.set-name {
    font-size: 1.4rem;
    font-weight: 700;
    color: var(--text);
}

.set-desc {
    opacity: 0.8;
    font-size: 0.9rem;
}

.set-progress {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.progress-bar {
    width: 150px;
    height: 6px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: var(--gold);
    border-radius: 3px;
    transition: width 0.3s ease;
}

.progress-text {
    font-size: 0.9rem;
    opacity: 0.9;
}

.level-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 1rem;
    background: var(--glass);
    backdrop-filter: blur(10px);
    border-radius: 16px;
    padding: 1.5rem;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.level-item {
    aspect-ratio: 1;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 12px;
    font-size: 1.2rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    color: var(--text);
    overflow: hidden;
}

.level-item.unlocked {
    background: linear-gradient(135deg, var(--accent), rgba(30, 144, 255, 0.7));
    box-shadow: 0 5px 15px rgba(30, 144, 255, 0.2);
}

.level-item.completed {
    background: linear-gradient(135deg, var(--success), #45b649);
    border: 2px solid var(--gold);
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
}

.level-item.perfect {
    background: linear-gradient(135deg, var(--gold), #FFA500);
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
}

.level-item.boss {
    background: linear-gradient(135deg, var(--gold), var(--accent));
    box-shadow: 0 0 25px rgba(255, 215, 0, 0.5);
}

.level-item.locked {
    background: rgba(128, 128, 128, 0.2);
    cursor: not-allowed;
}

.level-item.locked::before {
    content: '\f023';
    font-family: 'Font Awesome 6 Free';
    font-weight: 900;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 1.5rem;
    color: rgba(255, 255, 255, 0.5);
    z-index: 1;
}

.level-item.test::after {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 0;
    height: 0;
    border-style: solid;
    border-width: 0 25px 25px 0;
    border-color: transparent var(--gold) transparent transparent;
}

.level-item.unlocked:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 20px rgba(30, 144, 255, 0.3);
}

.level-item.completed:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 20px rgba(76, 175, 80, 0.3);
}

.level-item.perfect:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 25px rgba(255, 215, 0, 0.5);
}

.level-type-legend {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    margin-top: 1rem;
    justify-content: center;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.9rem;
}

.legend-color {
    width: 16px;
    height: 16px;
    border-radius: 4px;
}

@media (max-width: 768px) {
    .level-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
    }
    
    .set-icon {
        width: 48px;
        height: 48px;
        font-size: 1.4rem;
    }
    
    .set-name {
        font-size: 1.2rem;
    }
    
    .level-grid {
        grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
        gap: 0.75rem;
        padding: 1rem;
    }
    
    .level-item {
        font-size: 1rem;
    }
}

@media (max-width: 480px) {
    .level-container {
        padding: 1rem;
    }
    
    .level-grid {
        grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
        gap: 0.5rem;
    }
    
    .set-progress {
        flex-direction: column;
        align-items: flex-start;
    }
}


/* Question screen specific styles */
.question-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1.5rem;
  height: 100vh;
  padding: 1rem 1rem 2rem;
    min-height: 100vh;
    height: auto;
    justify-content: space-between;
    gap: 0.5rem;
    justify-content: space-between;
    padding: 1rem 1rem 2rem;
    overflow: hidden;
}

.question-word {
  font-size: 4rem;
  font-weight: 700;
  color: var(--gold);
  text-shadow: 0 2px 10px rgba(255,215,0,0.3);
  animation: float 3s ease-in-out infinite;
  margin: 0;
  padding: 1rem;
}

/* Progress Circle Styles - Updated */
.progress-circle {
    width: 200px;
    height: 200px;
    position: relative;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 1rem 0;
}

.progress-circle svg {
    position: absolute;
    width: 100%;
    height: 100%;
    transform: rotate(-90deg);
}

.progress-circle circle {
    fill: none;
    stroke-linecap: round;
}

.progress-circle .bg {
    stroke: rgba(255, 255, 255, 0.1);
}

.progress-circle .progress {
    stroke: var(--gold);
    transition: stroke-dashoffset 0.5s ease;
}

.progress-circle.completed {
    animation: pulseGrow 0.4s ease-in-out infinite;
}

.progress-circle.completed circle.progress {
    animation: colorShift 0.4s ease-in-out infinite;
    transition: stroke 0.3s linear;
}

@keyframes colorShift {
    0%, 100% { 
        stroke: var(--gold);
        filter: brightness(1.5);
    }
    50% { 
        stroke: #1E90FF; /* Lapiz Lazuli */
        filter: brightness(1.2);
    }
}

.progress-circle[data-progress="low"] .progress {
    stroke: var(--gold);
}

.progress-circle[data-progress="medium"] .progress {
    stroke: #FFA500; /* Orange */
}

.progress-circle[data-progress="high"] .progress {
    stroke: var(--success);
}

.progress-circle[data-progress="complete"] .progress {
    stroke: #1E90FF; /* Lapiz Lazuli */
}

.completion-ripple {
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    border: 2px solid var(--gold);
    animation: rippleOut 1s ease-out forwards;
}

@keyframes rippleOut {
    0% {
        transform: scale(1);
        opacity: 1;
    }
    100% {
        transform: scale(1.5);
        opacity: 0;
    }
}

@keyframes pulseGrow {
    0%, 100% { 
        transform: scale(1); 
        filter: brightness(1);
    }
    50% { 
        transform: scale(1.05); 
        filter: brightness(1.2);
    }
}

.failure-overlay .failure-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2rem;
}

.failure-overlay .restart-button {
    margin: 0 auto;
}

.failure-overlay .home-button {
    display: none;
}

.game-notification {
    position: fixed;
    top: 20px;
    left: 20px;
    padding: 1rem 2rem;
    border-radius: 10px;
    color: var(--text);
    background: var(--glass);
    backdrop-filter: blur(10px);
    z-index: 1100;
    transform: translateX(-100%);
    opacity: 0;
    transition: all 0.3s ease;
}

.game-notification.show {
    transform: translateX(0);
    opacity: 1;
}

.game-notification.success {
    border-left: 4px solid var(--success);
}

.game-notification.error {
    border-left: 4px solid var(--error);
}

.level.mixed {
    background: linear-gradient(135deg, var(--accent), var(--gold));
    position: relative;
    overflow: hidden;
}

.level.mixed::before {
    content: '';
    position: absolute;
    inset: -50%;
    background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.2) 50%, transparent 70%);
    animation: shimmerEffect 3s infinite linear;
}

@keyframes shimmerEffect {
    0% { transform: translate(-100%, -100%) rotate(45deg); }
    100% { transform: translate(100%, 100%) rotate(45deg); }
}

.list-actions {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 0.75rem;
    width: 100%;
    margin-bottom: 1rem;
}

.list-actions button {
    position: relative;
    padding: 0.75rem 1rem;
    background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
    color: var(--text);
    border: none;
    border-radius: 12px;
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 1px;
    backdrop-filter: blur(5px);
    overflow: hidden;
}

.list-actions button::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, var(--accent), #ff6b6b);
    opacity: 0;
    transition: opacity 0.3s ease;
    border-radius: inherit;
    z-index: -1;
}

.list-actions button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(233, 69, 96, 0.2);
}

.list-actions button:hover::before {
    opacity: 1;
}

.start-button.share-with-user-btn {
    padding: 0.5rem 1rem;
    font-size: 0.8rem;
    background: var(--accent);
    color: var(--text);
    border: none;
    border-radius: 20px;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.start-button.share-with-user-btn:hover {
    transform: translateY(-2px);
    filter: brightness(1.2);
    box-shadow: 0 5px 15px rgba(233, 69, 96, 0.3);
}

.share-modal .start-button {
    margin-top: 1rem;
    width: 100%;
    padding: 0.8rem;
    font-size: 1rem;
}

/* Mobile responsive adjustments */
@media (max-width: 768px) {
    .list-actions {
        grid-template-columns: 1fr 1fr;
    }
    
    .list-actions button {
        padding: 0.6rem 0.8rem;
        font-size: 0.8rem;
    }
}

@media (max-width: 480px) {
    .list-actions {
        grid-template-columns: 1fr;
    }
}


/* Button modifiers */
.main-button.small-button {
    padding: 0.5rem 1rem;
    font-size: 0.85rem;
    min-width: 0;
    width: auto;
}

/* Grid layouts for custom list section */
.list-actions {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    gap: 0.75rem;
    width: 100%;
    margin-bottom: 1rem;
}

.list-actions .main-button {
    width: 100%;
    padding: 0.75rem 1rem;
    font-size: 0.9rem;
}

.word-input-actions {
    display: flex;
    gap: 1rem;
    margin-bottom: 1.5rem;
    flex-wrap: wrap;
    justify-content: center;
}

.word-input-actions .main-button {
    min-width: 100px;
    width: auto;
    flex: 1;
}

/* Share modal specific styles */
.share-modal .modal-close {
    margin-top: 1.5rem;
    width: 100%;
}

.user-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.75rem;
    margin: 0.5rem 0;
    background: rgba(255,255,255,0.1);
    border-radius: 10px;
    transition: all 0.3s ease;
}

.user-item:hover {
    background: rgba(255,255,255,0.15);
}

.user-item .main-button {
    width: auto;
    margin-left: 1rem;
}

/* Mobile adjustments */
@media (max-width: 768px) {
    .list-actions {
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    }
    
    .word-input-actions .main-button {
        padding: 0.7rem 1rem;
        font-size: 0.85rem;
    }
    
    .user-item {
        flex-direction: column;
        align-items: stretch;
        gap: 0.75rem;
    }
    
    .user-item .main-button {
        width: 100%;
        margin-left: 0;
    }
}

@media (max-width: 480px) {
    .list-actions {
        grid-template-columns: 1fr;
    }
    
    .word-input-actions {
        flex-direction: column;
    }
    
    .word-input-actions .main-button {
        width: 100%;
    }
}

.custom-list-dropdown {
    position: absolute;
    top: 100%;
    left: 0;
    width: 100%;
    max-height: 300px;
    overflow-y: auto;
    background: var(--glass);
    backdrop-filter: blur(10px);
    border-radius: 15px;
    padding: 1rem;
    margin-top: 0.5rem;
    z-index: 1000;
    border: 1px solid rgba(255,255,255,0.1);
}

.selected-lists {
    margin: 1rem 0;
}

.list-item {
    display: flex;
    align-items: center;
    padding: 0.75rem;
    margin: 0.5rem 0;
    background: rgba(255,255,255,0.1);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.list-item:hover {
    background: rgba(255,255,255,0.2);
    transform: translateY(-2px);
}

.perks-container {
  display: flex;
  gap: 1rem;
  margin: 1rem 0;
  background: var(--glass);
  padding: 0.75rem;
  border-radius: 25px;
  backdrop-filter: blur(10px);
}

.perk-button {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.25rem;
  padding: 0.5rem;
  border-radius: 15px;
  cursor: pointer;
  transition: all 0.3s ease;
  background: rgba(255, 255, 255, 0.1);
  border: none;
  color: var(--text);
}

.perk-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.perk-button:not(:disabled):hover {
  background: rgba(255, 255, 255, 0.2);
  transform: translateY(-2px);
}

.perk-icon {
  font-size: 1.5rem;
  color: var(--gold);
}

.perk-count {
  font-size: 0.8rem;
  font-weight: bold;
}

.timer-container {
    position: absolute;
    visibility: hidden;
    opacity: 0;
    pointer-events: none;
    height: 0;
    margin: 0;
}

.timer-value {
    font-size: 0;
    padding: 0;
}

.timer-value.warning {
  color: var(--error);
  text-shadow: 0 0 15px rgba(244, 67, 54, 0.5);
  animation: warningPulse 1s infinite;
}

.buttons {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
  max-width: 800px;
  width: 100%;
  margin: 1rem auto;
  margin-bottom: 0rem;
  padding: 0 1rem;
}

.buttons button {
  padding: 1rem 2rem;
  font-size: 1.2rem;
  font-weight: 600;
  color: var(--primary);
  background: var(--text);
  border: none;
  border-radius: 15px;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 5px 15px rgba(0,0,0,0.1);
}

.buttons button:hover {
  transform: translateY(-5px);
  box-shadow: 0 10px 20px rgba(0,0,0,0.2);
}

.buttons button.correct {
  background: var(--success);
  color: var(--text);
  animation: correctAnswer 0.5s ease;
}

.buttons button.wrong {
  background: var(--error);
  color: var(--text);
  animation: wrongAnswer 0.5s ease;
}

.failure-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background 1s ease;
  z-index: 1000;
}

.failure-overlay.show {
  background: rgba(0, 0, 0, 0.9);
}

.failure-content {
  text-align: center;
  transform: translateY(50px);
  opacity: 0;
  transition: all 1s ease;
}

.failure-overlay.show .failure-content {
  transform: translateY(0);
  opacity: 1;
}

.failure-title {
  font-size: 3rem;
  color: var(--error);
  margin-bottom: 2rem;
  text-shadow: 0 2px 10px rgba(244, 67, 54, 0.3);
}

.failure-buttons {
  display: flex;
  gap: 2rem;
  justify-content: center;
}

.restart-button, .home-button {
  padding: 1rem;
  width: 80px;
  height: 80px;
  font-size: 2rem;
  color: var(--text);
  background: var(--accent);
  border: none;
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 10px 20px rgba(233, 69, 96, 0.3);
}

.restart-button:hover, .home-button:hover {
  transform: translateY(-5px);
  box-shadow: 0 15px 30px rgba(233, 69, 96, 0.4);
}

.coins-container {
    position: absolute;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 2;
}

.coins-container .coin-icon {
    color: var(--gold);
    font-size: 2rem;
    filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.5));
}

.coins-container .coin-count {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--text);
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
}

.coin-pulse {
    animation: coinPulse 0.5s ease-in-out 3;
}

.skip-button {
    position: absolute;
    top: 1rem;
    left: 1rem;
    padding: 0.5rem 1rem;
    border: none;
    background: rgba(255,255,255,0.1);
    color: var(--text);
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.skip-button:hover {
    background: rgba(255,255,255,0.2);
}

.coins-header {
  position: fixed;
  top: 2rem;
  right: 2rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  background: var(--glass);
  padding: 0.75rem 1.5rem;
  border-radius: 25px;
  backdrop-filter: blur(10px);
  z-index: 100;
}

.user-tier {
    position: relative;
    top: 2rem;
    display: flex; /* Add this to enable flexbox alignment */
    justify-content: center; /* Center horizontally */
    align-items: center; /* Center vertically */
    z-index: 100;
    min-width: 200px;
    text-align: center;
    backdrop-filter: blur(10px);
    padding: 0;
    border-radius: 0;
}

.user-info {
    position: fixed;
    top: 2rem;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    z-index: 100;
}

#userEmail {
    font-size: 1.5rem;
    color: var(--gold);
    margin-bottom: 0.5rem;
}

.tier-text {
    font-weight: 600;
    font-size: 1.1rem;
}

.tier-text.unregistered {
    color: #ff4444;
}

.tier-text.trial {
    color: #ffa500;
}

.tier-text.pending {
    color: #00bfff;
    animation: pendingBlink 2s infinite;
}

.tier-text.premium {
    color: #4CAF50;
}

@keyframes pendingBlink {
    0%, 100% { opacity: 0.7; }
    50% { opacity: 1; }
}

.upgrade-confirmation-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
}

.modal-backdrop {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
}

.confirmation-content {
    background: var(--glass);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 2rem;
    text-align: center;
    max-width: 400px;
    z-index: 2001;
}

.confirmation-content h2 {
    color: var(--gold);
    margin-bottom: 1rem;
}

.continue-button {
    margin-top: 1rem;
    padding: 0.75rem 1.5rem;
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 25px;
    cursor: pointer;
    transition: background 0.3s ease;
}

.continue-button:hover {
    background: color-mix(in srgb, var(--accent) 90%, white);
}

.confirmation-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.7);
    opacity: 0;
    transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    z-index: 1001;
    pointer-events: none;
    width: 90%;
    max-width: 500px;
    background: var(--primary-dark);
    padding: 2rem;
    border-radius: 20px;
    box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    border: 2px solid var(--accent);
    text-align: center;
}

.confirmation-popup.show {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
    pointer-events: auto;
    animation: popupAppear 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.confirmation-popup h2 {
    color: var(--gold);
    margin-bottom: 1.5rem;
}

.confirmation-popup p {
    color: var(--text);
    margin-bottom: 2rem;
}

.confirmation-popup button {
    position: relative;
    padding: 0.875rem 2rem;
    border: 2px solid var(--accent);
    background: transparent;
    color: var(--text);
    border-radius: 50px;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.confirmation-popup button:hover {
    box-shadow: 0 0 15px var(--accent), 0 0 30px var(--accent);
}

.level.boss {
    background: linear-gradient(135deg, var(--gold), var(--accent));
    border: 2px solid var(--gold);
    box-shadow: 0 0 20px var(--gold);
    position: relative;
    overflow: hidden;
}

.level.boss::before {
    content: '';
    position: absolute;
    top: -10px;
    right: -10px;
    font-size: 1.2rem;
    transform: rotate(45deg);
}



.user-tier {
    display: block; /* Ensure it's always visible */
    text-align: center;
    margin-top: 0.5rem;
}

.tier-text {
    font-weight: 600;
    font-size: 1rem;
    padding: 0.25rem 0.5rem;
    border-radius: 15px;
    background: rgba(255,255,255,0.1);
}

.tier-text.unregistered { color: #ff4444; }
.tier-text.trial { color: #ffa500; }
.tier-text.pending { 
    color: #00bfff;
    animation: pendingBlink 2s infinite;
}
.tier-text.premium { color: #4CAF50; }

@keyframes pendingBlink {
    0%, 100% { opacity: 0.7; }
    50% { opacity: 1; }
}

.leaderboard-screen {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 2rem;
    min-height: 100vh;
}

.leaderboard-container {
    background: var(--glass);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 2rem;
    width: 100%;
    max-width: 800px;
    margin-top: 2rem;
}

#arcade-leaderboard {
    width: 100%;
    max-width: 800px;
    margin: 0 auto;
    padding: 2rem;
}

.leaderboard-header {
    display: grid;
    grid-template-columns: 0.5fr 2fr 1fr 1fr;
    padding: 1rem 2rem;
    background: rgba(255,255,255,0.1);
    border-radius: 10px;
    margin-bottom: 1rem;
    font-weight: bold;
    font-size: 1.1rem;
}

.leaderboard-header > div {
    text-align: center;
}

.leaderboard-entry.moving-up {
    background: rgba(76, 175, 80, 0.08);
    animation: moveUp 0.8s ease-in-out forwards;
    z-index: 2;
}

.leaderboard-entry.moving-down {
    background: rgba(244, 67, 54, 0.08);
    animation: moveDown 0.8s ease-in-out forwards;
    z-index: 1;
}

@keyframes moveUp {
    0% { transform: translateY(65px); }
    100% { transform: translateY(0); }
}

@keyframes moveDown {
    0% { transform: translateY(-65px); }
    100% { transform: translateY(0); }
}

.leaderboard-entry:hover {
    background: rgba(255,255,255,0.1);
}

.leaderboard-entry.you {
    background: rgba(6, 145, 64, 0.2);
    border: 1px solid var(--gold);
}

.leaderboard-entry.rank-1 {
    color: var(--gold);
}

.leaderboard-entry.rank-2 {
    color: var(--silver);
}

.leaderboard-entry.rank-3 {
    color: var(--bronze);
}

@media (max-width: 768px) {
    .leaderboard-header, 
    .leaderboard-entry {
        padding: 1rem;
        font-size: 0.9rem;
    }
}

    .leaderboard-header, 
    .leaderboard-entry {
        grid-template-columns: 0.5fr 2fr 1fr 1fr 1fr;
        font-size: 0.9rem;
        padding: 0.75rem;
    }

.premium-celebration {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, rgba(26, 26, 46, 0.95), rgba(22, 33, 62, 0.95));
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.5s ease;
}

.premium-celebration.show {
    opacity: 1;
    pointer-events: auto;
}

.celebration-content {
    text-align: center;
    transform: translateY(30px);
    transition: transform 0.5s ease;
}

.premium-celebration.show .celebration-content {
    transform: translateY(0);
}

.celebration-title {
    font-size: 3rem;
    color: var(--gold);
    margin-bottom: 2rem;
    text-shadow: 0 2px 10px rgba(255,215,0,0.3);
}

.celebration-message {
    font-size: 1.5rem;
    color: var(--text);
    margin-bottom: 2rem;
    line-height: 1.5;
}

.celebration-button {
    padding: 1rem 2rem;
    font-size: 1.2rem;
    background: var(--gold);
    color: var(--primary-dark);
    border: none;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.celebration-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(255,215,0,0.3);
}

.toast {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    padding: 1rem 2rem;
    border-radius: 25px;
    z-index: 1000;
    color: white;
    font-weight: bold;
    opacity: 0;
    transition: all 0.3s ease;
}

.toast.success {
    background-color: #4CAF50;
}

.toast.error {
    background-color: #f44336;
}

.toast.show {
    opacity: 1;
    transform: translate(-50%, 0);
}

.toast.hide {
    opacity: 0;
    transform: translate(-50%, -20px);
}

/* Shop Styles */
.shop-container {
  display: flex;
  flex-direction: column;
  gap: 2rem;
  max-width: 800px;
  width: 100%;
  padding: 1rem;
}

.shop-title {
  font-size: 3rem;
  font-weight: 700;
  text-align: center;
  color: var(--gold);
  margin-bottom: 2rem;
}

.shop-items {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
}

.shop-item {
  background: var(--glass);
  border-radius: 20px;
  padding: 2rem;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1.5rem;
  backdrop-filter: blur(10px);
  transition: all 0.3s ease;
  cursor: pointer;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.shop-item:hover {
  transform: translateY(-5px);
  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
}

.shop-item.disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.shop-item-title {
  font-size: 1.5rem;
  font-weight: 600;
  color: var(--text);
}

.shop-item-icon {
  font-size: 2.5rem;
  color: var(--gold);
}

.shop-item-description {
  color: var(--text);
  opacity: 0.8;
  font-size: 0.9rem;
  line-height: 1.4;
}

.shop-item-price {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  color: var(--gold);
  font-size: 1.2rem;
  font-weight: 600;
}

.shop-item-price i {
  font-size: 1.5rem;
}

/* Animations */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes shimmer {
  0% { background-position: -200% center; }
  100% { background-position: 200% center; }
}

@keyframes shine {
  to { transform: rotate(45deg) translate(100%, 100%); }
}

@keyframes pulse {
  0% { box-shadow: 0 0 30px var(--gold); }
  50% { box-shadow: 0 0 50px var(--gold); }
  100% { box-shadow: 0 0 30px var(--gold); }
}

@keyframes float {
  0% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
  100% { transform: translateY(0); }
}

@keyframes correctAnswer {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

@keyframes wrongAnswer {
  0%, 100% { transform: translateX(0); }
  20%, 60% { transform: translateX(-5px); }
  40%, 80% { transform: translateX(5px); }
}

@keyframes unlockSet {
  0% { 
    transform: scale(1);
    background: var(--locked);
  }
  50% { 
    transform: scale(1.1);
    background: var(--gold);
    box-shadow: 0 0 50px var(--gold);
  }
  100% { 
    transform: scale(1);
    background: linear-gradient(135deg, var(--gold), #ffa500);
  }
}

@keyframes unlockLevel {
  0% { 
    transform: scale(1);
    background: var(--locked);
  }
  50% { 
    transform: scale(1.1);
    background: var(--accent);
    box-shadow: 0 0 50px var(--accent);
  }
  100% { 
    transform: scale(1);
    background: linear-gradient(135deg, var(--accent), #1E90FF);
  }
}

@keyframes progressPulsate {
  0% { transform: scale(1); filter: brightness(1); }
  50% { transform: scale(1.1); filter: brightness(1.5); }
  100% { transform: scale(1); filter: brightness(1); }
}

@keyframes warningPulse {
  0% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.8; transform: scale(1.05); }
  100% { opacity: 1; transform: scale(1); }
}

@keyframes coinPulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.2); filter: drop-shadow(0 0 20px var(--gold)); }
  100% { transform: scale(1); }
}

/* Media Queries */
@media (max-width: 768px) {
  .question-screen {
    padding-top: 2rem;
    gap: 1rem;
  }

  .welcome-title {
    font-size: 3rem;
  }
  
  .stage-container {
    grid-template-columns: repeat(2, 1fr);
    padding: 1rem;
    gap: 1rem;
  }
  
  .set-container {
    grid-template-columns: repeat(3, 1fr);
    gap: 0.75rem;
    padding: 0.75rem;
  }
  
  
  .level {
    max-width: none;
    aspect-ratio: 1;
    font-size: 1.5rem;
  }
  
  .question-word {
    font-size: 2.5rem;
    margin: 0.5rem 0;
  }

  .progress-circle {
    width: 150px;
    height: 150px;
    margin: 0.5rem 0;
  }
  
  .progress-circle .timer-progress.warning {
    stroke: #f44336; /* This is the --error color */
    filter: drop-shadow(0 0 5px rgba(244, 67, 54, 0.5));
    transition: stroke 0.3s ease, stroke-dashoffset 1s linear;
}


  .timer-value {
    font-size: 2.5rem;
  }
  
  .buttons {
    grid-template-columns: 1fr;
    gap: 0.75rem;
  }
  
  .buttons button {
    min-height: 3.5rem;
    font-size: 1rem;
    padding: 0.75rem;
    line-height: 1.2;
  }

  .coins-header {
    top: 1rem;
    right: 1rem;
    padding: 0.5rem 1rem;
  }

  .perks-container {
    padding: 0.5rem;
    gap: 0.5rem;
    margin: 0.5rem 0;
  }

  .perk-button {
    padding: 0.35rem;
  }

  .perk-icon {
    font-size: 1.2rem;
  }

  .perk-count {
    font-size: 0.7rem;
  }
}

@media (max-width: 480px) {
  .welcome-title {
    font-size: 2.5rem;
    text-align: center;
    padding: 0 1rem;
  }
    
  .stage-container {
    grid-template-columns: 1fr;
  }
  
  .set-container {
    grid-template-columns: repeat(2, 1fr);
  }
  

  .question-word {
    font-size: 2rem;
  }

  .progress-circle {
    width: 120px;
    height: 120px;
    margin: 0.5rem 0;
  }

  .timer-value {
    font-size: 2rem;
  }
}

@supports(padding: max(0px)) {
  .screen {
    padding-left: max(2rem, env(safe-area-inset-left));
    padding-right: max(2rem, env(safe-area-inset-right));
    padding-bottom: max(2rem, env(safe-area-inset-bottom));
  }
}

/* Stage-specific themes */
.stage-1 {
  background: linear-gradient(135deg, var(--stage1-primary), var(--stage1-secondary));
}

.stage-1 .stage-button, .stage-1 .set-button.active {
  background: var(--stage1-accent);
}

.stage-2 {
  background: linear-gradient(135deg, var(--stage2-primary), var(--stage2-secondary));
}

.stage-2 .stage-button, .stage-2 .set-button.active {
  background: var(--stage2-accent);
}

.stage-3 {
  background: linear-gradient(135deg, var(--stage3-primary), var(--stage3-secondary));
}

.stage-3 .stage-button, .stage-3 .set-button.active {
  background: var(--stage3-accent);
}

.stage-4 {
  background: linear-gradient(135deg, var(--stage4-primary), var(--stage4-secondary));
}

.stage-4 .stage-button, .stage-4 .set-button.active {
  background: var(--stage4-accent);
}

.stage-5 {
  background: linear-gradient(135deg, var(--stage5-primary), var(--stage5-secondary));
}

.stage-5 .stage-button, .stage-5 .set-button.active {
  background: var(--stage5-accent);
}
  .screen {
    padding-left: max(2rem, env(safe-area-inset-left));
    padding-right: max(2rem, env(safe-area-inset-right));
    padding-bottom: max(2rem, env(safe-area-inset-bottom));
  }

  @keyframes goldGreenPulse {
    0%, 100% { 
        stroke: var(--gold);
        filter: brightness(1.5);
    }
    50% { 
        stroke: #1E90FF; /* Lapiz Lazuli */
        filter: brightness(1.2);
    }
}

@keyframes particleBurst {
    0% { transform: translate(0, 0); opacity: 1; }
    100% { transform: translate(var(--x), var(--y)); opacity: 0; }
}

.particle {
    position: absolute;
    width: 12px; /* Increased from 8px */
    height: 12px; /* Increased from 8px */
    border-radius: 50%;
    pointer-events: none;
    z-index: 1000;
    animation: particleBurst 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
}

@keyframes particleBurst {
    0% { 
        transform: translate(0, 0) scale(1); 
        opacity: 1; 
    }
    100% { 
        transform: translate(var(--x), var(--y)) scale(0.5); 
        opacity: 0; 
    }
}

.progress-circle.completed {
    animation: pulseGrow 0.4s ease-in-out infinite;
}

.progress-circle.completed circle.progress {
    animation: colorShift 0.4s ease-in-out infinite;
    transition: stroke 0.3s linear;
}

@keyframes particleBurst {
    0% { 
        transform: translate(0, 0) scale(1); 
        opacity: 1; 
    }
    100% { 
        transform: translate(var(--x), var(--y)) scale(0); 
        opacity: 0; 
    }
}


.particle-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    pointer-events: none;
    z-index: 0;
}

.letter-particle {
    position: absolute;
    font-size: 16px;
    color: rgba(255,255,255,0.2);
    user-select: none;
    pointer-events: none;
    opacity: 0;
    font-weight: bold;
    text-shadow: 0 0 3px rgba(255,255,255,0.1);
}

@keyframes letterFloat {
    0% {
        transform: translate(0, 0) rotate(0deg);
        opacity: 0;
    }
    10% {
        opacity: var(--opacity);
    }
    90% {
        opacity: var(--opacity);
    }
    100% {
        transform: translate(var(--moveX), var(--moveY)) rotate(var(--rotate));
        opacity: 0;
    }
}

/* Timer circle styles */
.progress-circle .timer-bg {
    stroke: rgba(255, 255, 255, 0.1);
    fill: none;
}

.progress-circle .timer-progress {
    stroke: rgba(255, 255, 255, 0.9);
    fill: none;
    transform-origin: center;
    transform: rotate(-180deg);
    transition: stroke-dashoffset 1s linear, stroke 0.3s ease;
}

.progress-circle .timer-progress.warning {
    stroke: #f44336;
    filter: drop-shadow(0 0 5px rgba(244, 67, 54, 0.5));
}

/* Initialize the circle properties */
.progress-circle circle.timer-bg,
.progress-circle circle.timer-progress {
    stroke-linecap: round;
}

/* Ensure inner circle doesn't get affected by outer circle animations */
.progress-circle.completed circle.timer-progress {
    animation: none;
}

/* Override any inherited animations for timer circles */
.progress-circle.completed .timer-bg,
.progress-circle.completed .timer-progress {
    animation: none !important;
}



.home-button i, .back-button i {
    color: var(--text);
    font-size: 1.5rem;
}

.home-button:hover, .back-button:hover {
    background: var(--accent);
    transform: scale(1.1);
}

.perk-button.disabled {
    opacity: 0.3;
    cursor: not-allowed;
}

.reset-button i {
    color: var(--text);
    font-size: 1.5rem;
}

.reset-button.warning {
    animation: blinkRed 0.2s linear 5;
}

@keyframes blinkRed {
    0%, 100% { background-color: transparent; }
    50% { background-color: var(--error); }
}


.admin-verification {
    background: var(--glass);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 2rem;
    width: 100%;
    max-width: 800px;
    margin: 2rem auto;
}

.pending-payments {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.payment-request {
    background: rgba(255,255,255,0.1);
    border-radius: 15px;
    padding: 1.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.verification-actions {
    display: flex;
    gap: 1rem;
}

.verification-actions button {
    padding: 0.5rem 1rem;
    border-radius: 25px;
    border: none;
    cursor: pointer;
    transition: all 0.3s ease;
}

.verification-actions button:not(.reject) {
    background: var(--success);
    color: white;
}

.verification-actions button.reject {
    background: var(--error);
    color: white;
}


.navigation-container {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    margin: 1rem 0;
    background: var(--glass);
    padding: 0.75rem;
    border-radius: 25px;
    backdrop-filter: blur(10px);
    position: fixed;
    top: 1rem;
    left: 1rem;
    z-index: 100;
}

.navigation-button {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    padding: 0;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    border: none;
    cursor: pointer;
    transition: background-color 0.3s ease;
    box-shadow: none;
}

.navigation-button:hover {
    background: transparent !important;
    box-shadow: none !important;
    transform: none !important;
}

.navigation-button:hover svg {
    fill: var(--text) !important;
    stroke: var(--text) !important;
}

.navigation-icon {
    font-size: 1.5rem;
    color: var(--text);
}

/* Override any glow effects */
.navigation-button.restart-level {
    color: var(--text);
    animation: none;
}

.navigation-button.restart-level:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-2px);
}

.navigation-button.disabled {
    cursor: pointer;
    opacity: 0.3;
}

@keyframes blinkRed {
    0%, 100% { background-color: transparent; }
    50% { background-color: var(--error); }
}

@keyframes particleBurst {
    0% { 
        transform: translate(0, 0) scale(1); 
        opacity: 1; 
    }
    100% { 
        transform: translate(var(--x), var(--y)) scale(0.5); 
        opacity: 0; 
    }
}

.menu-button {
    position: fixed;
    top: 2rem;
    right: 2rem;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: var(--glass);
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
    z-index: 100;
}

.menu-button:hover {
    transform: scale(1.1);
    background: rgba(255, 255, 255, 0.2);
}

.menu-button .navigation-icon {
    color: var(--text);
    font-size: 1.5rem;
}

.upgrade-prompt {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.7);
    opacity: 0;
    transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    z-index: 1000;
    pointer-events: none;
    width: 90%;
    max-width: 500px;
    background: var(--glass);
    backdrop-filter: blur(10px);
    padding: 2rem;
    border-radius: 20px;
    box-shadow: 0 20px 50px rgba(0,0,0,0.2);
    border: 1px solid rgba(255,255,255,0.1);
}

.upgrade-prompt.show {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
    pointer-events: auto;
    animation: popupAppear 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.upgrade-prompt h2 {
    color: var(--gold);
    margin-bottom: 1.5rem;
    text-align: center;
}

.upgrade-prompt-buttons {
    display: flex;
    gap: 1rem;
    justify-content: center;
    margin-top: 2rem;
}

.lock-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: inherit;
}

.lock-overlay i {
    color: var(--text);
    font-size: 2rem;
    opacity: 0.8;
}

@keyframes popupAppear {
    0% {
        transform: translate(-50%, -50%) scale(0.7) rotate(-5deg);
        opacity: 0;
    }
    70% {
        transform: translate(-50%, -50%) scale(1.05) rotate(2deg);
        opacity: 0.8;
    }
    100% {
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
        opacity: 1;
    }
}


/* Main Custom Practice Container */
.custom-practice-container {
    display: flex;
    gap: 2rem;
    max-width: 1400px;
    margin: 0 auto;
    padding: 2rem;
}

.practice-section {
    flex: 1;
    background: transparent;
    border-radius: 20px;
    padding: 2rem;
    backdrop-filter: none;
    box-shadow: none;
    border: 1px solid rgba(255,255,255,0.1);
}

.lists-section {
    flex: 1;
    background: transparent;
    border-radius: 20px;
    padding: 2rem;
    backdrop-filter: none;
    box-shadow: none;
    border: 1px solid rgba(255,255,255,0.1);
}

.list-name-section {
    margin-bottom: 1.5rem;
}

.list-name-input {
    width: 100%;
    padding: 0.875rem;
    border-radius: 50px;
    border: 1px solid rgba(255,255,255,0.2);
    background: rgba(255,255,255,0.1);
    color: var(--text);
    text-align: center;
    font-size: 1rem;
    transition: all 0.3s ease;
}

.list-name-input:focus {
    outline: none;
    border-color: var(--gold);
    box-shadow: 0 0 10px rgba(255,215,0,0.3);
}

#custom-word-input {
    width: 100%;
    margin-bottom: 1.5rem;
    padding: 1rem;
    border-radius: 15px;
    border: 1px solid rgba(255,255,255,0.2);
    background: rgba(255,255,255,0.1);
    color: var(--text);
    min-height: 120px;
    resize: vertical;
    transition: all 0.3s ease;
}

#custom-word-input:focus {
    outline: none;
    border-color: var(--gold);
    box-shadow: 0 0 10px rgba(255,215,0,0.3);
}

.translation-results {
    background: rgba(255,255,255,0.05);
    border-radius: 15px;
    padding: 1.5rem;
    margin-top: 1.5rem;
}

.word-translation-list {
    display: table;
    width: 100%;
    border-spacing: 0 0.75rem;
}

.word-translation-item {
    display: table-row;
    background: rgba(255,255,255,0.05);
    border-radius: 10px;
    transition: all 0.3s ease;
    cursor: grab;
}

.word-translation-item.dragging {
    opacity: 0.5;
    background: rgba(255,255,255,0.2);
    cursor: grabbing;
}

.word-translation-item > * {
    display: table-cell;
    padding: 0.75rem;
    vertical-align: middle;
    text-align: center;
}

.drag-handle {
    width: 20px;
    color: var(--text);
    opacity: 0.7;
    cursor: grab;
}

.drag-handle:hover {
    opacity: 1;
}

/* Split word input field styles */
.word-translation-item .source-word {
    padding: 0.5rem;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.1);
    color: var(--text);
    margin: 0.5rem;
    width: 200px;
    min-height: 36px;
    text-align: center;
    border: 1px solid rgba(255,255,255,0.2);
    transition: all 0.3s ease;
    display: inline-block;
    vertical-align: middle;
}

.word-translation-item .target-word {
    padding: 0.5rem;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.1);
    color: var(--text);
    margin: 0.5rem;
    width: 200px;
    min-height: 36px;
    text-align: center;
    border: 1px solid rgba(255,255,255,0.2);
    transition: all 0.3s ease;
    display: inline-block;
    vertical-align: middle;
}

.word-translation-item .source-word[contenteditable="true"] {
    font-family: inherit;
    font-size: inherit;
    appearance: none;
    -webkit-appearance: none;
}

.word-translation-item .target-word[contenteditable="true"] {
    font-family: inherit;
    font-size: inherit;
    appearance: none;
    -webkit-appearance: none;
}

.word-translation-item .target-word:not([readonly]) {
    font-family: inherit;
    font-size: inherit;
    appearance: none;
    -webkit-appearance: none;
}



.custom-list-item {
    position: relative;
    display: flex;
    flex-direction: column;
    padding: 1.25rem;
    margin-bottom: 1.5rem;
    background: transparent;
    border-radius: 15px;
    backdrop-filter: none;
    border: 1px solid rgba(255,255,255,0.1);
}

.custom-list-item h3 {
    margin-bottom: 0.5rem;
    color: var(--gold);
}

.custom-list-item .list-info {
    margin: 1rem 0;
    color: var(--text);
    opacity: 0.8;
}

.list-header {
    cursor: pointer;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    order: 1; /* Places header after buttons */
}

.list-summary {
    font-size: 0.9rem;
    opacity: 0.8;
}

.list-content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease;
}

.custom-list-item:not(.collapsed) .list-content {
    max-height: 1000px;
    margin-top: 1rem;
}

.list-header {
    cursor: pointer;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.word-preview {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
    margin-top: 0.25rem;
}


/* Media Queries */

@media (max-width: 768px) {
    .list-actions {
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        width: 100%;
    }
    
    .add-word-button {
        width: 100%;
        justify-content: center;
    }
}

@media (max-width: 768px) {
    .custom-practice-container {
        flex-direction: column;
        gap: 1.5rem;
        padding: 1rem;
    }

    .practice-section {
        padding: 1rem;
        width: 100%;
    }

    .lists-section {
        padding: 1rem;
        width: 100%;
    }

    #custom-word-input {
        min-height: 150px;
        font-size: 16px;
        padding: 1rem;
    }

    .word-translation-list {
        display: block;
    }

    .word-translation-item {
    display: table-row;
    background: transparent;
    border-radius: 10px;
    transition: all 0.3s ease;
    cursor: grab;
    border: 1px solid rgba(255,255,255,0.1);
}

    .word-translation-item .source-word {
        width: 100%;
        min-height: 44px;
        font-size: 16px;
        padding: 0.75rem;
        margin: 0;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
    }

    .word-translation-item .target-word {
        width: 100%;
        min-height: 44px;
        font-size: 16px;
        padding: 0.75rem;
        margin: 0;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
    }

    .list-actions {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 0.75rem;
        margin-top: 1rem;
        width: 100%;
    }

    

    .custom-list-item {
        padding: 1.25rem;
        margin-bottom: 1rem;
    }

    .custom-list-item h3 {
        font-size: 1.25rem;
        margin-bottom: 0.75rem;
    }

    .list-info {
        font-size: 0.9rem;
        margin: 0.75rem 0;
    }

    .list-stats {
        grid-column: 1 / -1;
        text-align: center;
        margin-top: 0.75rem;
        font-size: 0.875rem;
        opacity: 0.8;
    }

    .drag-handle {
        display: none;
    }

    .delete-word-btn {
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto;
    }

    .word-preview {
        font-size: 0.85rem;
    }
    
    .custom-list-item:not(.collapsed) {
        padding-bottom: 0.75rem;
    }
}

@media (max-width: 480px) {
    .custom-practice-container {
        padding: 0.5rem;
    }

    .start-button {
        width: 100%;
        max-width: 250px;
        font-size: 0.9rem;
        padding: 0.6rem;
    }

    .edit-mode-button {
        width: 100%;
        max-width: none;
        font-size: 0.9rem;
        padding: 0.6rem;
    }

    
    .list-actions {
        grid-template-columns: 1fr;
    }

    .custom-list-item h3 {
        font-size: 1.1rem;
    }

    .list-info {
        font-size: 0.85rem;
    }

    .word-translation-item {
        padding: 0.75rem;
    }

    .word-translation-item .source-word {
        font-size: 0.95rem;
        padding: 0.6rem;
    }

    .word-translation-item .target-word {
        font-size: 0.95rem;
        padding: 0.6rem;
    }
}

@media (max-width: 360px) {
    .custom-practice-container {
        padding: 0.25rem;
    }

    .practice-section {
        padding: 0.75rem;
    }

    .lists-section {
        padding: 0.75rem;
    }

    .custom-list-item {
        padding: 1rem;
    }

    .custom-list-item h3 {
        font-size: 1rem;
    }
}

.username-display {
    padding: 0.75rem;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 15px;
    margin-bottom: 0.5rem;
    color: var(--gold);
    font-weight: bold;
}

.victory-screen {
    background: rgba(0,0,0,0.9);
}

.victory-screen .completion-modal-content {
    background: transparent;
    display: flex;
    flex-direction: column;
    align-items: center;
    max-width: 400px;
    padding: 0;
    border-radius: 20px;
    overflow: hidden;
}

.victory-header {
    width: 100%;
    text-align: center;
    padding: 1.5rem;
    color: white;
}

.victory-header .rank-emoji {
    font-size: 3rem;
    display: block;
    margin-bottom: 0.5rem;
}

.victory-header h2 {
    font-size: 1.5rem;
    text-transform: uppercase;
    letter-spacing: 2px;
}

.victory-message {
    padding: 1rem;
    text-align: center;
    background: rgba(255,255,255,0.1);
    width: 100%;
}

.completion-stats {
    display: flex;
    justify-content: space-around;
    width: 100%;
    padding: 1.5rem;
    background: rgba(255,255,255,0.05);
}

.stat-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}

.stat-icon {
    font-size: 2rem;
    margin-bottom: 0.5rem;
}

.stat-label {
    font-size: 0.8rem;
    color: rgba(255,255,255,0.7);
    text-transform: uppercase;
}

.stat-value {
    font-size: 1.5rem;
    font-weight: bold;
    color: white;
}

.victory-button {
    width: 100%;
    padding: 1rem;
    background: var(--accent);
    color: white;
    border: none;
    font-size: 1rem;
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: background 0.3s ease;
}

.victory-button:hover {
    background: color-mix(in srgb, var(--accent) 90%, white);
}

.inactivity-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}

.inactivity-overlay.visible {
    opacity: 1;
    pointer-events: auto;
}

.countdown-timer {
    font-size: 8rem;
    color: var(--gold);
    margin-bottom: 2rem;
    text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
}

.inactivity-message {
    font-size: 1.5rem;
    color: var(--text);
    text-align: center;
    max-width: 80%;
}

.countdown-cancel {
    margin-top: 2rem;
    padding: 1rem 2rem;
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 25px;
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

.countdown-cancel:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(233, 69, 96, 0.4);
}

.countdown-progress {
    width: 200px;
    height: 5px;
    background: rgba(255,255,255,0.2);
    border-radius: 3px;
    margin-top: 1rem;
    overflow: hidden;
}

.countdown-bar {
    height: 100%;
    width: 100%;
    background: var(--gold);
    transform-origin: left;
    transition: transform 1s linear;
}
@keyframes celebrationGlow {
    0% { box-shadow: 0 0 15px #FFD700; background: rgba(255, 215, 0, 0.2); }
    25% { box-shadow: 0 0 20px #FF1493; background: rgba(255, 20, 147, 0.2); }
    50% { box-shadow: 0 0 25px #00BFFF; background: rgba(0, 191, 255, 0.2); }
    75% { box-shadow: 0 0 20px #7CFC00; background: rgba(124, 252, 0, 0.2); }
    100% { box-shadow: 0 0 15px #FFD700; background: rgba(255, 215, 0, 0.2); }
}

@keyframes celebrationGlowIntense {
    0% { box-shadow: 0 0 25px #FFD700; background: rgba(255, 215, 0, 0.3); }
    25% { box-shadow: 0 0 35px #FF1493; background: rgba(255, 20, 147, 0.3); }
    50% { box-shadow: 0 0 45px #00BFFF; background: rgba(0, 191, 255, 0.3); }
    75% { box-shadow: 0 0 35px #7CFC00; background: rgba(124, 252, 0, 0.3); }
    100% { box-shadow: 0 0 25px #FFD700; background: rgba(255, 215, 0, 0.3); }
}

@keyframes confettiFall {
    0% { transform: translateY(-20vh) rotate(0deg); opacity: 1; }
    100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
}

@keyframes celebrationEmoji {
    0% { transform: scale(0) rotate(-30deg); opacity: 0; }
    50% { transform: scale(1.2) rotate(5deg); opacity: 1; }
    100% { transform: scale(1) rotate(0); opacity: 1; }
}

@keyframes gracefulCenterMove {
    0% { 
        position: absolute;
        transform: translate(0, 0) scale(1);
        z-index: 20;
    }
    100% { 
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(3);
        z-index: 100;
    }
}

@keyframes firstPlaceMove {
    0% { 
        position: absolute;
        transform: translate(0, 0) scale(1);
    }
    100% { 
        position: fixed;
        top: 30vh;
        left: 50%;
        transform: translate(-50%, 0) scale(1.5);
        z-index: 103;
    }
}

@keyframes secondPlaceMove {
    0% { 
        position: absolute;
        transform: translate(0, 0) scale(1);
    }
    100% { 
        position: fixed;
        top: 50vh;
        left: 50%;
        transform: translate(-50%, 0) scale(1.25);
        z-index: 102;
    }
}

@keyframes thirdPlaceMove {
    0% { 
        position: absolute;
        transform: translate(0, 0) scale(1);
    }
    100% { 
        position: fixed;
        top: 70vh;
        left: 50%;
        transform: translate(-50%, 0) scale(1);
        z-index: 101;
    }
}

.winner-entry {
    position: relative;
    transition: all 0.5s ease;
}

.winner-entry.celebrating {
    border-radius: 15px;
    border: 2px solid transparent;
    overflow: visible !important;
}

.winner-entry.first-place {
    border: 3px solid var(--gold);
    animation: firstPlaceMove 1.5s forwards, celebrationGlowIntense 2s infinite 1.5s;
    background: rgba(255, 215, 0, 0.2);
}

.winner-entry.second-place {
    border: 3px solid var(--silver);
    animation: secondPlaceMove 1.5s forwards, celebrationGlowIntense 2.5s infinite 1.5s;
    background: rgba(192, 192, 192, 0.2);
}

.winner-entry.third-place {
    border: 3px solid var(--bronze);
    animation: thirdPlaceMove 1.5s forwards, celebrationGlowIntense 3s infinite 1.5s;
    background: rgba(205, 127, 50, 0.2);
}

/* Enhance winner entry text styling */
.winner-entry.first-place .player-name,
.winner-entry.second-place .player-name,
.winner-entry.third-place .player-name {
    font-size: 1.8rem;
    transition: all 0.5s ease;
    text-shadow: 0 0 5px rgba(255,255,255,0.3);
}

.winner-entry.first-place .words,
.winner-entry.first-place .coins,
.winner-entry.second-place .words,
.winner-entry.second-place .coins,
.winner-entry.third-place .words,
.winner-entry.third-place .coins {
    font-size: 1.4rem;
    transition: all 0.5s ease;
}

/* Greatly enhanced text when entries grow */
.winner-entry.first-place.centered .player-name {
    font-size: 3.2rem;
    font-weight: 800;
    color: white;
    text-shadow: 0 0 10px var(--gold), 0 0 20px var(--gold);
    letter-spacing: 1px;
}
.winner-entry.first-place.centered .words,
.winner-entry.first-place.centered .coins {
    font-size: 2.4rem;
    font-weight: 700;
    text-shadow: 0 0 8px rgba(255,215,0,0.6);
}

.winner-entry.second-place.centered .player-name {
    font-size: 2.8rem;
    font-weight: 700;
    color: white;
    text-shadow: 0 0 10px var(--silver), 0 0 20px var(--silver);
}
.winner-entry.second-place.centered .words,
.winner-entry.second-place.centered .coins {
    font-size: 2.2rem;
    font-weight: 600;
    text-shadow: 0 0 8px rgba(192,192,192,0.6);
}

.winner-entry.third-place.centered .player-name {
    font-size: 2.4rem;
    font-weight: 600;
    color: white;
    text-shadow: 0 0 10px var(--bronze), 0 0 20px var(--bronze);
}
.winner-entry.third-place.centered .words,
.winner-entry.third-place.centered .coins {
    font-size: 2rem;
    font-weight: 600;
    text-shadow: 0 0 8px rgba(205,127,50,0.6);
}

/* Add CSS for laurel wreath */
.laurel-wreath {
    pointer-events: none;
}

/* Updated winner label */
.winner-label {
    position: absolute;
    top: -70px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 2.2rem;
    font-weight: bold;
    color: var(--gold);
    background: rgba(0,0,0,0.7);
    padding: 5px 20px;
    border: 2px solid rgba(255,215,0,0.3);
    border-radius: 30px;
    text-shadow: 0 0 15px rgba(255,215,0,0.8);
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.5s ease 1.5s;
    z-index: 250;
    letter-spacing: 1px;
}

.winner-entry.first-place.centered .winner-label {
    opacity: 1;
    box-shadow: 0 0 20px rgba(255,215,0,0.4);
}

.celebration-emoji {
    position: fixed;
    opacity: 0;
    transform: scale(0);
    animation: emojiAppear 0.6s forwards;
    filter: drop-shadow(0 0 10px rgba(0,0,0,0.5));
    z-index: 300;
}

@keyframes emojiAppear {
    0% { opacity: 0; transform: scale(0) rotate(-30deg); }
    70% { opacity: 1; transform: scale(1.2) rotate(10deg); }
    100% { opacity: 1; transform: scale(1) rotate(0); }
}

.confetti {
    position: fixed;
    width: 10px;
    height: 10px;
    top: -20px;
    z-index: 5;
    border-radius: 0;
    animation: confettiFall 4s linear forwards;
}

.celebration-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.85);
    z-index: 1;
    opacity: 0;
    transition: opacity 1s ease;
    pointer-events: none;
}

.celebration-overlay.visible {
    opacity: 1;
}


.home-button-container {
    position: fixed;
    bottom: 5vh;
    left: 50%;
    transform: translateX(-50%);
    z-index: 200;
    opacity: 0;
    transition: opacity 1s ease 2s;
}

.home-button-container.visible {
    opacity: 1;
}

.winner-label {
    position: absolute;
    top: -55px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 1.8rem;
    font-weight: bold;
    color: var(--gold);
    background-color: rgba(0,0,0,0.7);
    padding: 5px 15px;
    border-radius: 20px;
    text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.5s ease 1.5s;
    z-index: 105;
}

.winner-entry.centered .winner-label {
    opacity: 1;
}

/* Word Goal Slider Styles */
.slider-container {
    width: 100%;
    max-width: 500px;
    margin: 1rem auto;
    position: relative;
}

.word-goal-slider {
    -webkit-appearance: none;
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: rgba(255,255,255,0.2);
    outline: none;
    direction: ltr; /* Ensure left-to-right behavior */
}

.word-goal-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: var(--gold);
    cursor: pointer;
    box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    transition: all 0.2s ease;
}

.word-goal-slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: var(--gold);
    cursor: pointer;
    box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    transition: all 0.2s ease;
}

.word-goal-slider::-webkit-slider-thumb:hover {
    transform: scale(1.2);
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
}

.slider-stops {
    display: flex;
    justify-content: space-between;
    margin-top: 0.5rem;
    padding: 0 10px;
}

.slider-stop {
    position: relative;
    cursor: pointer;
    font-size: 0.9rem;
    color: var(--text);
    transition: all 0.2s ease;
}

.slider-stop:hover {
    color: var(--gold);
    transform: translateY(-2px);
}

.slider-stop::before {
    content: '';
    position: absolute;
    top: -15px;
    left: 50%;
    transform: translateX(-50%);
    width: 2px;
    height: 10px;
    background-color: rgba(255,255,255,0.5);
}

.word-goal-input {
    width: 80px;
    padding: 0.5rem;
    text-align: center;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 25px;
    color: var(--text);
    margin-top: 1rem;
    font-size: 1rem;
}

.word-goal-input:focus {
    outline: none;
    border-color: var(--gold);
    box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
}

.stage-checkboxes label {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    cursor: pointer;
    font-size: 1.4rem; /* Increased from 1.2rem */
    padding: 1.25rem; /* Increased from 1rem */
    background: rgba(255,255,255,0.1);
    border-radius: 15px;
    transition: all 0.3s ease;
    min-width: 120px; /* Added minimum width */
    justify-content: center; /* Center content */
}

.stage-checkboxes input[type="checkbox"] {
    width: 28px; /* Increased from 24px */
    height: 28px; /* Increased from 24px */
    cursor: pointer;
    accent-color: var(--gold); /* Highlight selected checkboxes */
}

.slider-stops {
    display: flex;
    justify-content: space-between;
    margin-top: 0.75rem;
    padding: 0 10px;
    width: 100%;
}

.slider-stop {
    position: relative;
    cursor: pointer;
    font-size: 1rem; /* Increased from 0.9rem */
    color: var(--text);
    transition: all 0.3s ease;
    padding: 0.5rem;
    background: rgba(255,255,255,0.05);
    border-radius: 12px;
    min-width: 40px;
    text-align: center;
}

.slider-stop:hover {
    color: var(--gold);
    transform: translateY(-3px);
    background: rgba(255,255,255,0.1);
}

.slider-stop::before {
    content: '';
    position: absolute;
    top: -15px;
    left: 50%;
    transform: translateX(-50%);
    width: 3px; /* Increased from 2px */
    height: 12px; /* Increased from 10px */
    background-color: rgba(255,255,255,0.6);
}

.word-goal-slider {
    height: 8px; /* Slightly thicker slider */
    border-radius: 4px;
    margin: 1.5rem 0 0.5rem;
}

.word-goal-slider::-webkit-slider-thumb {
    width: 24px; /* Larger thumb */
    height: 24px;
}

.word-goal-slider::-moz-range-thumb {
    width: 24px; /* Larger thumb */
    height: 24px;
}

/* Revive Overlay Styles */
.revive-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    opacity: 0;
    transition: opacity 0.5s ease;
}

.revive-overlay.show {
    opacity: 1;
}

.revive-content {
    text-align: center;
    transform: translateY(30px);
    transition: transform 0.5s ease;
}

.revive-overlay.show .revive-content {
    transform: translateY(0);
}

.ankh-symbol {
    font-size: 8rem;
    color: var(--gold);
    margin-bottom: 1rem;
    text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
    animation: ankhPulse 2s infinite;
}

@keyframes ankhPulse {
    0%, 100% { 
        transform: scale(1);
        text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
    }
    50% { 
        transform: scale(1.1);
        text-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
    }
}

.revive-title {
    font-size: 3rem;
    color: var(--text);
    margin-bottom: 2rem;
}

.revive-timer {
    font-size: 5rem;
    color: var(--gold);
    font-weight: bold;
    margin-bottom: 2rem;
    text-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
}

.revive-button {
    padding: 1rem 3rem;
    font-size: 1.5rem;
    background: var(--accent);
    color: var(--text);
    border: none;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 0 20px var(--accent);
    animation: buttonGlow 1.5s infinite;
}

.revive-button:hover {
    transform: translateY(-3px);
    box-shadow: 0 0 30px var(--accent);
}

@keyframes buttonGlow {
    0%, 100% { box-shadow: 0 0 20px var(--accent); }
    50% { box-shadow: 0 0 30px var(--accent); }
}

/* Resurrection Animation Styles */
.resurrection-animation {
    position: relative;
    width: 240px;
    height: 240px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.resurrection-circle {
    width: 200px;
    height: 200px;
}

.resurrection-progress {
    stroke: var(--gold);
    stroke-linecap: round;
    transform-origin: center;
    transform: rotate(-90deg);
    stroke-dashoffset: 339.29;
    filter: drop-shadow(0 0 10px var(--gold));
}

.resurrection-ankh {
    position: absolute;
    font-size: 5rem;
    color: var(--gold);
    animation: resurrectGlow 2s infinite;
}

@keyframes resurrectGlow {
    0%, 100% { text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
    50% { text-shadow: 0 0 40px rgba(255, 215, 0, 0.8); }
}

@keyframes particleFlow {
    0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 0;
    }
    20% {
        opacity: 1;
    }
    100% {
        transform: translate(calc(-50% + var(--end-x)), calc(-50% + var(--end-y))) scale(1);
        opacity: 0;
    }
}

/* Mobile Responsive Adjustments */
@media (max-width: 768px) {
    .ankh-symbol {
        font-size: 6rem;
    }
    
    .revive-title {
        font-size: 2rem;
    }
    
    .revive-timer {
        font-size: 4rem;
    }
    
    .revive-button {
        padding: 0.75rem 2rem;
        font-size: 1.2rem;
    }
    
    .resurrection-animation {
        width: 180px;
        height: 180px;
    }
    
    .resurrection-circle {
        width: 150px;
        height: 150px;
    }
    
    .resurrection-ankh {
        font-size: 3.5rem;
    }
}

@media (max-width: 480px) {
    .ankh-symbol {
        font-size: 5rem;
    }
    
    .revive-title {
        font-size: 1.8rem;
    }
    
    .revive-timer {
        font-size: 3.5rem;
    }
    
    .revive-button {
        padding: 0.5rem 1.5rem;
        font-size: 1rem;
    }
    
    .resurrection-animation {
        width: 150px;
        height: 150px;
    }
    
    .resurrection-circle {
        width: 120px;
        height: 120px;
    }
    
    .resurrection-ankh {
        font-size: 3rem;
    }
}

/* Stage-Set Cascade UI Styles */
.stages-container {
  width: 100%;
  max-width: 800px;
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  padding: 1rem;
  margin: 0 auto;
  margin-top: 3rem;
}

.stage-wrapper {
  width: 100%;
}

.stage-wrapper .stage-button {
  width: 100%;
  padding: 1.25rem;
  border-radius: 16px;
  background: var(--glass);
  backdrop-filter: blur(10px);
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border: 1px solid rgba(255, 255, 255, 0.1);
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.stage-wrapper .stage-button::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.15) 0%, transparent 70%);
  opacity: 0;
  transition: opacity 0.3s ease;
}

.stage-wrapper .stage-button:hover::before {
  opacity: 1;
}

.stage-wrapper .stage-button:hover {
  transform: translateY(-5px);
  box-shadow: 0 10px 20px rgba(0,0,0,0.2);
}

.stage-info {
  display: flex;
  align-items: center;
  gap: 1.25rem;
}

.stage-icon {
  width: 64px;
  height: 64px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.75rem;
  background: linear-gradient(135deg, var(--accent), rgba(30, 144, 255, 0.7));
  border-radius: 12px;
  box-shadow: 0 5px 15px rgba(30, 144, 255, 0.3);
}

.stage-text {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.stage-wrapper .stage-name {
  font-size: 1.2rem;
  font-weight: 700;
  color: var(--text);
}

.stage-desc {
  font-size: 0.9rem;
  opacity: 0.8;
}

.stage-status {
  font-size: 0.85rem;
  padding: 0.25rem 0.75rem;
  border-radius: 50px;
  background: rgba(255, 255, 255, 0.1);
}

.stage-toggle {
  font-size: 1.25rem;
  transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
}

.stage-wrapper.open .stage-toggle {
  transform: rotate(180deg);
}

/* Sets container and styling */
.sets-container {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  background: rgba(0, 0, 0, 0.2);
  border-radius: 0 0 16px 16px;
  margin-top: 2px;
  border: 1px solid rgba(255, 255, 255, 0.05);
  border-top: none;
}

.stage-wrapper.open .sets-container {
  max-height: 800px; /* Allows up to around 6-7 sets visible */
}

.sets-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 1rem;
  padding: 1.5rem;
}

.sets-grid .set-button {
  aspect-ratio: 16/9;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 1rem;
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.05);
  backdrop-filter: blur(5px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  cursor: pointer;
  transition: all 0.3s ease;
  font-weight: 600;
  overflow: hidden;
}

.sets-grid .set-button.active {
  background: linear-gradient(135deg, var(--accent), rgba(30, 144, 255, 0.7));
  border: 1px solid rgba(255, 255, 255, 0.3);
  box-shadow: 0 5px 15px rgba(30, 144, 255, 0.2);
}

.sets-grid .set-button.locked {
  background: rgba(128, 128, 128, 0.2);
  cursor: not-allowed;
}

.sets-grid .set-button:not(.locked):hover {
  transform: translateY(-3px) scale(1.03);
  box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
}

.sets-grid .set-button::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 80%);
  opacity: 0;
  transition: opacity 0.3s ease;
}

.sets-grid .set-button:not(.locked):hover::before {
  opacity: 1;
}

.lock-icon {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.5rem;
  color: rgba(255, 255, 255, 0.5);
}

.completed-indicator {
  position: absolute;
  top: 0.5rem;
  right: 0.5rem;
  font-size: 0.75rem;
  color: var(--gold);
}

/* Open/Closed Stage State */
.stage-wrapper.closed .sets-container {
  max-height: 0;
}

.stage-wrapper.open .stage-button {
  border-radius: 16px 16px 0 0;
  transform: translateY(0);
  box-shadow: none;
}

/* Stage themes */
.stage-wrapper[data-stage="1"] .stage-icon {
  background: linear-gradient(135deg, #ff416c, #ff4b2b);
}

.stage-wrapper[data-stage="2"] .stage-icon {
  background: linear-gradient(135deg, #4facfe, #00f2fe);
}

.stage-wrapper[data-stage="3"] .stage-icon {
  background: linear-gradient(135deg, #a18cd1, #fbc2eb);
}

.stage-wrapper[data-stage="4"] .stage-icon {
  background: linear-gradient(135deg, #84fab0, #8fd3f4);
}

.stage-wrapper[data-stage="5"] .stage-icon {
  background: linear-gradient(135deg, #fad0c4, #ffd1ff);
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .stages-container {
    max-width: 100%;
    padding: 0.5rem;
  }
  
  .stage-icon {
    width: 48px;
    height: 48px;
    font-size: 1.4rem;
  }
  
  .stage-wrapper .stage-name {
    font-size: 1rem;
  }
  
  .stage-desc {
    font-size: 0.8rem;
  }
  
  .sets-grid {
    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    padding: 1rem;
    gap: 0.75rem;
  }
}

/* Add to the existing CSS in index.html */
.accessibility-toggle {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: var(--primary);
    border: 2px solid var(--accent);
    color: var(--text);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 9999;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    transition: all 0.3s ease;
}

.accessibility-toggle:hover {
    transform: scale(1.1);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
}

.accessibility-toggle i {
    font-size: 24px;
}

.accessibility-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(5px);
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
}

.accessibility-modal.show {
    opacity: 1;
    visibility: visible;
}

.accessibility-content {
    width: 90%;
    max-width: 600px;
    max-height: 90vh;
    overflow-y: auto;
    background: var(--primary-dark);
    border-radius: 20px;
    padding: 2rem;
    color: var(--text);
    border: 1px solid var(--accent);
}

.accessibility-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.accessibility-header h2 {
    margin: 0;
    color: var(--gold);
    font-size: 1.8rem;
}

.close-accessibility {
    background: transparent;
    border: none;
    color: var(--text);
    font-size: 1.5rem;
    cursor: pointer;
    opacity: 0.8;
    transition: opacity 0.3s ease;
}

.close-accessibility:hover {
    opacity: 1;
}

.accessibility-options {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
}

.accessibility-section {
    margin-bottom: 1rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.accessibility-section h3 {
    margin-top: 0;
    margin-bottom: 1rem;
    color: var(--accent);
    font-size: 1.3rem;
}

.option-group {
    margin-bottom: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.option-group label {
    font-size: 1rem;
    color: var(--text);
    opacity: 0.9;
}

.controls {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
}

.accessibility-button {
    padding: 0.5rem 1rem;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: var(--text);
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 0.9rem;
}

.accessibility-button:hover {
    background: rgba(255, 255, 255, 0.2);
}

.accessibility-button.active {
    background: var(--accent);
    border-color: var(--accent);
    color: var(--primary-dark);
    box-shadow: 0 0 10px rgba(30, 144, 255, 0.5);
}

.accessibility-footer {
    margin-top: 1.5rem;
    padding-top: 1rem;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    text-align: center;
}

.reset-all {
    width: 100%;
    padding: 0.75rem !important;
    background: rgba(244, 67, 54, 0.2) !important;
    border: 1px solid rgba(244, 67, 54, 0.4) !important;
    color: #f44336 !important;
}

.reset-all:hover {
    background: rgba(244, 67, 54, 0.3) !important;
}

/* Helper classes that will be applied by JavaScript */
body.high-contrast {
    --primary-dark: #000000;
    --primary: #000000;
    --secondary: #000000;
    --text: #ffffff;
    --accent: #ffff00;
}

body.inverted-colors {
    filter: invert(1) hue-rotate(180deg);
}

body.grayscale {
    filter: grayscale(1);
}

body.large-font {
    --font-scale: 1.2;
    font-size: calc(1rem * var(--font-scale));
}

body.larger-font {
    --font-scale: 1.4;
    font-size: calc(1rem * var(--font-scale));
}

body.largest-font {
    --font-scale: 1.6;
    font-size: calc(1rem * var(--font-scale));
}

body.dyslexic-font {
    font-family: 'OpenDyslexic', 'Comic Sans MS', sans-serif;
}

body.increased-letter-spacing {
    letter-spacing: 0.1em;
}

body.no-animations * {
    animation: none !important;
    transition: none !important;
}

body.reduced-animations * {
    animation-duration: 0.001s !important;
    transition-duration: 0.001s !important;
}

body.high-focus :focus {
    outline: 3px solid var(--accent) !important;
    outline-offset: 3px !important;
    box-shadow: 0 0 0 3px var(--accent) !important;
}

body.large-buttons button,
body.large-buttons .main-button,
body.large-buttons .nav-link,
body.large-buttons input[type="submit"] {
    padding: calc(0.75rem * 1.3) calc(1.5rem * 1.3) !important;
    font-size: calc(1rem * 1.3) !important;
    min-height: 44px !important;
}

body.large-cursor,
body.large-cursor * {
    cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'%3E%3Ccircle cx='16' cy='16' r='15' fill='white' stroke='black' stroke-width='2'/%3E%3C/svg%3E") 16 16, auto !important;
}

/* Light theme */
body.light-theme {
    --primary-dark: #ffffff;
    --primary: #f5f5f5;
    --secondary: #e0e0e0;
    --text: #333333;
    --accent: #1E90FF;
    --gradient: linear-gradient(135deg, #f5f5f5, #e0e0e0);
}

/* Dark theme - already exists in original CSS */
body.dark-theme {
    --primary-dark: #1a1a2e;
    --primary: #16213e;
    --secondary: #0f3460;
    --text: #ffffff;
    --accent: #1E90FF;
    --gradient: linear-gradient(135deg, var(--secondary), var(--primary-dark));
}

/* Add OpenDyslexic font support */
@font-face {
    font-family: 'OpenDyslexic';
    src: url('https://cdn.jsdelivr.net/npm/open-dyslexic@1.0.3/woff/OpenDyslexic-Regular.woff') format('woff');
    font-weight: normal;
    font-style: normal;
}

/* Media query for mobile devices */
@media (max-width: 768px) {
    .accessibility-content {
        width: 95%;
        padding: 1.5rem;
    }
    
    .accessibility-toggle {
        bottom: 15px;
        right: 15px;
        width: 45px;
        height: 45px;
    }
    
    .accessibility-button {
        padding: 0.5rem 0.75rem;
        font-size: 0.85rem;
    }
}

/* Boss level styles */
.boss-mode {
  background: linear-gradient(135deg, #800000, #3a0000) !important;
}
.boss-orb {
  font-size: 28px;
  animation: pulseOrb 1.5s infinite;
}
@keyframes pulseOrb {
  0%, 100% { transform: scale(1); opacity: 0.8; text-shadow: 0 0 15px #ff3333; }
  50% { transform: scale(1.2); opacity: 1; text-shadow: 0 0 25px #ff3333, 0 0 35px #ff3333; }
}
.boss-health.warning {
  animation: bossHealthWarning 0.5s infinite alternate;
}
@keyframes bossHealthWarning {
  from { stroke: #ff3333; }
  to { stroke: #ffffff; }
}
.boss-hit {
  animation: bossHitEffect 0.2s;
}
@keyframes bossHitEffect {
  0% { transform: scale(1); }
  50% { transform: scale(1.02); background-color: rgba(255, 0, 0, 0.2); }
  100% { transform: scale(1); }
}
.perk-disabled {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.5em;
  color: red;
  pointer-events: none;
}

/* Custom Lists Section */
.custom-lists-container {
    margin: 20px 0;
}

.custom-lists-wrapper {
    max-height: 150px;
    overflow-y: auto;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 10px;
    margin-top: 10px;
    background-color: #f9f9f9;
}

.custom-lists-checkboxes label {
    display: flex;
    align-items: center;
    margin-bottom: 8px;
    cursor: pointer;
}

.custom-lists-checkboxes input[type="checkbox"] {
    margin-right: 8px;
}

.custom-words-count {
    margin-top: 10px;
    font-weight: 500;
    font-size: 14px;
}

/* Start Button Styling */
.arcade-start-btn {
    background-color: var(--primary);
    color: white;
    padding: 12px 24px;
    border-radius: 8px;
    font-weight: bold;
    font-size: 16px;
    transition: background-color 0.3s ease, transform 0.1s ease;
    border: none;
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16);
    margin-top: 20px;
    width: 100%;
    cursor: pointer;
}

.arcade-start-btn:hover {
    background-color: var(--primary-dark, #0056b3);
    transform: translateY(-2px);
}

.arcade-start-btn:active {
    transform: translateY(1px);
}

.arcade-start-btn:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

</style>
</head>
<body>

<div id="qr-landing" class="screen" style="display: none;">
    <div class="qr-landing-content">
        <h2>Welcome to Simplos Arcade!</h2>
        <p>Your game code is:</p>
        <div class="game-code-display"></div>
        <button class="join-game-button" onclick="proceedToGame()">
            Join Game
        </button>
    </div>
</div>


  <div id="welcome-screen" class="screen visible">
    <div class="particle-container" id="particleContainer"></div>    
    <h1 class="welcome-title">Simplos</h1>
    
    <div class="main-buttons">
        <button class="main-button primary" onclick="showAuthModal()">Login / Sign Up</button>
        <button class="main-button guest-play-button" onclick="startGame()">Play as Guest</button>
        <button class="main-button arcade-button" onclick="showArcadeModal()">Arcade</button>
        <button class="main-button" onclick="showCustomListsManager()">My Lists</button>
        <button class="main-button stages-button" onclick="showStageCascadeScreen()">Stages</button>
        <button class="main-button" disabled>Download the App</button>
    </div>

    <!-- New Auth Modal -->
    <div id="authModal" class="auth-modal">
        <div class="auth-modal-content">
            <div id="loginForm" class="auth-form">
                <h2>Login</h2>
                <input type="text" class="auth-input" placeholder="Username or Email" id="loginUsername">                <input type="password" class="auth-input" placeholder="Password" id="loginPassword">
                <button class="auth-button" onclick="handleLogin()">Login</button>
                <button class="auth-toggle" onclick="toggleAuthMode()">New? Register here</button>
            </div>
            <div id="signupForm" class="auth-form hidden">
                <h2>Sign Up</h2>
                <input type="email" class="auth-input" placeholder="Email" id="signupEmail">
                <input type="text" class="auth-input" placeholder="Username" id="signupUsername">
                <input type="password" class="auth-input" placeholder="Password" id="signupPassword">
                <button class="auth-button" onclick="handleSignup()">Sign Up</button>
                <button class="auth-toggle" onclick="toggleAuthMode()">Already have an account?</button>
            </div>
        </div>
    </div>

    <!-- Side Panel -->
    <button class="hamburger-button" onclick="toggleSidePanel()">
       <i class="fas fa-bars"></i>
   </button>

   <div class="side-panel">
    <div class="side-panel-content">
        <button class="logout-button logout-top-button">
    <i class="fas fa-sign-out-alt"></i> Logout
</button>        
        <div class="welcome-buttons">
            <a href="#" class="nav-link" onclick="showScreen('stage-screen'); return false;">
    <i class="fas fa-map-marked-alt"></i> Level Map
</a>
            <a href="#" class="nav-link" onclick="showCustomListsManager(); return false;">
                <i class="fas fa-list"></i> My Lists
            </a>
            <a href="#" class="nav-link" onclick="showLeaderboard(); return false;">
                <i class="fas fa-trophy"></i> Speedboard
            </a>
            <a href="#" class="nav-link" onclick="showPricesScreen(); return false;">
                <i class="fas fa-dollar-sign"></i> Prices
            </a>
            <a href="#" class="nav-link" onclick="showRightsAndPolicies(); return false;">
                <i class="fas fa-balance-scale"></i> Rights & Policies
            </a>
            <a href="#" class="nav-link" onclick="showAboutPage(); return false;">
                <i class="fas fa-info-circle"></i> About
            </a>
            <a href="#" class="nav-link" onclick="showContactUs(); return false;">
                <i class="fas fa-envelope"></i> Contact Us
            </a>
        </div>
        
        <div class="user-profile-section user-profile-bottom">
            <div class="username-display" id="userEmail"></div>
            <div class="status-badge" id="userTierText"></div>
            
            <div class="user-stats">
                <div class="stat-item">
                    <div class="stat-label">Words</div>
                    <div class="stat-value" id="totalWords">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Coins</div>
                    <div class="stat-value">
                        <i class="fas fa-coins coin-icon"></i>
                        <span id="totalCoins">0</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
</div>

<div id="stage-cascade-screen" class="screen">
    <div class="particle-container"></div>
    <div class="navigation-container" style="position: fixed; top: 1rem; left: 50%; transform: translateX(-50%); flex-direction: row; gap: 0.75rem; background: none; margin: 0;">
        <button class="navigation-button home-button" onclick="navigateHome()">
            <i class="fas fa-home navigation-icon"></i>
        </button>
        <button class="navigation-button reset-button" onclick="handleResetProgress()">
            <i class="fas fa-trash-alt navigation-icon"></i>
        </button>
        <button class="navigation-button fullscreen-button" onclick="toggleFullScreen()">
            <i class="fas fa-expand navigation-icon"></i>
        </button>
    </div>
    
    <div class="stages-container">
        <!-- Stages will be populated dynamically here -->
    </div>
</div>

<!-- REPLACE level-screen div -->
<div id="level-screen" class="screen">
    <div class="particle-container"></div>
    <div class="navigation-container">
        <button class="navigation-button home-button" onclick="showScreen('stage-cascade-screen')">
            <i class="fas fa-arrow-left navigation-icon"></i>
        </button>
        <button class="navigation-button fullscreen-button" onclick="toggleFullScreen()">
            <i class="fas fa-expand navigation-icon"></i>
        </button>
    </div>
    <div class="level-container" id="level-container"></div>
</div>

<div id="question-screen" class="screen">
    <div class="particle-container"></div>
    <div class="navigation-container">
        <button class="navigation-button home-button" onclick="showScreen('welcome-screen')">
            <i class="fas fa-home navigation-icon"></i>
        </button>
    </div>

    

    <!-- Question Word -->
    <div class="question-word" id="question-word"></div>

    <!-- Progress Circle with Timer and Coins -->
    <div class="progress-circle">
        <svg width="100%" height="100%" viewBox="0 0 120 120">
            <circle class="bg" cx="60" cy="60" r="54" stroke-width="8"/>
            <circle class="progress" cx="60" cy="60" r="54" stroke-width="8"/>
            <circle class="timer-bg" cx="60" cy="60" r="40" stroke-width="4"/>
            <circle class="timer-progress" cx="60" cy="60" r="40" stroke-width="4"/>
        </svg>
        <div class="coins-container">
            <i class="fas fa-coins coin-icon"></i>
            <span class="coin-count">0</span>
        </div>
    </div>

    <!-- Perks Container -->
    <div class="perks-container">
        <button class="perk-button" id="timeFreezePerk">
            <i class="fas fa-clock perk-icon"></i>
            <span class="perk-count">0</span>
        </button>
        <button class="perk-button" id="skipPerk">
            <i class="fas fa-forward perk-icon"></i>
            <span class="perk-count">0</span>
        </button>
        <button class="perk-button" id="cluePerk">
            <i class="fas fa-lightbulb perk-icon"></i>
            <span class="perk-count">0</span>
        </button>
        <button class="perk-button" id="revealPerk">
            <i class="fas fa-eye perk-icon"></i>
            <span class="perk-count">0</span>
        </button>
    </div>


    
    <!-- Replace the old powerups-container content with this -->
    <div class="powerups-container">
    <!-- Goodies -->
    <div class="powerup-card goodie" id="highFiveCard">
        <i class="fas fa-hand-paper powerup-icon"></i>
        <div class="powerup-name">High Five</div>
        <div class="powerup-cost">30</div>
    </div>
    <div class="powerup-card goodie" id="fistBumpCard">
        <i class="fas fa-fist-raised powerup-icon"></i>
        <div class="powerup-name">Fist Bump</div>
        <div class="powerup-cost">40</div>
    </div>
    <div class="powerup-card goodie" id="energyBoostCard">
        <i class="fas fa-bolt powerup-icon"></i>
        <div class="powerup-name">Energy Boost</div>
        <div class="powerup-cost">45</div>
    </div>

    <!-- Baddies -->
    <div class="powerup-card baddie" id="freezeCard">
        <i class="fas fa-snowflake powerup-icon"></i>
        <div class="powerup-name">Freeze</div>
        <div class="powerup-cost">150</div>
    </div>
    <div class="powerup-card baddie" id="coinStormCard">
        <i class="fas fa-cloud-showers-heavy powerup-icon"></i>
        <div class="powerup-name">Coin Storm</div>
        <div class="powerup-cost">160</div>
    </div>
    <div class="powerup-card baddie" id="screenShakeCard">
        <i class="fas fa-shake powerup-icon"></i>
        <div class="powerup-name">Screen Shake</div>
        <div class="powerup-cost">130</div>
    </div>
</div>

    <!-- Timer Container -->
    <div class="timer-container">
        <div class="timer-value">00:00</div>
    </div>

    <!-- Answer Buttons -->
    <div class="buttons" id="buttons"></div>
</div>

<!-- Failure Overlay -->
<div class="failure-overlay" style="display: none;">
    <div class="failure-content">
        <h2 class="failure-title">Time's Up!</h2>
        <div class="failure-buttons">
            <button class="restart-button">
                <i class="fas fa-redo"></i>
            </button>
            <button class="home-button">
                <i class="fas fa-home"></i>
            </button>
        </div>
    </div>
</div>

<div id="custom-practice-screen" class="screen">
    <div class="navigation-container">
        <button class="navigation-button home-button" onclick="showScreen('welcome-screen')">
            <i class="fas fa-home navigation-icon"></i>
        </button>
    </div>

    <div class="custom-practice-container">
        <div class="lists-section">
            <h2 class="welcome-title">My Word Lists</h2>
            <div id="custom-lists-container" class="custom-lists-container">
                <!-- Lists will be dynamically populated here -->
            </div>
        </div>
        
        <div class="practice-section">
            <h2 class="welcome-title">Create Custom Word List</h2>
            <div class="list-name-section">
                <input 
                    type="text" 
                    id="custom-list-name" 
                    class="list-name-input" 
                    placeholder="List Name"
                >
            </div>
            <textarea 
                id="custom-word-input" 
                placeholder="Enter words, separated by commas or newlines"
            ></textarea>
            <div class="word-input-actions">
                <button 
                    onclick="processCustomWords()" 
                    class="main-button"
                >
                    <i class="fas fa-magic"></i> Make
                </button>
                <button 
                    onclick="saveCurrentList()" 
                    class="main-button"
                >
                    <i class="fas fa-save"></i> Save
                </button>
                <button 
                    onclick="addNewWord()" 
                    class="main-button"
                >
                    <i class="fas fa-plus"></i> Add Word
                </button>
            </div>
<div class="translation-results" id="translation-results">
    <div class="word-translation-list" id="word-translation-list">
        <!-- Processed words will appear here -->
    </div>
</div>
            </div>
        </div>
    </div>
</div>


<div id="upgrade-screen" class="screen">
    <div class="upgrade-modal">
        <div class="upgrade-form">
    <h2> </h2>
    <form id="upgradeForm" onsubmit="handleUpgradeSubmit(event)">
        <div class="form-group">
            <label>
                <input type="checkbox" id="isAdult" onchange="toggleParentFields()" name="isAdult">
                   18
            </label>
        </div>
        
        <!-- Parent Info Section -->
        <div id="parentInfoSection">
            <div class="form-group">
                <label>   </label>
                <input type="text" id="parentName" name="parentName">
            </div>
            <div class="form-group">
                <label>   </label>
                <input type="tel" id="parentPhone" name="parentPhone" 
                       pattern="[0-9]{10}" placeholder="    ">
            </div>
        </div>

        <!-- Adult Info Section -->
        <div id="adultInfoSection" style="display:none;">
            <div class="form-group">
                <label> </label>
                <input type="text" id="fullName" name="fullName">
            </div>
            <div class="form-group">
                <label> </label>
                <input type="tel" id="phone" name="phone" 
                       pattern="[0-9]{10}" placeholder="  ">
            </div>
        </div>

        <div class="form-group">
            <label>  ?</label>
            <select id="referralSource" name="referralSource">
                <option value="friend">/</option>
                <option value="teacher"></option>
                <option value="social"> </option>
                <option value="other"></option>
            </select>
        </div>

        <button type="submit" class="submit-button">/ </button>
        <button type="button" class="skip-button" onclick="skipUpgrade()"></button>
    </form>
    <p>      </p>
</div>
    </div>
</div>

<div id="leaderboard-screen" class="screen">
    <div class="navigation-container">
        <button class="navigation-button home-button" onclick="showScreen('welcome-screen')">
            <i class="fas fa-home navigation-icon"></i>
        </button>
    </div>
    
    <h1 class="welcome-title">Speedboard</h1>
    
    <div class="leaderboard-header">
        <div>Rank</div>
        <div>Player</div>
        <div>Status</div>
    </div>


        <div id="leaderboard-entries">
            <!-- Entries will be populated here -->
        </div>
    </div>
</div>

<div id="arcade-modal" class="modal">
    <div class="modal-content">
        <div id="teacher-view" style="display: none;">
            <h2>Your OTP: <span id="otp"></span></h2>
            <p>Players: <span id="player-count">0</span></p>
            
            <div class="stage-selector">
                <h3>Select Word Pools:</h3>
                <div class="stage-checkboxes">
                    <label>
                        <input type="checkbox" value="1"> Stage 1
                    </label>
                    <label>
                        <input type="checkbox" value="2"> Stage 2
                    </label>
                    <label>
                        <input type="checkbox" value="3"> Stage 3
                    </label>
                    <label>
                        <input type="checkbox" value="4"> Stage 4
                    </label>
                    <label>
                        <input type="checkbox" value="5"> Stage 5
                    </label>
                </div>
                <p class="stage-warning" style="display: none; color: var(--error);">Please select at least one stage</p>
            </div>
            
            <div class="custom-lists-container">
                <h3>Include Your Custom Lists:</h3>
                <div class="custom-lists-wrapper">
                  <div id="no-custom-lists" style="display: none; font-style: italic; color: #777;">
                    No custom lists available
                  </div>
                  <div id="custom-lists-checkboxes" class="custom-lists-checkboxes">
                    <!-- Custom lists will be populated here by JavaScript -->
                  </div>
                </div>
                <p id="custom-words-count" class="custom-words-count">Selected custom words: 0</p>
              </div>

            <div class="word-goal">
                <h3>Word Goal: <span id="wordGoalDisplay">50</span> words</h3>
                <div class="slider-container">
                    <input type="range" min="1" max="200" value="50" class="word-goal-slider" id="wordGoalSlider">
                    <div class="slider-stops">
                        <span class="slider-stop" data-value="0">0</span>
                        <span class="slider-stop" data-value="50">50</span>
                        <span class="slider-stop" data-value="100">100</span>
                        <span class="slider-stop" data-value="150">150</span>
                        <span class="slider-stop" data-value="200">200</span>
                    </div>
                </div>
                <input type="number" id="wordGoalInput" min="1" max="200" value="50" class="word-goal-input">
            </div>
            
            <button 
            class="arcade-start-btn" 
            :disabled="!isFormValid" 
            @click="createArcadeEvent"
          >
            Start Arcade
          </button>
                
        </div>
        
        <div id="player-view" style="display: none;">
            <h2>Join Arcade</h2>
            <div class="input-group">
                <input 
                    type="text"
                    id="arcadeUsername"
                    placeholder="Choose your username"
                    maxlength="15"
                >
                <input 
                    type="text"
                    id="otpInput"
                    placeholder="Enter 4-digit Game Code"
                    maxlength="4"
                    pattern="[0-9]{4}"
                    inputmode="numeric"
                >
            </div>
            <button class="join-button" onclick="joinArcadeWithUsername()">Join Game</button>
        </div>
    </div>
</div>

<div id="waiting-screen" class="screen">
    <div class="waiting-container">
        <div class="spinner-container">
            <div class="spinner"></div>
        </div>
        <h2 class="waiting-title">Waiting for Game to Start...</h2>
        <!-- Removed player count display -->
        <div class="floating-particles"></div>
    </div>
</div>

<div id="moderator-screen" class="screen">
    <div class="moderator-container">
        <div class="session-info-panel">
            <div class="session-details">
    <h2>Arcade Session</h2>
    <div class="otp-display" id="moderatorOtp"></div>
    <div class="qr-section">
        <canvas id="qrCode"></canvas>
        <p class="qr-hint">Scan to join game</p>
                </div>
                    <div class="session-metadata">
                    <p>Date: <span id="sessionDate"></span></p>
                    <p>Start Time: <span id="sessionStartTime"></span></p>
                    <p>Word Goal: <span id="sessionWordGoal"></span></p>
                    <p>Active Participants: <span id="activeParticipantCount">0</span></p>
                </div>
                <div class="game-controls">
                    <button class="start-button initialize-button" onclick="initializeArcade()">
                        Initialize Arcade
                    </button>
                    <button class="end-arcade-button" onclick="endArcade()">
                        End Arcade
                    </button>
                </div>
            </div>
        </div>
        <div class="leaderboard-panel">
            <div id="arcade-leaderboard" class="moderator-leaderboard">
                <div class="leaderboard-header">
                    <div>Rank</div>
                    <div>Player</div>
                    <div>Words</div>
                    <div>Coins</div>
                    <div>Actions</div>
                </div>
                <!-- Participants will be dynamically populated here -->
            </div>
        </div>
    </div>
</div>

<div id="remove-player-modal" class="modal">
   <div class="modal-content">
       <h3>Remove Player</h3>
       <p>Remove <span id="player-to-remove"></span> from the game?</p>
       <div class="modal-buttons">
           <button class="start-button" onclick="confirmRemovePlayer()">Remove</button>
           <button class="start-button secondary" onclick="closeRemoveModal()">Cancel</button>
       </div>
   </div>
</div>

<!-- Add before the closing </body> tag in index.html -->
<button class="accessibility-toggle" aria-label="Open accessibility menu">
    <i class="fas fa-universal-access"></i>
</button>

<div class="accessibility-modal">
    <div class="accessibility-content">
        <div class="accessibility-header">
            <h2>Accessibility Options</h2>
            <button class="close-accessibility" aria-label="Close accessibility menu">
                <i class="fas fa-times"></i>
            </button>
        </div>
        
        <div class="accessibility-options">
            <!-- Appearance Section -->
            <div class="accessibility-section">
                <h3>Display</h3>
                
                <!-- Contrast Controls -->
                <div class="option-group">
                    <label for="contrast-setting">Contrast</label>
                    <div class="controls">
                        <button class="accessibility-button" data-action="contrast" data-value="normal">Normal</button>
                        <button class="accessibility-button" data-action="contrast" data-value="high">High</button>
                        <button class="accessibility-button" data-action="contrast" data-value="inverted">Inverted</button>
                    </div>
                </div>
                
                <!-- Theme Controls -->
                <div class="option-group">
                    <label>Theme</label>
                    <div class="controls">
                        <button class="accessibility-button" data-action="theme" data-value="default">Default</button>
                        <button class="accessibility-button" data-action="theme" data-value="light">Light</button>
                        <button class="accessibility-button" data-action="theme" data-value="dark">Dark</button>
                    </div>
                </div>
                
                <!-- Saturation Controls -->
                <div class="option-group">
                    <label>Saturation</label>
                    <div class="controls">
                        <button class="accessibility-button" data-action="saturation" data-value="normal">Normal</button>
                        <button class="accessibility-button" data-action="saturation" data-value="grayscale">Grayscale</button>
                    </div>
                </div>
            </div>
            
            <!-- Text Section -->
            <div class="accessibility-section">
                <h3>Text</h3>
                
                <!-- Font Size Controls -->
                <div class="option-group">
                    <label>Font Size</label>
                    <div class="controls">
                        <button class="accessibility-button" data-action="fontSize" data-value="decrease">
                            <i class="fas fa-minus"></i>
                        </button>
                        <button class="accessibility-button" data-action="fontSize" data-value="reset">
                            Reset
                        </button>
                        <button class="accessibility-button" data-action="fontSize" data-value="increase">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                </div>
                
                <!-- Font Type Controls -->
                <div class="option-group">
                    <label>Font Type</label>
                    <div class="controls">
                        <button class="accessibility-button" data-action="fontFamily" data-value="default">Default</button>
                        <button class="accessibility-button" data-action="fontFamily" data-value="dyslexic">Dyslexia Friendly</button>
                    </div>
                </div>
                
                <!-- Letter Spacing Controls -->
                <div class="option-group">
                    <label>Letter Spacing</label>
                    <div class="controls">
                        <button class="accessibility-button" data-action="letterSpacing" data-value="normal">Normal</button>
                        <button class="accessibility-button" data-action="letterSpacing" data-value="increased">Increased</button>
                    </div>
                </div>
            </div>
            
            <!-- Motion and Navigation Section -->
            <div class="accessibility-section">
                <h3>Motion & Navigation</h3>
                
                <!-- Animation Controls -->
                <div class="option-group">
                    <label>Animations</label>
                    <div class="controls">
                        <button class="accessibility-button" data-action="animations" data-value="enabled">Enabled</button>
                        <button class="accessibility-button" data-action="animations" data-value="reduced">Reduced</button>
                        <button class="accessibility-button" data-action="animations" data-value="disabled">Disabled</button>
                    </div>
                </div>
                
                <!-- Focus Indicator Controls -->
                <div class="option-group">
                    <label>Focus Indicator</label>
                    <div class="controls">
                        <button class="accessibility-button" data-action="focus" data-value="normal">Normal</button>
                        <button class="accessibility-button" data-action="focus" data-value="high">Enhanced</button>
                    </div>
                </div>
            </div>
            
            <!-- Interface Section -->
            <div class="accessibility-section">
                <h3>Interface</h3>
                
                <!-- Button Size Controls -->
                <div class="option-group">
                    <label>Button Size</label>
                    <div class="controls">
                        <button class="accessibility-button" data-action="buttonSize" data-value="normal">Normal</button>
                        <button class="accessibility-button" data-action="buttonSize" data-value="large">Large</button>
                    </div>
                </div>
                
                <!-- Cursor Size Controls -->
                <div class="option-group">
                    <label>Cursor Size</label>
                    <div class="controls">
                        <button class="accessibility-button" data-action="cursorSize" data-value="normal">Normal</button>
                        <button class="accessibility-button" data-action="cursorSize" data-value="large">Large</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="accessibility-footer">
            <button class="accessibility-button reset-all" data-action="reset" data-value="all">Reset All Settings</button>
        </div>
    </div>
</div>

<script>
    
    document.addEventListener('progressSaved', (event) => {
  // If the stage-cascade screen is currently visible, refresh it
  const stageCascadeScreen = document.getElementById("stage-cascade-screen");
  if (stageCascadeScreen && stageCascadeScreen.classList.contains("visible")) {
    console.log("Refreshing stage cascade screen after progress save");
    renderStageCascadeScreen();
  }
});
   
    document.addEventListener('DOMContentLoaded', () => {
    const logoutButton = document.querySelector('.logout-button');
    if (logoutButton) {
        logoutButton.addEventListener('click', handleLogout);
    }
});

document.addEventListener('click', (e) => {
    const sidePanel = document.querySelector('.side-panel');
    const hamburgerButton = document.querySelector('.hamburger-button');
    
    if (sidePanel.classList.contains('open') && 
        !sidePanel.contains(e.target) && 
        !hamburgerButton.contains(e.target)) {
        toggleSidePanel();
    }
});

    document.addEventListener('DOMContentLoaded', () => {
    const gameAssets = {
        stages: {}, // Cache stage data
        currentWords: [], // Cache current level words
        particles: new Set() // Reuse particle elements
    };
});

const ParticleSystem = {
    particlePool: [],
    maxParticles: 20, // Reduced from 50
    
    init() {
        // Pre-create fewer particles
        for(let i = 0; i < this.maxParticles; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle mobile-particle'; // Add mobile class
            this.particlePool.push(particle);
        }
    },
    
    createParticle(x, y) {
        // Check if mobile before creating
        if (window.innerWidth <= 768) {
            return; // Skip particle creation on mobile
        }
        
        const particle = this.particlePool.pop();
        if (!particle) return;
        
        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;
        
        setTimeout(() => {
            this.particlePool.push(particle);
        }, 500); // Reduced timeout
    }
};



const currentArcadeSessionStructure = {
    eventId: null,
    otp: null,
    wordPool: [],
    participants: [], // Player data during game
    teacherId: null,
    wordGoal: 50,
    state: 'pre-start',  // 'pre-start', 'started', 'active', 'ended'
    completedPlayers: [], // Players who reached word goal, in order of completion
    startTime: null,     // When the session started
    endTime: null,       // When the session ended
    
    // Ranks determined by order of completion - only top 3 matter
    podiumRanks: {
        // username: { rank: 1-3, completionTime: timestamp }
    },
    
    // Local player properties
    playerName: null,    // Current player's username
    winnerScreenShown: false // Flag to prevent multiple winner screens
};

// Use event delegation instead of multiple listeners
document.addEventListener('click', (e) => {
    const target = e.target;
    
    if (target.matches('.game-btn')) {
        handleButtonClick(target);
    } else if (target.matches('.level')) {
        handleLevelClick(target);
    }
});

function updateUI() {
    // Batch DOM updates
    requestAnimationFrame(() => {
        const fragment = document.createDocumentFragment();
        // Add elements to fragment
        document.body.appendChild(fragment);
    });
}

const CoinsManager = {
    displayElements: new Set(),
    
    initialize() {
        this.displayElements.clear();
        document.querySelectorAll('.coin-count').forEach(display => {
            this.displayElements.add(display);
        });
    },
    
    async loadUserCoins() {
        if (!currentUser) {
            return parseInt(localStorage.getItem('simploxCustomCoins') || '0');
        }

        try {
            const { data, error } = await supabaseClient
                .from('game_progress')
                .select('coins')
                .eq('user_id', currentUser.id)
                .single();

            if (error) throw error;
            return data.coins || 0;
        } catch (error) {
            console.error('Error loading coins:', error);
            return 0;
        }
    },

    async updateCoins(amount) {
        try {
            const oldTotal = gameState.coins;
            const newTotal = oldTotal + amount;
            gameState.coins = newTotal;

            // Animate all displays
            this.displayElements.forEach(display => {
                let currentValue = oldTotal;
                const duration = 1000;
                const startTime = performance.now();
                
                function animate(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    currentValue = oldTotal + (newTotal - oldTotal) * progress;
                    display.textContent = Math.round(currentValue);
                    
                    if (amount > 0) {
                        display.style.color = 'var(--success)';
                    } else if (amount < 0) {
                        display.style.color = 'var(--error)';
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        display.textContent = newTotal;
                        setTimeout(() => {
                            display.style.color = 'var(--text)';
                        }, 300);
                    }
                }
                
                requestAnimationFrame(animate);
            });

            // Save to database/localStorage
            if (currentUser) {
                const { error } = await supabaseClient
                    .from('game_progress')
                    .update({ coins: newTotal })
                    .eq('user_id', currentUser.id);

                if (error) throw error;
            } else {
                localStorage.setItem('simploxCustomCoins', newTotal.toString());
            }

            // Update perk buttons based on new coin total
            updatePerkButtons();
            return true;

        } catch (error) {
            console.error('Failed to update coins:', error);
            this.displayElements.forEach(display => {
                display.textContent = gameState.coins - amount;
            });
            updatePerkButtons();  // Also update buttons on error
            return false;
        }
    },

    updateDisplays() {
        this.displayElements.forEach(display => {
            display.textContent = gameState.coins;
        });
        updatePerkButtons();  // Update buttons whenever displays are updated
    }
};

const WordsManager = {
  displayElements: new Set(),
  
  initialize() {
    this.displayElements.clear();
    document.querySelectorAll("#totalWords").forEach(el => {
      this.displayElements.add(el);
    });
    
    // Initialize word counts for logged-in users
    if (currentUser) {
      this.loadUserWords().then(wordCount => {
        this.updateDisplays(wordCount);
      });
    }
  },
  
  async loadUserWords() {
    if (!currentUser) return 0;
    
    try {
      const { data, error } = await supabaseClient
        .from("player_stats")
        .select("unique_words_practiced")
        .eq("user_id", currentUser.id)
        .single();
        
      if (error) throw error;
      return data?.unique_words_practiced || 0;
    } catch (err) {
      console.error("Error loading words:", err);
      return 0;
    }
  },
  
  async updateWords(count) {
    try {
      const currentCount = parseInt(document.getElementById("totalWords").textContent) || 0;
      const newCount = currentCount + count;
      
      this.displayElements.forEach(el => {
        let value = currentCount;
        const startTime = performance.now();
        
        requestAnimationFrame(function updateValue(timestamp) {
          const elapsed = timestamp - startTime;
          const progress = Math.min(elapsed / 1000, 1);
          
          value = currentCount + (newCount - currentCount) * progress;
          el.textContent = Math.round(value);
          
          if (progress < 1) {
            requestAnimationFrame(updateValue);
          } else {
            el.textContent = newCount;
          }
        });
      });
      
      if (currentUser) {
        const { error } = await supabaseClient
          .from("player_stats")
          .update({ unique_words_practiced: newCount })
          .eq("user_id", currentUser.id);
          
        if (error) throw error;
      }
      
      return true;
    } catch (err) {
      console.error("Failed to update words:", err);
      return false;
    }
  },
  
  updateDisplays(count) {
    this.displayElements.forEach(el => {
      el.textContent = count;
    });
  }
};


const perkButtons = {
    timeFreeze: document.getElementById('timeFreezePerk'),
    skip: document.getElementById('skipPerk'),
    clue: document.getElementById('cluePerk'),
    reveal: document.getElementById('revealPerk')
};

// REPLACE the perk button initialization
Object.entries(perkButtons).forEach(([perkType, button]) => {
    if (button) {
        button.onclick = () => buyPerk(perkType);
    }
});

const GameTimer = {
    lastTick: 0,
    
    update(timestamp) {
        if (!this.lastTick) this.lastTick = timestamp;
        const delta = timestamp - this.lastTick;
        
        if (delta >= 1000) { // Update every second
            this.updateTimer();
            this.lastTick = timestamp;
        }
        
        requestAnimationFrame(this.update.bind(this));
    }
};

function cleanupLevel() {
    // Clear unused event listeners
    document.querySelectorAll('.buttons button').forEach(btn => {
        btn.onclick = null;
    });
    
    // Clear particle effects
    ParticleSystem.clear();
    
    // Clear timeouts
    clearTimeout(levelTimeout);
}


async function transitionScreen(screenType) {
    const currentScreen = document.querySelector('.screen.visible');
    if (currentScreen) {
        currentScreen.style.opacity = 0;
        await new Promise(r => setTimeout(r, 300));
        currentScreen.style.display = 'none';
    }
    
    const nextScreen = document.getElementById(`${screenType}-screen`);
    nextScreen.style.display = 'flex';
    requestAnimationFrame(() => {
        nextScreen.style.opacity = 1;
    });
}

const GameCache = {
    words: new Map(),
    
    async getWords(setId) {
        if (this.words.has(setId)) {
            return this.words.get(setId);
        }
        
        const words = await loadWords(setId);
        this.words.set(setId, words);
        return words;
    }
};

const gameInit = {
    async init() {
        console.log("Game initialization starting");
        
        // First check for existing session
        await checkExistingSession();
        
        if (currentUser) {
            console.log("User is logged in, checking database schema");
            // Check and fix database schema
            const schemaOk = await ensureCorrectSchema();
            
            if (schemaOk) {
                // Load progress from database
                console.log("Schema is OK, loading progress from database");
                await loadUserGameProgress(currentUser.id);
            } else {
                console.log("Schema issues detected, loading from localStorage and initializing defaults");
                // Initialize from localStorage or defaults
                initializeGame();
            }
        } else {
            console.log("No user logged in, initializing local game state");
            // Initialize default game state
            initializeGame();
        }
        
        // Update UI elements
        updatePerkButtons();
        initializeParticles(document.getElementById("welcome-screen"));
        
        // Load custom lists
        await loadCustomLists();
        
        // Set up auto-save
        setupAutoSave();
        
        // Log the final game state
        console.log("Game initialization complete. Game state:", {
            currentStage: gameState.currentStage,
            currentSet: gameState.currentSet, 
            currentLevel: gameState.currentLevel,
            unlockedSets: Object.keys(gameState.unlockedSets || {}),
            unlockedLevels: Object.keys(gameState.unlockedLevels || {})
        });
    }
};

// Replace window.onload with:
document.addEventListener('DOMContentLoaded', () => {
    gameInit.init();
});

const { createClient } = supabase;
const supabaseClient = createClient(
    'https://mczfgzffyyyacisrccqb.supabase.co',
    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1jemZnemZmeXl5YWNpc3JjY3FiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzgzODYyMDQsImV4cCI6MjA1Mzk2MjIwNH0.rLga_B29Coz1LMeJzFTGLIhckdcojGXnD1ae1bw-QAI',
    {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true
    }
);




document.addEventListener('DOMContentLoaded', async () => {
   try {
       // Define CustomListsManager first before any functions try to use it
       if (!window.CustomListsManager) {
           window.CustomListsManager = {
               lists: [],
               
               async initialize() {
                   if (currentUser) {
                       await this.loadFromSupabase();
                   } else {
                       this.loadFromLocalStorage();
                   }
               },
               
               async loadFromSupabase() {
                   try {
                       const { data, error } = await supabaseClient
                           .from('custom_lists')
                           .select('*')
                           .or(`user_id.eq.${currentUser.id},shared_with.cs.{${currentUser.id}}`);
                           
                       if (error) throw error;
                       
                       this.lists = data.map(item => ({
                           id: item.id,
                           name: item.name,
                           words: item.words || [],
                           translations: item.translations || [],
                           isShared: item.is_shared,
                           sharedBy: item.shared_by,
                           userId: item.user_id,
                           createdAt: item.created_at
                       }));
                       
                       console.log('Loaded lists from Supabase:', this.lists.length);
                   } catch (error) {
                       console.error('Error loading lists from Supabase:', error);
                       this.lists = [];
                   }
               },
               
               loadFromLocalStorage() {
                   try {
                       const savedLists = localStorage.getItem('simploxCustomLists');
                       this.lists = savedLists ? JSON.parse(savedLists) : [];
                       console.log('Loaded lists from localStorage:', this.lists.length);
                   } catch (error) {
                       console.error('Error loading lists from localStorage:', error);
                       this.lists = [];
                   }
               },
               
               async save(list) {
                   if (!list) return null;
                   
                   if (currentUser) {
                       return await this.saveToSupabase(list);
                   } else {
                       return this.saveToLocalStorage(list);
                   }
               },
               
               async saveToSupabase(list) {
                   try {
                       const listData = {
                           name: list.name,
                           words: list.words || [],
                           translations: list.translations || [],
                           user_id: currentUser.id
                       };
                       
                       if (list.id && typeof list.id === 'string' && list.id.length === 36) {
                           const { data, error } = await supabaseClient
                               .from('custom_lists')
                               .update(listData)
                               .eq('id', list.id)
                               .select()
                               .single();
                               
                           if (error) throw error;
                           return data;
                       } else {
                           const { data, error } = await supabaseClient
                               .from('custom_lists')
                               .insert(listData)
                               .select()
                               .single();
                               
                           if (error) throw error;
                           
                           const index = this.lists.findIndex(l => 
                               l.id === list.id || 
                               (l.tempId && l.tempId === list.tempId));
                               
                           if (index !== -1) {
                               this.lists[index] = {
                                   ...data,
                                   words: data.words || [],
                                   translations: data.translations || []
                               };
                           } else {
                               this.lists.push({
                                   ...data,
                                   words: data.words || [],
                                   translations: data.translations || []
                               });
                           }
                           
                           return data;
                       }
                   } catch (error) {
                       console.error('Error saving list to Supabase:', error);
                       return null;
                   }
               },
               
               saveToLocalStorage(list) {
                   try {
                       const newList = {
                           ...list,
                           id: list.id || Date.now(),
                           tempId: list.tempId || Date.now()
                       };
                       
                       const index = this.lists.findIndex(l => 
                           l.id === list.id || 
                           (l.tempId && l.tempId === list.tempId));
                           
                       if (index !== -1) {
                           this.lists[index] = newList;
                       } else {
                           this.lists.push(newList);
                       }
                       
                       localStorage.setItem('simploxCustomLists', JSON.stringify(this.lists));
                       return newList;
                   } catch (error) {
                       console.error('Error saving list to localStorage:', error);
                       return null;
                   }
               },
               
               async delete(listId) {
                   if (currentUser) {
                       try {
                           if (typeof listId === 'string' && listId.length === 36) {
                               const { error } = await supabaseClient
                                   .from('custom_lists')
                                   .delete()
                                   .eq('id', listId);
                                   
                               if (error) throw error;
                           }
                           
                           this.lists = this.lists.filter(list => list.id !== listId);
                           return true;
                       } catch (error) {
                           console.error('Error deleting list from Supabase:', error);
                           return false;
                       }
                   } else {
                       this.lists = this.lists.filter(list => list.id !== listId);
                       localStorage.setItem('simploxCustomLists', JSON.stringify(this.lists));
                       return true;
                   }
               },
               
               async share(listId, recipientId) {
                   if (!currentUser) return false;
                   
                   try {
                       const list = this.lists.find(l => l.id === listId);
                       if (!list) return false;
                       
                       const result = await supabaseClient.rpc('insert_shared_list', {
                           p_user_id: recipientId,
                           p_name: `${list.name} (Shared by ${currentUser.user_metadata?.username || 'User'})`,
                           p_words: list.words || [],
                           p_translations: list.translations || [],
                           p_is_shared: true,
                           p_local_id: Date.now(),
                           p_shared_with: [recipientId],
                           p_shared_by: currentUser.id
                       });
                       
                       return !result.error;
                   } catch (error) {
                       console.error('Error sharing list:', error);
                       return false;
                   }
               },
               
               getListLimits() {
                   if (!currentUser) {
                       return {
                           maxLists: 3,
                           maxWords: 10,
                           maxPlays: 5,
                           canShare: false,
                           playDisplay: '5'
                       };
                   }
                   
                   const userStatus = currentUser.status || 'free';
                   
                   switch(userStatus) {
                       case 'premium':
                           return {
                               maxLists: 30,
                               maxWords: 50,
                               maxPlays: Infinity,
                               canShare: true,
                               playDisplay: ''
                           };
                       case 'pending':
                           return {
                               maxLists: 30,
                               maxWords: 50,
                               maxPlays: Infinity,
                               canShare: false,
                               playDisplay: ''
                           };
                       case 'free':
                           return {
                               maxLists: 5,
                               maxWords: 20,
                               maxPlays: 10,
                               canShare: false,
                               playDisplay: '10'
                           };
                       default:
                           return {
                               maxLists: 3,
                               maxWords: 10,
                               maxPlays: 5,
                               canShare: false,
                               playDisplay: '5'
                           };
                   }
               },
               
               canCreateMoreLists() {
                   const limits = this.getListLimits();
                   return this.lists.length < limits.maxLists;
               }
           };
       }
       
       // Next, check session and initialize the game
       await checkExistingSession();
       initializeGame();
       updatePerkButtons();
       updateGuestPlayButton();
       
       // Initialize managers in correct order
       CoinsManager.initialize();
       WordsManager.initialize();
       await CustomListsManager.initialize();

       // Load initial coins
       if (currentUser) {
           gameState.coins = await CoinsManager.loadUserCoins();
           CoinsManager.updateDisplays();
           
           const words = await WordsManager.loadUserWords();
           WordsManager.updateDisplays(words);
       }
       
       // Handle QR code joining
       window.addEventListener('hashchange', handleHashChange);
       window.addEventListener('load', handleHashChange);
       
       // Check for join hash on initial load
       if (window.location.hash.startsWith('#join=')) {
           console.log('Initial join hash detected');
           const otp = window.location.hash.replace('#join=', '');
           history.pushState("", document.title, window.location.pathname);
           showJoinModal(otp);
       }

       // Ensure particles on welcome screen
       const welcomeScreen = document.getElementById('welcome-screen');
       initializeParticles(welcomeScreen);
       
       // Mobile fullscreen handling
       if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
           // Request on first touch
           document.addEventListener('touchstart', function onFirstTouch() {
               requestFullscreenMode();
               document.removeEventListener('touchstart', onFirstTouch);
           }, { once: true });
           
           // Request when clicking any button
           document.addEventListener('click', function(e) {
               if (e.target.tagName === 'BUTTON') {
                   requestFullscreenMode();
               }
           });
           
           // Screen orientation handling
           if (screen.orientation) {
               screen.orientation.lock('portrait')
                   .catch(err => console.log('Failed to lock orientation:', err));
           }
       }

       // OTP input handling
       const otpInput = document.getElementById('otpInput');
       if (otpInput) {
           otpInput.addEventListener('input', function(e) {
               // Remove any non-numeric characters
               this.value = this.value.replace(/[^0-9]/g, '');
               
               // Limit to 4 digits
               if (this.value.length > 4) {
                   this.value = this.value.slice(0, 4);
               }
           });
       }

       // Initialize real-time channels if user is logged in
       if (currentUser) {
           setupUserStatusSubscription();
           initializeStatusCheck();
       }
   } catch (error) {
       console.error('Initialization error:', error);
   }
});

// Add this to the existing showJoinModal function to ensure proper mobile display
function showJoinModal(otp = '') {
    console.log('Opening join modal with OTP:', otp);
    const modal = document.getElementById('arcade-modal');
    const teacherView = document.getElementById('teacher-view');
    const playerView = document.getElementById('player-view');
    const otpInput = document.getElementById('otpInput');
    
    if (modal) {
        modal.style.display = 'block';
        if (teacherView) teacherView.style.display = 'none';
        if (playerView) playerView.style.display = 'block';
        
        if (otpInput && otp) {
            otpInput.value = otp;
            // Auto-focus username input
            const usernameInput = document.getElementById('arcadeUsername');
            if (usernameInput) {
                setTimeout(() => usernameInput.focus(), 300);
            }
        }
    }
}

async function handleSignup() {
  const email = document.getElementById("signupEmail").value;
  const username = document.getElementById("signupUsername").value;
  const password = document.getElementById("signupPassword").value;

  if (email && username && password) {
    try {
      // 1. Sign up the user
      const { data: authData, error: authError } = await supabaseClient.auth.signUp({
        email: email,
        password: password,
        options: {
          data: {
            username: username,
            full_name: username
          }
        }
      });
      
      if (authError) throw authError;
      
      // 2. Create the user profile
      const { error: profileError } = await supabaseClient
        .from("user_profiles")
        .upsert({
          id: authData.user.id,
          username: username,
          email: email,
          status: "free",
          role: "student"
        }, { onConflict: "id" });
      
      if (profileError) {
        console.error("Profile upsert error:", profileError);
      }
      
      // 3. Check if game progress exists and create if needed
      const { data: existingProgress, error: progressCheckError } = await supabaseClient
        .from("game_progress")
        .select("user_id")
        .eq("user_id", authData.user.id)
        .single();
      
      // Only insert if record doesn't exist
      if (progressCheckError && progressCheckError.code === "PGRST116") {
        const gameProgressData = {
          user_id: authData.user.id,
          stage: 1,
          set_number: 1,
          level: 1,
          coins: 0,
          perks: {},
          unlocked_sets: {1: [1]},
          unlocked_levels: {"1_1": [1]},
          perfect_levels: [],
          completed_levels: []
        };
        
        const { error: insertProgressError } = await supabaseClient
          .from("game_progress")
          .insert([gameProgressData]);
        
        if (insertProgressError && insertProgressError.code !== "23505") {
          // Log error but continue if it's not a duplicate key error
          console.error("Game progress initialization error:", insertProgressError);
        }
      }
      
      // 4. Check if player stats exists and create if needed
      const { data: existingStats, error: statsCheckError } = await supabaseClient
        .from("player_stats")
        .select("user_id")
        .eq("user_id", authData.user.id)
        .single();
      
      // Only insert if record doesn't exist
      if (statsCheckError && statsCheckError.code === "PGRST116") {
        const playerStatsData = {
          user_id: authData.user.id,
          total_levels_completed: 0,
          unique_words_practiced: 0
        };
        
        const { error: insertStatsError } = await supabaseClient
          .from("player_stats")
          .insert([playerStatsData]);
        
        if (insertStatsError && insertStatsError.code !== "23505") {
          // Log error but continue if it's not a duplicate key error
          console.error("Player stats initialization error:", insertStatsError);
        }
      }
      
      // 5. Sign in the user
      const { data: signInData, error: signInError } = await supabaseClient.auth.signInWithPassword({
        email: email,
        password: password
      });
      
      if (signInError) throw signInError;
      
      // 6. Update the UI and game state
      hideAuthModal();
      currentUser = signInData.user;
      gameState.currentStage = 1;
      gameState.currentSet = 1;
      gameState.currentLevel = 1;
      gameState.coins = 0;
      gameState.perks = {};
      gameState.unlockedSets = {1: new Set([1])};
      gameState.unlockedLevels = {"1_1": new Set([1])};
      gameState.perfectLevels = new Set;
      gameState.completedLevels = new Set;
      updateAuthUI();
      showScreen("welcome-screen");
      
    } catch (error) {
      console.error("Detailed signup error:", error);
      if (error.message && error.message.includes("duplicate key")) {
        alert("This username or email is already taken. Please try another.");
      } else {
        alert("Signup error: " + error.message);
      }
    }
  } else {
    alert("All fields are required");
  }
}

// Add this helper function to safely upsert records
async function safeUpsertRecord(table, data, keyField = 'user_id') {
  try {
    // First check if the record exists
    const { data: existingData, error: checkError } = await supabaseClient
      .from(table)
      .select(keyField)
      .eq(keyField, data[keyField])
      .single();
    
    if (checkError && checkError.code === "PGRST116") {
      // Record doesn't exist, try to insert it
      const { error: insertError } = await supabaseClient
        .from(table)
        .insert([data]);
      
      if (insertError) {
        // If insert fails with a duplicate key error, try to update instead
        if (insertError.code === "23505") {
          const { error: updateError } = await supabaseClient
            .from(table)
            .update(data)
            .eq(keyField, data[keyField]);
          
          if (updateError) {
            console.error(`Error updating ${table}:`, updateError);
            return false;
          }
        } else {
          console.error(`Error inserting into ${table}:`, insertError);
          return false;
        }
      }
    } else if (!checkError) {
      // Record exists, update it
      const { error: updateError } = await supabaseClient
        .from(table)
        .update(data)
        .eq(keyField, data[keyField]);
      
      if (updateError) {
        console.error(`Error updating ${table}:`, updateError);
        return false;
      }
    } else {
      console.error(`Error checking ${table}:`, checkError);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error(`Unexpected error in safeUpsertRecord for ${table}:`, error);
    return false;
  }
}

async function updateUserCoins(amount) {
    // Update local game state
    const previousCoins = gameState.coins;
    gameState.coins += amount;
    
    // Update UI
    updateAllCoinDisplays();
    updatePerkButtons();
    
    // Save to database if logged in
    if (currentUser) {
        try {
            const { error } = await supabaseClient
                .from("game_progress")
                .update({ coins: gameState.coins })
                .eq("user_id", currentUser.id);
                
            if (error) {
                console.error("Failed to update coins in database:", error);
                // Revert local change if database save fails
                gameState.coins = previousCoins;
                updateAllCoinDisplays();
                updatePerkButtons();
                return false;
            }
        } catch (err) {
            console.error("Error updating coins:", err);
            // Revert local change
            gameState.coins = previousCoins;
            updateAllCoinDisplays();
            updatePerkButtons();
            return false;
        }
    }
    
    // Also save to localStorage
    const progressData = JSON.parse(localStorage.getItem("simploxProgress") || "{}");
    progressData.coins = gameState.coins;
    localStorage.setItem("simploxProgress", JSON.stringify(progressData));
    
    return true;
}

// Add this function to handle database schema upgrade
async function checkAndFixDatabaseSchema() {
    if (!currentUser) return false;
    
    try {
        // First check the schema
        const { data, error } = await supabaseClient
            .from("game_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .single();
            
        if (error) {
            console.error("Error checking database schema:", error);
            return false;
        }
        
        // Check if we need to add the missing columns
        const missingCompletedLevels = !('completed_levels' in data);
        const missingPerfectLevels = !('perfect_levels' in data);
        
        if (!missingCompletedLevels && !missingPerfectLevels) {
            console.log("Database schema is up to date");
            return true;
        }
        
        console.log("Adding missing columns to database schema");
        
        // Create a migration update with the minimal required fields
        const updateData = {
            user_id: currentUser.id,
            stage: data.stage || 1,
            set_number: data.set_number || 1,
            level: data.level || 1
        };
        
        // Try to preserve existing data
        if ('coins' in data) updateData.coins = data.coins || 0;
        if ('unlocked_sets' in data) updateData.unlocked_sets = data.unlocked_sets || {};
        if ('unlocked_levels' in data) updateData.unlocked_levels = data.unlocked_levels || {};
        
        // Add the missing columns with default values
        if (missingCompletedLevels) updateData.completed_levels = [];
        if (missingPerfectLevels) updateData.perfect_levels = [];
        
        // Update the record
        const { error: updateError } = await supabaseClient
            .from("game_progress")
            .update(updateData)
            .eq("user_id", currentUser.id);
            
        if (updateError) {
            console.error("Failed to update database schema:", updateError);
            return false;
        }
        
        console.log("Database schema successfully updated");
        return true;
    } catch (err) {
        console.error("Error fixing database schema:", err);
        return false;
    }
}

async function initializeGameProgressForUser(userId) {
    const { error } = await supabaseClient
        .from('game_progress')
        .insert({
            user_id: userId,
            stage: 1,
            set_number: 1,
            level: 1,
            coins: 0,
            perks: {},
            unlocked_sets: { "1": [1] },
            unlocked_levels: { "1_1": [1] },
            perfect_levels: [],
            completed_levels: []
        });

    if (error) {
        console.error('Error initializing game progress:', error);
    }
}

async function handleLogin() {
    const loginInput = document.getElementById('loginUsername').value;
    const password = document.getElementById('loginPassword').value;
    
    if (!loginInput || !password) {
        alert('Please enter both username/email and password');
        return;
    }

    try {
        // Determine if input is an email or username
        const isEmail = loginInput.includes('@');
        
        let loginMethod;
        if (isEmail) {
            // Login with email
            loginMethod = supabaseClient.auth.signInWithPassword({
                email: loginInput,
                password: password
            });
        } else {
            // Login with username
            const { data: userProfile, error: profileError } = await supabaseClient
                .from('user_profiles')
                .select('email')
                .eq('username', loginInput)
                .single();

            if (profileError || !userProfile) {
                alert('Username not found');
                return;
            }

            loginMethod = supabaseClient.auth.signInWithPassword({
                email: userProfile.email,
                password: password
            });
        }

        const { data, error } = await loginMethod;

        if (error) {
            console.error('Login Error:', error);
            alert(error.message);
            return;
        }

        if (data.user) {
            currentUser = data.user;
            
            // Hide auth modal first
            hideAuthModal();
            
            // Then update UI and load data
            const { data: profile } = await supabaseClient
                .from('user_profiles')
                .select('status')
                .eq('id', currentUser.id)
                .single();
                
            if (profile) {
                currentUser.status = profile.status;
                updateUserStatusDisplay(profile.status);
            }

            await Promise.all([
                loadCustomLists(),
                loadUserGameProgress(currentUser.id)
            ]);

            updateAuthUI();
            updateGuestPlayButton();
            showScreen('welcome-screen');
        }

    } catch (error) {
        console.error('Unexpected Login Error:', error);
        alert('An unexpected error occurred during login');
    }
}

function initializeGame() {
    console.log("Initializing game state");
    
    // Default initial values
    gameState.currentStage = 1;
    gameState.currentSet = 1;
    gameState.currentLevel = 1;
    gameState.coins = 0;
    gameState.perks = {};
    gameState.unlockedSets = {};
    gameState.unlockedLevels = {};
    gameState.perfectLevels = new Set();
    gameState.completedLevels = new Set();
    
    // Check localStorage for saved progress (for guest users or as backup)
    const savedProgress = localStorage.getItem("simploxProgress");
    if (savedProgress) {
        try {
            console.log("Found saved progress in localStorage");
            const progress = JSON.parse(savedProgress);
            
            // Load basic game state
            if (progress.stage) gameState.currentStage = progress.stage;
            if (progress.set_number) gameState.currentSet = progress.set_number;
            if (progress.level) gameState.currentLevel = progress.level;
            if (progress.coins) gameState.coins = progress.coins;
            if (progress.perks) gameState.perks = progress.perks;
            
            // Load unlocked sets
            if (progress.unlocked_sets) {
                Object.entries(progress.unlocked_sets).forEach(([stage, sets]) => {
                    gameState.unlockedSets[stage] = new Set(Array.isArray(sets) ? sets : []);
                });
            }
            
            // Load unlocked levels
            if (progress.unlocked_levels) {
                Object.entries(progress.unlocked_levels).forEach(([setKey, levels]) => {
                    gameState.unlockedLevels[setKey] = new Set(Array.isArray(levels) ? levels : []);
                });
            }
            
            // Load perfect and completed levels
            if (progress.perfect_levels) {
                gameState.perfectLevels = new Set(progress.perfect_levels);
            }
            
            if (progress.completed_levels) {
                gameState.completedLevels = new Set(progress.completed_levels);
            }
            
            console.log("Loaded progress from localStorage:", {
                currentStage: gameState.currentStage,
                currentSet: gameState.currentSet,
                currentLevel: gameState.currentLevel
            });
        } catch (e) {
            console.error("Error parsing saved progress:", e);
        }
    }
    
    // Check for game context which has precedence for the current level
    const savedContext = localStorage.getItem("gameContext");
    if (savedContext) {
        try {
            const context = JSON.parse(savedContext);
            const timeSinceContext = Date.now() - (context.timestamp || 0);
            
            // Only use context if it's less than 24 hours old
            if (timeSinceContext < 24 * 60 * 60 * 1000) {
                console.log("Found recent game context, updating current location:", context);
                if (context.stage) gameState.currentStage = context.stage;
                if (context.set) gameState.currentSet = context.set;
                if (context.level) gameState.currentLevel = context.level;
            }
        } catch (e) {
            console.error("Error parsing saved context:", e);
        }
    }
    
    // Ensure we have default unlocks regardless
    setupDefaultUnlocks();
    
    updateAllCoinDisplays();
    updatePerkButtons();
    
    console.log("Game initialized with state:", {
        currentStage: gameState.currentStage,
        currentSet: gameState.currentSet,
        currentLevel: gameState.currentLevel
    });
}

function setupDefaultUnlocks() {
    // Stage 1: Level 1 of all sets should be unlocked
    if (!gameState.unlockedSets[1]) {
        gameState.unlockedSets[1] = new Set();
    }
    for (let i = 1; i <= 9; i++) {
        gameState.unlockedSets[1].add(i);
        const setKey = `1_${i}`;
        if (!gameState.unlockedLevels[setKey]) {
            gameState.unlockedLevels[setKey] = new Set([1]);
        }
    }

    // Stages 2-5: Level 1 of Set 1 should be unlocked
    for (let stage = 2; stage <= 5; stage++) {
        if (!gameState.unlockedSets[stage]) {
            gameState.unlockedSets[stage] = new Set([1]);
        }
        const setKey = `${stage}_1`;
        if (!gameState.unlockedLevels[setKey]) {
            gameState.unlockedLevels[setKey] = new Set([1]);
        }
    }
}



document.addEventListener('DOMContentLoaded', function() {
    currentUser = null;
    checkExistingSession().then(() => {
        initializeGame();
        updatePerkButtons();
    });
});

document.addEventListener('DOMContentLoaded', () => {
    // Immediately invoke an async function
    (async () => {
        await checkExistingSession();
        initializeGame();
        updatePerkButtons();
        updateGuestPlayButton();
        
        CoinsManager.initialize();
        WordsManager.initialize();
        
        // Load initial values if user is logged in
        if (currentUser) {
            const [coins, words] = await Promise.all([
                CoinsManager.loadUserCoins(),
                WordsManager.loadUserWords()
            ]);
            
            gameState.coins = coins;
            CoinsManager.updateDisplays();
            WordsManager.updateDisplays(words);
        }
        
        // Check for join hash on initial load
        if (window.location.hash.startsWith('#join=')) {
            console.log('Initial join hash detected');
            const otp = window.location.hash.replace('#join=', '');
            history.pushState("", document.title, window.location.pathname);
            showJoinModal(otp);
        }

        // Ensure particles on welcome screen
        const welcomeScreen = document.getElementById('welcome-screen');
        initializeParticles(welcomeScreen);
        
        await loadCustomLists();

        // Mobile fullscreen handling
        if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
            // Request on first touch
            document.addEventListener('touchstart', function onFirstTouch() {
                requestFullscreenMode();
                document.removeEventListener('touchstart', onFirstTouch);
            }, { once: true });
            
            // Request when clicking any button
            document.addEventListener('click', function(e) {
                if (e.target.tagName === 'BUTTON') {
                    requestFullscreenMode();
                }
            });
            
            // Screen orientation handling
            if (screen.orientation) {
                screen.orientation.lock('portrait')
                    .catch(err => console.log('Failed to lock orientation:', err));
            }
        }

        // Initialize real-time channels if user is logged in
        if (currentUser) {
            setupUserStatusSubscription();
            initializeStatusCheck();
        }
    })().catch(error => {
        console.error('Initialization error:', error);
    });
});

async function loadUserGameProgress(userId) {
    console.log("Loading game progress for user:", userId);
    
    try {
        // Set up default values
        gameState.currentStage = 1;
        gameState.currentSet = 1;
        gameState.currentLevel = 1;
        gameState.coins = 0;
        gameState.perks = {};
        gameState.unlockedSets = { "1": new Set([1]) };
        gameState.unlockedLevels = { "1_1": new Set([1]) };
        gameState.perfectLevels = new Set();
        gameState.completedLevels = new Set();
        
        // First try to load from localStorage (this includes extended fields)
        const localProgress = localStorage.getItem("simploxProgress");
        if (localProgress) {
            try {
                const parsedProgress = JSON.parse(localProgress);
                console.log("Found progress in localStorage:", parsedProgress);
                
                // Load basic fields
                if (parsedProgress.stage) gameState.currentStage = parsedProgress.stage;
                if (parsedProgress.set_number) gameState.currentSet = parsedProgress.set_number;
                if (parsedProgress.level) gameState.currentLevel = parsedProgress.level;
                if (parsedProgress.coins) gameState.coins = parsedProgress.coins;
                if (parsedProgress.perks) gameState.perks = parsedProgress.perks;
                
                // Load unlocked sets
                if (parsedProgress.unlocked_sets) {
                    gameState.unlockedSets = {};
                    Object.entries(parsedProgress.unlocked_sets).forEach(([stage, sets]) => {
                        gameState.unlockedSets[stage] = new Set(sets);
                    });
                }
                
                // Load unlocked levels
                if (parsedProgress.unlocked_levels) {
                    gameState.unlockedLevels = {};
                    Object.entries(parsedProgress.unlocked_levels).forEach(([setKey, levels]) => {
                        gameState.unlockedLevels[setKey] = new Set(levels);
                    });
                }
                
                // Load completed and perfect levels
                if (parsedProgress.perfect_levels) {
                    gameState.perfectLevels = new Set(parsedProgress.perfect_levels);
                }
                
                if (parsedProgress.completed_levels) {
                    gameState.completedLevels = new Set(parsedProgress.completed_levels);
                }
            } catch (e) {
                console.error("Error parsing localStorage progress:", e);
            }
        }
        
        // Then try to load from database (this might not include all fields)
        const { data, error } = await supabaseClient
            .from("game_progress")
            .select("*")
            .eq("user_id", userId)
            .single();
            
        if (error) {
            if (error.code === "PGRST116") {
                console.log("No progress record found, creating initial progress");
                
                // Create a new record with minimal fields
                const initialProgress = {
                    user_id: userId,
                    stage: gameState.currentStage,
                    set_number: gameState.currentSet,
                    level: gameState.currentLevel,
                    coins: gameState.coins
                };
                
                const { error: insertError } = await supabaseClient
                    .from("game_progress")
                    .insert([initialProgress]);
                    
                if (insertError) {
                    console.error("Error creating initial game progress:", insertError);
                }
            } else {
                console.error("Error loading game progress:", error);
            }
        } else if (data) {
            // We found database data - prioritize this for core fields
            console.log("Game progress loaded from database:", data);
            
            // Core fields - always use database values if present
            gameState.currentStage = data.stage || gameState.currentStage;
            gameState.currentSet = data.set_number || gameState.currentSet;
            gameState.currentLevel = data.level || gameState.currentLevel;
            gameState.coins = data.coins || gameState.coins;
            
            // Extended fields - only use if present in database
            try {
                // Perks
                if (data.perks && Object.keys(data.perks).length > 0) {
                    gameState.perks = data.perks;
                }
                
                // Unlocked sets
                if (data.unlocked_sets && Object.keys(data.unlocked_sets).length > 0) {
                    gameState.unlockedSets = {};
                    Object.entries(data.unlocked_sets).forEach(([stage, sets]) => {
                        gameState.unlockedSets[stage] = new Set(sets);
                    });
                }
                
                // Unlocked levels
                if (data.unlocked_levels && Object.keys(data.unlocked_levels).length > 0) {
                    gameState.unlockedLevels = {};
                    Object.entries(data.unlocked_levels).forEach(([setKey, levels]) => {
                        gameState.unlockedLevels[setKey] = new Set(levels);
                    });
                }
                
                // Perfect levels
                if (data.perfect_levels && data.perfect_levels.length > 0) {
                    gameState.perfectLevels = new Set(data.perfect_levels);
                }
                
                // Completed levels
                if (data.completed_levels && data.completed_levels.length > 0) {
                    gameState.completedLevels = new Set(data.completed_levels);
                }
            } catch (e) {
                console.error("Error loading extended fields from database:", e);
            }
        }
        
        // Always setup default unlocks to ensure valid state
        setupDefaultUnlocks();
        
        console.log("Game state after loading progress:", {
            currentStage: gameState.currentStage,
            currentSet: gameState.currentSet,
            currentLevel: gameState.currentLevel
        });
        
        updateAllCoinDisplays();
        return true;
    } catch (err) {
        console.error("Unexpected error in loadUserGameProgress:", err);
        return false;
    }
}

function debugUnlockState() {
    console.group('Current Game State');
    console.log('Current Stage:', gameState.currentStage);
    console.log('Current Set:', gameState.currentSet);
    console.log('Current Level:', gameState.currentLevel);
    
    // Log unlocked sets
    console.group('Unlocked Sets');
    Object.entries(gameState.unlockedSets).forEach(([stageId, sets]) => {
        console.log(`Stage ${stageId}:`, Array.from(sets).sort((a, b) => a - b));
    });
    console.groupEnd();
    
    // Log unlocked levels
    console.group('Unlocked Levels');
    Object.entries(gameState.unlockedLevels).forEach(([setKey, levels]) => {
        console.log(`Set ${setKey}:`, Array.from(levels).sort((a, b) => a - b));
    });
    console.groupEnd();
    
    // Log completed levels
    console.log('Completed Levels:', Array.from(gameState.completedLevels));
    console.log('Perfect Levels:', Array.from(gameState.perfectLevels));
    console.groupEnd();
}

async function handleLogout() {
    try {
        const { error } = await supabaseClient.auth.signOut();
        
        if (error) {
            console.error('Supabase logout error:', error.message);
        }

        // Reset game state
        gameState.coins = 0;
        gameState.unlockedSets = {};
        gameState.unlockedLevels = {};
        gameState.perfectLevels = new Set();
        gameState.completedLevels = new Set();


        // Clear all input fields and UI state
        clearCustomPracticeUI();

        // Reset current user and update UI
        currentUser = null;
        updateAuthUI();
        updateUserStatusDisplay(null);
        updateGuestPlayButton(); // Add this line
        
        // Show welcome screen
        showScreen('welcome-screen');

    } catch (error) {
        console.error('Unexpected error during logout:', error);
        // Ensure UI is reset even if logout fails
        currentUser = null;
        updateAuthUI();
        updateUserStatusDisplay(null);
        updateGuestPlayButton(); // Add this line
        showScreen('welcome-screen');
    }
}

function clearCustomPracticeUI() {
    // Clear list name input
    const listNameInput = document.getElementById('custom-list-name');
    if (listNameInput) {
        listNameInput.value = '';
    }

    // Clear word input
    const wordInput = document.getElementById('custom-word-input');
    if (wordInput) {
        wordInput.value = '';
    }

    // Clear translation results
    const translationResults = document.getElementById('translation-results');
    if (translationResults) {
        translationResults.style.display = 'none';
    }

    // Clear word translation list
    const wordList = document.getElementById('word-translation-list');
    if (wordList) {
        wordList.innerHTML = '';
    }

    // Reset current list
    customPracticeLists.currentList = null;
    customPracticeLists.lists = [];
}

function saveProgress() {
    console.log("Saving game progress");
    
    if (!gameState.currentStage) {
        console.log("No game state to save");
        return;
    }
    
    // Format the data for storage
    const progressData = {
        stage: gameState.currentStage || 1,
        set_number: gameState.currentSet || 1,
        level: gameState.currentLevel || 1,
        coins: gameState.coins || 0
    };
    
    // Prepare the extended data that might be affected by schema cache
    const extendedData = {
        perks: gameState.perks || {},
        unlocked_sets: Object.fromEntries(
            Object.entries(gameState.unlockedSets || {}).map(([stage, sets]) => 
                [stage, Array.from(sets || [])]
            )
        ),
        unlocked_levels: Object.fromEntries(
            Object.entries(gameState.unlockedLevels || {}).map(([setKey, levels]) => 
                [setKey, Array.from(levels || [])]
            )
        ),
        perfect_levels: Array.from(gameState.perfectLevels || []),
        completed_levels: Array.from(gameState.completedLevels || [])
    };
    
    // Save full data to localStorage for backup
    localStorage.setItem("simploxProgress", JSON.stringify({
        ...progressData,
        ...extendedData
    }));
    
    // Save current context for resuming
    const contextData = {
        stage: gameState.currentStage,
        set: gameState.currentSet,
        level: gameState.currentLevel,
        timestamp: Date.now()
    };
    localStorage.setItem("gameContext", JSON.stringify(contextData));
    
    // If user is logged in, save to database
    if (currentUser) {
        console.log("Saving progress to Supabase for user:", currentUser.id);
        
        // First try to save just the core fields - this should always work
        supabaseClient
            .from("game_progress")
            .upsert({
                user_id: currentUser.id,
                ...progressData
            })
            .then(({ error: coreError }) => {
                if (coreError) {
                    console.error("Error saving core progress:", coreError);
                } else {
                    console.log("Core progress saved successfully");
                    
                    // Now try to save each extended field individually
                    // This way if one field fails due to schema issues, others might still work
                    const saveExtendedField = (fieldName, fieldValue) => {
                        const updateData = { [fieldName]: fieldValue };
                        
                        supabaseClient
                            .from("game_progress")
                            .update(updateData)
                            .eq("user_id", currentUser.id)
                            .then(({ error }) => {
                                if (error) {
                                    console.warn(`Error saving ${fieldName}:`, error);
                                } else {
                                    console.log(`${fieldName} saved successfully`);
                                }
                            });
                    };
                    
                    // Try each field separately
                    Object.entries(extendedData).forEach(([field, value]) => {
                        saveExtendedField(field, value);
                    });
                }
            });
    }
}

async function ensureCorrectSchema() {
    if (!currentUser) return false;
    
    console.log("Checking database schema for user:", currentUser.id);
    
    try {
        // First check if the user has a game_progress record
        const { data, error } = await supabaseClient
            .from("game_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .single();
            
        if (error) {
            if (error.code === "PGRST116") {
                // Record doesn't exist, create it
                console.log("Creating game progress record for user");
                
                const initialData = {
                    user_id: currentUser.id,
                    stage: 1,
                    set_number: 1,
                    level: 1,
                    coins: 0,
                    perks: {},
                    unlocked_sets: { "1": [1] },
                    unlocked_levels: { "1_1": [1] },
                    perfect_levels: [],
                    completed_levels: []
                };
                
                const { error: insertError } = await supabaseClient
                    .from("game_progress")
                    .insert([initialData]);
                    
                if (insertError) {
                    console.error("Error creating game progress record:", insertError);
                    return false;
                }
                
                return true;
            }
            
            console.error("Error checking game progress record:", error);
            return false;
        }
        
        // Check if we need to add missing data
        let needsUpdate = false;
        const updateData = { ...data };
        
        // Check each required field
        const requiredFields = [
            { name: 'unlocked_sets', defaultValue: { "1": [1] } },
            { name: 'unlocked_levels', defaultValue: { "1_1": [1] } },
            { name: 'perfect_levels', defaultValue: [] },
            { name: 'completed_levels', defaultValue: [] }
        ];
        
        for (const field of requiredFields) {
            if (!(field.name in data) || data[field.name] === null) {
                updateData[field.name] = field.defaultValue;
                needsUpdate = true;
                console.log(`Field "${field.name}" missing, will add it`);
            }
        }
        
        if (needsUpdate) {
            console.log("Updating record with missing fields");
            const { error: updateError } = await supabaseClient
                .from("game_progress")
                .update(updateData)
                .eq("user_id", currentUser.id);
                
            if (updateError) {
                console.error("Error updating game progress record:", updateError);
                return false;
            }
        }
        
        return true;
    } catch (err) {
        console.error("Unexpected error in ensureCorrectSchema:", err);
        return false;
    }
}


function switchAuthTab(tab) {
    const loginTab = document.querySelector('.auth-tab[onclick="switchAuthTab(\'login\')"]');
    const signupTab = document.querySelector('.auth-tab[onclick="switchAuthTab(\'signup\')"]');
    const loginForm = document.getElementById('loginForm');
    const signupForm = document.getElementById('signupForm');

    if (tab === 'login') {
        loginTab.classList.add('active');
        signupTab.classList.remove('active');
        loginForm.classList.remove('hidden');
        signupForm.classList.add('hidden');
    } else {
        loginTab.classList.remove('active');
        signupTab.classList.add('active');
        loginForm.classList.add('hidden');
        signupForm.classList.remove('hidden');
    }
}

function updateAuthUI() {
    const authBox = document.getElementById('authBox');
    const userInfo = document.getElementById('userInfo');
    const userEmailElement = document.getElementById('userEmail');
    const logoutButton = document.querySelector('.logout-button');

    if (currentUser) {
        authBox.classList.add('hidden');
        userInfo.classList.remove('hidden');
        logoutButton.classList.remove('hidden');
        
        // Display username from metadata if available, fallback to email
        userEmailElement.textContent = currentUser.user_metadata?.username || currentUser.email;
        
        // Get and display user status
        supabaseClient
            .from('user_profiles')
            .select('status, username')
            .eq('id', currentUser.id)
            .single()
            .then(({ data }) => {
                if (data) {
                    // If we have a username in the profile, use it
                    if (data.username) {
                        userEmailElement.textContent = data.username;
                    }
                    updateUserStatusDisplay(data.status);
                }
            })
            .catch(error => console.error('Error fetching user status:', error));
            
    } else {
        authBox.classList.remove('hidden');
        userInfo.classList.add('hidden');
        logoutButton.classList.add('hidden');
        userEmailElement.textContent = '';
    }
}



// Game Constants & State Management
const gameStructure = {
    stages: [
        { id: 1, numSets: 9, levelsPerSet: 21, bossLevel: 21 },
        { id: 2, numSets: 10, levelsPerSet: 21, bossLevel: 21 },
        { id: 3, numSets: 12, levelsPerSet: 21, bossLevel: 21 },
        { id: 4, numSets: 30, levelsPerSet: 21, bossLevel: 21 },
        { id: 5, numSets: 14, levelsPerSet: 21, bossLevel: 21 }
    ],
    levelTypes: {
        normal: 'normal',
        boss: 'boss'
    }
};

const gameState = {
    currentStage: null,
    currentSet: null,
    currentLevel: null,
    unlockedSets: {},
    unlockedLevels: {},
    levelScores: {},
    completedLevels: new Set(),
    perfectLevels: new Set(),
    coins: 0,
    
};

// ADD this clean perk configuration
const PERK_CONFIG = {
    timeFreeze: {
        name: 'Time Freeze',
        description: 'Pause the timer for 5 seconds',
        cost: 15,
        icon: 'fa-clock',
        duration: 5000
    },
    skip: {
        name: 'Skip Question',
        description: 'Skip the current word without penalty',
        cost: 1,
        icon: 'fa-forward'
    },
    clue: {
        name: 'Eliminate Wrong Answer',
        description: 'Remove one incorrect answer',
        cost: 35,
        icon: 'fa-lightbulb'
    },
    reveal: {
        name: 'Reveal Correct Answer',
        description: 'Show the correct translation',
        cost: 50,
        icon: 'fa-eye'
    }
};

function buyPerk(perkType) {
    const perkConfig = PERK_CONFIG[perkType];
    if (!perkConfig) return;

    if (gameState.coins < perkConfig.cost) {
        showNotification(`Need ${perkConfig.cost} coins!`, 'error');
        return;
    }

    gameState.coins -= perkConfig.cost;
    updateAllCoinDisplays();

    switch(perkType) {
        case 'timeFreeze':
            isFrozen = true;
            setTimeout(() => {
                isFrozen = false;
            }, perkConfig.duration);
            break;

        case 'skip':
            handleAnswer(true, true);
            break;

        case 'clue':
            const buttons = document.querySelectorAll('.buttons button');
            const correctAnswer = currentGame.isHebrewToEnglish ? 
                currentGame.words[currentGame.currentIndex] : 
                currentGame.translations[currentGame.currentIndex];
            
            const wrongButtons = Array.from(buttons).filter(btn => 
                btn.textContent !== correctAnswer);
            
            if (wrongButtons.length > 0) {
                const buttonToDisable = wrongButtons[Math.floor(Math.random() * wrongButtons.length)];
                buttonToDisable.disabled = true;
                buttonToDisable.style.opacity = '0.5';
            }
            break;

        // REPLACE the reveal case in buyPerk function
case 'reveal':
    const correctAns = currentGame.isHebrewToEnglish ? 
        currentGame.words[currentGame.currentIndex] : 
        currentGame.translations[currentGame.currentIndex];
    
    document.querySelectorAll('.buttons button').forEach(btn => {
        if (btn.textContent === correctAns) {
            btn.classList.add('correct');
            // Store original background
            const originalBackground = btn.style.background;
            btn.style.background = 'var(--success)';
            
            // Reset after 5 seconds
            setTimeout(() => {
                btn.classList.remove('correct');
                btn.style.background = originalBackground;
            }, 5000);
        }
    });
    break;
    }

    saveProgress();
}


function updatePerkButtons() {
    Object.entries(PERK_CONFIG).forEach(([perkType, config]) => {
        const button = document.getElementById(`${perkType}Perk`);
        if (button) {
            // Calculate number of times perk can be purchased
            const availablePurchases = Math.floor(gameState.coins / config.cost);
            const canAfford = availablePurchases > 0;
            
            button.disabled = !canAfford;
            button.classList.toggle('disabled', !canAfford);
            
            // Update counter to show number of purchasable perks
            const countElement = button.querySelector('.perk-count');
            if (countElement) {
                countElement.textContent = canAfford ? availablePurchases.toString() : '0';
            }
        }
    });
}

updatePerkButtons();

let currentGame = {
    words: [],
    translations: [],
    currentIndex: 0,
    correctAnswers: 0,
    firstAttempt: true,
    isHebrewToEnglish: false,
    mixed: false,
    speedChallenge: false,
    startTime: 0,
    levelStartTime: 0,
    timeBonus: 0,
    streakBonus: true,
    questionStartTime: 0,
    wrongStreak: 0,
    progressLost: 0
};

let timer = null;
let timeRemaining = 0;
let isFrozen = false;

let resetProgressTimeout = null;
let isFirstResetAttempt = true;


// Progress Management
function saveProgress() {
    if (currentUser) {
        // Save to Supabase for logged in users
        const progressToSave = {
            stage: gameState.currentStage,
            set_number: gameState.currentSet,
            level: gameState.currentLevel,
            coins: gameState.coins,
            perks: gameState.perks,
            unlocked_sets: Object.fromEntries(
                Object.entries(gameState.unlockedSets).map(([k, v]) => [k, Array.from(v)])
            ),
            unlocked_levels: Object.fromEntries(
                Object.entries(gameState.unlockedLevels).map(([k, v]) => [k, Array.from(v)])
            ),
            perfect_levels: Array.from(gameState.perfectLevels),
            completed_levels: Array.from(gameState.completedLevels)
        };

        supabaseClient
            .from('game_progress')
            .update(progressToSave)
            .eq('user_id', currentUser.id)
            .then(({ error }) => {
                if (error) console.error('Error saving game progress:', error);
            });
    } else {
        // For guest users, save to localStorage
        localStorage.setItem('simploxProgress', JSON.stringify({
            unlockedSets: Object.fromEntries(
                Object.entries(gameState.unlockedSets).map(([k, v]) => [k, Array.from(v)])
            ),
            unlockedLevels: Object.fromEntries(
                Object.entries(gameState.unlockedLevels).map(([k, v]) => [k, Array.from(v)])
            ),
            perfectLevels: Array.from(gameState.perfectLevels),
            completedLevels: Array.from(gameState.completedLevels),
            coins: gameState.coins,
            perks: gameState.perks
        }));
    }
}


function loadProgress() {
    const saved = localStorage.getItem('simploxProgress');
    if (saved) {
        const data = JSON.parse(saved);
        gameState.unlockedSets = Object.fromEntries(
            Object.entries(data.unlockedSets).map(([k, v]) => [k, new Set(v)])
        );
        gameState.unlockedLevels = Object.fromEntries(
            Object.entries(data.unlockedLevels).map(([k, v]) => [k, new Set(v)])
        );
        gameState.perfectLevels = new Set(data.perfectLevels);
        gameState.completedLevels = new Set(data.completedLevels || []);
        gameState.coins = data.coins;
        gameState.perks = data.perks || {timeFreeze: 0, skip: 0, clue: 0, reveal: 0};
    }
    const savedCustomCoins = localStorage.getItem('simploxCustomCoins');
    if (savedCustomCoins) {
        gameState.coins = parseInt(savedCustomCoins);
    }
}

async function handleLogout() {
    try {
        const { error } = await supabaseClient.auth.signOut();
        
        if (error) {
            console.error('Supabase logout error:', error.message);
        }

        currentUser = null;
        updateAuthUI();
        showScreen('welcome-screen');
        
        // Reload game progress from localStorage
        initializeGame();

    } catch (error) {
        console.error('Unexpected error during logout:', error);
    }
}



// Timer Functions
// Replace the startTimer function:
function startTimer(questionCount) {
    clearTimer();
    if (currentGame.currentIndex >= currentGame.words.length) return;
    
    // Set initial time only if not already set
    if (!currentGame.initialTimeRemaining) {
        currentGame.initialTimeRemaining = currentGame.words.length * 10;
        timeRemaining = currentGame.initialTimeRemaining;
        currentGame.totalTime = timeRemaining; // Store the initial total time
    } else {
        // Use the remaining time from the previous interval
        timeRemaining = currentGame.initialTimeRemaining;
    }
    
    console.log('Starting timer with:', timeRemaining, 'seconds');
    currentGame.questionStartTime = Date.now();
    updateTimerDisplay();
    updateTimerCircle(timeRemaining, currentGame.totalTime); // Use stored total time
    
    timer = setInterval(() => {
        if (!isFrozen) {
            timeRemaining = Math.max(0, timeRemaining - 1);
            updateTimerDisplay();
            updateTimerCircle(timeRemaining, currentGame.totalTime); // Use stored total time
            
            // Update the initialTimeRemaining to track remaining time
            currentGame.initialTimeRemaining = timeRemaining;
            
            if (timeRemaining <= 10) {
                document.querySelector('.timer-value').classList.add('warning');
            }
            
            if (timeRemaining <= 0) {
                handleTimeUp();
            }
        }
    }, 1000);
}

function updateTimerDisplay() {
    const minutes = Math.floor(timeRemaining / 60);
    const seconds = timeRemaining % 60;
    const timerElement = document.querySelector('.timer-value');
    timerElement.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    
    if (timeRemaining <= 10) {
        timerElement.classList.add('warning');
    } else {
        timerElement.classList.remove('warning');
    }
}

function clearTimer() {
    if (timer) {
        clearInterval(timer);
        timer = null;
    }
    timeRemaining = 0;
    isFrozen = false;
    
    const timerProgress = document.querySelector('.timer-progress');
    if (timerProgress) {
        timerProgress.classList.remove('warning');
    }
    
    updateTimerCircle(0, 1); // This will empty the circle
}

function createParticles(x, y) {
    // Detect mobile device
    const isMobile = window.matchMedia("(max-width: 768px)").matches;
    
    // Define particle parameters based on device type
    const particleConfig = isMobile 
        ? {
            count: 10,      // Fewer particles on mobile
            size: 6,        // Smaller particles
            distance: 50,   // Shorter spread
            opacity: 0.7,   // Lower opacity
            duration: 1000  // Shorter animation
        }
        : {
            count: 40,      // More particles on desktop
            size: 10,       // Standard particle size
            distance: 150,  // Wider spread
            opacity: 1,     // Full opacity
            duration: 1500  // Longer animation
        };

    const colors = ['#ffd700', '#FFA500', '#4CAF50', '#FFD700'];
    const container = document.body;
    
    for (let i = 0; i < particleConfig.count; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        
        // Position relative to click point
        particle.style.position = 'fixed';
        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;
        
        // Randomize particle properties
        const angle = (Math.random() * Math.PI * 2);
        const distance = particleConfig.distance + (Math.random() * 50);
        
        particle.style.width = `${particleConfig.size}px`;
        particle.style.height = `${particleConfig.size}px`;
        particle.style.opacity = `${particleConfig.opacity}`;
        
        particle.style.setProperty('--x', `${Math.cos(angle) * distance}px`);
        particle.style.setProperty('--y', `${Math.sin(angle) * distance}px`);
        
        // Create adaptive animation
        particle.style.animation = `particleBurst ${particleConfig.duration / 1000}s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards`;
        
        container.appendChild(particle);
        
        // Remove particle after animation completes
        setTimeout(() => {
            container.removeChild(particle);
        }, particleConfig.duration);
    }
}

function animateCoinsChange(element, startValue, endValue) {
    if (!element) return;
    
    const duration = 1000; // 1 second
    const frameRate = 60;
    const frames = duration / (1000 / frameRate);
    const increment = (endValue - startValue) / frames;
    
    let currentFrame = 0;
    let currentValue = startValue;

    function updateFrame() {
        currentFrame++;
        currentValue += increment;
        
        if (currentFrame <= frames) {
            // Round to nearest integer for whole number display
            element.textContent = Math.round(currentValue);
            
            // Add color change based on increase/decrease
            if (increment > 0) {
                element.style.color = 'var(--success)';
            } else if (increment < 0) {
                element.style.color = 'var(--error)';
            }
            
            requestAnimationFrame(updateFrame);
        } else {
            // Final frame
            element.textContent = endValue;
            
            // Reset color after animation
            setTimeout(() => {
                element.style.color = 'var(--text)';
            }, 300);
        }
    }

    updateFrame();
}


function updatePlayerProgress(payload) {
    const existingPlayerIndex = currentArcadeSession.participants.findIndex(
        p => p.username === payload.username
    );
    
    // Store old positions and values for animation
    const oldPositions = {};
    const oldValues = {};
    document.querySelectorAll('.leaderboard-entry').forEach(entry => {
        const username = entry.querySelector('[data-username]').dataset.username;
        oldPositions[username] = entry.getBoundingClientRect();
        
        const wordsElement = entry.querySelector('[data-words]');
        const coinsElement = entry.querySelector('[data-coins]');
        
        if (wordsElement) oldValues[username] = {
            words: parseInt(wordsElement.textContent),
            coins: parseInt(coinsElement.textContent)
        };
    });
    
    if (existingPlayerIndex !== -1) {
        currentArcadeSession.participants[existingPlayerIndex] = {
            ...currentArcadeSession.participants[existingPlayerIndex],
            ...payload
        };
    } else {
        currentArcadeSession.participants.push({
            username: payload.username,
            wordsCompleted: payload.wordsCompleted || 0,
            coins: payload.coins || 0
        });
    }
    
    // Sort and create new entries
    const sortedPlayers = [...currentArcadeSession.participants]
        .sort((a, b) => {
            if (b.wordsCompleted !== a.wordsCompleted) {
                return b.wordsCompleted - a.wordsCompleted;
            }
            return b.coins - a.coins;
        });
    
    const entries = sortedPlayers.map((player, index) => `
        <div class="leaderboard-entry ${index < 3 ? `rank-${index + 1}` : ''}"
             data-rank="${index + 1}">
            <div>${index + 1}</div>
            <div data-username="${player.username}">${player.username}</div>
            <div data-words="${player.wordsCompleted}">${player.wordsCompleted || 0}</div>
            <div data-coins="${player.coins}">${player.coins || 0}</div>
        </div>
    `).join('');
    
    const leaderboard = document.getElementById('arcade-leaderboard');
    leaderboard.innerHTML = leaderboard.querySelector('.leaderboard-header').outerHTML + entries;

    // Apply animations
    const newEntries = leaderboard.querySelectorAll('.leaderboard-entry');
    newEntries.forEach(entry => {
        const username = entry.querySelector('[data-username]').dataset.username;
        if (oldPositions[username]) {
            const oldPos = oldPositions[username];
            const newPos = entry.getBoundingClientRect();
            const diff = oldPos.top - newPos.top;
            
            if (diff > 0) {
                entry.classList.add('moving-up');
            } else if (diff < 0) {
                entry.classList.add('moving-down');
            }
            
            // Animate words and coins if values changed
            if (oldValues[username]) {
                const wordsElement = entry.querySelector('[data-words]');
                const coinsElement = entry.querySelector('[data-coins]');
                
                animateCoinsChange(
                    wordsElement, 
                    oldValues[username].words, 
                    parseInt(wordsElement.textContent)
                );
                
                animateCoinsChange(
                    coinsElement, 
                    oldValues[username].coins, 
                    parseInt(coinsElement.textContent)
                );
            }
            
            entry.addEventListener('animationend', () => {
                entry.classList.remove('moving-up', 'moving-down');
            }, { once: true });
        }
    });
}

function handleTimeUp() {
    if (currentGame.currentIndex >= currentGame.words.length) return; // Don't show if level is complete
    
    clearTimer();
    showReviveOverlay();
}

document.addEventListener('DOMContentLoaded', function() {
  // Existing code...
  
  // Check for admin user and add test button if we're on the question screen
  if (document.getElementById('question-screen').classList.contains('visible')) {
    console.log("Question screen is visible on load, adding admin button");
    addAdminTestButton();
  }
  
  // Also add a direct check just to be safe
  setTimeout(() => {
    if (currentUser && currentUser.email === 'admin123@gmail.com') {
      console.log("Admin user detected on page load");
      addAdminTestButton();
    }
  }, 2000); // Give time for user to be loaded
});

function showScreen(screenId, forceRefresh = false) {
  // When returning to welcome screen, clear game context
  if (screenId === "welcome-screen") {
    console.log("Returning to welcome screen, clearing game context");
    localStorage.removeItem("gameContext");
  }
  
  console.log("showScreen called with:", {
    screenId: screenId,
    forceRefresh: forceRefresh,
    currentUser: currentUser ? currentUser.id : "No user"
  });
  
  // Special handling for leaderboard screen cleanup
  if (document.querySelector('.screen.visible')?.id === 'leaderboard-screen') {
    cleanupLeaderboard();
  }
  
  // Get currently visible screen
  const currentScreen = document.querySelector('.screen.visible');
  
  // Cleanup if leaving question screen
  if (currentScreen && currentScreen.id === 'question-screen') {
    clearTimer();
    isFrozen = false;
  }
  
  // Handle force refresh
  if (forceRefresh && screenId === "welcome-screen") {
    console.log("Initiating full page reload");
    saveProgress();
    window.location.reload(true);
    return;
  }
  
  // Hide all screens
  document.querySelectorAll('.screen').forEach(screen => {
    screen.classList.remove('visible');
    
    // Remove particle containers
    const particleContainer = screen.querySelector('.particle-container');
    if (particleContainer) {
      particleContainer.remove();
    }
  });
  
  // Show requested screen
  const screenElement = document.getElementById(screenId);
  if (screenElement) {
    // Make screen visible
    screenElement.classList.add('visible');
    
    // Initialize particles for the screen
    initializeParticles(screenElement);
    
    // Update UI elements
    updateAllCoinDisplays();
    
    // Special handling for different screens
    switch (screenId) {
      case "question-screen":
        updatePerkButtons();
        
        // Check for admin user and add test button
        console.log("Question screen shown, checking for admin button");
        setTimeout(() => {
          addAdminTestButton();
        }, 100);
        break;
        
      case "welcome-screen":
        if (restoreGameContext()) {
          startGame();
        }
        break;
        
      case "stage-cascade-screen":
        // Handle the cascading stage screen specially
        return showStageCascadeScreen();
    }
    
    console.log(`Switched to screen: ${screenId}`);
  } else {
    console.error(`Screen with id ${screenId} not found`);
  }
}

document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.home-button').forEach(button => {
        button.addEventListener('click', (event) => {
            event.preventDefault();
            showScreen('welcome-screen', true);
        });
    });
});


// Add full-screen event listener
document.addEventListener('fullscreenchange', function() {
    if (!document.fullscreenElement) {
        console.log('Exited full-screen');
    }
});


function showLevelScreen(setId) {
    gameState.currentSet = setId;
    debugUnlockState(); // Add debug call here
    
    // Clear existing screen
    const container = document.getElementById('level-container');
    if (!container) return;
    container.innerHTML = '';
    
    const stage = gameStructure.stages[gameState.currentStage - 1];
    if (!stage) return;
    
    // Create level header
    const levelHeader = document.createElement('div');
    levelHeader.className = 'level-header';
    
    // Calculate level completion stats
    const totalLevels = stage.levelsPerSet;
    let completedCount = 0;
    let perfectCount = 0;
    
    for (let i = 1; i <= totalLevels; i++) {
        const levelKey = `${gameState.currentStage}_${setId}_${i}`;
        if (gameState.perfectLevels.has(levelKey)) {
            perfectCount++;
            completedCount++;
        } else if (gameState.completedLevels.has(levelKey)) {
            completedCount++;
        }
    }
    
    const progressPercentage = Math.round((completedCount / totalLevels) * 100);
    const setIcon = getSetIcon(gameState.currentStage, setId);
    const setDescription = getSetDescription(gameState.currentStage, setId);
    
    // Populate header
    levelHeader.innerHTML = `
        <div class="level-title-area">
            <div class="set-icon">
                <i class="${setIcon}"></i>
            </div>
            <div class="set-details">
                <div class="set-name">Stage ${gameState.currentStage} - Set ${setId}</div>
                <div class="set-desc">${setDescription}</div>
            </div>
        </div>
        <div class="set-progress">
            <div class="progress-bar">
                <div class="progress-fill" style="width: ${progressPercentage}%"></div>
            </div>
            <div class="progress-text">${completedCount}/${totalLevels} levels</div>
        </div>
    `;
    
    container.appendChild(levelHeader);
    
    // Create level grid
    const levelGrid = document.createElement('div');
    levelGrid.className = 'level-grid';
    
    const testLevels = [3, 6, 9, 10, 13, 16, 19, 20];
    const setKey = `${gameState.currentStage}_${setId}`;
    
    // Ensure unlockedLevels exists for this set
    if (!gameState.unlockedLevels[setKey]) {
        gameState.unlockedLevels[setKey] = new Set([1]); // At minimum, level 1 should be unlocked
    }
    
    console.log(`Rendering levels for ${setKey}. Unlocked levels:`, 
                Array.from(gameState.unlockedLevels[setKey] || []));
    
    for (let i = 1; i <= stage.levelsPerSet; i++) {
        const levelItem = document.createElement('div');
        const levelKey = `${gameState.currentStage}_${setId}_${i}`;
        
        // Check if level is unlocked - use more direct access with fallback
        const isUnlocked = gameState.unlockedLevels[setKey]?.has(i);
        console.log(`Level ${i} unlocked:`, isUnlocked);
        
        const isPerfect = gameState.perfectLevels.has(levelKey);
        const isCompleted = gameState.completedLevels.has(levelKey);
        const isBossLevel = i === stage.bossLevel;
        const isTestLevel = testLevels.includes(i);
        
        // Set appropriate classes
        levelItem.className = 'level-item';
        if (isUnlocked) levelItem.classList.add('unlocked');
        if (isPerfect) levelItem.classList.add('perfect');
        else if (isCompleted) levelItem.classList.add('completed');
        if (isBossLevel) levelItem.classList.add('boss');
        if (isTestLevel) levelItem.classList.add('test');
        if (!isUnlocked) levelItem.classList.add('locked');
        
        levelItem.textContent = i;
        
        if (isUnlocked) {
            levelItem.onclick = () => startLevel(i);
        }
        
        levelGrid.appendChild(levelItem);
    }
    
    container.appendChild(levelGrid);
    
    // Add legend
    const legend = document.createElement('div');
    legend.className = 'level-type-legend';
    legend.innerHTML = `
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, var(--accent), rgba(30, 144, 255, 0.7));"></div>
            <span>Normal</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, var(--success), #45b649);"></div>
            <span>Completed</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, var(--gold), #FFA500);"></div>
            <span>Perfect</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, var(--gold), var(--accent));"></div>
            <span>Boss</span>
        </div>
    `;
    
    container.appendChild(legend);
    
    // Show the screen
    showScreen('level-screen');
}

// Helper functions for the level screen
function getSetIcon(stageId, setId) {
    const baseIcons = {
        1: 'fas fa-book',
        2: 'fas fa-graduation-cap',
        3: 'fas fa-school',
        4: 'fas fa-university',
        5: 'fas fa-brain'
    };
    
    // Adjust icon based on set number
    const variations = [
        'fas fa-book-open', 
        'fas fa-book-reader', 
        'fas fa-bookmark', 
        'fas fa-pencil-alt',
        'fas fa-pen'
    ];
    
    // Use base icon for first set, variations for others
    return setId === 1 ? baseIcons[stageId] || 'fas fa-star' : 
        variations[(setId - 2) % variations.length] || 'fas fa-star';
}

function getSetDescription(stageId, setId) {
    const stageNames = {
        1: 'Beginner',
        2: 'Elementary',
        3: 'Intermediate',
        4: 'Advanced',
        5: 'Expert'
    };
    
    // Generic descriptions that combine stage and set
    return `${stageNames[stageId] || 'Advanced'} vocabulary - Group ${setId}`;
}

function calculateWordsForLevel(level, vocabulary) {
    const totalWords = vocabulary.words.length;
    const wordSurplus = totalWords - 50;

    // If we haven't already created a randomized index mapping for this vocabulary set
    // then create one and store it in the vocabulary object
    if (!vocabulary.randomIndices) {
        // Create an array of indices and shuffle it
        vocabulary.randomIndices = Array.from({ length: totalWords }, (_, i) => i);
        // Fisher-Yates shuffle algorithm
        for (let i = vocabulary.randomIndices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [vocabulary.randomIndices[i], vocabulary.randomIndices[j]] = 
            [vocabulary.randomIndices[j], vocabulary.randomIndices[i]];
        }
        console.log('Created randomized word indices:', vocabulary.randomIndices);
    }

    // Boss Level (21) - all words from the set with special mechanics
    if (level === 21) {
        return {
            startIndex: 0,
            count: totalWords,
            isBossLevel: true,
            speedChallenge: true,
            mixed: true,                    // Mix Hebrew/English questions
            isTestLevel: true,              // Boss is always a test level
            isHebrewToEnglish: Math.random() < 0.5,
            testLevels: [],                 // Boss level doesn't need test levels
            randomIndices: vocabulary.randomIndices // Pass the entire randomized index array
        };
    }

    // Level 1-2: Choose 3 new words
    if (level === 1 || level === 2) {
        // Get 3 words starting from the randomized index position
        const startPos = (level - 1) * 3;
        return {
            startIndex: startPos,
            count: 3,
            testLevels: [3, 10, 21],
            randomIndices: vocabulary.randomIndices.slice(startPos, startPos + 3)
        };
    }

    // Level 3: Test words from levels 1-2
    if (level === 3) {
        // Test all 6 words from levels 1-2 (randomized indices 0-5)
        return {
            startIndex: 0,
            count: 6,
            isTestLevel: true,
            mixed: true,
            isHebrewToEnglish: Math.random() < 0.5,
            randomIndices: vocabulary.randomIndices.slice(0, 6)
        };
    }

    // Level 4-5: Choose 3 new words
    if (level === 4 || level === 5) {
        const startPos = 6 + (level - 4) * 3;
        return {
            startIndex: startPos,
            count: 3,
            testLevels: [6, 10, 21],
            randomIndices: vocabulary.randomIndices.slice(startPos, startPos + 3)
        };
    }

    // Level 6: Test words from levels 4-5
    if (level === 6) {
        return {
            startIndex: 6,
            count: 6,
            isTestLevel: true,
            mixed: true,
            isHebrewToEnglish: Math.random() < 0.5,
            randomIndices: vocabulary.randomIndices.slice(6, 12)
        };
    }

    // Level 7-8: Choose 4 new words
    if (level === 7 || level === 8) {
        const startPos = 12 + (level - 7) * 4;
        return {
            startIndex: startPos,
            count: 4,
            testLevels: [9, 10, 21],
            randomIndices: vocabulary.randomIndices.slice(startPos, startPos + 4)
        };
    }

    // Level 9: Test words from levels 7-8
    if (level === 9) {
        return {
            startIndex: 12,
            count: 8,
            isTestLevel: true,
            mixed: true,
            isHebrewToEnglish: Math.random() < 0.5,
            randomIndices: vocabulary.randomIndices.slice(12, 20)
        };
    }

    // Level 10: Test words from levels 1,2,4,5,7,8
    if (level === 10) {
        return {
            startIndex: 0,
            count: 20,
            isTestLevel: true,
            speedChallenge: true,
            mixed: true,
            isHebrewToEnglish: Math.random() < 0.5,
            randomIndices: vocabulary.randomIndices.slice(0, 20)
        };
    }

    // Level 11-12: Choose 4 new words
    if (level === 11 || level === 12) {
        const startPos = 20 + (level - 11) * 4;
        return {
            startIndex: startPos,
            count: 4,
            testLevels: [13, 20, 21],
            randomIndices: vocabulary.randomIndices.slice(startPos, startPos + 4)
        };
    }

    // Level 13: Test words from levels 11-12
    if (level === 13) {
        return {
            startIndex: 20,
            count: 8,
            isTestLevel: true,
            mixed: true,
            isHebrewToEnglish: Math.random() < 0.5,
            randomIndices: vocabulary.randomIndices.slice(20, 28)
        };
    }

    // Level 14-15: Choose 5-6 new words
    if (level === 14 || level === 15) {
        const count = level === 14 ? 5 : 6;
        const startPos = 28 + (level === 14 ? 0 : 5);
        return {
            startIndex: startPos,
            count: count,
            testLevels: [16, 20, 21],
            randomIndices: vocabulary.randomIndices.slice(startPos, startPos + count)
        };
    }

    // Level 16: Test words from levels 14-15
    if (level === 16) {
        return {
            startIndex: 28,
            count: 11,
            isTestLevel: true,
            mixed: true,
            isHebrewToEnglish: Math.random() < 0.5,
            randomIndices: vocabulary.randomIndices.slice(28, 39)
        };
    }

    // Level 17-18: Flexible word count based on total vocabulary
    if (level === 17 || level === 18) {
        const baseCount = level === 17 ? 5 : 6;
        const adjustedCount = baseCount + (wordSurplus > 0 ? wordSurplus : 0);
        const startPos = 39 + (level === 17 ? 0 : baseCount);
        return {
            startIndex: startPos,
            count: adjustedCount,
            testLevels: [19, 20, 21],
            randomIndices: vocabulary.randomIndices.slice(startPos, startPos + adjustedCount)
        };
    }

    // Level 19: Test words from levels 17-18
    if (level === 19) {
        return {
            startIndex: 39,
            count: 11,
            isTestLevel: true,
            mixed: true,
            isHebrewToEnglish: Math.random() < 0.5,
            randomIndices: vocabulary.randomIndices.slice(39, 50)
        };
    }

    // Level 20: Test words from levels 11,12,14,15,17,18
    if (level === 20) {
        return {
            startIndex: 20,
            count: 30,
            isTestLevel: true,
            speedChallenge: true,
            mixed: true,
            isHebrewToEnglish: Math.random() < 0.5,
            randomIndices: vocabulary.randomIndices.slice(20, 50)
        };
    }
}

function getUnusedWords(vocabulary) {
    // Track used words in gameState
    if (!gameState.usedWords) gameState.usedWords = new Set();
    
    return vocabulary.words.map((_, index) => index)
        .filter(i => !gameState.usedWords.has(i));
}

function selectRandomWords(availableIndices, count) {
    const selected = new Set();
    
    while (selected.size < count && availableIndices.length > selected.size) {
        const randomIndex = Math.floor(Math.random() * availableIndices.length);
        selected.add(availableIndices[randomIndex]);
        gameState.usedWords.add(availableIndices[randomIndex]);
    }
    
    return Array.from(selected);
}

function generateAnswerChoices(correctAnswer, vocabulary) {
    const choices = new Set([correctAnswer]);
    const allChoices = vocabulary.translations;
    
    while (choices.size < 3) {
        const randomChoice = allChoices[Math.floor(Math.random() * allChoices.length)];
        choices.add(randomChoice);
    }
    
    return Array.from(choices).sort(() => Math.random() - 0.5);
}

function startLevel(level) {
  gameState.currentLevel = level;
  
  // Set game context for potential resume
  const gameContext = {
    stage: gameState.currentStage,
    set: gameState.currentSet,
    level: level,
    timestamp: Date.now()
  };
  
  console.log("Setting game context at level start:", gameContext);
  localStorage.setItem("gameContext", JSON.stringify(gameContext));
  
  // Reset state for new level
  currentGame.wrongStreak = 0;
  currentGame.correctAnswers = 0;
  currentGame.levelStartTime = Date.now();
  currentGame.firstAttempt = true;
  currentGame.streakBonus = true;
  
  // Update perks
  updatePerkButtons();
  
  // Debug logging
  console.log("Current unlocked levels:", gameState.unlockedLevels);
  
  const setKey = `${gameState.currentStage}_${gameState.currentSet}`;
  console.log(`Current set key: ${setKey}, unlocked levels in set:`, 
    gameState.unlockedLevels[setKey] ? Array.from(gameState.unlockedLevels[setKey]) : "none");
  
  // Setup UI elements
  const perksContainer = document.querySelector('.perks-container');
  const powerupsContainer = document.querySelector('.powerups-container');
  
  if (perksContainer) perksContainer.style.display = 'flex';
  if (powerupsContainer) powerupsContainer.style.display = 'none';
  
  // Update coin display
  const coinCount = document.querySelector('.coin-count');
  if (coinCount) {
    coinCount.textContent = gameState.coins || 0;
  }
  
  // Show coins container
  const coinsContainer = document.querySelector('.coins-container');
  if (coinsContainer) {
    coinsContainer.style.display = 'flex';
  }
  
  // Ensure game state is initialized
  gameState.currentStage = gameState.currentStage || 1;
  gameState.currentSet = gameState.currentSet || 1;
  gameState.currentLevel = level;
  
  console.log(`Starting level: Stage ${gameState.currentStage}, Set ${gameState.currentSet}, Level ${level}`);
  
  // Add admin test button if applicable
  addAdminTestButton();
  
  // Check if premium is required for this level
  const userStatus = currentUser ? currentUser.status : "unregistered";
  const isLevelRequiringPremium = [2, 7, 11, 15, 20].includes(level);
  
  if (isLevelRequiringPremium && userStatus !== "premium") {
    const savedLevel = level;
    
    // Handle unregistered users
    if (!currentUser) {
      return showUnregisteredWarning(() => {
        proceedWithLevel(savedLevel);
      });
    }
    
    // Check if upgrade already requested
    if (!localStorage.getItem(`upgradeRequested_${currentUser.id}`)) {
      return showUpgradePrompt(() => {
        proceedWithLevel(savedLevel);
      });
    }
  }
  
  // Flag boss level
  if (level === 21) {
    currentGame.isBossLevel = true;
    console.log("Boss level detected");
    
    // Apply boss styles after a small delay to ensure DOM is ready
    setTimeout(applyBossLevelStyles, 100);
    
    // Apply again after a longer delay to override any potential changes
    setTimeout(applyBossLevelStyles, 500);
  } else {
    currentGame.isBossLevel = false;
  }
  
  // Process with regular level start
  proceedWithLevel(level);
}

function addAdminTestButton() {
  console.log("Checking for admin user...");
  
  // Remove any existing button first
  const existingButton = document.getElementById('admin-test-button');
  if (existingButton) {
    existingButton.remove();
  }
  
  // Debug the current user
  console.log("Current user:", currentUser ? currentUser.email : "No user");
  
  // Check if current user is admin123@gmail.com (more permissive check)
  if (!currentUser || 
      (currentUser.email !== 'admin123@gmail.com' && 
       !currentUser.email?.includes('admin123'))) {
    console.log("Not admin user, not adding button");
    return;
  }
  
  console.log("Admin user detected, adding test button");
  
  // Create the test button
  const adminButton = document.createElement('button');
  adminButton.id = 'admin-test-button';
  adminButton.textContent = 'Jump to Level 20';
  adminButton.style.cssText = `
    position: fixed;
    top: 80px;
    right: 20px;
    background: #ff5722;
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 5px;
    cursor: pointer;
    z-index: 2000;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    font-weight: bold;
  `;
  
  // Add click handler
  adminButton.onclick = function() {
    console.log("Admin button clicked, jumping to level 20");
    // Jump to level 20
    gameState.currentLevel = 21;
    startLevel(21);
  };
  
  // Add to document body instead of question screen for higher visibility
  document.body.appendChild(adminButton);
  
  console.log("Admin test button added to body");
}

function findFurthestProgression() {
    console.log("Finding furthest progression");
    
    // First check if there's a saved game context
    const savedContext = localStorage.getItem("gameContext");
    if (savedContext) {
        try {
            const context = JSON.parse(savedContext);
            if (context.stage && context.set && context.level) {
                console.log("Found saved game context:", context);
                return {
                    stage: context.stage,
                    set: context.set,
                    level: context.level
                };
            }
        } catch (e) {
            console.error("Error parsing saved game context:", e);
        }
    }
    
    console.log("Current game state:", {
        currentStage: gameState.currentStage,
        currentSet: gameState.currentSet,
        currentLevel: gameState.currentLevel,
        unlockedSets: Object.fromEntries(Object.entries(gameState.unlockedSets || {}).map(([k, v]) => [k, Array.from(v || [])])),
        unlockedLevels: Object.fromEntries(Object.entries(gameState.unlockedLevels || {}).map(([k, v]) => [k, Array.from(v || [])])),
        perfectLevels: Array.from(gameState.perfectLevels || []),
        completedLevels: Array.from(gameState.completedLevels || [])
    });
    
    // If we have current stage and level information, use that directly
    if (gameState.currentStage && gameState.currentSet && gameState.currentLevel) {
        console.log(`Using current game state: Stage ${gameState.currentStage}, Set ${gameState.currentSet}, Level ${gameState.currentLevel}`);
        return {
            stage: gameState.currentStage,
            set: gameState.currentSet,
            level: gameState.currentLevel
        };
    }
    
    // If that doesn't work, fall back to stage 1, set 1, level 1
    console.log("No progression found, defaulting to beginning");
    return {
        stage: 1,
        set: 1,
        level: 1
    };
}

function proceedWithLevel(level) {
  currentGame.restartsRemaining = currentGame.restartsRemaining || 2;
  gameState.currentLevel = level;
  
  const setKey = `${gameState.currentStage}_${gameState.currentSet}`;
  const vocabulary = vocabularySets[setKey];
  
  // Update coin display
  const coinCount = document.querySelector('.coin-count');
  if (coinCount) {
    coinCount.textContent = gameState.coins || 0;
    coinCount.style.display = 'block';
  }
  
  // Store starting state
  currentGame.startingCoins = gameState.coins;
  currentGame.startingPerks = {...gameState.perks};
  currentGame.timeBonus = 0;
  currentGame.initialTimeRemaining = null;
  currentGame.streakBonus = true;
  currentGame.levelStartTime = Date.now();
  
  // Show level intro
  showLevelIntro(level, () => {
    // Set up the game state
    setupGameState(calculateWordsForLevel(level, vocabulary), vocabulary);
    
    // Show the question screen
    showScreen("question-screen");
    
    // Check for admin user and add test button
    addAdminTestButton();
    
    // Boss level requires special initialization
    if (level === 21) {
      console.log("Initializing boss level in proceedWithLevel");
      initializeBossLevel();
      
      // Apply boss styles forcefully after DOM is ready
      setTimeout(applyBossLevelStyles, 200);
      
      loadNextBossQuestion();
    } else {
      updateProgressCircle();
      loadNextQuestion();
    }
    
    // Start the timer
    setTimeout(() => {
      startTimer(currentGame.words.length);
    }, 200);
  });
}


document.querySelector('.perks-container').innerHTML = `
    ${Object.entries(PERK_CONFIG).map(([type, config]) => `
        <button class="perk-button" id="${type}Perk" onclick="buyPerk('${type}')">
            <i class="fas ${config.icon} perk-icon"></i>
            <span class="perk-count">0</span>
        </button>
    `).join('')}
`;

function proceedWithLevel(levelId) {
    if (!currentGame.restartsRemaining) {
        currentGame.restartsRemaining = 2;
    }
    
    gameState.currentLevel = levelId;
    const setKey = `${gameState.currentStage}_${gameState.currentSet}`;
    const vocabulary = vocabularySets[setKey];

    // Ensure coin display remains visible
    const coinDisplay = document.querySelector('.coin-count');
    if (coinDisplay) {
        coinDisplay.textContent = gameState.coins || 0;
        coinDisplay.style.display = 'block';
    }

    // Prepare all game state first
    currentGame.startingCoins = gameState.coins;
    currentGame.startingPerks = { ...gameState.perks };
    currentGame.timeBonus = 0;
    currentGame.initialTimeRemaining = null;
    currentGame.streakBonus = true;
    currentGame.levelStartTime = Date.now();
    
    // Show intro, but prepare the level during the curtain-down moment
    showLevelIntro(levelId, () => {
        // Setup all game state while curtain is down
        const levelConfig = calculateWordsForLevel(levelId, vocabulary);
        setupGameState(levelConfig, vocabulary);
        
        // Prepare the question screen while curtain is still down
        showScreen('question-screen');
        updateProgressCircle();
        loadNextQuestion();
        
        // Only start the timer after curtain is fully up
        setTimeout(() => {
            startTimer(currentGame.words.length);
        }, 200);
    });
}

function setupGameState(levelConfig, vocabulary) {
    if (typeof levelConfig === 'object') {
        // Check if we have randomized indices
        if (levelConfig.randomIndices) {
            // Create new arrays with just the words we need based on random indices
            const randomWords = levelConfig.randomIndices.map(index => vocabulary.words[index]);
            const randomTranslations = levelConfig.randomIndices.map(index => vocabulary.translations[index]);
            
            Object.assign(currentGame, {
                words: randomWords,
                translations: randomTranslations,
                currentIndex: 0,
                correctAnswers: 0,
                firstAttempt: true,
                isHebrewToEnglish: levelConfig.isHebrewToEnglish || false,
                mixed: levelConfig.mixed || false,
                speedChallenge: levelConfig.speedChallenge || false,
                isBossLevel: levelConfig.isBossLevel || false
            });
        } else {
            // Fallback to original behavior if randomIndices not available
            const { startIndex, count, isHebrewToEnglish, mixed, speedChallenge, isBossLevel } = levelConfig;
            Object.assign(currentGame, {
                words: vocabulary.words.slice(startIndex, startIndex + count),
                translations: vocabulary.translations.slice(startIndex, startIndex + count),
                currentIndex: 0,
                correctAnswers: 0,
                firstAttempt: true,
                isHebrewToEnglish: isHebrewToEnglish || false,
                mixed: mixed || false,
                speedChallenge: speedChallenge || false,
                isBossLevel: isBossLevel || false
            });
        }
    } else {
        // Legacy behavior for backwards compatibility
        Object.assign(currentGame, {
            words: vocabulary.words.slice(0, levelConfig),
            translations: vocabulary.translations.slice(0, levelConfig),
            currentIndex: 0,
            correctAnswers: 0,
            firstAttempt: true,
            isHebrewToEnglish: false,
            mixed: false,
            speedChallenge: false,
            isBossLevel: false
        });
    }
}

function handleLevelProgression() {
    const currentStageConfig = gameStructure.stages[gameState.currentStage - 1];
    const isLastLevelInSet = gameState.currentLevel === currentStageConfig.levelsPerSet;
    const isLastSetInStage = gameState.currentSet === currentStageConfig.numSets;

    if (isLastLevelInSet) {
        if (!isLastSetInStage) {
            gameState.currentSet++;
            startLevel(1);
        } else if (gameState.currentStage < 5) {
            gameState.currentStage++;
            gameState.currentSet = 1;
            startLevel(1);
        } else {
            showScreen('stage-screen');
        }
    } else {
        startLevel(gameState.currentLevel + 1);
    }
}

function updateNavigationIcons(screenId) {
    // Remove existing navigation containers
    
    // Screens that should have navigation
    const screensWithNav = ['stage-screen', 'set-screen', 'level-screen', 'question-screen'];
    
    if (screensWithNav.includes(screenId)) {
        const navContainer = document.createElement('div');
        navContainer.className = 'screen-nav';
        
        // Home button (always present)
        const homeButton = document.createElement('button');
        homeButton.className = 'home-button';
        homeButton.innerHTML = '<i class="fas fa-home"></i>';
        homeButton.onclick = () => showScreen('welcome-screen');
        navContainer.appendChild(homeButton);
        
        // Back button (not for stage screen)
        if (screenId !== 'stage-screen') {
            const backButton = document.createElement('button');
            backButton.className = 'back-button';
            backButton.innerHTML = '<i class="fas fa-arrow-left"></i>';
            
            // Determine back navigation based on current screen
            switch(screenId) {
                case 'set-screen':
                    backButton.onclick = () => showScreen('stage-screen');
                    break;
                case 'level-screen':
                    backButton.onclick = () => showSetScreen(gameState.currentStage);
                    break;
                case 'question-screen':
                    backButton.onclick = () => stopLevelAndGoBack();
                    break;
            }
            
            navContainer.appendChild(backButton);
        }
        
        // Add navigation to the current screen
        const currentScreen = document.getElementById(screenId);
        currentScreen.appendChild(navContainer);
    }
}

function updateProgressCircle() {
    const circle = document.querySelector('.progress-circle .progress');
    const progressCircle = document.querySelector('.progress-circle');
    
    const radius = 54;
    const circumference = 2 * Math.PI * radius;
    
    const progress = currentGame.currentIndex / currentGame.words.length;
    
    circle.style.strokeDasharray = `${circumference} ${circumference}`;
    circle.style.strokeDashoffset = circumference * (1 - progress);
    
    // Advanced color progression
    let hue, saturation, lightness;
    
    if (progress <= 0.2) {
        // 0-20%: Dark Red
        hue = 0;
        saturation = 100;
        lightness = 20;
    } else if (progress <= 0.4) {
        // 20-40%: Bright Red
        hue = 0;
        saturation = 100;
        lightness = 50;
    } else if (progress <= 0.6) {
        // 40-60%: Orange
        hue = 30;
        saturation = 100;
        lightness = 50;
    } else if (progress <= 0.8) {
        // 60-80%: Bright Green
        hue = 120;
        saturation = 100;
        lightness = 40;
    } else {
        // 80-100%: Gold to Blue transition
        const goldToBlueProgress = (progress - 0.8) * 5;
        hue = 120 * (1 - goldToBlueProgress) + 60 * goldToBlueProgress;
        saturation = 100;
        lightness = 40 + (20 * goldToBlueProgress);
    }
    
    circle.style.stroke = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    
}


function loadNextQuestion() {
  // Clear any existing classes from previous question
  document.querySelectorAll(".buttons button").forEach(btn => {
    btn.classList.remove("correct", "wrong");
  });
  
  if (currentGame.currentIndex >= currentGame.words.length) {
    return;
  }
  
  const e = !![3, 6, 9, 10, 13, 16, 19, 20, 21].includes(gameState.currentLevel) && Math.random() < 0.5;
  const t = currentGame.currentIndex;
  const n = e ? currentGame.translations[t] : currentGame.words[t];
  
  document.getElementById("question-word").textContent = n;
  
  const r = e ? currentGame.words[t] : currentGame.translations[t];
  const s = e ? currentGame.words : currentGame.translations;
  const o = new Set([r]);
  
  while (o.size < 3) {
    const e = s[Math.floor(Math.random() * s.length)];
    if (e !== r) {
      o.add(e);
    }
  }
  
  const a = document.getElementById("buttons");
  a.innerHTML = "";
  
  Array.from(o).sort(() => Math.random() - 0.5).forEach((e) => {
    const t = document.createElement("button");
    t.textContent = e;
    t.onclick = () => handleAnswer(e === r);
    a.appendChild(t);
  });
}


function showBossVictoryScreen() {
  console.log("Boss victory screen function called - redirecting to new implementation");
  showBossDefeatEffect();
}

function addAdminTestingButton() {
  // Only add for admin user
  if (!currentUser || currentUser.email !== 'admin123@gmail.com') return;
  
  const questionScreen = document.getElementById('question-screen');
  
  // Check if button already exists
  if (document.getElementById('admin-test-button')) return;
  
  const adminButton = document.createElement('button');
  adminButton.id = 'admin-test-button';
  adminButton.innerHTML = 'Jump to Level 20';
  adminButton.style.cssText = `
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: #ff5722;
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 5px;
    cursor: pointer;
    z-index: 1000;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
  `;
  
  adminButton.onclick = function() {
    // Jump to level 20
    gameState.currentLevel = 20;
    startLevel(20);
  };
  
  questionScreen.appendChild(adminButton);
}

function awardTimeBonus() {
   const timeSpent = (Date.now() - currentGame.questionStartTime) / 1000;
   const maxTime = 10; // Maximum time allowed per question
   if (timeSpent < maxTime) {
       const bonusCoins = Math.floor(maxTime - timeSpent);
       currentGame.timeBonus += bonusCoins;
       return bonusCoins;
   }
   return 0;
}

function pulseCoins(times = 1) {
    // Update both the header coin icon and the in-game coin icon
    const coinIcons = document.querySelectorAll('.coin-icon');
    
    coinIcons.forEach(coinIcon => {
        let pulseCount = 0;
        const doPulse = () => {
            coinIcon.classList.add('coin-pulse');
            setTimeout(() => {
                coinIcon.classList.remove('coin-pulse');
                pulseCount++;
                if (pulseCount < times) {
                    setTimeout(doPulse, 100);
                }
            }, 500);
        };
        
        doPulse();
    });
}


function updateAllCoinDisplays() {
    const displays = document.querySelectorAll('.coin-count');
    displays.forEach(display => {
        const currentValue = parseInt(display.textContent) || 0;
        let targetValue;

        // Determine the target value based on the context
        if (window.location.pathname.includes('arcade')) {
            targetValue = currentGame.coins || 0;
        } else {
            targetValue = gameState.coins || 0;
        }

        // Ensure we're using actual numeric values
        const startNum = Number(currentValue);
        const endNum = Number(targetValue);

        animateNumber(display, startNum, endNum);
    });
}




function eliminateWrongAnswer() {
   const buttons = document.querySelectorAll('.buttons button');
   const correctAnswer = currentGame.isHebrewToEnglish ? 
       currentGame.words[currentGame.currentIndex] : 
       currentGame.translations[currentGame.currentIndex];
   
   const wrongButtons = Array.from(buttons).filter(btn => 
       btn.textContent !== correctAnswer
   );
   
   if (wrongButtons.length > 0) {
       const buttonToDisable = wrongButtons[Math.floor(Math.random() * wrongButtons.length)];
       buttonToDisable.disabled = true;
       buttonToDisable.style.opacity = '0.5';
   }
}

function revealCorrectAnswer() {
   const correctAnswer = currentGame.isHebrewToEnglish ? 
       currentGame.words[currentGame.currentIndex] : 
       currentGame.translations[currentGame.currentIndex];
   
   document.querySelectorAll('.buttons button').forEach(btn => {
       if (btn.textContent === correctAnswer) {
           btn.classList.add('correct');
           setTimeout(() => {
               currentGame.correctAnswers++;
               currentGame.currentIndex++;
               loadNextQuestion();
           }, 1000);
       } else {
           btn.disabled = true;
           btn.style.opacity = '0.5';
       }
   });
}


function buyPerk(perkType) {
    const perkConfig = PERK_CONFIG[perkType];
    const button = document.getElementById(`${perkType}Perk`);
    
    if (!perkConfig) {
        console.error('Invalid perk type:', perkType);
        return;
    }

    // Simple coin check
    if (gameState.coins < perkConfig.cost) {
        showNotification(`Need ${perkConfig.cost} coins for ${perkConfig.name}!`, 'error');
        return;
    }

    // Deduct coins first
    gameState.coins -= perkConfig.cost;
    
    // Improved perk count display update
    const countElement = button.querySelector('.perk-count');
    const currentCount = parseInt(countElement.textContent) || 0;
    const newCount = currentCount - 1;
    
    // Use animation to smoothly transition the count
    animateNumberChange(countElement, currentCount, newCount);

    // Apply effect immediately
    switch(perkType) {
        case 'timeFreeze':
            isFrozen = true;
            button.disabled = true;
            setTimeout(() => {
                isFrozen = false;
                button.disabled = false;
            }, perkConfig.duration);
            break;

        case 'skip':
            handleAnswer(true, true);
            break;

        case 'clue':
            eliminateWrongAnswer();
            break;

        case 'reveal':
            revealCorrectAnswer();
            break;
    }

    // Update all coin displays
    updateAllCoinDisplays();

    // Update button state based on remaining coins
    if (button) {
        button.disabled = gameState.coins < perkConfig.cost;
        button.classList.toggle('disabled', gameState.coins < perkConfig.cost);
    }

    // Save progress after perk use
    saveProgress();
}

// New helper function for smooth number transition
function animateNumberChange(element, startValue, endValue) {
    if (!element) return;
    
    const duration = 300; // Shorter animation for quick updates
    const frames = 20;
    const increment = (endValue - startValue) / frames;
    
    let currentFrame = 0;
    let currentValue = startValue;

    function updateFrame() {
        currentFrame++;
        currentValue += increment;
        
        if (currentFrame <= frames) {
            // Round to nearest integer
            element.textContent = Math.round(currentValue);
            requestAnimationFrame(updateFrame);
        } else {
            // Ensure final value is exact
            element.textContent = endValue;
        }
    }

    requestAnimationFrame(updateFrame);
}


function handleLevelCompletion() {
  // Clear timer
  clearTimer();
  
  // Restore from boss level if applicable
  if (currentGame.isBossLevel) {
  restoreFromBossLevel();
  CoinsManager.updateCoins(100).then(() => {
    showBossDefeatEffect();
      // Show victory message
      const victoryMessage = document.createElement('div');
      victoryMessage.className = 'boss-victory-message';
      victoryMessage.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #4CAF50, #2E7D32);
        color: white;
        padding: 2rem;
        border-radius: 20px;
        text-align: center;
        z-index: 1000;
        max-width: 80%;
        box-shadow: 0 0 30px rgba(76, 175, 80, 0.5);
      `;
      
      victoryMessage.innerHTML = `
        <h2 style="font-size: 2rem; margin-bottom: 1rem;">Boss Defeated!</h2>
        <p style="font-size: 1.2rem; margin-bottom: 2rem;">You've earned 100 coins for defeating the boss!</p>
        <div style="display: flex; justify-content: center; gap: 1rem;">
          <button class="continue-button" style="
            background: white;
            color: #2E7D32;
            border: none;
            padding: 1rem 2rem;
            border-radius: 50px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
          ">Continue to Next Set</button>
          <button class="home-button" style="
            background: transparent;
            color: white;
            border: 2px solid white;
            padding: 1rem 2rem;
            border-radius: 50px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
          ">Return Home</button>
        </div>
      `;
      
      // Add to DOM
      document.body.appendChild(victoryMessage);
      
      // Add button handlers
      const continueButton = victoryMessage.querySelector('.continue-button');
      if (continueButton) {
        continueButton.addEventListener('click', () => {
          victoryMessage.remove();
          
          // Unlock next set
          unlockNextSet();
          
          // Move to next set
          const nextSet = gameState.currentSet + 1;
          gameState.currentSet = nextSet;
          gameState.currentLevel = 1;
          
          // Start next set
          startLevel(1);
        });
      }
      
      const homeButton = victoryMessage.querySelector('.home-button');
      if (homeButton) {
        homeButton.addEventListener('click', () => {
          victoryMessage.remove();
          
          // Unlock next set
          unlockNextSet();
          
          // Go to welcome screen
          showScreen('welcome-screen');
        });
      }
    });
    
    return;
  }
  
  // Regular level completion logic
  const levelKey = `${gameState.currentStage}_${gameState.currentSet}_${gameState.currentLevel}`;
  console.log(`Completing level: ${levelKey}`);
  
  const wasCompletedBefore = gameState.perfectLevels.has(levelKey) || gameState.completedLevels.has(levelKey);
  console.log(`Level was previously completed: ${wasCompletedBefore}`);
  
  const isPerfect = currentGame.streakBonus && currentGame.correctAnswers === currentGame.words.length;
  
  if (!wasCompletedBefore && isPerfect) {
    // Award 5 coins for perfect completion of a new level
    const perfectBonus = 5;
    CoinsManager.updateCoins(perfectBonus).then(() => {
      updateLevelProgress(gameState.currentStage, gameState.currentSet, gameState.currentLevel, true, true);
      
      const rect = document.getElementById('question-screen').getBoundingClientRect();
      createParticles(rect.left + rect.width / 2, rect.top + rect.height / 2);
    });
  } else if (!wasCompletedBefore) {
    updateLevelProgress(gameState.currentStage, gameState.currentSet, gameState.currentLevel, true, false);
  }
  
  // Pulse coins and update UI
  pulseCoins(5);
  updatePerkButtons();
  
  // Determine next steps
  const stageData = gameStructure.stages[gameState.currentStage - 1];
  const isLastLevelInSet = gameState.currentLevel === stageData.levelsPerSet;
  const isLastSetInStage = gameState.currentSet === stageData.numSets;
  const userStatus = currentUser ? currentUser.status : "unregistered";
  
  // Check if we completed a set
  if (isLastLevelInSet) {
    // Update game progression by checking set completion
    checkSetCompletion(gameState.currentStage, gameState.currentSet);
    
    if (isLastSetInStage) {
      // Completed the last set in the stage
      if (userStatus === "premium" && gameState.currentStage < 5) {
        // Premium user, not on last stage, go to next stage
        setTimeout(() => {
          gameState.currentStage++;
          gameState.currentSet = 1;
          gameState.currentLevel = 1;
          startLevel(1);
        }, 1500);
      } else {
        // Either not premium, or last stage reached
        setTimeout(() => showScreen("stage-cascade-screen"), 1500);
      }
    } else {
      // Last level in set but not last set in stage
      setTimeout(() => {
        gameState.currentSet++;
        gameState.currentLevel = 1;
        startLevel(1);
      }, 1500);
    }
  } else {
    // Not the last level in set, simply go to next level
    setTimeout(() => {
      gameState.currentLevel++;
      startLevel(gameState.currentLevel);
    }, 1500);
  }
}

function checkSetCompletion(stage, set) {
  // Get total number of levels in the set
  const totalLevels = gameStructure.stages[stage-1].levelsPerSet;
  
  // Check if all levels are completed
  let completedCount = 0;
  for (let i = 1; i <= totalLevels; i++) {
    const levelKey = `${stage}_${set}_${i}`;
    if (gameState.completedLevels.has(levelKey) || gameState.perfectLevels.has(levelKey)) {
      completedCount++;
    }
  }
  
  console.log(`Set ${stage}-${set} completion: ${completedCount}/${totalLevels}`);
  
  // If all levels are completed, unlock next set
  if (completedCount === totalLevels) {
    console.log(`Set ${stage}-${set} is complete. Unlocking next set.`);
    unlockNextSet();
  }
}

function handleProgression(levelKey) {
    const setKey = `${gameState.currentStage}_${gameState.currentSet}`;
    if (!gameState.unlockedLevels[setKey]) {
        gameState.unlockedLevels[setKey] = new Set();
    }
    gameState.unlockedLevels[setKey].add(gameState.currentLevel);

    const currentStageConfig = gameStructure.stages[gameState.currentStage - 1];
    const isLastLevelInSet = gameState.currentLevel === currentStageConfig.levelsPerSet;
    const isLastSetInStage = gameState.currentSet === currentStageConfig.numSets;

    // Handle unlocks
    if (!isLastLevelInSet) {
        gameState.unlockedLevels[setKey].add(gameState.currentLevel + 1);
    } else if (!isLastSetInStage) {
        unlockNextSet();
    } else if (gameState.currentStage < 5) {
        unlockNextStage();
    }

    saveProgress();
    updateAllCoinDisplays();

    // Progress to next level
    setTimeout(() => {
        if (isLastLevelInSet) {
            if (!isLastSetInStage) {
                gameState.currentSet++;
                startLevel(1);
            } else if (gameState.currentStage < 5) {
                gameState.currentStage++;
                gameState.currentSet = 1;
                startLevel(1);
            } else {
                showScreen('stage-screen');
            }
        } else {
            startLevel(gameState.currentLevel + 1);
        }
    }, 1500);
}

function createCompletionParticles() {
    const questionScreen = document.getElementById('question-screen');
    const rect = questionScreen.getBoundingClientRect();
    const viewportX = rect.left + (rect.width / 2);
    const viewportY = rect.top + (rect.height / 2);
    
    for (let i = 0; i < 5; i++) {
        setTimeout(() => createParticles(viewportX, viewportY), i * 300);
    }
}


function activatePerk(perkType, cost) {
    const powerupCooldown = powerupCooldowns.get(perkType) || 0;
    const now = Date.now();
    
    if (now - powerupCooldown < 5000) { // 5-second cooldown
        showNotification('Perk is on cooldown', 'warning');
        return;
    }

    CoinsManager.updateCoins(-cost).then(success => {
        if (success) {
            gameState.perks[perkType]++;
            saveProgress();
            updatePerkButtons();
            
            // Use perk immediately
            usePerk(perkType);
            
            // Set cooldown
            powerupCooldowns.set(perkType, now);
            
            // Show feedback
            showNotification(`${perkType} activated!`, 'success');
        } else {
            showNotification('Not enough coins', 'error');
        }
    }).catch(error => {
        console.error('Perk activation failed:', error);
        showNotification('Failed to activate perk', 'error');
    });
}
  

// Particle background initialization
function initializeParticles(container = document.body) {
    // Ensure container is a valid DOM element
    if (!(container instanceof HTMLElement)) {
        container = document.body;
    }
    
    // Find or create the particle container
    let particleContainer = container.querySelector('.particle-container');
    if (!particleContainer) {
        particleContainer = document.createElement('div');
        particleContainer.classList.add('particle-container');
        container.appendChild(particleContainer);
    }
    
    const characterSet = [
        ...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
        ...'',
        ...''
    ];

    function createLetterParticle() {
        const particle = document.createElement('div');
        particle.classList.add('letter-particle');
        
        particle.textContent = characterSet[Math.floor(Math.random() * characterSet.length)];
        
        const startX = Math.random() * container.clientWidth;
        const startY = Math.random() * container.clientHeight;
        
        const moveX = -100 + Math.random() * 200;
        const moveY = -100 + Math.random() * 200;
        
        const size = 12 + Math.random() * 16;
        const opacity = 0.2 + Math.random() * 0.3;
        const rotate = Math.random() * 180;
        const duration = 8 + Math.random() * 10;
        
        particle.style.cssText = `
            position: absolute;
            left: ${startX}px;
            top: ${startY}px;
            font-size: ${size}px;
            animation: letterFloat ${duration}s ease-in-out forwards;
            --moveX: ${moveX}px;
            --moveY: ${moveY}px;
            --opacity: ${opacity};
            --rotate: ${rotate}deg;
            pointer-events: none;
        `;
        
        particleContainer.appendChild(particle);
        
        setTimeout(() => {
            particleContainer.removeChild(particle);
        }, duration * 1000);
    }
    
    // Initial particles
    for (let i = 0; i < 50; i++) {
        createLetterParticle();
    }
    
    // Continuous particle generation
    const particleInterval = setInterval(createLetterParticle, 1000);
    
    // Optional: store the interval to clear it if needed
    particleContainer.dataset.intervalId = particleInterval;
}

// Modify the existing window.onload
window.onload = async () => {
    await checkExistingSession();
    initializeGame();
    updatePerkButtons();
    
    // Ensure particles on welcome screen
    const welcomeScreen = document.getElementById('welcome-screen');
    initializeParticles(welcomeScreen);
    
    await loadCustomLists();
};

function stopLevelAndGoBack() {
    clearTimer();
    isFrozen = false;
    
    // Reset game state
    currentGame = {
        words: [],
        translations: [],
        currentIndex: 0,
        correctAnswers: 0,
        firstAttempt: true,
        isHebrewToEnglish: false,
        mixed: false,
        speedChallenge: false,
        timeBonus: 0,
        initialTimeRemaining: null,
        streakBonus: true,
        restartsRemaining: null
    };
    
    // Immediately show welcome screen
    showScreen('welcome-screen');
}


function showGameOverOverlay() {
    clearTimer();
    const overlay = document.querySelector('.failure-overlay');
    const title = overlay.querySelector('.failure-title');
    title.textContent = 'Game Over!';
    
    overlay.style.display = 'flex';
    setTimeout(() => {
        overlay.classList.add('show');
    }, 100);
    
    // Set up restart button
    document.querySelector('.restart-button').onclick = () => {
        overlay.classList.remove('show');
        setTimeout(() => {
            overlay.style.display = 'none';
            if (currentGame.isCustomPractice) {
                startCustomLevel(currentGame.practiceState.currentLevel, currentGame.practiceState);
            } else {
                startLevel(gameState.currentLevel);
            }
        }, 1000);
    };
    
    // Set up home button
    document.querySelector('.home-button').onclick = () => {
        overlay.classList.remove('show');
        setTimeout(() => {
            overlay.style.display = 'none';
            showScreen('welcome-screen');
        }, 1000);
    };
}

function updateTimerCircle(timeRemaining, totalTime) {
    const timerProgress = document.querySelector('.timer-progress');
    if (!timerProgress) return;

    const radius = 40;
    const circumference = 2 * Math.PI * radius;
    
    timerProgress.style.strokeDasharray = `${circumference} ${circumference}`;
    
    const percentage = timeRemaining / totalTime;
    const dashoffset = circumference * (1 - percentage);
    timerProgress.style.strokeDashoffset = dashoffset;

    // Add warning state when time is low
    if (timeRemaining <= 10) {
        timerProgress.classList.add('warning');
    } else {
        timerProgress.classList.remove('warning');
    }
}

function handleResetProgress() { 
    if (!isFirstResetAttempt) {
        // Reset game state
        gameState.currentStage = 1;
        gameState.currentSet = 1;
        gameState.currentLevel = 1;
        gameState.coins = 0;
        gameState.unlockedSets = { "1": new Set([1]) };
        gameState.unlockedLevels = { "1_1": new Set([1]) };
        gameState.perfectLevels = new Set();
        gameState.completedLevels = new Set();

        // Clear localStorage
        localStorage.removeItem('simploxProgress');
        localStorage.removeItem('simploxCustomCoins');
        
        // Update UI
        updatePerkButtons();
        updateAllCoinDisplays();
        showScreen('welcome-screen');
        
        // Reset the first attempt flag
        isFirstResetAttempt = true;
        return;
    }

    // First attempt - show warning
    const resetButton = document.querySelector('.reset-button');
    resetButton.classList.add('warning');
    isFirstResetAttempt = false;

    // Clear warning after animation
    setTimeout(() => {
        resetButton.classList.remove('warning');
    }, 1000);

    // Reset the attempt after 10 seconds
    if (resetProgressTimeout) {
        clearTimeout(resetProgressTimeout);
    }
    
    resetProgressTimeout = setTimeout(() => {
        isFirstResetAttempt = true;
    }, 10000);
}

function toggleFullScreen() {
    const button = document.querySelector('.fullscreen-button i');
    
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen()
            .then(() => {
                button.classList.remove('fa-expand');
                button.classList.add('fa-compress');
            })
            .catch(err => {
                console.log(`Error attempting to enable fullscreen: ${err.message}`);
            });
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen()
                .then(() => {
                    button.classList.remove('fa-compress');
                    button.classList.add('fa-expand');
                })
                .catch(err => {
                    console.log(`Error attempting to exit fullscreen: ${err.message}`);
                });
        }
    }
}

async function handleLogout() {
    try {
        const { error } = await supabaseClient.auth.signOut();
        
        if (error) {
            console.error('Supabase logout error:', error.message);
        }

        currentUser = null;
        updateAuthUI();
        showScreen('welcome-screen');
        
        // Reload game progress from localStorage
        initializeGame();

    } catch (error) {
        console.error('Unexpected error during logout:', error);
    }
}


function handleRestartLevel() {
    // If no restarts remaining, ignore the click entirely
    if (currentGame.restartsRemaining <= 0) {
        return;
    }
    
    const restartButton = document.querySelector('.navigation-button.restart-level');
    
    // Update the restarts counter
    currentGame.restartsRemaining--;
    
    // Show visual feedback of remaining restarts
    if (currentGame.restartsRemaining === 1) {
        restartButton.style.opacity = '0.7';
    } else if (currentGame.restartsRemaining === 0) {
        restartButton.classList.add('disabled');
        
        // Remove the click handler when out of restarts
        restartButton.onclick = null;
        // Additional safety: explicitly disable the button
        restartButton.disabled = true;
    }
    
    // Restore initial state
    gameState.coins = currentGame.startingCoins;
    gameState.perks = { ...currentGame.startingPerks };
    
    // Update UI
    updatePerkButtons();
    updateAllCoinDisplays();
    
    // Save current state
    saveProgress();
    
    // Restart the level
    startLevel(gameState.currentLevel);
}

function showStagesFromMenu() {
    showScreen('stage-screen');
}

function findFurthestProgression() {
    // Check for saved game context first
    const savedContext = localStorage.getItem("gameContext");
    if (savedContext) {
        try {
            const context = JSON.parse(savedContext);
            if (context.stage && context.set && context.level) {
                console.log("Resuming from saved context:", context);
                return {
                    stage: context.stage,
                    set: context.set,
                    level: context.level
                };
            }
        } catch (e) {
            console.error("Error parsing saved context:", e);
        }
    }

    // Check for preferred stage
    const preferredStage = parseInt(localStorage.getItem("preferredStage"));
    
    // Debug logging
    console.log("Finding furthest progression");
    console.log("Current unlocked sets:", gameState.unlockedSets);
    console.log("Current unlocked levels:", gameState.unlockedLevels);
    console.log("Completed levels:", Array.from(gameState.completedLevels));
    console.log("Perfect levels:", Array.from(gameState.perfectLevels));

    // We'll track the furthest level found
    let furthestLevel = null;
    let highestRank = -1;

    // Helper to check if a level is unlocked but not completed
    const isUnlockedNotCompleted = (stage, set, level) => {
        const levelKey = `${stage}_${set}_${level}`;
        const setKey = `${stage}_${set}`;
        
        // Check if the level is unlocked
        const isUnlocked = gameState.unlockedLevels[setKey]?.has(level);
        
        // Check if the level is not yet completed
        const isNotCompleted = !gameState.completedLevels.has(levelKey) && 
                              !gameState.perfectLevels.has(levelKey);
                              
        return isUnlocked && isNotCompleted;
    };

    // Helper to calculate a rank score for a level (higher = further progression)
    const calculateRank = (stage, set, level) => {
        return 10000 * stage + 100 * set + level;
    };

    // First check preferred stage if set
    if (preferredStage && preferredStage >= 1 && preferredStage <= 5) {
        console.log(`Checking preferred stage: ${preferredStage}`);
        
        // Go through all possible sets in this stage
        for (let set = 1; set <= gameStructure.stages[preferredStage-1].numSets; set++) {
            const setKey = `${preferredStage}_${set}`;
            
            // Skip if no unlocked levels for this set
            if (!gameState.unlockedLevels[setKey]) continue;
            
            // Sort levels in descending order (highest first)
            const levels = Array.from(gameState.unlockedLevels[setKey]).sort((a, b) => b - a);
            
            console.log(`Checking set ${setKey}, unlocked levels:`, levels);
            
            // Check each level for this set
            for (let level of levels) {
                if (isUnlockedNotCompleted(preferredStage, set, level)) {
                    const rank = calculateRank(preferredStage, set, level);
                    if (rank > highestRank) {
                        highestRank = rank;
                        furthestLevel = {
                            stage: preferredStage,
                            set: set,
                            level: level
                        };
                        console.log(`Found candidate in preferred stage: ${preferredStage}-${set}-${level}`);
                    }
                }
            }
        }
    }

    // If we didn't find a level in the preferred stage, check all stages
    if (!furthestLevel) {
        // Check each stage
        for (let stage = 1; stage <= 5; stage++) {
            // Skip if no unlocked sets for this stage
            if (!gameState.unlockedSets[stage]) continue;
            
            // Get all unlocked sets for this stage, sorted in descending order
            const sets = Array.from(gameState.unlockedSets[stage]).sort((a, b) => b - a);
            
            for (let set of sets) {
                const setKey = `${stage}_${set}`;
                
                // Skip if no unlocked levels for this set
                if (!gameState.unlockedLevels[setKey]) continue;
                
                // Get all unlocked levels for this set, sorted in descending order
                const levels = Array.from(gameState.unlockedLevels[setKey]).sort((a, b) => b - a);
                
                for (let level of levels) {
                    if (isUnlockedNotCompleted(stage, set, level)) {
                        const rank = calculateRank(stage, set, level);
                        if (rank > highestRank) {
                            highestRank = rank;
                            furthestLevel = {
                                stage: stage,
                                set: set,
                                level: level
                            };
                            console.log(`Found candidate: ${stage}-${set}-${level}`);
                        }
                    }
                }
            }
        }
    }

    // If we found a furthest level, return it
    if (furthestLevel) {
        console.log("Found furthest progress:", furthestLevel);
        return furthestLevel;
    }

    // If no furthest level found but preferred stage is set, return that stage's first level
    if (preferredStage && preferredStage >= 1 && preferredStage <= 5) {
        return {
            stage: preferredStage,
            set: 1,
            level: 1
        };
    }

    // Default to the very beginning
    return {
        stage: 1,
        set: 1,
        level: 1
    };
}

function startGame() {
    console.log("Starting game");
    
    if (!hasExistingProgress()) {
        console.log("No existing progress found, showing grade selector");
        showGradeLevelSelector();
        return;
    }
    
    // Check for saved game context first
    const savedContext = localStorage.getItem("gameContext");
    if (savedContext) {
        try {
            const context = JSON.parse(savedContext);
            if (context.stage && context.set && context.level) {
                console.log("Found saved game context:", context);
                
                // Use context data for current level
                gameState.currentStage = context.stage;
                gameState.currentSet = context.set;
                gameState.currentLevel = context.level;
                
                startLevel(gameState.currentLevel);
                return;
            }
        } catch (e) {
            console.error("Error parsing game context:", e);
        }
    }
    
    // If no context, use current game state
    console.log("Using current game state:", {
        stage: gameState.currentStage,
        set: gameState.currentSet,
        level: gameState.currentLevel
    });
    
    startLevel(gameState.currentLevel);
}

function updateLevelProgress(stage, set, level, completed, perfect) {
    // Create a key to reference this specific level
    const levelKey = `${stage}_${set}_${level}`;
    
    // Update completion state
    if (perfect) {
        gameState.perfectLevels.add(levelKey);
        gameState.completedLevels.add(levelKey);  // Perfect levels are also completed
    } else if (completed) {
        gameState.completedLevels.add(levelKey);
    }
    
    // Ensure level is unlocked
    const setKey = `${stage}_${set}`;
    if (!gameState.unlockedLevels[setKey]) {
        gameState.unlockedLevels[setKey] = new Set();
    }
    gameState.unlockedLevels[setKey].add(level);
    
    // Unlock next level if not already unlocked
    const nextLevel = level + 1;
    const isLastLevelInSet = level === gameStructure.stages[stage-1].levelsPerSet;
    
    if (!isLastLevelInSet) {
        gameState.unlockedLevels[setKey].add(nextLevel);
        console.log(`Unlocked next level: ${nextLevel} in set ${setKey}`);
    }
    
    // Check if set is now complete
    if (isLastLevelInSet && completed) {
        checkSetCompletion(stage, set);
    }
    
    // Save progress
    saveProgress();
}

function checkSetCompletion(stage, set) {
    // Get total number of levels in the set
    const totalLevels = gameStructure.stages[stage-1].levelsPerSet;
    
    // Check if all levels are completed
    let completedCount = 0;
    for (let i = 1; i <= totalLevels; i++) {
        const levelKey = `${stage}_${set}_${i}`;
        if (gameState.completedLevels.has(levelKey) || gameState.perfectLevels.has(levelKey)) {
            completedCount++;
        }
    }
    
    console.log(`Set ${stage}-${set} completion: ${completedCount}/${totalLevels}`);
    
    // If all levels are completed, unlock next set
    if (completedCount === totalLevels) {
        console.log(`Set ${stage}-${set} is complete. Unlocking next set.`);
        unlockNextSet();
    }
}

function unlockNextSet() {
  const currentStage = gameState.currentStage;
  const currentSet = gameState.currentSet;
  
  // Get stage structure to check max sets
  const stageStructure = gameStructure.stages[currentStage-1];
  if (!stageStructure) {
    console.error(`Invalid stage: ${currentStage}`);
    return;
  }
  
  // Check if we're not already at the last set
  if (currentSet < stageStructure.numSets) {
    const nextSet = currentSet + 1;
    
    // Ensure the stage is in unlockedSets
    if (!gameState.unlockedSets[currentStage]) {
      gameState.unlockedSets[currentStage] = new Set();
    }
    
    // Add the next set
    gameState.unlockedSets[currentStage].add(nextSet);
    
    // Also unlock the first level of the next set
    const nextSetKey = `${currentStage}_${nextSet}`;
    if (!gameState.unlockedLevels[nextSetKey]) {
      gameState.unlockedLevels[nextSetKey] = new Set();
    }
    gameState.unlockedLevels[nextSetKey].add(1);
    
    console.log(`Unlocked set ${currentStage}-${nextSet} and its first level`);
    
    // Save the updated progress
    saveProgress();
  } else if (currentStage < 5) {
    // Unlock the first set of the next stage
    unlockNextStage();
  }
}

function unlockNextStage() {
  const currentStage = gameState.currentStage;
  
  // Make sure we're not at the last stage
  if (currentStage < 5) {
    const nextStage = currentStage + 1;
    
    // Ensure the next stage exists in unlockedSets
    if (!gameState.unlockedSets[nextStage]) {
      gameState.unlockedSets[nextStage] = new Set();
    }
    
    // Unlock the first set of the next stage
    gameState.unlockedSets[nextStage].add(1);
    
    // Also unlock the first level of the first set
    const nextSetKey = `${nextStage}_1`;
    if (!gameState.unlockedLevels[nextSetKey]) {
      gameState.unlockedLevels[nextSetKey] = new Set();
    }
    gameState.unlockedLevels[nextSetKey].add(1);
    
    console.log(`Unlocked stage ${nextStage}, set 1, level 1`);
    
    // Save the updated progress
    saveProgress();
  }
}

function showLevelIntro(level, callback) {
  // If it's a custom practice, just call the callback
  if (currentGame.isCustomPractice) {
    callback();
    return;
  }

  const overlay = document.createElement('div');
  overlay.className = 'slide-transition';
  
  // Check if it's a test level, boss level, etc.
  const isTestLevel = [3, 6, 9, 10, 13, 16, 19, 20].includes(level);
  const isBossLevel = level === 21;
  
  let levelClass = 'normal-level';
  if (isTestLevel) levelClass = 'test-level';
  if (isBossLevel) levelClass = 'boss-level';
  
  overlay.innerHTML = `
    <div class="slide-panel-left"></div>
    <div class="slide-panel-right"></div>
    <div class="level-announcement ${levelClass}">
      <h1>${isBossLevel ? 'BOSS FIGHT!' : `Stage ${gameState.currentStage}`}</h1>
      <h2>${isBossLevel ? 'FINAL CHALLENGE' : `Level ${gameState.currentSet}-${level}`}</h2>
      ${isTestLevel ? '<div class="test-badge">Review Challenge</div>' : ''}
      ${isBossLevel ? '<div class="boss-badge">DANGER ZONE</div>' : ''}
    </div>
  `;
  
  document.body.appendChild(overlay);
  
  const announcement = overlay.querySelector('.level-announcement');
  
  // Force a reflow before adding the show class
  overlay.offsetHeight;
  
  overlay.classList.add('show');
  announcement.classList.add('show');
  
  // Special boss styling
  if (isBossLevel) {
    const bossAnnouncement = overlay.querySelector('.level-announcement');
    if (bossAnnouncement) {
      bossAnnouncement.style.background = 'linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%)';
      bossAnnouncement.style.boxShadow = '0 0 30px rgba(255, 0, 0, 0.5)';
      
      const bossTitle = bossAnnouncement.querySelector('h1');
      if (bossTitle) {
        bossTitle.style.color = '#ffffff';
        bossTitle.style.textShadow = '0 0 20px rgba(255, 0, 0, 0.8)';
      }
    }
  }
  
  setTimeout(() => {
    callback();
    overlay.classList.remove('show');
    announcement.classList.remove('show');
    
    setTimeout(() => {
      document.body.removeChild(overlay);
    }, 400);
  }, 1500);
}

const customPracticeLists = {
    lists: [],
    currentList: null,
    maxLists: 5
};


// Function to add a new word list
function addCustomWordList(name = null) {
    // Check if we've reached the maximum number of lists
    if (customPracticeLists.lists.length >= customPracticeLists.maxLists) {
        alert(`You can only create up to ${customPracticeLists.maxLists} custom lists.`);
        return null;
    }

    // Generate a default name if not provided
    if (!name) {
        name = `List ${customPracticeLists.lists.length + 1}`;
    }

    const newList = {
        id: Date.now(),
        name: name,
        words: [],
        translations: []
    };

    customPracticeLists.lists.push(newList);
    saveCustomLists();
    return newList;
}


// Function to translate a single word using MyMemory Translation API
function translateWord(word) {
    const apiUrl = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(word)}&langpair=en|he`;
    
    return fetch(apiUrl)
        .then(response => response.json())
        .then(data => {
            // Extract translation, fallback to original word if translation fails
            return data.responseData.translatedText || word;
        })
        .catch(() => word);
}

function trackListPlay(listId) {
    const playCountKey = `listPlays_${listId}`;
    let plays = parseInt(localStorage.getItem(playCountKey) || '0');
    plays++;
    
    const limits = getUserListLimits();
    localStorage.setItem(playCountKey, plays);

    if (plays >= limits.maxPlays) {
        // Remove list if max plays reached
        deleteCustomList(listId);
        return false;
    }
    
    return limits.maxPlays - plays;
}





function toggleAuthMode() {
    const loginForm = document.getElementById('loginForm');
    const signupForm = document.getElementById('signupForm');
    
    loginForm.classList.toggle('hidden');
    signupForm.classList.toggle('hidden');
}


function updateLocalSharedLists(sharedList) {
    // Add the shared list to the recipient's local lists
    if (currentUser) {
        customPracticeLists.lists.push({
            id: sharedList.local_id,
            supabaseId: sharedList.id,
            name: sharedList.name,
            words: sharedList.words,
            translations: sharedList.translations,
            is_shared: true,
            shared_by: sharedList.shared_by
        });
        
        // Save to local storage or sync
        saveCustomLists();
    }
}

// ADD this fallback function to try alternative sharing approaches
async function debugShareList(listId, recipientId) {
    try {
        console.log("Debug share function called with:", { listId, recipientId });
        
        // Find the list
        const list = CustomListsManager.lists.find(l => String(l.id) === String(listId));
        if (!list) {
            console.error("List not found for debug sharing");
            return false;
        }
        
        // Try direct table access with minimal fields
        const { data, error } = await supabaseClient
            .from('custom_lists')
            .insert({
                user_id: recipientId,
                name: "Shared list", 
                words: ["test"],
                translations: ["test"],
                is_shared: true
            });
            
        if (error) {
            console.error("Debug share error:", error);
            
            // Check what tables are available
            const { data: tables, error: tablesError } = await supabaseClient
                .from('information_schema.tables')
                .select('table_name')
                .eq('table_schema', 'public');
                
            if (tablesError) {
                console.error("Error fetching tables:", tablesError);
            } else {
                console.log("Available tables:", tables);
            }
            
            return false;
        }
        
        console.log("Debug share success:", data);
        return true;
    } catch (error) {
        console.error("Debug share exception:", error);
        return false;
    }
}

async function shareListWithUser(listId, recipientId) {
    try {
        console.log("Sharing list:", listId, "with user:", recipientId);
        
        if (!currentUser) {
            console.error("No current user - cannot share list");
            return false;
        }
        
        // Find the list in CustomListsManager
        const list = CustomListsManager.lists.find(l => String(l.id) === String(listId));
        
        if (!list) {
            console.error("List not found for sharing:", listId);
            return false;
        }
        
        console.log("Found list to share:", list.name);
        
        // Direct insert into custom_lists table
        const { data, error } = await supabaseClient
            .from('custom_lists')
            .insert({
                user_id: recipientId,
                name: `${list.name} (Shared by ${currentUser.user_metadata?.username || "User"})`,
                words: list.words || [],
                translations: list.translations || [],
                is_shared: true,
                shared_with: [recipientId],
                shared_by: currentUser.id,
                created_at: new Date().toISOString(),
                status: 'active'
            });
        
        if (error) {
            console.error("Error sharing list:", error);
            return false;
        }
        
        console.log("List shared successfully");
        showNotification("List shared successfully!", "success");
        closeShareModal();
        return true;
    } catch (error) {
        console.error("Error in shareListWithUser:", error);
        showNotification("Error sharing list", "error");
        return false;
    }
}

function showSuccessToast(message) {
    const toast = document.createElement('div');
    toast.className = 'toast success';
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
        toast.classList.add('hide');
        setTimeout(() => document.body.removeChild(toast), 600);
    }, 3000);
}

function showErrorToast(message) {
    const toast = document.createElement('div');
    toast.className = 'toast error';
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
        toast.classList.add('hide');
        setTimeout(() => document.body.removeChild(toast), 600);
    }, 3000);
}

function closeShareModal() {
    const modal = document.querySelector('.share-modal');
    const backdrop = document.querySelector('.modal-backdrop');
    
    if (modal) modal.remove();
    if (backdrop) backdrop.remove();
}

async function loadSharedLists() {
    if (!currentUser) return [];

    const { data, error } = await supabaseClient
        .from('custom_lists')
        .select('*')
        .or(`shared_with.cs.{${currentUser.id}},is_shared.eq.true`);

    if (error) {
        console.error('Error loading shared lists:', error);
        return [];
    }

    return data.map(list => ({
        ...list,
        isShared: true
    }));
}

// REPLACE the showShareModal function
function showShareModal(listId) {
    console.log("Opening share modal for list:", listId);
    
    // Remove any existing modals
    const existingModal = document.querySelector('.share-modal');
    const existingBackdrop = document.querySelector('.modal-backdrop');
    if (existingModal) existingModal.remove();
    if (existingBackdrop) existingBackdrop.remove();
    
    // Create modal backdrop
    const backdrop = document.createElement('div');
    backdrop.className = 'modal-backdrop';
    backdrop.onclick = closeShareModal;
    document.body.appendChild(backdrop);
    
    // Create share modal
    const modal = document.createElement('div');
    modal.className = 'share-modal';
    modal.innerHTML = `
        <h3 class="share-modal-header">Share List</h3>
        <div class="users-list">Loading users...</div>
        <button class="start-button modal-close" onclick="closeShareModal()">Cancel</button>
    `;
    document.body.appendChild(modal);
    
    // Now we know the modal and users-list are in the DOM
    const usersList = modal.querySelector('.users-list');
    
    // Fetch users
    supabaseClient.from("user_profiles")
        .select("id, username")
        .neq("id", currentUser.id)
        .then(({ data, error }) => {
            if (error) {
                console.error("Error fetching users:", error);
                usersList.innerHTML = '<div class="user-item"><span>Error loading users</span></div>';
                return;
            }
            
            if (!data || data.length === 0) {
                usersList.innerHTML = '<div class="user-item"><span>No other users available</span></div>';
                return;
            }
            
            usersList.innerHTML = data.map(user => `
                <div class="user-item">
                    <span>${user.username || "Unnamed User"}</span>
                    <button class="main-button small-button share-with-user-btn" data-user-id="${user.id}">
    <i class="fas fa-share-alt"></i> Share
</button>
                </div>
            `).join("");
            
            // Add click handlers to share buttons
            modal.querySelectorAll('.share-with-user-btn').forEach(btn => {
                btn.onclick = async () => {
                    const userId = btn.getAttribute('data-user-id');
                    btn.disabled = true;
                    const originalText = btn.innerHTML;
                    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Sharing...';
                    
                    const success = await shareListWithUser(listId, userId);
                    
                    if (!success) {
                        btn.disabled = false;
                        btn.innerHTML = originalText;
                    }
                };
            });
        });
}

// ADD this function to close the share modal
function closeShareModal() {
    const modal = document.querySelector('.share-modal');
    const backdrop = document.querySelector('.modal-backdrop');
    
    if (modal) modal.remove();
    if (backdrop) backdrop.remove();
}


function handleProgressionAfterCompletion(isLevelCompleted) {
    if (!isLevelCompleted && currentGame.streakBonus) {
        // Award completion bonus
        gameState.coins += 5;
        pulseCoins(5);
        
        // Handle level unlocks and progression
        const setKey = `${gameState.currentStage}_${gameState.currentSet}`;
        if (!gameState.unlockedLevels[setKey]) {
            gameState.unlockedLevels[setKey] = new Set();
        }
        gameState.unlockedLevels[setKey].add(gameState.currentLevel);

        const currentStageConfig = gameStructure.stages[gameState.currentStage - 1];
        const isLastLevelInSet = gameState.currentLevel === currentStageConfig.levelsPerSet;
        const isLastSetInStage = gameState.currentSet === currentStageConfig.numSets;

        if (!isLastLevelInSet) {
            startLevel(gameState.currentLevel + 1);
        } else if (!isLastSetInStage) {
            gameState.currentSet++;
            startLevel(1);
        } else {
            showScreen('stage-screen');
        }
        
        saveProgress();
    } else {
        startLevel(gameState.currentLevel);
    }
}



function hideUpgradePrompt() {
    const prompt = document.querySelector('.upgrade-prompt');
    if (prompt) {
        prompt.classList.remove('show');
        setTimeout(() => prompt.remove(), 300);
    }
}



function showUpgradePrompt(callback) {
    // Store the current screen and level info
    const gameContext = {
        screen: document.querySelector('.screen.visible')?.id,
        stage: gameState.currentStage,
        set: gameState.currentSet,
        level: gameState.currentLevel
    };
    
    if (gameContext.screen) {
        localStorage.setItem('gameContext', JSON.stringify(gameContext));
    }

    if (!currentUser) {
        showUnregisteredWarning(() => {
            if (callback) callback();
        });
    } else if (!checkUpgradeStatus()) {
        showUpgradeScreen();
    } else {
        // Already requested upgrade, continue with game
        if (callback) callback();
    }
}

function hideUpgradePromptAndContinue() {
    // Hide upgrade screen
    const upgradeScreen = document.getElementById('upgrade-screen');
    if (upgradeScreen) {
        upgradeScreen.classList.remove('visible');
    }
    
    // Reset any frozen state
    isFrozen = false;
    clearTimer();
    
    // Continue to the next level using the current level as reference
    if (gameState.currentLevel) {
        proceedWithLevel(gameState.currentLevel);
    } else {
        showScreen('welcome-screen');
    }
}

function handleUpgradeClick() {
    hideUpgradePrompt();
    showPaymentScreen();
}


async function checkUserAccess() {
    if (!currentUser) {
        return {
            fullAccess: false,
            unlockedStages: {
                1: [1],     // Only set 1 of stage 1
                2: [1],     // Only set 1 of stage 2
                3: [1],     // Only set 1 of stage 3
                4: [1],     // Only set 1 of stage 4
                5: [1]      // Only set 1 of stage 5
            },
            defaultUnlockedLevels: {
                1: true,    // Level 1 always unlocked in set 1
            }
        };
    }

    // Check user access level
    const { data, error } = await supabaseClient
        .from('user_profiles')
        .select('status, payment_pending')
        .eq('id', currentUser.id)
        .single();

    if (error) return null;

    // Free/Pending/Unregistered users
    if (data.payment_pending || data.status === 'free' || data.status === 'pending') {
        return {
            fullAccess: false,
            unlockedStages: {
                1: [1],     // Only set 1 of stage 1
                2: [1],     // Only set 1 of stage 2
                3: [1],     // Only set 1 of stage 3
                4: [1],     // Only set 1 of stage 4
                5: [1]      // Only set 1 of stage 5
            },
            defaultUnlockedLevels: {
                1: true,    // Level 1 always unlocked in set 1
            }
        };
    }

    // Premium users
    if (data.status === 'premium') {
        return {
            fullAccess: true,
            unlockedStages: {
                1: [1],     // Only set 1 initially unlocked
                2: [1],     // Only set 1 initially unlocked
                3: [1],     // Only set 1 initially unlocked
                4: [1],     // Only set 1 initially unlocked
                5: [1]      // Only set 1 initially unlocked
            },
            defaultUnlockedLevels: {
                1: true,    // Level 1 always unlocked in set 1
            }
        };
    }
}

function toggleAuthMode() {
    const loginForm = document.getElementById('loginForm');
    const signupForm = document.getElementById('signupForm');
    
    loginForm.classList.toggle('hidden');
    signupForm.classList.toggle('hidden');
}

// REPLACE this function
function showSetScreen(stageId) {
    // This function now redirects to the cascade screen
    gameState.currentStage = stageId;
    showStageCascadeScreen();
    
    // Automatically open the selected stage
    setTimeout(() => {
        const stageWrapper = document.querySelector(`.stage-wrapper[data-stage="${stageId}"]`);
        if (stageWrapper && !stageWrapper.classList.contains('open')) {
            stageWrapper.classList.add('open');
        }
    }, 100);
}

function showUnregisteredWarning(callback) {
    // Prevent multiple popups in the same page load
    if (window.unregisteredWarningShown) {
        if (callback) callback();
        return;
    }

    // Mark that the warning has been shown
    window.unregisteredWarningShown = true;

    // Create full-screen signup page
    const fullscreenPrompt = document.createElement('div');
    fullscreenPrompt.className = 'fullscreen-signup-page';
    fullscreenPrompt.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--gradient);
        z-index: 2000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
        padding: 2rem;
        animation: fadeIn 0.3s ease-in-out;
    `;

    // Create content container
    fullscreenPrompt.innerHTML = `
        <div class="signup-header" style="width: 100%; display: flex; justify-content: flex-start; margin-bottom: 2rem;">
            <button class="skip-signup-button" style="
                background: rgba(255,255,255,0.15);
                border: none;
                color: var(--text);
                padding: 0.75rem 1.5rem;
                border-radius: 50px;
                font-size: 0.9rem;
                cursor: pointer;
                transition: all 0.3s ease;
            ">
                Skip
            </button>
        </div>
        
        <div class="signup-content" style="
            text-align: center;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            max-width: 600px;
            width: 100%;
        ">
            <h2 style="
                font-size: 2rem;
                color: var(--gold);
                margin-bottom: 1.5rem;
                animation: floatAnimation 3s ease-in-out infinite;
            ">Save Your Progress!</h2>
            
            <p style="
                font-size: 1.2rem;
                line-height: 1.6;
                margin-bottom: 2rem;
                color: var(--text);
            ">Create a free account to track your vocabulary progress, earn rewards, and unlock more advanced content</p>
            
            <div class="features-list" style="
                display: flex;
                flex-direction: column;
                gap: 1rem;
                margin-bottom: 3rem;
                text-align: left;
            ">
                <div class="feature-item" style="
                    display: flex;
                    align-items: center;
                    gap: 1rem;
                ">
                    <i class="fas fa-check-circle" style="color: var(--gold); font-size: 1.5rem;"></i>
                    <span>Track your learning progress</span>
                </div>
                <div class="feature-item" style="
                    display: flex;
                    align-items: center;
                    gap: 1rem;
                ">
                    <i class="fas fa-check-circle" style="color: var(--gold); font-size: 1.5rem;"></i>
                    <span>Practice custom word lists</span>
                </div>
                <div class="feature-item" style="
                    display: flex;
                    align-items: center;
                    gap: 1rem;
                ">
                    <i class="fas fa-check-circle" style="color: var(--gold); font-size: 1.5rem;"></i>
                    <span>Earn coins for premium content</span>
                </div>
            </div>
        </div>
        
        <div class="signup-footer" style="
            width: 100%;
            display: flex;
            justify-content: center;
            padding-bottom: 2rem;
        ">
            <button class="signup-now-button" style="
                background: var(--gold);
                color: var(--primary-dark);
                border: none;
                padding: 1.25rem 3rem;
                border-radius: 50px;
                font-size: 1.2rem;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s ease;
                box-shadow: 0 10px 20px rgba(255, 215, 0, 0.2);
                animation: pulseAnimation 1.5s infinite ease-in-out;
            ">
                Sign Up Now
            </button>
        </div>
    `;

    // Add to body
    document.body.appendChild(fullscreenPrompt);
    
    // Add animations CSS
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes floatAnimation {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        @keyframes pulseAnimation {
            0%, 100% { transform: scale(1); box-shadow: 0 10px 20px rgba(255, 215, 0, 0.2); }
            50% { transform: scale(1.05); box-shadow: 0 10px 30px rgba(255, 215, 0, 0.4); }
        }
    `;
    document.head.appendChild(styleElement);

    // Add event listeners
    const skipButton = fullscreenPrompt.querySelector('.skip-signup-button');
    const signupButton = fullscreenPrompt.querySelector('.signup-now-button');
    
    skipButton.addEventListener('click', function() {
        // Remove the prompt
        document.body.removeChild(fullscreenPrompt);
        if (styleElement.parentNode) {
            styleElement.parentNode.removeChild(styleElement);
        }
        
        // Execute callback to continue game
        if (callback) {
            callback();
        }
    });
    
    signupButton.addEventListener('click', function() {
        // Remove the prompt
        document.body.removeChild(fullscreenPrompt);
        if (styleElement.parentNode) {
            styleElement.parentNode.removeChild(styleElement);
        }
        
        // First, make sure we're on welcome screen since auth modal works best there
        showScreen('welcome-screen');
        
        // Show the auth modal with signup form
        setTimeout(function() {
            const authModal = document.getElementById('authModal');
            if (authModal) {
                authModal.classList.add('show');
                
                // Switch to signup form
                const signupForm = document.getElementById('signupForm');
                const loginForm = document.getElementById('loginForm');
                if (signupForm && loginForm) {
                    signupForm.classList.remove('hidden');
                    loginForm.classList.add('hidden');
                }
            }
        }, 100); // Short delay to ensure welcome screen is visible first
    });
}



function toggleParentPhone() {
    const isAdult = document.getElementById('isAdult').checked;
    const parentPhoneGroup = document.getElementById('parentPhoneGroup');
    const parentPhoneInput = document.getElementById('parentPhone');
    
    parentPhoneGroup.style.display = isAdult ? 'none' : 'block';
    parentPhoneInput.required = !isAdult;
}

function showUpgradeScreen() {
    // Check if user already submitted upgrade request
    if (localStorage.getItem(`upgradeRequested_${currentUser.id}`)) {
        hideUpgradePromptAndContinue();
        return;
    }
    
    showScreen('upgrade-screen');
}

class RateLimiter {
    constructor(maxRequests = 100, timeWindow = 60000) {
        this.requests = new Map();
    }
    
    checkLimit(userId) {
        const now = Date.now();
        const userRequests = this.requests.get(userId) || [];
        const recentRequests = userRequests.filter(time => now - time < this.timeWindow);
        
        if (recentRequests.length >= this.maxRequests) {
            return false;
        }
        
        recentRequests.push(now);
        this.requests.set(userId, recentRequests);
        return true;
    }
}

function sanitizeInput(input) {
    return input
        .replace(/[<>]/g, '') // Remove potential HTML
        .trim()
        .slice(0, 500); // Reasonable length limit
}


const SessionManager = {
    maxInactiveTime: 30 * 60 * 1000, // 30 minutes
    lastActivity: Date.now(),
    
    init() {
        document.addEventListener('click', () => this.updateActivity());
        document.addEventListener('keypress', () => this.updateActivity());
        setInterval(() => this.checkSession(), 60000);
    },
    
    updateActivity() {
        this.lastActivity = Date.now();
    },
    
    async checkSession() {
        if (Date.now() - this.lastActivity > this.maxInactiveTime) {
            await handleLogout();
            modalSystem.show('timeout', {
                title: "Session Expired",
                message: "Please log in again"
            });
        }
    }
};

const DataValidator = {
    validateGameProgress(progress) {
        const maxAllowedCoins = 100000;
        const maxAllowedPerks = 100;
        
        return {
            ...progress,
            coins: Math.min(progress.coins, maxAllowedCoins),
            perks: Object.fromEntries(
                Object.entries(progress.perks).map(([key, value]) => 
                    [key, Math.min(value, maxAllowedPerks)]
                )
            )
        };
    },
    
    validateCustomList(list) {
        return {
            ...list,
            words: list.words.slice(0, 1000).map(sanitizeInput),
            translations: list.translations.slice(0, 1000).map(sanitizeInput)
        };
    }
};

function escapeHTML(str) {
    return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}

function createListItem(list) {
    return `
        <div class="list-item">
            <h3>${escapeHTML(list.name)}</h3>
            <p>${escapeHTML(list.description)}</p>
        </div>
    `;
}

const ErrorHandler = {
    async logError(error, context) {
        if (currentUser) {
            await supabaseClient
                .from('error_logs')
                .insert([{
                    user_id: currentUser.id,
                    error: error.message,
                    stack: error.stack,
                    context,
                    timestamp: new Date()
                }]);
        }
        console.error(`${context}:`, error);
    },
    
    handleError(error, context) {
        this.logError(error, context);
        modalSystem.show('error', {
            title: "Oops!",
            message: "Something went wrong. Please try again."
        });
    }
};

function toggleParentFields() {
    const isAdult = document.getElementById('isAdult').checked;
    const parentSection = document.getElementById('parentInfoSection');
    const adultSection = document.getElementById('adultInfoSection');
    
    // Get input elements
    const parentInputs = parentSection.querySelectorAll('input');
    const adultInputs = adultSection.querySelectorAll('input');
    
    if (isAdult) {
        parentSection.style.display = 'none';
        adultSection.style.display = 'block';
        
        // Toggle required attributes
        parentInputs.forEach(input => input.required = false);
        adultInputs.forEach(input => input.required = true);
    } else {
        parentSection.style.display = 'block';
        adultSection.style.display = 'none';
        
        // Toggle required attributes
        parentInputs.forEach(input => input.required = true);
        adultInputs.forEach(input => input.required = false);
    }
}

async function handleUpgradeSubmit(event) {
    event.preventDefault();
    const isAdult = document.getElementById('isAdult').checked;
    
    try {
        // First get user profile details
        const { data: userProfile } = await supabaseClient
            .from('user_profiles')
            .select('username, created_at')
            .eq('id', currentUser.id)
            .single();

        let formData = {
            user_id: currentUser.id,
            is_adult: isAdult,
            full_name: isAdult ? document.getElementById('fullName').value : document.getElementById('parentName').value,
            phone: isAdult ? document.getElementById('phone').value : document.getElementById('parentPhone').value,
            parent_name: !isAdult ? document.getElementById('parentName').value : null,
            parent_phone: !isAdult ? document.getElementById('parentPhone').value : null,
            referral_source: document.getElementById('referralSource').value
        };

        if (!validateForm(isAdult)) {
            alert('Please fill in all required fields');
            return;
        }

        const { data, error } = await supabaseClient
            .from('upgrade_requests')
            .insert([formData])
            .select();

        if (error) throw error;

        // Update user profile status to pending
        const { error: profileError } = await supabaseClient
            .from('user_profiles')
            .update({ status: 'pending' })
            .eq('id', currentUser.id);

        if (profileError) throw profileError;

        // Store in localStorage to prevent repeated prompts
        localStorage.setItem(`upgradeRequested_${currentUser.id}`, 'true');

        // Show confirmation popup
        const popup = document.createElement('div');
        popup.className = 'confirmation-popup';
        popup.innerHTML = `
            <h2>Thank You!</h2>
            <p>We've received your upgrade request. We'll contact you soon with payment details.</p>
            <button onclick="continueAfterUpgrade()">Continue Playing</button>
        `;
        document.body.appendChild(popup);
        
        // Show popup with animation
        setTimeout(() => popup.classList.add('show'), 100);

    } catch (error) {
        console.error('Upgrade Request Error:', error);
        alert('Error processing request. Please try again.');
    }
}

function continueAfterUpgrade() {
    // Remove popup
    const popup = document.querySelector('.confirmation-popup');
    if (popup) {
        popup.classList.remove('show');
        setTimeout(() => popup.remove(), 300);
    }
    
    // Hide upgrade screen
    const upgradeScreen = document.getElementById('upgrade-screen');
    if (upgradeScreen) {
        upgradeScreen.classList.remove('visible');
    }
    
    // Clear form
    const form = document.getElementById('upgradeForm');
    if (form) form.reset();
    
    // Update the display manually
    if (currentUser) {
        updateUserStatusDisplay('pending');
    }
    
    // Continue game
    hideUpgradePromptAndContinue();
}

function validateForm(isAdult) {
    if (isAdult) {
        return document.getElementById('fullName').value && 
               document.getElementById('phone').value;
    } else {
        return document.getElementById('parentName').value && 
               document.getElementById('parentPhone').value;
    }
}

function skipUpgrade() {
    hideUpgradePromptAndContinue();
}

function updateUserStatusDisplay(status) {
    const userProfileSection = document.querySelector('.user-profile-section');
    const statusBadge = document.getElementById('userTierText');
    
    if (!userProfileSection || !statusBadge) {
        console.warn('User profile elements not found');
        return;
    }
    
    // Clear existing classes
    statusBadge.className = 'status-badge';
    
    if (!currentUser) {
        statusBadge.classList.add('unregistered');
        statusBadge.textContent = 'Unregistered';
        userProfileSection.style.display = 'none';
    } else {
        userProfileSection.style.display = 'block';
        
        switch(status) {
            case 'free':
                statusBadge.classList.add('trial');
                statusBadge.textContent = 'Trial Account';
                break;
            case 'pending':
                statusBadge.classList.add('pending');
                statusBadge.textContent = 'Premium Pending';
                break;
            case 'premium':
                statusBadge.classList.add('premium');
                statusBadge.textContent = 'Premium';
                break;
            default:
                statusBadge.classList.add('trial');
                statusBadge.textContent = 'Trial Account';
        }
    }
    
    // Update stats if available
    if (currentUser) {
        updateUserStats();
    }
}

async function updateUserStats() {
  try {
    if (!currentUser) return;
    
    const { data: gameData } = await supabaseClient
      .from("game_progress")
      .select("coins")
      .eq("user_id", currentUser.id)
      .single();
      
    const { data: statsData } = await supabaseClient
      .from("player_stats")
      .select("unique_words_practiced")
      .eq("user_id", currentUser.id)
      .single();
    
    if (gameData) {
      document.getElementById("totalCoins").textContent = gameData.coins || 0;
    }
    
    if (statsData) {
      document.getElementById("totalWords").textContent = statsData.unique_words_practiced || 0;
    }
    
    // Add this to force UI refresh
    updateAllCoinDisplays();
    WordsManager.updateDisplays(statsData?.unique_words_practiced || 0);
  } catch (err) {
    console.error("Error updating user stats:", err);
  }
}


function setupUserStatusSubscription() {
    if (!currentUser) return;

    const subscription = supabaseClient
        .channel('user-status-' + currentUser.id)  // Unique channel per user
        .on('postgres_changes', {
            event: 'UPDATE',
            schema: 'public',
            table: 'user_profiles',
            filter: `id=eq.${currentUser.id}`
        }, 
        payload => {
            console.log('Profile update received:', payload.new); // Debug log
            if (payload.new && payload.new.status) {
                updateUserStatusDisplay(payload.new.status);
                
                // If status changed to premium, trigger celebration
                if (payload.new.status === 'premium') {
                    showPremiumCelebration();
                }
            }
        })
        .subscribe(status => {
            console.log('Subscription status:', status); // Debug log
        });

    return subscription;
}

function restoreGameContext() {
    const savedContext = localStorage.getItem('gameContext');
    if (savedContext) {
        const context = JSON.parse(savedContext);
        gameState.currentStage = context.stage || 1;
        gameState.currentSet = context.set || 1;
        gameState.currentLevel = context.level;
        
        // Clear the saved context
        localStorage.removeItem('gameContext');
        
        return true;
    }
    return false;
}

function checkUpgradeStatus() {
    if (!currentUser) return false;
    
    const hasRequestedUpgrade = localStorage.getItem(`upgradeRequested_${currentUser.id}`);
    const isPremium = currentUser.status === 'premium';
    const isPending = currentUser.status === 'pending';
    
    return hasRequestedUpgrade || isPremium || isPending;
}

function navigateHome() {
    console.log('Navigating home with full refresh');
    saveProgress();  // Ensure current state is saved
    window.location.reload(true);
}

function forceReload() {
    console.log('Force Reload Initiated');
    
    // Multiple reload strategies
    if (window.location) {
        window.location.href = window.location.href;  // Reload current page
    }
    
    if (window.location.reload) {
        window.location.reload(true);  // Hard reload with cache bypass
    }
    
    // Fallback reload method
    window.location.replace(window.location.pathname);
}

// Replace ALL home button onclick events with this
document.querySelectorAll('.home-button').forEach(button => {
    button.onclick = function() {
        console.log('Home button clicked');
        forceReload();
    };
});

async function showLeaderboard() {
    showScreen('leaderboard-screen');
    const entriesContainer = document.getElementById('leaderboard-entries');
    
    try {
        async function fetchAndRenderLeaderboard() {
            const { data: leaderboard, error } = await supabaseClient
                .from('player_leaderboard')
                .select('*');
                    
            if (error) {
                console.error('Leaderboard fetch error:', error);
                return;
            }

            const currentEntries = entriesContainer.children;
            
            // Store current positions
            const oldPositions = {};
            Array.from(currentEntries).forEach(entry => {
                const username = entry.querySelector('[data-username]').dataset.username;
                oldPositions[username] = entry.getBoundingClientRect();
            });

            // Render new entries
            entriesContainer.innerHTML = leaderboard.map((entry, index) => `
                <div class="leaderboard-entry ${entry.username === currentUser?.user_metadata?.username ? 'you' : ''} ${index < 3 ? `rank-${index + 1}` : ''}"
                     data-rank="${index + 1}">
                    <div>${entry.player_rank}</div>
                    <div data-username="${entry.username}">${entry.username || 'Anonymous'}</div>
                    <div>${entry.total_levels_completed}</div>
                    <div>${entry.total_words_learned}</div>
                </div>
            `).join('');

            // Apply animations
            const newEntries = entriesContainer.children;
            Array.from(newEntries).forEach(entry => {
                const username = entry.querySelector('[data-username]').dataset.username;
                if (oldPositions[username]) {
                    const oldPos = oldPositions[username];
                    const newPos = entry.getBoundingClientRect();
                    const diff = oldPos.top - newPos.top;
                    
                    if (diff > 0) {
                        entry.classList.add('moving-up');
                    } else if (diff < 0) {
                        entry.classList.add('moving-down');
                    }
                    
                    // Remove animation classes after completion
                    entry.addEventListener('animationend', () => {
                        entry.classList.remove('moving-up', 'moving-down');
                    }, { once: true });
                }
            });
        }

        // Initial load
        await fetchAndRenderLeaderboard();

        // Set up polling
        const pollInterval = setInterval(fetchAndRenderLeaderboard, 10000);

        // Store interval for cleanup
        const leaderboardScreen = document.getElementById('leaderboard-screen');
    if (leaderboardScreen) {
        if (leaderboardScreen.dataset.pollInterval) {
            clearInterval(parseInt(leaderboardScreen.dataset.pollInterval));
        }
        leaderboardScreen.dataset.pollInterval = pollInterval;
    }
    } catch (error) {
        console.error('Detailed leaderboard error:', error);
        entriesContainer.innerHTML = `<p>Error loading leaderboard: ${error.message}</p>`;
    }
}

function cleanupLeaderboard() {
    const leaderboardScreen = document.getElementById('leaderboard-screen');
    if (leaderboardScreen) {
        // Cleanup channel
        if (leaderboardScreen.dataset.channel) {
            supabaseClient.removeChannel(leaderboardScreen.dataset.channel);
            delete leaderboardScreen.dataset.channel;
        }
        // Cleanup interval
        if (leaderboardScreen.dataset.pollInterval) {
            clearInterval(parseInt(leaderboardScreen.dataset.pollInterval));
            delete leaderboardScreen.dataset.pollInterval;
        }
    }
}

async function updatePlayerStats(levelTime, mistakes, currentStreak) {
    if (currentUser && "premium" === currentUser.status) {
        try {
            // Get current player stats
            const { data: currentStats, error: statsError } = 
                await supabaseClient.from("player_stats")
                    .select("*")
                    .eq("user_id", currentUser.id)
                    .single();

            if (statsError && statsError.code !== "PGRST116") throw statsError;

            // Calculate unique words (remove duplicates)
            const uniqueWords = [...new Set(currentGame.words)];
            const wordsToAdd = uniqueWords.length;

            // Prepare update object
            const statsUpdate = {
                user_id: currentUser.id,
                total_levels_completed: (currentStats?.total_levels_completed || 0) + 1,
                unique_words_practiced: (currentStats?.unique_words_practiced || 0) + wordsToAdd,
                last_updated: new Date().toISOString()
            };

            // Update database
            const { error: upsertError } = 
                await supabaseClient.from("player_stats")
                    .upsert(statsUpdate, { onConflict: "user_id", returning: "minimal" });

            if (upsertError) throw upsertError;

            // Immediately update UI
            await WordsManager.updateWords(wordsToAdd);

        } catch (error) {
            console.error("Error updating player stats:", error);
        }
    }
}

async function checkExistingSession() {
    console.log("Checking for existing user session");
    
    try {
        const { data: { session } } = await supabaseClient.auth.getSession();
        
        if (session) {
            console.log("Found existing session for user:", session.user.id);
            currentUser = session.user;
            
            // Fetch user profile data
            const { data: profileData } = await supabaseClient
                .from("user_profiles")
                .select("status")
                .eq("id", currentUser.id)
                .single();
                
            if (profileData) {
                currentUser.status = profileData.status;
                updateUserStatusDisplay(profileData.status);
            }
            
            // Initialize status check
            initializeStatusCheck();
            
            // Update UI
            updateAuthUI();
            updateGuestPlayButton();
            
            return true;
        } else {
            console.log("No active session found");
            currentUser = null;
            updateAuthUI();
            updateUserStatusDisplay(null);
            updateGuestPlayButton();
            return false;
        }
    } catch (error) {
        console.error("Session check error:", error);
        currentUser = null;
        updateAuthUI();
        updateUserStatusDisplay(null);
        updateGuestPlayButton();
        return false;
    }
}

// Add at the document.addEventListener("DOMContentLoaded", ...) section
document.addEventListener("DOMContentLoaded", function() {
    console.log("DOM fully loaded, initializing game");
    
    // Initialize game with explicit progression saving/loading
    gameInit.init().then(() => {
        console.log("Game initialization completed");
        
        // Check for saved context on startup
        const savedContext = localStorage.getItem("gameContext");
        if (savedContext && !window.location.hash) {
            try {
                const context = JSON.parse(savedContext);
                const timeSinceContext = Date.now() - (context.timestamp || 0);
                
                // Only use context if it's less than 24 hours old
                if (timeSinceContext < 24 * 60 * 60 * 1000) {
                    console.log("Found recent game context, updating game state:", context);
                    gameState.currentStage = context.stage || gameState.currentStage;
                    gameState.currentSet = context.set || gameState.currentSet;
                    gameState.currentLevel = context.level || gameState.currentLevel;
                }
            } catch (e) {
                console.error("Error parsing saved context:", e);
            }
        }
    });
});

function setupAutoSave() {
    // Auto-save progress every 30 seconds
    const autoSaveInterval = setInterval(() => {
        if (gameState.currentStage && gameState.currentSet && gameState.currentLevel) {
            console.log("Auto-saving game progress");
            saveProgress();
        }
    }, 30000);
    
    // Save progress when the window is about to unload
    window.addEventListener("beforeunload", () => {
        if (gameState.currentStage && gameState.currentSet && gameState.currentLevel) {
            console.log("Saving progress before page unload");
            saveProgress();
        }
    });
    
    return autoSaveInterval;
}

// Call this function at initialization
document.addEventListener("DOMContentLoaded", function() {
    setupAutoSave();
});

function showPremiumCelebration() {
    // Create the celebration overlay
    const celebrationOverlay = document.createElement('div');
    celebrationOverlay.className = 'premium-celebration';
    
    celebrationOverlay.innerHTML = `
        <div class="celebration-content">
            <h1 class="celebration-title">Congratulations!</h1>
            <p class="celebration-message">You've unlocked Premium Access!</p>
            <button class="celebration-button" onclick="handlePremiumCelebrationComplete()">
                Continue
            </button>
        </div>
    `;
    
    // Add to body
    document.body.appendChild(celebrationOverlay);
    
    // Trigger show animation
    setTimeout(() => {
        celebrationOverlay.classList.add('show');
    }, 100);
}

function handlePremiumCelebrationComplete() {
    const overlay = document.querySelector('.premium-celebration');
    if (overlay) {
        overlay.classList.remove('show');
        setTimeout(() => {
            overlay.remove();
            // Optionally refresh the screen or update UI
            showScreen('welcome-screen');
        }, 500);
    }
}

function handlePremiumCelebrationComplete() {
    const overlay = document.querySelector('.premium-celebration');
    if (overlay) {
        overlay.classList.remove('show');
        setTimeout(() => {
            overlay.remove();
            // Refresh game state with new premium access
            showScreen('welcome-screen');
        }, 500);
    }
}

function initializeStatusCheck() {
    // Clear any existing interval
    if (window.statusCheckInterval) {
        clearInterval(window.statusCheckInterval);
    }

    // Only set up interval if user is logged in
    if (currentUser) {
        const statusCheckInterval = setInterval(async () => {
            try {
                // Check if currentUser is still valid
                if (!currentUser || !currentUser.id) {
                    clearInterval(window.statusCheckInterval);
                    return;
                }

                const { data, error } = await supabaseClient
                    .from('user_profiles')
                    .select('status')
                    .eq('id', currentUser.id)
                    .single();
                    
                if (error || !data) {
                    // If no user found, clear interval and reset
                    clearInterval(window.statusCheckInterval);
                    currentUser = null;
                    updateAuthUI();
                    return;
                }
                    
                // Update status display if needed
                updateUserStatusDisplay(data.status);
                
                // If status changes to premium, show celebration
                if (data.status === 'premium' && currentUser.status !== 'premium') {
                    currentUser.status = 'premium';
                    showPremiumCelebration();
                }
            } catch (error) {
                console.error('Status check error:', error);
                // Clear interval on any unexpected error
                clearInterval(window.statusCheckInterval);
                currentUser = null;
                updateAuthUI();
            }
        }, 3000); // Check every 30 seconds
        
        // Store interval ID for cleanup
        window.statusCheckInterval = statusCheckInterval;
    }
}

// ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE ARCADE





document.addEventListener('DOMContentLoaded', () => {
    const otpInput = document.getElementById('otpInput');
    if (otpInput) {
        otpInput.addEventListener('input', function(e) {
            // Remove any non-numeric characters
            this.value = this.value.replace(/[^0-9]/g, '');
            
            // Limit to 4 digits
            if (this.value.length > 4) {
                this.value = this.value.slice(0, 4);
            }
        });
    }
});

let currentArcadeSession = {
    eventId: null,
    otp: null,
    wordPool: [],
    participants: [],
    teacherId: null,
    wordGoal: 50,
    state: 'pre-start',  // 'pre-start', 'started', 'active', 'ended'
    completedPlayers: [],  // To track players who already completed
    playerRank: null,      // Current player's rank if completed
    winnerScreenShown: false, // Flag to prevent multiple winner screens
    startTime: null,       // When the session started
    endTime: null          // When the session ended
};




function startPlayerCounting(teacherId) {
    if (window.countInterval) clearInterval(window.countInterval);
    
    async function updateCount() {
        try {
            const { data } = await supabaseClient
                .from('game_progress')
                .select('arcade_session')
                .eq('user_id', teacherId)
                .single();
                
            if (data?.arcade_session?.participants) {
                document.getElementById('player-count').textContent = 
                    data.arcade_session.participants.length;
            }
        } catch (error) {
            console.error('Count update error:', error);
        }
    }
    
    updateCount();
    window.countInterval = setInterval(updateCount, 2000);
}

async function joinArcade() {
    const otp = document.getElementById('otpInput').value.trim().toUpperCase();
    
    try {
        window.arcadeChannel = supabaseClient.channel(`arcade:${otp}`);
        
        const playerName = currentUser ? 
            currentUser.user_metadata?.username : 
            getRandomSimploName();
            
        currentArcadeSession.playerName = playerName;
        
        // Set up state polling
        let stateCheckInterval;
        
        window.arcadeChannel
        .on('broadcast', { event: 'game_end' }, ({ payload }) => {
            handleGameEnd(payload);
                currentArcadeSession.state = payload.state;
                
                if (payload.state === 'active') {
                    currentArcadeSession.wordPool = payload.wordPool;
                    currentArcadeSession.wordGoal = payload.wordGoal;
                    startArcadeGame();
                    if (stateCheckInterval) clearInterval(stateCheckInterval);
                }
            })
            .on('broadcast', { event: 'game_playing' }, ({ payload }) => {
                if (payload.state === 'active') {
                    currentArcadeSession.wordPool = payload.wordPool;
                    currentArcadeSession.wordGoal = payload.wordGoal;
                    startArcadeGame();
                    if (stateCheckInterval) clearInterval(stateCheckInterval);
                }
            })
            .subscribe();

        // Broadcast join
        await window.arcadeChannel.send({
            type: 'broadcast',
            event: 'player_join',
            payload: {
                username: playerName,
                joinedAt: new Date().toISOString()
            }
        });

        // Hide arcade modal and show waiting screen
        document.getElementById('arcade-modal').style.display = 'none';
        showWaitingScreen();

        // Start state polling for late joiners
        stateCheckInterval = setInterval(async () => {
            await window.arcadeChannel.send({
                type: 'broadcast',
                event: 'check_game_status'
            });
        }, 2000);

        // Clear interval after 5 minutes to prevent indefinite polling
        setTimeout(() => {
            if (stateCheckInterval) clearInterval(stateCheckInterval);
        }, 300000);

    } catch (error) {
        console.error('Join error:', error);
        alert('Failed to join arcade');
    }
}

function showJoinButton() {
    const joinButton = document.getElementById('joinGameButton');
    if (joinButton) {
        joinButton.style.display = 'block';
        joinButton.textContent = 'Join Active Game';
    }
}

async function getCurrentCoins() {
    if (!currentUser) return 0;
    
    const { data } = await supabaseClient
        .from('game_progress')
        .select('coins')
        .eq('user_id', currentUser.id)
        .single();
        
    return data?.coins || 0;
}

function getRandomSimploName() {
    const names = [
        'Simplosaurus', 'Simplodian', 'Simpleton', 'Simplonius', 'Simplomancer',
        'Simplonaut', 'Simplobot', 'Simplozilla', 'Simplopedia', 'Simplotron',
        'Simplodex', 'Simplomatic', 'Simplomobile', 'Simplocopter', 'Simplonium',
        'Simplotastic', 'Simplominator', 'Simploverse', 'Simplonado', 'Simplophant',
        'Simplowizard', 'Simplodragon', 'Simplosapien', 'Simploninja', 'Simplowarrior'
    ];
    return names[Math.floor(Math.random() * names.length)];
}

function showWaitingScreen() {
    // If game is already active, skip waiting screen
    if (currentArcadeSession.state === 'active') {
        startArcadeGame();
        return;
    }

    document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('visible');
    });
    
    const waitingScreen = document.getElementById('waiting-screen');
    waitingScreen.classList.add('visible');
    
    const joinButton = document.getElementById('joinGameButton');
    if (joinButton) {
        joinButton.style.display = currentArcadeSession.state === 'active' ? 'block' : 'none';
    }
    
    // Start polling for game state
    const pollInterval = setInterval(() => {
        if (window.arcadeChannel) {
            try {
                window.arcadeChannel.send({
                    type: 'broadcast',
                    event: 'check_game_status',
                    payload: {
                        username: currentArcadeSession.playerName,
                        requestType: 'waitingCheck'
                    }
                });
            } catch (err) {
                console.error('Error checking game status:', err);
            }
        }
    }, 2000);
    
    // Remove player count display
    const playerCountElement = document.getElementById('waiting-player-count');
    if (playerCountElement) {
        playerCountElement.parentElement.style.display = 'none';
    }
    
    // Store interval ID for cleanup
    waitingScreen.dataset.pollInterval = pollInterval;

    // Auto-cleanup after 5 minutes
    setTimeout(() => {
        if (pollInterval) {
            clearInterval(pollInterval);
        }
    }, 300000);
}



function showModeratorScreen() {
    // Hide all screens
    document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('visible');
    });
    
    // Show moderator screen
    const moderatorScreen = document.getElementById('moderator-screen');
    moderatorScreen.classList.add('visible');
    
    // Display OTP and generate QR
    const otpDisplay = document.getElementById('moderatorOtp');
    if (otpDisplay && currentArcadeSession.otp) {
        otpDisplay.textContent = currentArcadeSession.otp;
        
        // Generate QR code with proper URL construction
        const currentUrl = window.location.origin + window.location.pathname;
        const joinUrl = `${currentUrl}#join=${currentArcadeSession.otp}`;
        console.log('QR URL generated:', joinUrl);
        
        new QRious({
            element: document.getElementById('qrCode'),
            value: joinUrl,
            size: 200,
            backgroundAlpha: 1,
            foreground: '#16213e',
            background: '#ffffff',
            level: 'H'
        });
        
        // Update all session info at once
        const now = new Date();
        const sessionInfo = {
            'sessionDate': now.toLocaleDateString(),
            'sessionStartTime': now.toLocaleTimeString(),
            'sessionWordGoal': currentArcadeSession.wordGoal,
            'activeParticipantCount': currentArcadeSession.participants.length
        };
        
        Object.entries(sessionInfo).forEach(([id, value]) => {
            const element = document.getElementById(id);
            if (element) element.textContent = value;
        });
    }
    
    initializeLeaderboard();
    
    // Initialize the inactivity timer for moderator
    initializeModeratorInactivityTimer();
}

function initializeLeaderboard() {
    const leaderboard = document.getElementById('arcade-leaderboard');
    
    // Add header
    leaderboard.innerHTML = `
        <div class="leaderboard-header">
            <div>Rank</div>
            <div>Player</div>
            <div>Words</div>
            <div>Coins</div>
        </div>
    `;
    
    // Show any existing participants
    if (currentArcadeSession.participants.length > 0) {
        updateAllPlayersProgress();
    }
}


const readyPhrases = [
    "Born Ready!",
    "Ready to Roll!",
    "All Set!",
    "Locked & Loaded!",
    "Ready Player!",
    "Game Face On!",
    "In Position!",
    "Ready to Rock!",
    "Standing By!",
    "Powered Up!",
    "Challenge Ready!",
    "Mission Ready!",
    "Ready to Shine!",
    "Bring it On!",
    "Ready to Rumble!",
    "Set for Success!",
    "Level Ready!",
    "Shields Up!",
    "Word Warrior Ready!",
    "Let's Do This!"
];

const shineColors = [
    '#1E90FF',  // Blue
    '#FF1493',  // Deep Pink
    '#00CED1',  // Dark Turquoise
    '#9370DB',  // Medium Purple
    '#FFD700',  // Gold
    '#FF4500',  // Orange Red
    '#32CD32',  // Lime Green
    '#FF69B4',  // Hot Pink
    '#4169E1',  // Royal Blue
    '#8A2BE2'   // Blue Violet
];


function updateAllPlayersProgress() {
    // Sort by words completed
    const sortedPlayers = [...currentArcadeSession.participants]
        .sort((a, b) => {
            if (b.wordsCompleted !== a.wordsCompleted) {
                return b.wordsCompleted - a.wordsCompleted;
            }
            return b.coins - a.coins;
        });
    
    const getRandomColor = () => shineColors[Math.floor(Math.random() * shineColors.length)];
    const getReadyPhrase = () => readyPhrases[Math.floor(Math.random() * readyPhrases.length)];

    const entries = sortedPlayers.map((player, index) => {
        if (currentArcadeSession.state === 'active' && player.username) {
            // For active players (after game has started)
            return `
                <div class="leaderboard-entry ${index < 3 ? `rank-${index + 1}` : ''}"
                     data-rank="${index + 1}">
                    <div class="rank">${index + 1}</div>
                    <div data-username="${player.username}" class="player-name">${player.username}</div>
                    <div data-words="${player.wordsCompleted || 0}" class="words">${player.wordsCompleted || 0}</div>
                    <div data-coins="${player.coins || 0}" class="coins">${player.coins || 0}</div>
                </div>
            `;
        } else {
            // For waiting players
            return `
                <div class="leaderboard-entry waiting ${index < 3 ? `rank-${index + 1}` : ''}"
                     data-rank="${index + 1}">
                    <div class="rank">${index + 1}</div>
                    <div data-username="${player.username}" class="player-name">${player.username}</div>
                    <div class="player-status-waiting">
                        <span class="status-text" style="color: ${getRandomColor()}">${getReadyPhrase()}</span>
                    </div>
                    <div class="waiting-indicator">
                        <span class="dot"></span>
                        <span class="dot"></span>
                        <span class="dot"></span>
                    </div>
                </div>
            `;
        }
    }).join('');
    
    // Always show the header with all columns
    const leaderboardHTML = `
        <div class="leaderboard-header">
            <div>Rank</div>
            <div>Player</div>
            <div>Words</div>
            <div>Coins</div>
        </div>
        ${entries}
    `;
    
    const leaderboard = document.getElementById('arcade-leaderboard');
    leaderboard.innerHTML = leaderboardHTML;
    
    // Update session metadata
    document.getElementById('activeParticipantCount').textContent = sortedPlayers.length;
    document.getElementById('sessionDate').textContent = new Date().toLocaleDateString();
    document.getElementById('sessionStartTime').textContent = new Date().toLocaleTimeString();
    document.getElementById('sessionWordGoal').textContent = currentArcadeSession.wordGoal;
}


function generateWordPool(stages) {
    let pool = [];
    
    stages.forEach(stage => {
        Object.keys(vocabularySets).forEach(key => {
            if (key.startsWith(`${stage}_`)) {
                const set = vocabularySets[key];
                set.words.forEach((word, index) => {
                    pool.push({
                        word: word,
                        translation: set.translations[index]
                    });
                });
            }
        });
    });
    
    return pool.sort(() => Math.random() - 0.5);
}

function cleanupModeratorScreen() {
    const moderatorScreen = document.getElementById('moderator-screen');
    if (moderatorScreen && moderatorScreen.dataset.channelSubscription) {
        supabaseClient.removeChannel(moderatorScreen.dataset.channelSubscription);
        delete moderatorScreen.dataset.channelSubscription;
    }
}

async function startArcadeGame() {
   // Clean up any waiting screen intervals
   const waitingScreen = document.getElementById('waiting-screen');
   if (waitingScreen && waitingScreen.dataset.pollInterval) {
       clearInterval(parseInt(waitingScreen.dataset.pollInterval));
       delete waitingScreen.dataset.pollInterval;
   }

   const questionScreen = document.getElementById('question-screen');
   questionScreen.classList.add('visible');
   document.getElementById('waiting-screen').classList.remove('visible');
   
   // Determine player username more robustly
   const playerUsername = currentArcadeSession.playerName || 
       (currentUser?.user_metadata?.username || getRandomSimploName());
   
   // Initialize coins
   document.querySelectorAll('.coin-count').forEach(display => {
       display.textContent = currentGame.coins || 0;
       display.style.display = 'flex';
   });
   
   document.querySelectorAll('.coins-container').forEach(container => {
       container.style.display = 'flex';
   });

   // Toggle menus for arcade mode
   const perksContainer = document.querySelector('.perks-container');
   const powerupsContainer = document.querySelector('.powerups-container');
   
   perksContainer.style.display = 'none';
   powerupsContainer.style.display = 'flex';
   
   let initialCoins = 0;
   
   // For premium users, get current coins from game progress
   if (currentUser && currentUser.status === 'premium') {
       try {
           const { data, error } = await supabaseClient
               .from('game_progress')
               .select('coins')
               .eq('user_id', currentUser.id)
               .single();
               
           if (!error && data) {
               initialCoins = data.coins;
               console.log('Loaded initial coins:', initialCoins);
               
               // Immediately update UI and broadcast initial state
               currentGame.coins = initialCoins;
               updateAllCoinDisplays();
               
               // Store initial coins value for final calculations
               currentArcadeSession.initialCoins = initialCoins;
               
               // Broadcast initial coin state
               await window.arcadeChannel.send({
                   type: 'broadcast',
                   event: 'progress_update',
                   payload: {
                       username: playerUsername,
                       wordsCompleted: 0,
                       coins: initialCoins,
                       timestamp: Date.now()
                   }
               });
           }
       } catch (error) {
           console.error('Failed to load coins:', error);
       }
   }
   
   // Mark session start time
   currentArcadeSession.startTime = Date.now();
   
   // Reset game state with additional properties
   currentGame = {
       currentIndex: 0,
       correctStreak: 0,
       wrongStreak: 0,
       words: currentArcadeSession.wordPool || [],
       wordsCompleted: 0,
       coins: initialCoins,
       lastBroadcast: Date.now(),
       initialCoinsLoaded: true,
       playerUsername: playerUsername
   };
   
   // Guard against empty word pool for late joiners
   if (!currentGame.words || currentGame.words.length === 0) {
       console.error('Empty word pool detected. Trying to fetch from currentArcadeSession');
       if (currentArcadeSession.wordPool && currentArcadeSession.wordPool.length > 0) {
           currentGame.words = currentArcadeSession.wordPool;
       } else {
           // Show error and return to welcome screen
           showErrorToast('Failed to join game: No words available');
           showScreen('welcome-screen');
           return;
       }
   }

   // Broadcast player initialization BEFORE first question
   try {
       await window.arcadeChannel.send({
           type: 'broadcast',
           event: 'player_initialized',
           payload: {
               username: playerUsername,
               initialCoins: initialCoins,
               wordsCompleted: 0,
               timestamp: Date.now(),
               lateJoin: currentArcadeSession.state === 'active' // Flag for late joiners
           }
       });
   } catch (error) {
       console.error('Initialization broadcast failed:', error);
   }

   // Initialize powerups
   initializePowerups();

   // Set up Supabase real-time leaderboard channel
   const leaderboardChannel = supabaseClient
       .channel('arcade_leaderboard')
       .on('postgres_changes', { 
           event: '*', 
           schema: 'public', 
           table: 'arcade_participants' 
       }, payload => {
           console.log('Direct DB Change:', payload);
           updateAllPlayersProgress();
       })
       .subscribe();

   // Store channel reference for cleanup
   currentArcadeSession.leaderboardChannel = leaderboardChannel;

   // Set up broadcast channel listeners
   window.arcadeChannel
       .on('broadcast', { event: 'player_initialized' }, ({ payload }) => {
           console.log('Player Initialization Received:', payload);
           
           const existingPlayerIndex = currentArcadeSession.participants.findIndex(
               p => p.username === payload.username
           );
           
           const playerEntry = {
               username: payload.username,
               wordsCompleted: 0,
               coins: payload.initialCoins || 0,
               lateJoin: payload.lateJoin || false
           };
           
           if (existingPlayerIndex === -1) {
               currentArcadeSession.participants.push(playerEntry);
           } else {
               currentArcadeSession.participants[existingPlayerIndex] = playerEntry;
           }
           
           updateAllPlayersProgress();
           updateArcadeProgress();
       })
       .on('broadcast', { event: 'progress_update' }, ({ payload }) => {
           console.log('Progress update received:', payload);
           if (payload.username !== currentArcadeSession.playerName) {
               const existingPlayerIndex = currentArcadeSession.participants.findIndex(
                   p => p.username === payload.username
               );
               
               if (existingPlayerIndex !== -1) {
                   currentArcadeSession.participants[existingPlayerIndex] = {
                       ...currentArcadeSession.participants[existingPlayerIndex],
                       ...payload
                   };
               } else {
                   currentArcadeSession.participants.push({
                       username: payload.username,
                       wordsCompleted: payload.wordsCompleted || 0,
                       coins: payload.coins || 0
                   });
               }
               
               updatePlayerProgress({
                   username: payload.username,
                   wordsCompleted: payload.wordsCompleted,
                   coins: payload.coins
               });
           }
       })
       .on('broadcast', { event: 'player_completed' }, ({ payload }) => {
           console.log('Player completed event:', payload);
           
           // If this player has completed, add to completed players list
           if (!currentArcadeSession.completedPlayers.includes(payload.username)) {
               currentArcadeSession.completedPlayers.push(payload.username);
           }
           
           // Update player UI
           updatePlayerProgress(payload);
           
           // If 3 players have completed, end the game (failsafe for non-moderator)
           if (currentArcadeSession.completedPlayers.length >= 3) {
               endArcadeForAll();
           }
       })
       .on('broadcast', { event: 'powerup_effect' }, ({ payload }) => {
           if (payload.targetUser === currentArcadeSession.playerName) {
               const powerup = payload.powerup;
               
               // Show notification
               showNotification(
                   `${payload.fromUser} ${powerup.message} you!`,
                   powerup.type
               );

               // Apply effect based on powerup type
               switch (powerup.name) {
                   case 'High Five':
                   case 'Fist Bump':
                       const oldCoins = currentGame.coins;
                       currentGame.coins += powerup.effect;
                       document.querySelectorAll('.coin-count').forEach(display => {
                           animateNumber(display, oldCoins, currentGame.coins);
                       });
                       break;

                   case 'Energy Boost':
                       currentGame.coinMultiplier = 2;
                       currentGame.boostedAnswersLeft = 3;
                       break;

                   case 'Freeze':
                       const buttons = document.querySelectorAll('.buttons button');
                       buttons.forEach(btn => btn.disabled = true);
                       setTimeout(() => {
                           buttons.forEach(btn => btn.disabled = false);
                       }, powerup.duration);
                       break;

                   case 'Coin Storm':
                       currentGame.coinBlockedAnswers = 3;
                       break;

                   case 'Screen Shake':
                       const questionScreen = document.getElementById('question-screen');
                       questionScreen.classList.add('screen-shake');
                       setTimeout(() => {
                           questionScreen.classList.remove('screen-shake');
                       }, powerup.duration);
                       break;
               }

               updatePlayerProgress({
                   username: currentArcadeSession.playerName,
                   coins: currentGame.coins,
                   wordsCompleted: currentGame.wordsCompleted
               });
           }
       })
       .on('broadcast', { event: 'coin_effect' }, ({ payload }) => {
            if (payload.targetUser === currentArcadeSession.playerName) {
                const oldCoins = currentGame.coins;
                currentGame.coins += payload.amount;
                
                // Animate coin changes
                document.querySelectorAll('.coin-count').forEach(display => {
                    animateNumber(display, oldCoins, currentGame.coins);
                });
                
                // Immediately update moderator leaderboard
                const participantIndex = currentArcadeSession.participants.findIndex(
                    p => p.username === currentArcadeSession.playerName
                );
                
                if (participantIndex !== -1) {
                    currentArcadeSession.participants[participantIndex].coins = currentGame.coins;
                    updateModeratorLeaderboard();
                }
                
                // Show notification
                if (payload.type === 'blessing') {
                    showNotification(`${payload.fromUser} high-fived you!`, 'blessing');
                } else if (payload.type === 'curse') {
                    showNotification(`${payload.fromUser} poisoned you!`, 'curse');
                }
                
                // Update leaderboard
                updatePlayerProgress({
                    username: currentArcadeSession.playerName,
                    coins: currentGame.coins,
                    wordsCompleted: currentGame.wordsCompleted
                });
            }
        })
        .on('broadcast', { event: 'game_end' }, ({ payload }) => {
            handleGameEnd(payload);
        });

   // Update UI elements
   updateAllCoinDisplays();
   
   // Start first question
   loadNextArcadeQuestion();
   
   // Initialize arrays to track timers and intervals
   window.arcadeTimeouts = [];
   window.arcadeIntervals = [];
}

async function updateArcadeCoins(amount) {
    const oldCoins = currentGame.coins;
    currentGame.coins += amount;

    // For registered users, update their game_progress
    if (currentUser) {
        try {
            const { error } = await supabaseClient
                .from('game_progress')
                .update({ coins: currentGame.coins })
                .eq('user_id', currentUser.id);

            if (error) throw error;
        } catch (error) {
            console.error('Failed to update coins in database:', error);
            currentGame.coins = oldCoins; // Rollback on error
        }
    }

    // Update displays with animation
    const displays = document.querySelectorAll('.coin-count');
    displays.forEach(display => {
        animateCoinsChange(display, oldCoins, currentGame.coins);
    });

    return currentGame.coins;
}

async function getCurrentCoinsForArcade() {
    if (!currentUser) {
        // For guest users, use localStorage or default
        return parseInt(localStorage.getItem('simploxCustomCoins') || '0');
    }

    // For logged-in users, especially premium
    try {
        const { data, error } = await supabaseClient
            .from('game_progress')
            .select('coins')
            .eq('user_id', currentUser.id)
            .single();

        if (error) console.error('Coin retrieval error:', error);
        return data?.coins || 0;
    } catch (error) {
        console.error('Unexpected coin retrieval error:', error);
        return 0;
    }
}

function loadNextArcadeQuestion() {
    if (!currentGame.words.length) return;
    
    const questionWord = document.getElementById('question-word');
    const buttonsDiv = document.getElementById('buttons');
    
    // Get random word from pool
    const currentIndex = Math.floor(Math.random() * currentGame.words.length);
    const currentWord = currentGame.words[currentIndex];
    
    // 50% chance for Hebrew to English
    const isHebrewToEnglish = Math.random() < 0.5;
    
    questionWord.textContent = isHebrewToEnglish ? 
        currentWord.translation : currentWord.word;
    
    // Generate options
    let options = [isHebrewToEnglish ? currentWord.word : currentWord.translation];
    while (options.length < 3) {
        const randomWord = currentGame.words[Math.floor(Math.random() * currentGame.words.length)];
        const option = isHebrewToEnglish ? randomWord.word : randomWord.translation;
        if (!options.includes(option)) {
            options.push(option);
        }
    }
    
    // Shuffle options
    options = options.sort(() => Math.random() - 0.5);
    
    // Create buttons
    buttonsDiv.innerHTML = '';
    options.forEach(option => {
        const button = document.createElement('button');
        button.textContent = option;
        button.onclick = () => handleArcadeAnswer(
            option === (isHebrewToEnglish ? currentWord.word : currentWord.translation)
        );
        buttonsDiv.appendChild(button);
    });
    
    // Remove used word from pool
    currentGame.words.splice(currentIndex, 1);
}


function updateArcadeProgress() {
    const circle = document.querySelector('.progress-circle .progress');
    const radius = 54;
    const circumference = 2 * Math.PI * radius;
    
    // Default to 0 for initial state
    const progress = currentGame.wordsCompleted 
        ? currentGame.wordsCompleted / currentArcadeSession.wordGoal 
        : 0;
    
    circle.style.strokeDasharray = `${circumference} ${circumference}`;
    circle.style.strokeDashoffset = circumference * (1 - progress);
}

function showArcadeCompletionScreen(playerData) {
    const overlay = document.createElement('div');
    overlay.className = 'arcade-completion-modal';
    overlay.innerHTML = `
        <div class="completion-modal-content">
            <h2>Arcade Complete!</h2>
            <div class="completion-stats">
                <div class="stat-item">
                    <i class="fas fa-book"></i>
                    <span>Words: ${playerData.wordsCompleted}</span>
                </div>
                <div class="stat-item">
                    <i class="fas fa-coins"></i>
                    <span>Coins: ${playerData.coins}</span>
                </div>
                <div class="stat-item">
                    <i class="fas fa-trophy"></i>
                    <span>Rank: ${playerData.rank}</span>
                </div>
            </div>
            <button onclick="exitArcade()" class="start-button">Exit</button>
        </div>
    `;
    
    document.body.appendChild(overlay);
    requestAnimationFrame(() => overlay.classList.add('show'));
}

function exitArcadeCompletion() {
    const modal = document.querySelector('.arcade-completion-modal');
    if (modal) {
        modal.classList.remove('show');
        setTimeout(() => {
            modal.remove();
            showScreen('welcome-screen');
        }, 300);
    }
}

function exitArcade() {
    // Clean up
    if (window.arcadeChannel) {
        window.arcadeChannel.unsubscribe();
    }
    currentArcadeSession = {
        eventId: null,
        otp: null,
        wordPool: [],
        participants: [],
        teacherId: null,
        wordGoal: 50
    };
    
    // Return to welcome screen
    showScreen('welcome-screen');
    document.querySelector('.completion-overlay')?.remove();
}

function handleAnswer(isCorrect, skipMode = false) {
  const now = Date.now();
  if (now - (currentGame.lastAnswerTime || 0) < 1000) {
    console.warn("Answer too quickly. Please wait a moment.");
    return;
  }
  
  if (!currentGame || !currentGame.words || currentGame.words.length === 0 || currentGame.currentIndex >= currentGame.words.length) {
    console.error("Invalid game state or index");
    return;
  }
  
  currentGame.lastAnswerTime = now;
  currentGame.perks = currentGame.perks || { clue: 0, skip: 0, timeFreeze: 0, reveal: 0 };
  
  try {
    if (isCorrect) {
      currentGame.currentIndex++;
      
      if (currentGame.isBossLevel) {
        const bossOrb = document.querySelector(".boss-orb-inner");
        if (bossOrb) {
          const colors = ["yellow", "purple", "turquoise", "darkgreen", "brown"];
          const randomColor = colors[Math.floor(Math.random() * colors.length)];
          const originalBackground = bossOrb.style.background;
          bossOrb.style.background = `radial-gradient(circle at 30% 30%, ${randomColor}, #990000)`;
          bossOrb.style.transform = "scale(1.3)";
          bossOrb.style.filter = "brightness(1.5)";
          setTimeout(() => {
            bossOrb.style.transform = "";
            bossOrb.style.filter = "";
            bossOrb.style.background = originalBackground;
          }, 300);
        }
        
        // Check if this was the final boss hit
        if (currentGame.currentIndex >= currentGame.words.length) {
          console.log("Boss defeated - final hit!");
          currentGame.bossDefeated = true; // Mark boss as defeated
          clearTimer(); // Clear the timer
          
          // Force health bar to zero
          const progressCircle = document.querySelector('.progress-circle');
          if (progressCircle) {
            const progress = progressCircle.querySelector('.progress');
            if (progress) {
              const circumference = 2 * Math.PI * 54;
              progress.style.strokeDashoffset = circumference; // Set to full circumference (empty)
            }
          }
          
          // Direct call to defeat sequence with forced update
          showBossDefeatEffect();
          CoinsManager.updateCoins(100).then(() => {
            updateAllCoinDisplays(); // Update coin display explicitly
          });
          
          return; // Exit function early
        }
        
        // Otherwise just update the health bar
        updateBossHealthBar();
      } else {
        updateProgressCircle();
      }
      
      if (!skipMode) {
        let coinsEarned = 0;
        const timeBonus = awardTimeBonus();
        if (timeBonus > 0) {
          coinsEarned += timeBonus;
          pulseCoins(timeBonus);
        }
        
        if (currentGame.firstAttempt) {
          coinsEarned += 3;
          pulseCoins(3);
        } else {
          coinsEarned += 1;
          pulseCoins(1);
        }
        
        CoinsManager.updateCoins(coinsEarned).then(() => {
          updatePerkButtons();
          updateAllCoinDisplays(); // Added to ensure coin display updates
        }).catch(err => {
          console.error("Error updating total coins:", err);
        });
        
        currentGame.correctAnswers++;
        
        // Track word for any registered user without status check
        if (currentUser) {
          const wordIndex = currentGame.currentIndex - 1;
          const word = currentGame.isHebrewToEnglish ? 
            currentGame.words[wordIndex] : 
            currentGame.translations[wordIndex];
          
          const gameMode = currentGame.isCustomPractice ? 'custom' : 
                           currentGame.isArcadeMode ? 'arcade' : 'story';
          
          // Call trackWordEncounter without status check
          trackWordEncounter(word, gameMode);
        }
      }
    } else {
      currentGame.firstAttempt = false;
      currentGame.streakBonus = false;
      currentGame.wrongStreak++;
      
      CoinsManager.updateCoins(-3).then(() => {
        updatePerkButtons();
        updateAllCoinDisplays(); // Added to ensure coin display updates
      }).catch(err => {
        console.error("Error updating coins:", err);
      });
      
      if (currentGame.currentIndex > 0) {
        currentGame.progressLost++;
        currentGame.currentIndex = Math.max(0, currentGame.currentIndex - 1);
        if (currentGame.isBossLevel) {
          updateBossHealthBar();
        }
      }
      
      if (currentGame.wrongStreak >= 3) {
        showGameOverOverlay();
        return;
      }
    }
    
    // Clear previous visual indicators from all buttons
    const allButtons = document.querySelectorAll(".buttons button");
    
    // Get current question's correct answer
    const currentCorrectAnswer = currentGame.isHebrewToEnglish
      ? currentGame.words[Math.max(0, currentGame.currentIndex - 1)]
      : currentGame.translations[Math.max(0, currentGame.currentIndex - 1)];
      
    // Highlight current answer status (right or wrong)
    allButtons.forEach((button) => {
      if (button.textContent === currentCorrectAnswer) {
        button.classList.add("correct");
      } else if (!isCorrect && event && event.target && button.textContent === event.target.textContent) {
        button.classList.add("wrong");
      }
    });
    
    saveProgress();
    
    // Use a promise to ensure proper timing and button state clearance
    const transitionDelay = 500; // ms
    
    setTimeout(() => {
      // Clear all button classes before loading next question
      allButtons.forEach(btn => {
        btn.classList.remove("correct", "wrong");
      });
      
      // Check if game is still valid (not a defeated boss)
      if (currentGame && (!currentGame.bossDefeated || !currentGame.isBossLevel)) {
        if (currentGame.currentIndex < currentGame.words.length) {
          startTimer(currentGame.words.length - currentGame.currentIndex);
          
          if (currentGame.isBossLevel) {
            loadNextBossQuestion();
          } else {
            loadNextQuestion();
          }
          
          updatePerkButtons();
        } else if (!currentGame.isBossLevel) {
          if (currentGame.isCustomPractice) {
            handleCustomLevelCompletion();
          } else {
            handleLevelCompletion();
          }
        }
      }
    }, transitionDelay);
    
  } catch (err) {
    console.error("Unexpected error in handleAnswer:", err);
    console.error("Error details:", err.stack);
    
    try {
      if (currentGame && currentGame.currentIndex < currentGame.words.length && !currentGame.bossDefeated) {
        loadNextQuestion();
      } else {
        showScreen("welcome-screen");
      }
    } catch (err) {
      console.error("Failed to recover from error:", err);
      showScreen("welcome-screen");
    }
  }
}

async function handleArcadeAnswer(isCorrect) {
  const now = Date.now();
  if (now - (currentGame.lastAnswerTime || 0) < 1000) {
    return;
  }
  
  currentGame.lastAnswerTime = now;
  const playerName = currentArcadeSession.playerName || 
                     currentUser?.user_metadata?.username || 
                     getRandomSimploName();
  
  if (isCorrect) {
    currentGame.wordsCompleted++;
    currentGame.correctStreak++;
    currentGame.wrongStreak = 0;
    
    // Track the word for registered users
    if (currentUser) {
      const wordIndex = Math.floor(Math.random() * currentGame.words.length);
      const wordObj = currentGame.words[wordIndex];
      const word = wordObj.word || wordObj;
      
      // Track word for any registered user without status check
      await trackWordEncounter(word, 'arcade');
      
      if (window.arcadeChannel) {
        window.arcadeChannel.send({
          type: "broadcast",
          event: "progress_update",
          payload: {
            username: playerName,
            wordsCompleted: currentGame.wordsCompleted,
            coins: gameState.coins || currentGame.coins || 0,
            timestamp: Date.now()
          }
        });
      }
    } else {
      let coinAmount = 5;
      if (currentGame.correctStreak >= 3) {
        coinAmount += 5;
      }
      
      CoinsManager.updateCoins(coinAmount)
        .then(() => {
          window.arcadeChannel && window.arcadeChannel.send({
            type: "broadcast",
            event: "progress_update",
            payload: {
              username: playerName,
              wordsCompleted: currentGame.wordsCompleted,
              coins: gameState.coins,
              timestamp: Date.now()
            }
          });
        });
    }
    
    updateArcadeProgress();
    
    if (currentGame.wordsCompleted >= currentArcadeSession.wordGoal) {
      handlePlayerCompletedGoal(playerName);
    }
  } else {
    // Incorrect answer logic
    // ...
  }
  
  loadNextArcadeQuestion();
}

function checkGameEnd() {
    const completedPlayers = currentArcadeSession.participants
        .filter(p => p.wordsCompleted >= currentArcadeSession.wordGoal)
        .length;
        
    if (completedPlayers >= 3) {
        window.arcadeChannel.send({
            type: 'broadcast',
            event: 'game_end'
        });
    }
}

function handleGameEnd(payload) {
    console.log('Game End Payload:', payload);

    // If no payload, exit
    if (!payload) return;
    
    // Use podiumPlayers if available
    let finalPlayers = payload.podiumPlayers || [];
                    
    if (finalPlayers.length === 0) {
        console.warn('No player data found in game end payload');
        showScreen('welcome-screen');
        return;
    }

    // Ensure we have exactly 3 podium players with ranks 1, 2, 3
    finalPlayers = finalPlayers
        .filter(p => p.rank && p.rank <= 3)
        .sort((a, b) => a.rank - b.rank);

    // Fill missing ranks if needed
    while (finalPlayers.length < 3) {
        finalPlayers.push({
            username: "---",
            wordsCompleted: 0,
            coins: 0,
            rank: finalPlayers.length + 1
        });
    }

    // If forcibly ended by moderator, just go back to welcome
    if (payload.forcedEnd) {
        showScreen('welcome-screen');
        return;
    }

    // If this is the moderator, show victory screen
    if (currentUser?.id === payload.teacherId) {
        showModeratorVictoryScreen(finalPlayers);
        return;
    }

    // Normal end for players - show final results
    showFinalResultsForPlayer(finalPlayers);
}

function showPodiumPlayerResults(players) {
    const playerUsername = currentArcadeSession.playerName;
    const playerRank = currentArcadeSession.podiumRanks[playerUsername].rank;
    
    // Calculate earned coins
    const startingCoins = currentArcadeSession.initialCoins || 0;
    const currentCoins = gameState.coins || currentGame.coins || 0;
    const coinsEarned = currentCoins - startingCoins;
    
    // Get player's words completed
    const wordsCompleted = currentGame.wordsCompleted || 0;
    
    // Create results modal for podium player
    const overlay = document.createElement('div');
    overlay.className = 'arcade-completion-modal';
    
    overlay.innerHTML = `
        <div class="completion-modal-content">
            <h2>Congratulations!</h2>
            <p class="personal-result">You finished in ${getOrdinal(playerRank)} place!</p>
            
            <div class="your-stats">
                <h3>Your Results</h3>
                <div class="completion-stats" style="display: flex; justify-content: space-around; margin: 1.5rem 0;">
                    <div class="stat-item" style="text-align: center;">
                        <i class="fas fa-language" style="font-size: 2rem; color: var(--gold); display: block; margin-bottom: 0.5rem;"></i>
                        <span style="display: block; margin-bottom: 0.25rem;">Words Learned</span>
                        <strong style="font-size: 1.5rem;">${wordsCompleted}</strong>
                    </div>
                    <div class="stat-item" style="text-align: center;">
                        <i class="fas fa-coins" style="font-size: 2rem; color: var(--gold); display: block; margin-bottom: 0.5rem;"></i>
                        <span style="display: block; margin-bottom: 0.25rem;">Coins Earned</span>
                        <strong style="font-size: 1.5rem;">${coinsEarned}</strong>
                    </div>
                    <div class="stat-item" style="text-align: center;">
                        <i class="fas fa-trophy" style="font-size: 2rem; color: var(--gold); display: block; margin-bottom: 0.5rem;"></i>
                        <span style="display: block; margin-bottom: 0.25rem;">Your Rank</span>
                        <strong style="font-size: 1.5rem;">${playerRank}</strong>
                    </div>
                </div>
            </div>
            
            <button onclick="exitArcadeCompletion()" class="start-button">
                Return to Welcome
            </button>
        </div>
    `;
    
    document.body.appendChild(overlay);
    requestAnimationFrame(() => overlay.classList.add('show'));
}

function showConsolationScreen() {
    // Create a simple consolation modal
    const overlay = document.createElement('div');
    overlay.className = 'arcade-completion-modal';
    
    // Random encouraging emoji
    const emojis = ['', '', '', '', '', '', '', ''];
    const randomEmoji = emojis[Math.floor(Math.random() * emojis.length)];
    
    overlay.innerHTML = `
        <div class="completion-modal-content">
            <h2 style="font-size: 3rem; margin-bottom: 1rem;">${randomEmoji}</h2>
            <h2>Game Complete!</h2>
            <p style="font-size: 1.2rem; margin: 1.5rem 0; line-height: 1.5;">
                Great effort! You did your best and gained valuable practice.
                <br><br>
                Keep playing to improve your skills and speed!
            </p>
            <button onclick="exitArcadeCompletion()" class="start-button" style="margin-top: 1.5rem;">
                Return to Welcome
            </button>
        </div>
    `;
    
    document.body.appendChild(overlay);
    requestAnimationFrame(() => overlay.classList.add('show'));
}


function showFinalResultsForPlayer(players) {
    const playerUsername = currentArcadeSession.playerName;
    
    // If player already saw their victory screen (top 3), don't show another
    if (currentArcadeSession.winnerScreenShown && 
        currentArcadeSession.podiumRanks && 
        currentArcadeSession.podiumRanks[playerUsername]) {
        return;
    }
    
    // Check if current player is on podium (rank 1-3)
    const isOnPodium = currentArcadeSession.podiumRanks && 
                       currentArcadeSession.podiumRanks[playerUsername];
    
    if (isOnPodium) {
        // Show detailed results for podium players
        showPodiumPlayerResults(players);
    } else {
        // Show simple consolation screen for non-podium players
        showConsolationScreen();
    }
}

function showPersonalVictoryScreen(rank) {
    if (currentArcadeSession.winnerScreenShown) return;
    currentArcadeSession.winnerScreenShown = true;
    
    console.log(`Showing personal victory screen with rank: ${rank}`);
    
    // Create a personalized victory overlay
    const overlay = document.createElement('div');
    overlay.className = 'arcade-completion-modal';
    
    // Different messages based on rank
    const rankMessages = {
        1: {
            title: " FIRST PLACE! ",
            message: "Incredible! You've claimed the top spot!",
            color: "var(--gold)"
        },
        2: {
            title: " SECOND PLACE! ",
            message: "Amazing job! You've secured second place!",
            color: "var(--silver)"
        },
        3: {
            title: " THIRD PLACE! ",
            message: "Well done! You've earned third place!",
            color: "var(--bronze)"
        }
    };
    
    const message = rankMessages[rank] || {
        title: "Game Complete!",
        message: "You've reached the word goal!",
        color: "var(--accent)"
    };
    
    // Calculate coins earned during this arcade session
    const startingCoins = currentArcadeSession.initialCoins || 0;
    const currentCoins = gameState.coins || currentGame.coins || 0;
    const coinsEarned = currentCoins - startingCoins;
    
    overlay.innerHTML = `
        <div class="completion-modal-content">
            <h2 style="color: ${message.color}">${message.title}</h2>
            <p>${message.message}</p>
            <div class="completion-stats">
                <div class="stat-item">
                    <i class="fas fa-language"></i>
                    <span>Words Learned</span>
                    <strong>${currentGame.wordsCompleted}</strong>
                </div>
                <div class="stat-item">
                    <i class="fas fa-coins"></i>
                    <span>Coins Earned</span>
                    <strong>${coinsEarned}</strong>
                </div>
                <div class="stat-item">
                    <i class="fas fa-trophy"></i>
                    <span>Your Rank</span>
                    <strong>${rank}</strong>
                </div>
            </div>
            <button onclick="exitArcadeCompletion()" class="start-button">
                Return to Welcome
            </button>
        </div>
    `;
    
    document.body.appendChild(overlay);
    requestAnimationFrame(() => overlay.classList.add('show'));
}

function showModeratorVictoryScreen(players) {
    // Clean up any inactivity timers
    if (moderatorActivityTimer) clearTimeout(moderatorActivityTimer);
    if (countdownTimer) clearInterval(countdownTimer);
    
    // Hide inactivity overlay if present
    const overlay = document.querySelector('.inactivity-overlay');
    if (overlay) overlay.remove();
    
    // Use the confetti celebration instead
    startLeaderboardCelebration(players);
}


function showPlayerFinalResults(players) {
    // Find current player's data and rank
    const playerUsername = currentArcadeSession.playerName;
    const currentPlayer = players.find(p => p.username === playerUsername);
    
    // Get player's rank - should be explicitly set in the players array
    const currentPlayerRank = currentPlayer?.rank || 
                            players.findIndex(p => p.username === playerUsername) + 1;
    
    // If we've already shown a victory screen for this player, don't show results
    if (currentArcadeSession.winnerScreenShown && currentPlayerRank <= 3) {
        return;
    }
    
    // Create final results overlay
    const overlay = document.createElement('div');
    overlay.className = 'arcade-completion-modal';
    
    // Get the top 3 players
    const top3 = players
        .filter(p => p.rank <= 3)
        .sort((a, b) => a.rank - b.rank);
    
    // Calculate coins earned during this arcade session
    const startingCoins = currentArcadeSession.initialCoins || 0;
    const currentCoins = gameState.coins || currentGame.coins || 0;
    const coinsEarned = currentCoins - startingCoins;
    
    overlay.innerHTML = `
        <div class="completion-modal-content">
            <h2>Arcade Game Complete!</h2>
            ${currentPlayerRank <= 3 ? 
                `<p class="personal-result">Congratulations! You finished in ${getOrdinal(currentPlayerRank)} place!</p>` : 
                `<p class="personal-result">You earned ${getOrdinal(currentPlayerRank)} place. Better luck next time!</p>`
            }
            <div class="leaderboard-preview">
                <h3>Top Players</h3>
                ${top3.map((player) => `
                    <div class="podium-player rank-${player.rank} ${player.username === playerUsername ? 'current-player' : ''}"
                         style="display: flex; justify-content: space-between; padding: 0.75rem 1rem; margin: 0.5rem 0; 
                                background: ${getPlayerBackground(player.rank, player.username === playerUsername)};
                                border-radius: 10px; color: ${player.rank === 1 ? '#000' : '#fff'};">
                        <div class="player-rank">${player.rank}</div>
                        <div class="player-name">${player.username}</div>
                        <div class="player-stats">
                            <span class="player-words">${player.wordsCompleted || 0} words</span>
                            <span class="player-coins">${player.coins || 0} coins</span>
                        </div>
                    </div>
                `).join('')}
                
                ${currentPlayerRank > 3 ? `
                    <div class="divider" style="border-top: 1px dashed rgba(255,255,255,0.2); margin: 1rem 0;"></div>
                    <div class="current-player-row podium-player"
                         style="display: flex; justify-content: space-between; padding: 0.75rem 1rem; margin: 0.5rem 0; 
                                background: rgba(255,255,255,0.1); border: 1px solid var(--accent);
                                border-radius: 10px; color: var(--text);">
                        <div class="player-rank">${currentPlayerRank}</div>
                        <div class="player-name">${playerUsername}</div>
                        <div class="player-stats">
                            <span class="player-words">${currentPlayer?.wordsCompleted || 0} words</span>
                            <span class="player-coins">${currentPlayer?.coins || 0} coins</span>
                        </div>
                    </div>
                ` : ''}
            </div>
            <div class="your-stats">
                <h3>Your Results</h3>
                <div class="completion-stats" style="display: flex; justify-content: space-around; margin: 1.5rem 0;">
                    <div class="stat-item" style="text-align: center;">
                        <i class="fas fa-language" style="font-size: 2rem; color: var(--gold); display: block; margin-bottom: 0.5rem;"></i>
                        <span style="display: block; margin-bottom: 0.25rem;">Words Learned</span>
                        <strong style="font-size: 1.5rem;">${currentPlayer?.wordsCompleted || 0}</strong>
                    </div>
                    <div class="stat-item" style="text-align: center;">
                        <i class="fas fa-coins" style="font-size: 2rem; color: var(--gold); display: block; margin-bottom: 0.5rem;"></i>
                        <span style="display: block; margin-bottom: 0.25rem;">Coins Earned</span>
                        <strong style="font-size: 1.5rem;">${coinsEarned}</strong>
                    </div>
                    <div class="stat-item" style="text-align: center;">
                        <i class="fas fa-trophy" style="font-size: 2rem; color: var(--gold); display: block; margin-bottom: 0.5rem;"></i>
                        <span style="display: block; margin-bottom: 0.25rem;">Your Rank</span>
                        <strong style="font-size: 1.5rem;">${currentPlayerRank}</strong>
                    </div>
                </div>
            </div>
            <button onclick="exitArcadeCompletion()" class="start-button">
                Return to Welcome
            </button>
        </div>
    `;
    
    document.body.appendChild(overlay);
    requestAnimationFrame(() => overlay.classList.add('show'));
    
    // Helper function for podium background colors
    function getPlayerBackground(rank, isCurrentPlayer) {
        const backgrounds = {
            1: 'linear-gradient(135deg, #FFD700 0%, #FFC800 100%)', // 1st place - gold
            2: 'linear-gradient(135deg, #C0C0C0 0%, #A9A9A9 100%)', // 2nd place - silver
            3: 'linear-gradient(135deg, #CD7F32 0%, #B87333 100%)'  // 3rd place - bronze
        };
        
        if (isCurrentPlayer) {
            return (backgrounds[rank] || 'rgba(255,255,255,0.1)') + 
                   '; border: 2px solid white; box-shadow: 0 0 15px rgba(255,255,255,0.5)';
        }
        
        return backgrounds[rank] || 'rgba(255,255,255,0.1)';
    }
}

function removePlayer(username) {
    // Remove player from current arcade session
    currentArcadeSession.participants = currentArcadeSession.participants.filter(
        player => player.username !== username
    );
    
    // Broadcast player removal
    if (window.arcadeChannel) {
        window.arcadeChannel.send({
            type: 'broadcast',
            event: 'player_removed',
            payload: { username }
        });
    }
    
    // Update leaderboard
    updateAllPlayersProgress();
}

function toggleSidePanel() {
    const sidePanel = document.querySelector('.side-panel');
    const hamburgerButton = document.querySelector('.hamburger-button');
    const modalOverlay = document.querySelector('.modal-overlay');
    
    if (sidePanel.classList.contains('open')) {
        sidePanel.classList.remove('open');
        hamburgerButton.classList.remove('open');
        if (modalOverlay) modalOverlay.classList.remove('open');
    } else {
        sidePanel.classList.add('open');
        hamburgerButton.classList.add('open');
        if (modalOverlay) modalOverlay.classList.add('open');
    }
}

function showAuthModal() {
    const modal = document.getElementById('authModal');
    if (modal) {
        modal.classList.add('open');
    }
}

function hideAuthModal() {
    const modal = document.getElementById('authModal');
    if (modal) {
        modal.classList.remove('open');
    }
}

function updateAuthUI() {
    const sidePanel = document.querySelector('.side-panel');
    const userProfileSection = document.querySelector('.user-profile-section');
    const userEmailElement = document.getElementById('userEmail');
    const logoutButton = document.querySelector('.logout-button');
    const mainLoginButton = document.querySelector('.main-button');

    if (currentUser) {
        // Show side panel elements
        if (userProfileSection) userProfileSection.style.display = 'block';
        if (logoutButton) logoutButton.style.display = 'block';
        
        // Update username/email display
        if (userEmailElement) {
            userEmailElement.textContent = currentUser.user_metadata?.username || currentUser.email;
        }
        
        // Hide main login button
        if (mainLoginButton) {
            mainLoginButton.style.display = 'none';
        }
        
        // Update stats
        updateUserStats();
    } else {
        // Hide user info and logout in side panel
        if (userProfileSection) userProfileSection.style.display = 'none';
        if (logoutButton) logoutButton.style.display = 'none';
        
        // Show main login button
        if (mainLoginButton) {
            mainLoginButton.style.display = 'block';
        }
    }
}

function showAuthModal() {
    const modal = document.getElementById('authModal');
    if (modal) {
        modal.classList.add('show');
    }
}

function hideAuthModal() {
    const modal = document.getElementById('authModal');
    if (modal) {
        modal.classList.remove('show');
    }
}

// Add click outside handler for auth modal
document.addEventListener('click', (e) => {
    const authModal = document.getElementById('authModal');
    const authContent = authModal?.querySelector('.auth-modal-content');
    const arcadeModal = document.getElementById('arcade-modal');
    const arcadeContent = arcadeModal?.querySelector('.modal-content');
    
    // Handle auth modal
    if (authModal?.classList.contains('show') && 
        !authContent.contains(e.target) && 
        !e.target.matches('.main-button')) {
        hideAuthModal();
    }
    
    // Handle arcade modal
    if (arcadeModal?.style.display === 'block' && 
        !arcadeContent.contains(e.target) && 
        !e.target.matches('.arcade-button')) {
        arcadeModal.style.display = 'none';
    }
});

// Update toggle auth mode function
function toggleAuthMode() {
    const loginForm = document.getElementById('loginForm');
    const signupForm = document.getElementById('signupForm');
    
    loginForm.classList.toggle('hidden');
    signupForm.classList.toggle('hidden');
}

function updateGuestPlayButton() {
    const guestPlayButton = document.querySelector('.guest-play-button');
    
    if (!currentUser || (currentUser && currentUser.status === 'unregistered')) {
        guestPlayButton.textContent = 'Play as Guest';
    } else {
        guestPlayButton.textContent = 'Start Game';
    }
}

function showPricesScreen() {
    // TODO: Implement prices screen
    alert('Prices screen coming soon!');
}

function showRightsAndPolicies() {
    // TODO: Implement rights and policies page
    alert('Rights & Policies page coming soon!');
}

function showAboutPage() {
    // TODO: Implement about page
    alert('About page coming soon!');
}

function showContactUs() {
    // TODO: Implement contact us functionality
    alert('Contact Us page coming soon!');
}

function animateNumber(element, start, end, duration = 500) {
    // Ensure start and end are numbers
    start = Number(start);
    end = Number(end);
    
    // If start and end are the same, just set the value
    if (start === end) {
        element.textContent = end;
        return;
    }

    const difference = end - start;
    const frames = 30; // Increased for smoother animation
    const step = difference / frames;
    let current = start;
    let frameCount = 0;
    
    function updateNumber() {
        current += step;
        frameCount++;
        
        // Round to handle floating point imprecision
        if (frameCount >= frames || 
            (step > 0 && current >= end) || 
            (step < 0 && current <= end)) {
            element.textContent = Math.round(end);
            return;
        }
        
        element.textContent = Math.round(current);
        requestAnimationFrame(updateNumber);
    }
    
    requestAnimationFrame(updateNumber);
}

function showNotification(message, type) {
    const notification = document.createElement('div');
    notification.className = `game-notification ${type}`;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    setTimeout(() => notification.classList.add('show'), 10);
    
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
    }, 2000);
}

function createParticles(x, y, type) {
    const particleCount = 15;
    const colors = type === 'blessing' ? 
        ['#3498db', '#2980b9', '#1abc9c'] : 
        ['#e74c3c', '#c0392b', '#d35400'];
    
    for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = `particle ${type}`;
        
        const size = Math.random() * 8 + 4;
        const angle = (Math.random() * Math.PI * 2);
        const velocity = Math.random() * 100 + 50;
        
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.borderRadius = '50%';
        particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        particle.style.position = 'fixed';
        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;
        
        document.body.appendChild(particle);
        
        const destinationX = x + Math.cos(angle) * velocity;
        const destinationY = y + Math.sin(angle) * velocity;
        
        particle.animate([
            { transform: 'translate(0, 0) scale(1)', opacity: 1 },
            { transform: `translate(${destinationX - x}px, ${destinationY - y}px) scale(0)`, opacity: 0 }
        ], {
            duration: 1000,
            easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
        }).onfinish = () => particle.remove();
    }
}

async function joinArcadeWithUsername() {
    const usernameInput = document.getElementById('arcadeUsername');
    const otpInput = document.getElementById('otpInput');
    
    // Get username either from input or from current user
    let username;
    if (currentUser) {
        username = currentUser.user_metadata?.username || 
                  currentUser.email.split('@')[0];
    } else {
        username = usernameInput.value.trim();
        
        // Username validation for guest users
        if (!username || username.length < 2 || username.length > 15) {
            showErrorToast('Username must be between 2 and 15 characters');
            usernameInput.focus();
            return;
        }

        // Validate username characters
        const validUsernameRegex = /^[a-zA-Z0-9\u0590-\u05FF\s._-]+$/;
        if (!validUsernameRegex.test(username)) {
            showErrorToast('Username can contain letters, numbers, spaces, periods, underscores, and hyphens');
            usernameInput.focus();
            return;
        }
    }
    
    const otp = otpInput.value.trim();
    
    // OTP validation
    if (!otp || otp.length !== 4 || !/^\d+$/.test(otp)) {
        showErrorToast('Please enter a valid 4-digit game code');
        otpInput.focus();
        return;
    }

    try {
        // Get initial coins for registered users
        let initialCoins = 0;
        if (currentUser) {
            try {
                const { data, error } = await supabaseClient
                    .from('game_progress')
                    .select('coins')
                    .eq('user_id', currentUser.id)
                    .single();
                    
                if (!error && data) {
                    initialCoins = data.coins;
                    console.log('Retrieved initial coins:', initialCoins);
                }
            } catch (error) {
                console.error('Failed to load initial coins:', error);
            }
        }

        // Create Supabase channel for the specific arcade session
        window.arcadeChannel = supabaseClient.channel(`arcade:${otp}`);
        
        // Set player name and initial state
        currentArcadeSession.playerName = username;
        currentArcadeSession.initialCoins = initialCoins;
        currentArcadeSession.otp = otp;
        
        // First, subscribe to channel
        await window.arcadeChannel.subscribe();
        
        // Set up celebration handler after channel initialization
        setupCelebrationHandler();
        
        // Set up standard event listeners
        window.arcadeChannel
            .on('broadcast', { event: 'game_end' }, ({ payload }) => {
                handleGameEnd(payload);
                currentArcadeSession.state = 'ended';
            })
            .on('broadcast', { event: 'game_playing' }, ({ payload }) => {
                if (payload.state === 'active') {
                    currentArcadeSession.state = 'active';
                    currentArcadeSession.wordPool = payload.wordPool;
                    currentArcadeSession.wordGoal = payload.wordGoal;
                    startArcadeGame();
                }
            })
            .on('broadcast', { event: 'player_join' }, ({ payload }) => {
                console.log('Player join event received:', payload);
                if (!currentArcadeSession.participants.find(p => p.username === payload.username)) {
                    currentArcadeSession.participants.push({
                        username: payload.username,
                        wordsCompleted: 0,
                        coins: 0
                    });

                    // Update player count 
                    const playerCountElement = document.getElementById('player-count');
                    if (playerCountElement) {
                        playerCountElement.textContent = currentArcadeSession.participants.length;
                    }

                    // Update leaderboard if visible
                    const leaderboard = document.getElementById('arcade-leaderboard');
                    if (leaderboard && leaderboard.offsetParent !== null) {
                        updateAllPlayersProgress();
                    }
                }
            });
        
        // Set up game state check listener
        window.arcadeChannel.on('broadcast', { event: 'game_state_response' }, ({ payload }) => {
            console.log('Received game state response:', payload);
            if (payload && payload.state === 'active') {
                // Game is active, store state 
                currentArcadeSession.state = 'active';
                currentArcadeSession.wordPool = payload.wordPool;
                currentArcadeSession.wordGoal = payload.wordGoal;
                
                // If we've already sent the join event, go straight to game
                if (currentArcadeSession.joinEventSent) {
                    // Hide arcade modal first
                    document.getElementById('arcade-modal').style.display = 'none';
                    startArcadeGame();
                }
            }
        });

        // Broadcast initial join
        await window.arcadeChannel.send({
            type: 'broadcast',
            event: 'player_join',
            payload: {
                username: username,
                type: 'initialJoin',
                coins: initialCoins,
                joinedAt: new Date().toISOString()
            }
        });
        currentArcadeSession.joinEventSent = true;
        
        // Now check if game is active
        await window.arcadeChannel.send({
            type: 'broadcast',
            event: 'check_game_status',
            payload: {
                username: username,
                requestType: 'lateJoin',
                timestamp: Date.now()
            }
        });
        
        // Hide arcade modal
        document.getElementById('arcade-modal').style.display = 'none';
        
        // Wait a moment to see if we get a response indicating the game is active
        setTimeout(() => {
            // If state has been updated to active by a response, startArcadeGame will have been called
            // Otherwise, show waiting screen
            if (currentArcadeSession.state !== 'active') {
                showWaitingScreen();
            }
        }, 500);

    } catch (error) {
        console.error('Join arcade error:', error);
        showErrorToast('Failed to join arcade. Please try again.');
    }
}

const powerupPool = {
    highFive: {
        id: 'highFiveCard',
        cost: 30,
        effect: 50,
        type: 'goodie',
        icon: 'fa-hand-paper',
        name: 'High Five',
        message: 'high-fived'
    },
    fistBump: {
        id: 'fistBumpCard',
        cost: 40,
        effect: 75,
        type: 'goodie',
        icon: 'fa-fist-raised',
        name: 'Fist Bump',
        message: 'fist-bumped'
    },
    energyBoost: {
        id: 'energyBoostCard',
        cost: 45,
        type: 'goodie',
        icon: 'fa-bolt',
        name: 'Energy Boost',
        message: 'boosted'
    },
    freeze: {
        id: 'freezeCard',
        cost: 150,
        duration: 10000,
        type: 'baddie',
        icon: 'fa-snowflake',
        name: 'Freeze',
        message: 'froze'
    },
    coinStorm: {
        id: 'coinStormCard',
        cost: 160,
        duration: 3,
        type: 'baddie',
        icon: 'fa-cloud-showers-heavy',
        name: 'Coin Storm',
        message: 'cast a coin storm on'
    },
    screenShake: {
        id: 'screenShakeCard',
        cost: 130,
        duration: 5000,
        type: 'baddie',
        icon: 'fa-shake',
        name: 'Screen Shake',
        message: 'shook'
    }
};

function initializePowerups() {
    const powerupPool = {
        highFive: {
            id: 'highFiveCard',
            cost: 30,
            effect: 50,
            type: 'goodie',
            icon: 'fa-hand-paper',
            name: 'High Five',
            message: 'high-fived'
        },
        fistBump: {
            id: 'fistBumpCard',
            cost: 40,
            effect: 75,
            type: 'goodie',
            icon: 'fa-fist-raised',
            name: 'Fist Bump',
            message: 'fist-bumped'
        },
        energyBoost: {
            id: 'energyBoostCard',
            cost: 45,
            type: 'goodie',
            icon: 'fa-bolt',
            name: 'Energy Boost',
            message: 'boosted'
        },
        freeze: {
            id: 'freezeCard',
            cost: 150,
            duration: 10000,
            type: 'baddie',
            icon: 'fa-snowflake',
            name: 'Freeze',
            message: 'froze'
        },
        coinStorm: {
            id: 'coinStormCard',
            cost: 160,
            type: 'baddie',
            icon: 'fa-cloud-showers-heavy',
            name: 'Coin Storm',
            message: 'cast a coin storm on'
        },
        screenShake: {
            id: 'screenShakeCard',
            cost: 130,
            duration: 5000,
            type: 'baddie',
            icon: 'fa-shake',
            name: 'Screen Shake',
            message: 'shook'
        }
    };

    function getRandomPowerups(count = 3) {
        const powerupKeys = Object.keys(powerupPool);
        const selectedKeys = [];
        while (selectedKeys.length < count && powerupKeys.length > 0) {
            const randomIndex = Math.floor(Math.random() * powerupKeys.length);
            selectedKeys.push(powerupKeys.splice(randomIndex, 1)[0]);
        }
        return selectedKeys;
    }

    function renderPowerups() {
        const container = document.querySelector('.powerups-container');
        if (!container) return;
        
        container.innerHTML = '';
        const selectedPowerups = getRandomPowerups(3);
        
        selectedPowerups.forEach(key => {
            const powerup = powerupPool[key];
            const card = document.createElement('div');
            card.className = `powerup-card ${powerup.type}`;
            card.id = powerup.id;
            
            card.innerHTML = `
                <i class="fas ${powerup.icon} powerup-icon"></i>
                <div class="powerup-name">${powerup.name}</div>
                <div class="powerup-cost">${powerup.cost}</div>
            `;
            
            card.onclick = async () => {
                console.log('Powerup clicked:', powerup.name); // Debug log
                
                if (currentGame.coins < powerup.cost) {
                    showNotification('Not enough coins!', 'error');
                    return;
                }
                
                // Change this section in the card.onclick function:
                const otherPlayers = currentArcadeSession.participants.filter(
            p => p.username !== currentArcadeSession.playerName && 
                 p.username !== undefined && 
                 p.username !== null
        );

        if (otherPlayers.length === 0) {
            showNotification('Waiting for other players to join...', 'info');
            return;
        }
                
                const targetPlayer = otherPlayers[Math.floor(Math.random() * otherPlayers.length)];
                
                // Deduct coins immediately
                const oldCoins = currentGame.coins;
                currentGame.coins -= powerup.cost;
                
                // Update coins display
                document.querySelectorAll('.coin-count').forEach(display => {
                    display.textContent = currentGame.coins;
                });
                
                try {
                    // Send powerup effect
                    await window.arcadeChannel.send({
                        type: 'broadcast',
                        event: 'powerup_effect',
                        payload: {
                            powerupKey: key,
                            targetUser: targetPlayer.username,
                            fromUser: currentArcadeSession.playerName,
                            powerup: powerup
                        }
                    });
                    
                    // Show feedback
                    showNotification(`Used ${powerup.name} on ${targetPlayer.username}!`, powerup.type);
                    
                    // Update progress
                    await window.arcadeChannel.send({
                        type: 'broadcast',
                        event: 'progress_update',
                        payload: {
                            username: currentArcadeSession.playerName,
                            wordsCompleted: currentGame.wordsCompleted,
                            coins: currentGame.coins,
                            timestamp: Date.now()
                        }
                    });
                    
                    // Get new powerups
                    renderPowerups();
                    
                } catch (error) {
                    console.error('Powerup use error:', error);
                    // Revert coins if failed
                    currentGame.coins = oldCoins;
                    document.querySelectorAll('.coin-count').forEach(display => {
                        display.textContent = oldCoins;
                    });
                    showNotification('Failed to use powerup!', 'error');
                }
            };
            
            container.appendChild(card);
        });
        
        updatePowerupAvailability();
    }

    function updatePowerupAvailability() {
        document.querySelectorAll('.powerup-card').forEach(card => {
            const costElement = card.querySelector('.powerup-cost');
            if (!costElement) return;
            
            const cost = parseInt(costElement.textContent);
            const canAfford = currentGame.coins >= cost;
            
            card.classList.toggle('disabled', !canAfford);
            card.style.cursor = canAfford ? 'pointer' : 'not-allowed';
            card.style.opacity = canAfford ? '1' : '0.5';
        });
    }

    // Initialize first set of powerups
    renderPowerups();
    
    // Watch for coin changes
    const coinDisplay = document.querySelector('.coin-count');
    if (coinDisplay) {
        new MutationObserver(() => {
            updatePowerupAvailability();
        }).observe(coinDisplay, { childList: true, characterData: true, subtree: true });
    }
    
    // Initial availability check
    updatePowerupAvailability();
}

function requestFullscreenMode() {
    const root = document.documentElement;
    
    // Check if the device is mobile
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    
    if (!isMobile) return; // Only proceed for mobile devices
    
    // Try different fullscreen methods
    if (root.requestFullscreen) {
        root.requestFullscreen().catch(err => console.log('Fullscreen request failed:', err));
    } else if (root.webkitRequestFullscreen) {
        root.webkitRequestFullscreen().catch(err => console.log('Fullscreen request failed:', err));
    } else if (root.msRequestFullscreen) {
        root.msRequestFullscreen().catch(err => console.log('Fullscreen request failed:', err));
    }
}

function generateQRCode(otp) {
    // Get the base URL without any parameters or hash
    const baseUrl = window.location.origin + window.location.pathname;
    const joinUrl = `${baseUrl}#join=${otp}`;
    
    // Add console logging for debugging
    console.log('Generating QR code with URL:', joinUrl);
    
    new QRious({
        element: document.getElementById('qrCode'),
        value: joinUrl,
        size: 200,
        backgroundAlpha: 1,
        foreground: '#16213e',
        background: '#ffffff',
        level: 'H'
    });
}

function handleHashChange() {
    console.log('Hash change detected:', window.location.hash);
    
    if (window.location.hash.startsWith('#join=')) {
        const otp = window.location.hash.replace('#join=', '');
        console.log('Join OTP detected:', otp);
        
        // Show landing page on mobile
        if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
            const qrLanding = document.getElementById('qr-landing');
            const codeDisplay = qrLanding.querySelector('.game-code-display');
            
            // Hide all other screens
            document.querySelectorAll('.screen').forEach(screen => {
                screen.style.display = 'none';
            });
            
            // Show and populate landing page
            qrLanding.style.display = 'flex';
            codeDisplay.textContent = otp;
            
            // Store OTP for later use
            qrLanding.dataset.otp = otp;
        } else {
            // Desktop behavior
            history.pushState("", document.title, window.location.pathname);
            showJoinModal(otp);
        }
    }
}

function proceedToGame() {
    const qrLanding = document.getElementById('qr-landing');
    const otp = qrLanding.dataset.otp;
    
    // Hide landing page
    qrLanding.style.display = 'none';
    
    // Show join modal with OTP
    showJoinModal(otp);
}

function showJoinModal(otp = '') {
    console.log('Showing join modal with OTP:', otp);  // Add logging
    const modal = document.getElementById('arcade-modal');
    const teacherView = document.getElementById('teacher-view');
    const playerView = document.getElementById('player-view');
    const otpInput = document.getElementById('otpInput');
    
    if (modal) {
        modal.style.display = 'block';
        if (teacherView) teacherView.style.display = 'none';
        if (playerView) playerView.style.display = 'block';
        
        if (otpInput && otp) {
            otpInput.value = otp;
            // Focus username input if it exists
            const usernameInput = document.getElementById('arcadeUsername');
            if (usernameInput) {
                usernameInput.focus();
            }
        }
    }
}

function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `game-notification ${type}`;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    requestAnimationFrame(() => notification.classList.add('show'));
    
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
    }, 3000);
}

function switchAuthForm(type) {
    const loginForm = document.getElementById('loginForm');
    const signupForm = document.getElementById('signupForm');
    
    if (type === 'signup') {
        loginForm.classList.add('hidden');
        signupForm.classList.remove('hidden');
    } else {
        loginForm.classList.remove('hidden');
        signupForm.classList.add('hidden');
    }
}

async function combineCustomLists(listIds) {
    if (!currentUser?.role === 'teacher') return;
    
    const combinedList = {
        id: Date.now(),
        name: 'Combined List',
        words: [],
        translations: [],
        isTeacherList: true
    };
    
    // Merge selected lists
    for (const listId of listIds) {
        const list = customPracticeLists.lists.find(l => l.id === listId);
        if (list) {
            combinedList.words.push(...list.words);
            combinedList.translations.push(...list.translations);
        }
    }
    
    return combinedList;
}

async function convertListToArcade(listId) {
    if (!currentUser?.role === 'teacher') return;
    
    const list = customPracticeLists.lists.find(l => l.id === listId);
    if (!list) return;
    
    // Create arcade configuration
    const arcadeConfig = {
        wordPool: list.words.map((word, index) => ({
            word: word,
            translation: list.translations[index]
        })),
        isCustomArcade: true,
        teacherId: currentUser.id,
        listId: listId
    };
    
    return arcadeConfig;
}

function initializeBossLevel() {
    console.log("Initializing boss level");
    
    // Create boss timer
    const { container: timerContainer, display: timerDisplay } = createBossTimer();
    document.getElementById('question-screen').appendChild(timerContainer);
    
    currentGame.bossFirstHealthRestored = false;
    currentGame.bossSecondHealthRestored = false;
    
    applyBossLevelStyles();
    
    document.querySelectorAll(".perk-button").forEach((e) => {
        if (e) {
            e.disabled = true;
            e.style.opacity = "0.3";
            
            const disabledOverlay = document.createElement("div");
            disabledOverlay.className = "perk-disabled";
            disabledOverlay.innerHTML = "";
            disabledOverlay.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 1.5em;
                color: red;
                pointer-events: none;
            `;
            
            e.style.position = 'relative';
            e.appendChild(disabledOverlay);
        }
    });
    
    const progressCircle = document.querySelector(".progress-circle");
    if (progressCircle) {
        const progressElement = progressCircle.querySelector(".progress");
        if (progressElement) {
            progressElement.style.stroke = "#4CAF50";
        }
    }
    
    // Set timer update logic in startTimer
    currentGame.updateBossTimer = (timeRemaining) => {
        const timerDisplay = document.querySelector('#boss-timer div');
        updateBossTimer(timerDisplay, timeRemaining);
    };
    
    setTimeout(applyBossLevelStyles, 100);
    setTimeout(applyBossLevelStyles, 500);
    
    console.log("Boss level initialization complete");
}


function replaceCoinWithBossOrb() {
  const coinsContainer = document.querySelector('.coins-container');
  if (!coinsContainer) {
    console.error("Coins container not found");
    return;
  }
  
  // Create boss orb
  const bossOrb = document.createElement('div');
  bossOrb.className = 'boss-orb';
  bossOrb.innerHTML = `<div class="boss-orb-inner"></div>`;
  
  // Apply direct styles
  bossOrb.style.cssText = `
    position: absolute;
    width: 60px;
    height: 60px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10;
  `;
  
  bossOrb.querySelector('.boss-orb-inner').style.cssText = `
    width: 50px;
    height: 50px;
    background: radial-gradient(circle at 30% 30%, #ff3333, #990000);
    border-radius: 50%;
    box-shadow: 0 0 20px #ff3333, inset 0 0 10px rgba(255,255,255,0.3);
    animation: pulseOrb 2s infinite;
  `;
  
  // Add animation for orb
  const orbStyle = document.createElement('style');
  orbStyle.innerHTML = `
    @keyframes pulseOrb {
      0%, 100% { transform: scale(1); filter: brightness(1); }
      50% { transform: scale(1.1); filter: brightness(1.2); }
    }
  `;
  document.head.appendChild(orbStyle);
  
  // Clear existing content and add boss orb
  coinsContainer.innerHTML = '';
  coinsContainer.appendChild(bossOrb);
}

function initializeBossHealthBar() {
  const progressCircle = document.querySelector('.progress-circle');
  if (!progressCircle) return;
  
  const progress = progressCircle.querySelector('.progress');
  if (!progress) return;
  
  // Start with full health - bright green
  progress.style.stroke = '#4CAF50';
  
  // Add health warning animation style
  const healthStyle = document.createElement('style');
  healthStyle.innerHTML = `
    .progress.warning {
      animation: healthWarning 0.8s infinite alternate;
    }
    @keyframes healthWarning {
      from { stroke: #ff3333; }
      to { stroke: #ffffff; }
    }
  `;
  document.head.appendChild(healthStyle);
}

function addBossLevelStyles() {
  // Remove existing styles first
  const existingStyle = document.getElementById('boss-level-style');
  if (existingStyle) {
    existingStyle.remove();
  }
  
  const bossStyle = document.createElement('style');
  bossStyle.id = 'boss-level-style';
  bossStyle.innerHTML = `
    .boss-mode {
      background: linear-gradient(135deg, #800000, #3a0000) !important;
    }
    
    @keyframes pulseBg {
      0%, 100% { filter: brightness(1); }
      50% { filter: brightness(1.2); }
    }
    
    .boss-orb {
      position: relative;
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .boss-orb-inner {
      width: 50px;
      height: 50px;
      background: radial-gradient(circle at 30% 30%, #ff3333, #990000);
      border-radius: 50%;
      position: relative;
      box-shadow: 0 0 20px #ff3333, inset 0 0 10px rgba(255,255,255,0.3);
      animation: pulseOrb 2s infinite;
    }
    
    .boss-orb-glow {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.3), transparent 70%);
      animation: rotateGlow 3s linear infinite;
    }
    
    @keyframes pulseOrb {
      0%, 100% { transform: scale(1); filter: brightness(1); }
      50% { transform: scale(1.1); filter: brightness(1.2); }
    }
    
    @keyframes rotateGlow {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .boss-health {
      transition: stroke 0.3s ease, stroke-dashoffset 0.5s ease;
    }
    
    .boss-health.warning {
      animation: healthWarning 0.8s infinite alternate;
    }
    
    @keyframes healthWarning {
      from { stroke: #ff3333; }
      to { stroke: #ffffff; }
    }
    
    .boss-word {
      color: #ff3333;
      text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
      animation: pulseWord 2s infinite;
    }
    
    @keyframes pulseWord {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    .boss-hit {
      animation: bossHitEffect 0.3s;
    }
    
    @keyframes bossHitEffect {
      0% { transform: scale(1); }
      50% { transform: scale(1.02); filter: brightness(1.3); }
      100% { transform: scale(1); }
    }
    
    .boss-orb-hit {
      animation: bossOrbHit 0.3s;
    }
    
    @keyframes bossOrbHit {
      0% { transform: scale(1); }
      50% { transform: scale(1.3); filter: brightness(1.5); }
      100% { transform: scale(1); }
    }
    
    .boss-restore-health {
      animation: bossRestoreHealth 1s;
    }
    
    @keyframes bossRestoreHealth {
      0% { filter: brightness(1); }
      50% { filter: brightness(2); }
      100% { filter: brightness(1); }
    }
    
    .boss-defeated {
      animation: bossDefeated 2s forwards;
    }
    
    @keyframes bossDefeated {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); opacity: 0.7; filter: brightness(2); }
      100% { transform: scale(0); opacity: 0; }
    }
    
    .raining-letter {
      position: absolute;
      color: rgba(255, 0, 0, 0.3);
      font-size: 16px;
      animation: letterRain linear forwards;
      z-index: 1;
    }
    
    @keyframes letterRain {
      0% { transform: translateY(-20px); opacity: 0; }
      10% { opacity: 0.7; }
      90% { opacity: 0.7; }
      100% { transform: translateY(100vh); opacity: 0; }
    }
    
    .boss-victory {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #00c6ff, #0072ff);
      padding: 2rem;
      border-radius: 20px;
      text-align: center;
      box-shadow: 0 0 30px rgba(0, 198, 255, 0.5);
      z-index: 1000;
      max-width: 500px;
      width: 90%;
    }
    
    .boss-victory h2 {
      font-size: 2rem;
      color: white;
      margin-bottom: 1rem;
    }
    
    .boss-victory p {
      font-size: 1.2rem;
      color: rgba(255, 255, 255, 0.9);
      margin-bottom: 2rem;
    }
    
    .victory-buttons {
      display: flex;
      justify-content: center;
      gap: 1rem;
    }
    
    .victory-button {
      padding: 1rem 2rem;
      border: none;
      border-radius: 50px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .victory-button.continue {
      background: #4CAF50;
      color: white;
    }
    
    .victory-button.home {
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: 2px solid white;
    }
    
    .victory-button:hover {
      transform: translateY(-5px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }
    
    .incineration-effect {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(circle, #ff9900, #ff3300);
      opacity: 0;
      transform: scale(0);
      animation: incinerateEffect 2s forwards;
    }
    
    @keyframes incinerateEffect {
      0% { transform: scale(0); opacity: 0; }
      10% { transform: scale(0.5); opacity: 0.8; }
      50% { transform: scale(1.5); opacity: 1; }
      100% { transform: scale(3); opacity: 0; }
    }
  `;
  
  document.head.appendChild(bossStyle);
}

function updateBossHealthBar() {
  // Only update if we're in boss level
  if (!currentGame.isBossLevel) return false;
  
  console.log("Updating boss health bar");

  const progressCircle = document.querySelector('.progress-circle');
  if (!progressCircle) {
    console.error("Progress circle not found");
    return false;
  }
  
  const progress = progressCircle.querySelector('.progress');
  if (!progress) {
    console.error("Progress element not found");
    return false;
  }
  
  // Calculate health values
  const totalWords = currentGame.words.length;
  const currentIndex = currentGame.currentIndex || 0;
  const remainingWords = Math.max(0, totalWords - currentIndex);
  const remainingPercentage = remainingWords / totalWords;
  
  console.log(`Boss health: ${(remainingPercentage * 100).toFixed(2)}% (${remainingWords}/${totalWords})`);
  
  // Calculate the circumference
  const circumference = 2 * Math.PI * 54;
  
  // Update the stroke dash offset (reverse of normal progress)
  progress.style.strokeDashoffset = circumference * (1 - remainingPercentage);
  
  // Update boss orb size
  const bossOrb = document.querySelector('.boss-orb-inner');
  if (bossOrb) {
    const minSize = 5;  // Minimum size of the orb
    const maxSize = 50; // Maximum size of the orb
    const currentSize = Math.max(minSize, maxSize * remainingPercentage);
    
    bossOrb.style.width = `${currentSize}px`;
    bossOrb.style.height = `${currentSize}px`;
    
    // Center the shrinking orb
    bossOrb.style.left = `${(50 - currentSize/2)}%`;
    bossOrb.style.top = `${(50 - currentSize/2)}%`;
  }
  
  // Change color based on health
  if (remainingPercentage > 0.66) {
    // Full health - green
    progress.style.stroke = '#4CAF50';
    progress.classList.remove('warning');
  } else if (remainingPercentage > 0.33) {
    // Medium health - yellow/orange
    progress.style.stroke = '#FFA500';
    progress.classList.remove('warning');
    
    // Boss health restoration at 2/3 health (once)
    if (remainingPercentage <= 0.66 && !currentGame.bossFirstHealthRestored) {
      currentGame.bossFirstHealthRestored = true;
      console.log("First boss health restoration");
      
      if (bossOrb) {
        // White flash
        bossOrb.style.background = 'radial-gradient(circle at 30% 30%, white, #FFEB3B)';
        bossOrb.style.transform = 'scale(1.3)';
        bossOrb.style.filter = 'brightness(1.8)';
        
        setTimeout(() => {
          bossOrb.style.transform = '';
          bossOrb.style.filter = '';
          bossOrb.style.background = 'radial-gradient(circle at 30% 30%, #ff3333, #990000)';
        }, 1000);
      }
      
      // Restore health to 75%
      const restoredIndex = Math.floor(totalWords * 0.25); // 75% health
      currentGame.currentIndex = restoredIndex;
      
      // Re-update the health bar after restoration
      setTimeout(() => updateBossHealthBar(), 100);
    }
  } else {
    // Low health - red
    progress.style.stroke = '#FF3333';
    progress.classList.add('warning');
    
    // Boss health restoration at 1/3 health (once)
    if (remainingPercentage <= 0.33 && !currentGame.bossSecondHealthRestored) {
      currentGame.bossSecondHealthRestored = true;
      console.log("Second boss health restoration");
      
      if (bossOrb) {
        // Green-white flash
        bossOrb.style.background = 'radial-gradient(circle at 30% 30%, white, #4CAF50)';
        bossOrb.style.transform = 'scale(1.3)';
        bossOrb.style.filter = 'brightness(1.8)';
        
        setTimeout(() => {
          bossOrb.style.transform = '';
          bossOrb.style.filter = '';
          bossOrb.style.background = 'radial-gradient(circle at 30% 30%, #ff3333, #990000)';
        }, 1000);
      }
      
      // Restore health to 50%
      const restoredIndex = Math.floor(totalWords * 0.5); // 50% health
      currentGame.currentIndex = restoredIndex;
      
      // Re-update the health bar after restoration
      setTimeout(() => updateBossHealthBar(), 100);
    }
  }

  // Only trigger defeat effect here if not already marked as defeated
  if (remainingPercentage <= 0 && !currentGame.bossDefeated) {
    console.log("Boss defeated via health bar check!");
    currentGame.bossDefeated = true;
    return true;
  }
  
  return false;
}

function startBossLevel() {
    showLevelIntro(21, () => {
        initializeBossLevel();
        startTimer(currentGame.words.length * 8); // Less time per word
        loadNextBossQuestion();
    });
}

function loadNextBossQuestion() {
  console.log("Loading next boss question");
  
  // Apply boss styles again to ensure they're active
  setTimeout(applyBossLevelStyles, 100);
  createLightningEffect();
    createBossRainingLetters();

  
  // Get question word element
  const questionWord = document.getElementById('question-word');
  if (questionWord) {
    // Apply boss word styling directly
    questionWord.style.setProperty('color', '#ff3333', 'important');
    questionWord.style.setProperty('text-shadow', '0 0 10px rgba(255, 0, 0, 0.5)', 'important');
    questionWord.style.setProperty('animation', 'pulseWord 2s infinite', 'important');
  }
  
  // Standard word loading with error handling
  try {
    loadNextQuestion();
    
    // Update health bar after loading question
    setTimeout(() => {
      updateBossHealthBar();
    }, 50);
    
    // Randomly reorder buttons to increase difficulty
    const buttonsContainer = document.getElementById('buttons');
    if (buttonsContainer && Math.random() < 0.3) {
      const buttons = Array.from(buttonsContainer.children);
      const shuffled = buttons.sort(() => Math.random() - 0.5);
      shuffled.forEach(button => {
        buttonsContainer.appendChild(button);
      });
    }
  } catch (error) {
    console.error("Error loading boss question:", error);
  }
}

function restoreFromBossLevel() {
  const questionScreen = document.getElementById("question-screen");
  if (questionScreen) {
    // First remove any inline styles
    questionScreen.removeAttribute("style");
    
    // Then apply default styles
    questionScreen.style.background = "radial-gradient(circle at center, var(--secondary) 0%, var(--primary-dark) 100%)";
  }

  const questionWord = document.getElementById("question-word");
  if (questionWord) {
    questionWord.removeAttribute("style");
  }

  if (window.originalCoinsHTML) {
    const coinsContainer = document.querySelector(".coins-container");
    if (coinsContainer) {
      coinsContainer.innerHTML = window.originalCoinsHTML;
    }
  }
  
  // Stop any boss-specific effects
  if (typeof stopBossRainingLetters === 'function') {
    stopBossRainingLetters();
  }
}

function removeInactivePlayer() {
    window.arcadeChannel.send({
        type: 'broadcast',
        event: 'player_inactive',
        payload: {
            username: currentArcadeSession.playerName
        }
    });
}

// Arcade Completion Handling
function handleArcadeCompletion(playerData) {
    const completionRank = currentArcadeSession.participants
        .sort((a, b) => b.wordsCompleted - a.wordsCompleted)
        .findIndex(p => p.username === playerData.username) + 1;

    if (completionRank <= 3) {
        showPersonalizedCompletion(completionRank);
        
        if (completionRank === 3) {
            // End game for all players
            window.arcadeChannel.send({
                type: 'broadcast',
                event: 'game_complete',
                payload: {
                    topThree: currentArcadeSession.participants
                        .sort((a, b) => b.wordsCompleted - a.wordsCompleted)
                        .slice(0, 3)
                }
            });
        }
    }
}

async function handlePlayerCompletedGoal(playerUsername) {
    if (currentArcadeSession.completedPlayers.includes(playerUsername)) {
        return; // Player already completed
    }
    
    // Add player to completed list with timestamp
    const completionTime = Date.now();
    currentArcadeSession.completedPlayers.push(playerUsername);
    
    // Determine player rank based on completion order - ONLY first 3 get ranks
    let playerRank = 0;
    const completionIndex = currentArcadeSession.completedPlayers.indexOf(playerUsername);
    
    if (completionIndex < 3) {
        // First 3 players get podium ranks
        playerRank = completionIndex + 1;
        
        // Initialize podium ranks object if needed
        if (!currentArcadeSession.podiumRanks) {
            currentArcadeSession.podiumRanks = {};
        }
        
        // Store this podium assignment with completion time - these ranks are final
        currentArcadeSession.podiumRanks[playerUsername] = {
            rank: playerRank,
            completionTime: completionTime
        };
        
        console.log(`Player ${playerUsername} earned podium rank ${playerRank}`);
    }
    
    // Update player's data in participants array
    const playerEntry = currentArcadeSession.participants.find(p => p.username === playerUsername);
    if (playerEntry) {
        // Only set rank for podium players (1-3)
        if (playerRank > 0) {
            playerEntry.rank = playerRank;
            playerEntry.completionTime = completionTime;
        }
        playerEntry.wordsCompleted = currentGame.wordsCompleted;
        playerEntry.coins = gameState.coins || currentGame.coins || 0;
        playerEntry.completed = true;
    }
    
    // Broadcast completion 
    await window.arcadeChannel.send({
        type: 'broadcast',
        event: 'player_completed',
        payload: {
            username: playerUsername,
            rank: playerRank,
            wordsCompleted: currentGame.wordsCompleted,
            coins: gameState.coins || currentGame.coins || 0,
            timestamp: completionTime,
            completed: true
        }
    });
    
    // If current player is the one who completed and earned a podium rank,
    // show personal victory screen
    if (playerUsername === currentArcadeSession.playerName && playerRank > 0) {
        showPersonalVictoryScreen(playerRank);
    }
    
    // If this was the third player to complete, end the game for everyone
    if (currentArcadeSession.completedPlayers.length === 3) {
        await endArcadeForAll();
    }
}

function endArcade() {
    // Prevent duplicate celebrations by marking inactive monitoring as finished
    moderatorInactivity.isGameActive = false;
    currentArcadeSession.celebrationTriggered = true;
    
    // Mark game as ended
    currentArcadeSession.state = 'ended';
    currentArcadeSession.endTime = Date.now();
    
    // Handle based on participant count
    if (currentArcadeSession.participants.length >= 3) {
        // Case B: At least 3 players - show celebration with current standings
        const sortedParticipants = [...currentArcadeSession.participants]
            .sort((a, b) => {
                if (b.wordsCompleted !== a.wordsCompleted) {
                    return b.wordsCompleted - a.wordsCompleted;
                }
                return b.coins - a.coins;
            });
        
        const podiumPlayers = sortedParticipants.slice(0, 3).map((player, index) => ({
            ...player,
            rank: index + 1,
            completionTime: Date.now() - (index * 1000)
        }));
        
        // Broadcast game end with winners
        window.arcadeChannel.send({
            type: 'broadcast',
            event: 'game_end',
            payload: {
                state: 'ended',
                podiumPlayers: podiumPlayers,
                teacherId: currentArcadeSession.teacherId,
                forcedEnd: false,
                duration: currentArcadeSession.endTime - (currentArcadeSession.startTime || currentArcadeSession.endTime)
            }
        });
        
        // Show celebration screen
        startLeaderboardCelebration(podiumPlayers);
        
    } else {
        // Case A: Less than 3 players - just end and return to welcome
        window.arcadeChannel.send({
            type: 'broadcast',
            event: 'game_end',
            payload: {
                state: 'ended',
                forcedEnd: true,
                teacherId: currentArcadeSession.teacherId
            }
        });
        
        showScreen('welcome-screen');
    }
    
    // Clean up
    if (window.arcadeChannel) {
        window.arcadeChannel.unsubscribe();
    }
}


function handleGameEnd(payload) {
    console.log('Game End Payload:', payload);

    // If no payload, exit
    if (!payload) return;
    
    // If forcibly ended by moderator, just go back to welcome
    if (payload.forcedEnd) {
        showScreen('welcome-screen');
        return;
    }

    // If this is the moderator, show victory screen with podium players
    if (currentUser?.id === payload.teacherId) {
        const podiumPlayers = payload.podiumPlayers || [];
        showModeratorVictoryScreen(podiumPlayers);
        return;
    }

    // For players: show appropriate completion screen based on their status
    showFinalResultsForPlayer(payload.podiumPlayers || []);
}

function hidePersonalVictoryScreen() {
    const modal = document.querySelector('.arcade-completion-modal');
    if (modal) {
        modal.classList.remove('show');
        setTimeout(() => {
            document.body.removeChild(modal);
        }, 300);
    }
}

async function endArcadeForAll() {
    currentArcadeSession.state = 'ended';
    currentArcadeSession.endTime = Date.now();
    
    // Extract podium players - already ranked during gameplay
    const podiumPlayers = [];
    
    // Convert podiumRanks to array of player objects with rank
    if (currentArcadeSession.podiumRanks) {
        Object.entries(currentArcadeSession.podiumRanks).forEach(([username, data]) => {
            // Find the player data in participants array
            const playerData = currentArcadeSession.participants.find(p => p.username === username);
            if (playerData) {
                podiumPlayers.push({
                    ...playerData,
                    rank: data.rank,
                    completionTime: data.completionTime
                });
            }
        });
    }
    
    // Ensure players are sorted by rank (1, 2, 3)
    podiumPlayers.sort((a, b) => a.rank - b.rank);
    
    // Fill in any missing podium positions
    while (podiumPlayers.length < 3) {
        const rank = podiumPlayers.length + 1;
        podiumPlayers.push({
            username: "---",
            wordsCompleted: 0,
            coins: 0,
            rank: rank
        });
    }
    
    console.log('Final podium players:', podiumPlayers.map(p => ({
        username: p.username,
        rank: p.rank,
        wordsCompleted: p.wordsCompleted
    })));
    
    // Broadcast final rankings with only podium players
    await window.arcadeChannel.send({
        type: 'broadcast',
        event: 'game_end',
        payload: {
            state: 'ended',
            podiumPlayers: podiumPlayers,
            teacherId: currentArcadeSession.teacherId,
            duration: currentArcadeSession.endTime - (currentArcadeSession.startTime || currentArcadeSession.endTime)
        }
    });
    
    // Show final results based on role
    if (currentUser?.id === currentArcadeSession.teacherId) {
        showModeratorVictoryScreen(podiumPlayers);
    } else {
        showFinalResultsForPlayer(podiumPlayers);
    }
}

function showFinalResults(players) {
    // Different behavior for moderator vs player
    if (currentUser?.id === currentArcadeSession.teacherId) {
        showModeratorVictoryScreen(players);
    } else {
        showPlayerFinalResults(players);
    }
}

function getOrdinal(n) {
    const s = ["th", "st", "nd", "rd"];
    const v = n % 100;
    return n + (s[(v - 20) % 10] || s[v] || s[0]);
}

// Add this to moderator screen initialization
function initializeModeratorIdleDetection() {
    let lastUpdateTimestamp = Date.now();
    let idleTimerActive = false;
    let idleCountdown = null;
    let overlayElement = null;
    
    // Function to update the timestamp whenever leaderboard changes
    function updateTimestamp() {
        lastUpdateTimestamp = Date.now();
        
        // If idle timer was active, clear it
        if (idleTimerActive) {
            clearIdleTimer();
        }
    }
    
    // Monitor progress updates and player movements
    function setupActivityMonitoring() {
        // Watch for DOM changes in the leaderboard
        const leaderboardObserver = new MutationObserver(() => {
            updateTimestamp();
        });
        
        const leaderboard = document.getElementById('arcade-leaderboard');
        if (leaderboard) {
            leaderboardObserver.observe(leaderboard, { 
                childList: true, 
                subtree: true,
                attributes: true,
                characterData: true
            });
        }
        
        // Also update timestamp when new progress events come in
        window.arcadeChannel.on('broadcast', { event: 'progress_update' }, () => {
            updateTimestamp();
        });
    }
    
    // Check for inactivity periodically
    const idleCheckInterval = setInterval(() => {
        // Only run if game is active and this is the moderator
        if (currentArcadeSession.state !== 'active' || 
            currentUser?.id !== currentArcadeSession.teacherId) {
            clearInterval(idleCheckInterval);
            return;
        }
        
        const currentTime = Date.now();
        const timeSinceLastUpdate = currentTime - lastUpdateTimestamp;
        
        // If no updates for 5 seconds and timer not already active, start idle timer
        if (timeSinceLastUpdate > 5000 && !idleTimerActive) {
            startIdleTimer();
        }
    }, 1000);
    
    // Create and start the visible countdown timer
    function startIdleTimer() {
        idleTimerActive = true;
        let secondsRemaining = 5;
        
        // Create overlay with timer
        overlayElement = document.createElement('div');
        overlayElement.className = 'idle-timer-overlay';
        overlayElement.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            pointer-events: none;
        `;
        
        const timerContent = document.createElement('div');
        timerContent.style.cssText = `
            background: var(--primary-dark);
            padding: 2rem;
            border-radius: 20px;
            border: 2px solid var(--gold);
            text-align: center;
        `;
        
        const timerTitle = document.createElement('h2');
        timerTitle.textContent = 'Game Inactive';
        timerTitle.style.color = 'var(--gold)';
        
        const timerDisplay = document.createElement('div');
        timerDisplay.className = 'countdown-timer';
        timerDisplay.textContent = secondsRemaining;
        timerDisplay.style.cssText = `
            font-size: 5rem;
            color: var(--gold);
            margin: 1rem 0;
            font-weight: bold;
        `;
        
        const timerMessage = document.createElement('p');
        timerMessage.textContent = 'No activity detected. Returning to welcome screen...';
        
        timerContent.appendChild(timerTitle);
        timerContent.appendChild(timerDisplay);
        timerContent.appendChild(timerMessage);
        overlayElement.appendChild(timerContent);
        document.body.appendChild(overlayElement);
        
        // Start countdown
        idleCountdown = setInterval(() => {
            secondsRemaining--;
            timerDisplay.textContent = secondsRemaining;
            
            if (secondsRemaining <= 0) {
                handleIdleTimeout();
            }
        }, 1000);
    }
    
    // Clear the idle timer
    function clearIdleTimer() {
        idleTimerActive = false;
        
        if (idleCountdown) {
            clearInterval(idleCountdown);
            idleCountdown = null;
        }
        
        if (overlayElement) {
            document.body.removeChild(overlayElement);
            overlayElement = null;
        }
    }
    
    // Handle what happens when timer reaches zero
    function handleIdleTimeout() {
        clearIdleTimer();
        
        // Count completed players
        const completedPlayers = currentArcadeSession.participants.filter(
            p => p.wordsCompleted >= currentArcadeSession.wordGoal
        );
        
        // Case 2: If there are three podium winners, show victory screen
        if (completedPlayers.length >= 3) {
            // Sort players by words completed and coins
            const topPlayers = [...completedPlayers]
                .sort((a, b) => {
                    if (b.wordsCompleted !== a.wordsCompleted) {
                        return b.wordsCompleted - a.wordsCompleted;
                    }
                    return b.coins - a.coins;
                })
                .slice(0, 3)
                .map((player, index) => ({
                    ...player,
                    rank: index + 1
                }));
                
            // Mark game as ended
            currentArcadeSession.state = 'ended';
            
            // Show victory screen
            showModeratorVictoryScreen(topPlayers);
        } 
        // Case 1: Otherwise, return to welcome screen
        else {
            showScreen('welcome-screen');
        }
    }
    
    // Start monitoring
    setupActivityMonitoring();
    
    return {
        clearIdleTimer,
        idleCheckInterval
    };
}

// Global variables for inactivity tracking
let moderatorActivityTimer = null;
let countdownTimer = null;
let lastLeaderboardUpdate = Date.now();
let isCountingDown = false;



function createInactivityOverlay() {
    // Remove any existing overlay
    const existingOverlay = document.querySelector('.inactivity-overlay');
    if (existingOverlay) existingOverlay.remove();
    
    // Create new overlay
    const overlay = document.createElement('div');
    overlay.className = 'inactivity-overlay';
    overlay.innerHTML = `
        <div class="countdown-timer">5</div>
        <div class="inactivity-message">No activity detected. Redirecting...</div>
        <div class="countdown-progress">
            <div class="countdown-bar"></div>
        </div>
        <button class="countdown-cancel">Cancel</button>
    `;
    
    // Add event handler for cancel button
    overlay.querySelector('.countdown-cancel').addEventListener('click', cancelCountdown);
    
    // Append to body
    document.body.appendChild(overlay);
}

function startInactivityMonitoring() {
    // Reset the timer whenever there's activity
    const moderatorScreen = document.getElementById('moderator-screen');
    
    // Activity events to monitor
    const events = ['mousemove', 'mousedown', 'keypress', 'scroll', 'touchstart'];
    
    // Add all event listeners
    events.forEach(event => {
        moderatorScreen.addEventListener(event, resetInactivityTimer);
    });
    
    // Start the initial timer
    resetInactivityTimer();
}

function resetInactivityTimer() {
    // If already counting down, don't reset
    if (isCountingDown) return;
    
    // Clear existing timer
    if (moderatorActivityTimer) clearTimeout(moderatorActivityTimer);
    
    // Set new timer - 3 seconds of inactivity
    moderatorActivityTimer = setTimeout(() => {
        // Check if leaderboard has been updated recently
        const timeSinceLastUpdate = Date.now() - lastLeaderboardUpdate;
        
        // If no updates for 5 seconds, start countdown
        if (timeSinceLastUpdate > 5000) {
            startCountdown();
        }
    }, 3000);
}

function trackLeaderboardUpdates() {
    // Get leaderboard element
    const leaderboard = document.getElementById('arcade-leaderboard');
    if (!leaderboard) return;
    
    // Create mutation observer to detect changes
    const observer = new MutationObserver(() => {
        lastLeaderboardUpdate = Date.now();
        
        // If countdown is active, cancel it since we have activity
        if (isCountingDown) {
            cancelCountdown();
        }
    });
    
    // Start observing
    observer.observe(leaderboard, { 
        childList: true, 
        subtree: true, 
        attributes: true,
        characterData: true
    });
}

function startCountdown() {
    isCountingDown = true;
    
    // Show the overlay
    const overlay = document.querySelector('.inactivity-overlay');
    if (overlay) overlay.classList.add('visible');
    
    // Initialize countdown
    let secondsLeft = 5;
    const timerDisplay = overlay.querySelector('.countdown-timer');
    const progressBar = overlay.querySelector('.countdown-bar');
    
    // Update initial display
    timerDisplay.textContent = secondsLeft;
    progressBar.style.transform = 'scaleX(1)';
    
    // Start countdown
    countdownTimer = setInterval(() => {
        secondsLeft--;
        
        // Update display
        timerDisplay.textContent = secondsLeft;
        progressBar.style.transform = `scaleX(${secondsLeft / 5})`;
        
        // Check if countdown is complete
        if (secondsLeft <= 0) {
            clearInterval(countdownTimer);
            handleCountdownComplete();
        }
    }, 1000);
}

function cancelCountdown() {
    // Hide overlay
    const overlay = document.querySelector('.inactivity-overlay');
    if (overlay) overlay.classList.remove('visible');
    
    // Reset state
    isCountingDown = false;
    if (countdownTimer) clearInterval(countdownTimer);
    
    // Restart inactivity monitoring
    resetInactivityTimer();
}

function handleCountdownComplete() {
    // Check if we have podium winners
    const hasPodiumWinners = currentArcadeSession.completedPlayers && 
                             currentArcadeSession.completedPlayers.length >= 3;
    
    if (hasPodiumWinners) {
        // Extract podium players
        const podiumPlayers = [];
        
        if (currentArcadeSession.podiumRanks) {
            // Get players by ranks
            Object.entries(currentArcadeSession.podiumRanks).forEach(([username, data]) => {
                const playerData = currentArcadeSession.participants.find(p => p.username === username);
                if (playerData) {
                    podiumPlayers.push({
                        username: playerData.username,
                        wordsCompleted: playerData.wordsCompleted || 0,
                        coins: playerData.coins || 0,
                        rank: data.rank
                    });
                }
            });
            
            // Sort by rank
            podiumPlayers.sort((a, b) => a.rank - b.rank);
        } else {
            // No explicit ranks, sort by words completed
            const sortedPlayers = [...currentArcadeSession.participants]
                .sort((a, b) => b.wordsCompleted - a.wordsCompleted)
                .slice(0, 3);
                
            // Assign ranks
            sortedPlayers.forEach((player, index) => {
                podiumPlayers.push({
                    ...player,
                    rank: index + 1
                });
            });
        }
        
        // Show victory screen
        showModeratorVictoryScreen(podiumPlayers);
    } else {
        // No winners yet, just go back to welcome screen
        showScreen('welcome-screen');
    }
}

// Variables specific to moderator screen
const moderatorInactivity = {
    activityTimer: null,
    countdownTimer: null,
    lastLeaderboardUpdate: Date.now(),
    isCountingDown: false,
    isInitialized: false,
    isGameActive: false
};


function isModeratorScreenActive() {
    const moderatorScreen = document.getElementById('moderator-screen');
    return moderatorScreen && moderatorScreen.classList.contains('visible');
}

function clearModeratorTimers() {
    if (moderatorInactivity.activityTimer) {
        clearTimeout(moderatorInactivity.activityTimer);
        moderatorInactivity.activityTimer = null;
    }
    if (moderatorInactivity.countdownTimer) {
        clearInterval(moderatorInactivity.countdownTimer);
        moderatorInactivity.countdownTimer = null;
    }
}

function createModeratorInactivityOverlay() {
    // Remove any existing overlay
    const existingOverlay = document.querySelector('.moderator-inactivity-overlay');
    if (existingOverlay) existingOverlay.remove();
    
    // Create new overlay
    const overlay = document.createElement('div');
    overlay.className = 'moderator-inactivity-overlay';
    overlay.innerHTML = `
        <div class="moderator-countdown-timer">5</div>
        <div class="moderator-inactivity-message">No leaderboard activity detected. Redirecting...</div>
        <div class="moderator-countdown-progress">
            <div class="moderator-countdown-bar"></div>
        </div>
        <button class="moderator-countdown-cancel">Cancel</button>
    `;
    
    // Add event handler for cancel button
    overlay.querySelector('.moderator-countdown-cancel').addEventListener('click', cancelModeratorCountdown);
    
    // Append to moderator screen specifically
    const moderatorScreen = document.getElementById('moderator-screen');
    if (moderatorScreen) {
        moderatorScreen.appendChild(overlay);
    }
}

function startModeratorInactivityMonitoring() {
    const moderatorScreen = document.getElementById('moderator-screen');
    if (!moderatorScreen) return;
    
    // Activity events to monitor (only on moderator screen)
    const events = ['mousemove', 'mousedown', 'keypress', 'scroll', 'touchstart'];
    
    // Add all event listeners
    events.forEach(event => {
        moderatorScreen.addEventListener(event, resetModeratorInactivityTimer);
    });
    
    // Add screen change listener
    document.addEventListener('visibilitychange', () => {
        if (document.hidden || !isModeratorScreenActive()) {
            // Stop monitoring when page is hidden or moderator screen is not active
            clearModeratorTimers();
        } else if (moderatorInactivity.isGameActive && isModeratorScreenActive()) {
            // Restart when returning to visible state and on moderator screen
            resetModeratorInactivityTimer();
        }
    });
    
    // Start the initial timer
    resetModeratorInactivityTimer();
}

function resetModeratorInactivityTimer() {
    // Only proceed if on moderator screen, game is active, and not already counting down
    if (!isModeratorScreenActive() || !moderatorInactivity.isGameActive || moderatorInactivity.isCountingDown) {
        return;
    }
    
    // Clear existing timer
    if (moderatorInactivity.activityTimer) {
        clearTimeout(moderatorInactivity.activityTimer);
    }
    
    // Set new timer - 3 seconds of inactivity
    moderatorInactivity.activityTimer = setTimeout(() => {
        // Check if leaderboard has been updated recently
        const timeSinceLastUpdate = Date.now() - moderatorInactivity.lastLeaderboardUpdate;
        
        // If no updates for 5 seconds, start countdown
        if (timeSinceLastUpdate > 5000 && isModeratorScreenActive()) {
            startModeratorCountdown();
        }
    }, 3000);
}

function trackModeratorLeaderboardUpdates() {
    // Get leaderboard element
    const leaderboard = document.getElementById('arcade-leaderboard');
    if (!leaderboard) return;
    
    // Create mutation observer to detect changes
    const observer = new MutationObserver(() => {
        // Only track updates if moderator screen is active and game is initialized
        if (isModeratorScreenActive() && moderatorInactivity.isGameActive) {
            moderatorInactivity.lastLeaderboardUpdate = Date.now();
            
            // If countdown is active, cancel it since we have activity
            if (moderatorInactivity.isCountingDown) {
                cancelModeratorCountdown();
            }
        }
    });
    
    // Start observing
    observer.observe(leaderboard, { 
        childList: true, 
        subtree: true, 
        attributes: true,
        characterData: true
    });
}

function startModeratorCountdown() {
    // Only proceed if on moderator screen and game is active
    if (!isModeratorScreenActive() || !moderatorInactivity.isGameActive) {
        return;
    }
    
    moderatorInactivity.isCountingDown = true;
    
    // Show the overlay
    const overlay = document.querySelector('.moderator-inactivity-overlay');
    if (overlay) overlay.classList.add('visible');
    
    // Initialize countdown
    let secondsLeft = 5;
    const timerDisplay = overlay.querySelector('.moderator-countdown-timer');
    const progressBar = overlay.querySelector('.moderator-countdown-bar');
    
    // Update initial display
    timerDisplay.textContent = secondsLeft;
    progressBar.style.transform = 'scaleX(1)';
    
    // Start countdown
    moderatorInactivity.countdownTimer = setInterval(() => {
        // Stop if we're no longer on the moderator screen
        if (!isModeratorScreenActive()) {
            cancelModeratorCountdown();
            return;
        }
        
        secondsLeft--;
        
        // Update display
        timerDisplay.textContent = secondsLeft;
        progressBar.style.transform = `scaleX(${secondsLeft / 5})`;
        
        // Check if countdown is complete
        if (secondsLeft <= 0) {
            clearInterval(moderatorInactivity.countdownTimer);
            handleModeratorCountdownComplete();
        }
    }, 1000);
}

function cancelModeratorCountdown() {
    // Hide overlay
    const overlay = document.querySelector('.moderator-inactivity-overlay');
    if (overlay) overlay.classList.remove('visible');
    
    // Reset state
    moderatorInactivity.isCountingDown = false;
    if (moderatorInactivity.countdownTimer) {
        clearInterval(moderatorInactivity.countdownTimer);
        moderatorInactivity.countdownTimer = null;
    }
    
    // Restart inactivity monitoring if still on moderator screen
    if (isModeratorScreenActive() && moderatorInactivity.isGameActive) {
        resetModeratorInactivityTimer();
    }
}

function handleModeratorCountdownComplete() {
   // Skip if celebration already triggered
   if (currentArcadeSession.celebrationTriggered) {
       return;
   }
   
   // Check if we have podium winners
   const completedPlayers = currentArcadeSession.participants.filter(
       p => p.wordsCompleted >= currentArcadeSession.wordGoal
   );
   
   const hasPodiumWinners = completedPlayers && 
                            completedPlayers.length >= 3;
   
   currentArcadeSession.celebrationTriggered = true;
   
   if (hasPodiumWinners) {
       // Extract podium players
       const podiumPlayers = [];
       
       if (currentArcadeSession.podiumRanks) {
           // Get players by ranks
           Object.entries(currentArcadeSession.podiumRanks).forEach(([username, data]) => {
               const playerData = currentArcadeSession.participants.find(p => p.username === username);
               if (playerData) {
                   podiumPlayers.push({
                       username: playerData.username,
                       wordsCompleted: playerData.wordsCompleted || 0,
                       coins: playerData.coins || 0,
                       rank: data.rank
                   });
               }
           });
           
           // Sort by rank
           podiumPlayers.sort((a, b) => a.rank - b.rank);
       } else {
           // No explicit ranks, sort by words completed
           const sortedPlayers = [...currentArcadeSession.participants]
               .sort((a, b) => b.wordsCompleted - a.wordsCompleted)
               .slice(0, 3);
               
           // Assign ranks
           sortedPlayers.forEach((player, index) => {
               podiumPlayers.push({
                   ...player,
                   rank: index + 1
               });
           });
       }
       
       // Show victory screen
       startLeaderboardCelebration(podiumPlayers);
   } else {
       // No winners yet, just go back to welcome screen
       showScreen('welcome-screen');
   }
}

function cleanupModeratorInactivityMonitoring() {
    // Clean up all timers and state
    clearModeratorTimers();
    moderatorInactivity.isGameActive = false;
    moderatorInactivity.isInitialized = false;
    moderatorInactivity.isCountingDown = false;
    
    // Remove overlay if exists
    const overlay = document.querySelector('.moderator-inactivity-overlay');
    if (overlay) overlay.remove();
}

function startLeaderboardCelebration(winners) {
   // Hide the inactivity overlay
   const inactivityOverlay = document.querySelector('.moderator-inactivity-overlay');
   if (inactivityOverlay) inactivityOverlay.classList.remove('visible');
   
   // Create celebration overlay to dim everything else
   const overlay = document.createElement('div');
   overlay.className = 'celebration-overlay';
   document.body.appendChild(overlay);
   setTimeout(() => overlay.classList.add('visible'), 10);
   
   // Get and clone winner entries
   const leaderboard = document.getElementById('arcade-leaderboard');
   const entries = leaderboard.querySelectorAll('.leaderboard-entry');
   
   // Map for tracking original positions
   const originalPositions = new Map();
   
   // Find the winner entries and clone them
   winners.forEach(winner => {
       entries.forEach(entry => {
           const usernameEl = entry.querySelector('[data-username]');
           if (!usernameEl) return;
           
           const username = usernameEl.dataset.username;
           if (username === winner.username) {
               // Store original position
               const rect = entry.getBoundingClientRect();
               originalPositions.set(username, {
                   left: rect.left,
                   top: rect.top,
                   width: rect.width,
                   height: rect.height
               });
               
               // Clone entry for animation
               const clone = entry.cloneNode(true);
               clone.classList.add('winner-entry', 'celebrating');
               
               // Add place-specific class
               if (winner.rank === 1) {
                   clone.classList.add('first-place');
                   
                   // Add winner label
                   const label = document.createElement('div');
                   label.className = 'winner-label';
                   label.textContent = 'CHAMPION';
                   clone.appendChild(label);
                   
                   addWinnerEmojis(clone, ['', '', ''], winner.rank);
               } else if (winner.rank === 2) {
                   clone.classList.add('second-place');
                   
                   const label = document.createElement('div');
                   label.className = 'winner-label';
                   label.textContent = 'RUNNER-UP';
                   clone.appendChild(label);
                   
                   addWinnerEmojis(clone, ['', ''], winner.rank);
               } else if (winner.rank === 3) {
                   clone.classList.add('third-place');
                   
                   const label = document.createElement('div');
                   label.className = 'winner-label';
                   label.textContent = 'BRONZE MEDAL';
                   clone.appendChild(label);
                   
                   addWinnerEmojis(clone, ['', ''], winner.rank);
               }
               
               // Set initial position to match original entry
               clone.style.position = 'fixed';
               clone.style.left = `${rect.left}px`;
               clone.style.top = `${rect.top}px`;
               clone.style.width = `${rect.width}px`;
               clone.style.height = `${rect.height}px`;
               clone.style.zIndex = 100 + (3 - winner.rank);
               
               // Make text within entries bigger
               const rankEl = clone.querySelector('.rank');
               const nameEl = clone.querySelector('[data-username]');
               const wordsEl = clone.querySelector('[data-words]');
               const coinsEl = clone.querySelector('[data-coins]');
               
               if (rankEl) rankEl.style.fontSize = '3rem';
               if (nameEl) nameEl.style.fontSize = '3rem';
               if (wordsEl) wordsEl.style.fontSize = '2.5rem';
               if (coinsEl) coinsEl.style.fontSize = '2.5rem';
               
               // Append to body for animation
               document.body.appendChild(clone);
               
               // Add animation class after a small delay to ensure starting position
               setTimeout(() => {
                   clone.classList.add('centered');
               }, 50);
           }
       });
   });
   
   // Start confetti after entries have moved to center
   setTimeout(() => {
       startConfettiShower();
       
       // Broadcast celebration to all players
       window.arcadeChannel.send({
           type: 'broadcast',
           event: 'celebration',
           payload: {
               winners: winners.map(w => ({
                   username: w.username,
                   rank: w.rank,
                   wordsCompleted: w.wordsCompleted,
                   coins: w.coins
               }))
           }
       });
   }, 1500);
   
   // Add home button
   const homeButtonContainer = document.createElement('div');
   homeButtonContainer.className = 'home-button-container';
   homeButtonContainer.innerHTML = `
       <button class="start-button" onclick="finishCelebrationAndGoHome()">
           Return to Home
       </button>
   `;
   document.body.appendChild(homeButtonContainer);
   setTimeout(() => homeButtonContainer.classList.add('visible'), 2500);
}

function addWinnerEmojis(element, emojis, rank) {
    setTimeout(() => {
        // Create fixed emojis that don't overlap with winner entries
        emojis.forEach((emoji, index) => {
            const emojiElement = document.createElement('div');
            emojiElement.className = 'celebration-emoji';
            emojiElement.textContent = emoji;
            
            // Position in fixed locations around the screen edges
            let x, y, size;
            const baseSize = 2.5;
            
            // Calculate offset to avoid overlap
            if (rank === 1) {
                // First place: top area
                size = baseSize + 0.5;
                if (index % 2 === 0) {
                    // Left side
                    x = 5 + (index * 3) + '%';
                    y = 5 + (index * 2) + '%';
                } else {
                    // Right side
                    x = 95 - (index * 3) + '%';
                    y = 5 + (index * 2) + '%';
                }
            } else if (rank === 2) {
                // Second place: sides
                size = baseSize;
                if (index % 2 === 0) {
                    // Left side  
                    x = 5 + '%';
                    y = 40 + (index * 5) + '%';
                } else {
                    // Right side
                    x = 95 + '%';
                    y = 40 + (index * 5) + '%';
                }
            } else {
                // Third place: bottom
                size = baseSize - 0.5;
                if (index % 2 === 0) {
                    // Left bottom
                    x = 15 + (index * 5) + '%';
                    y = 90 + '%';
                } else {
                    // Right bottom
                    x = 85 - (index * 5) + '%';
                    y = 90 + '%';
                }
            }
            
            emojiElement.style.fontSize = `${size}rem`;
            emojiElement.style.left = x;
            emojiElement.style.top = y;
            emojiElement.style.zIndex = 300;
            emojiElement.style.animationDelay = `${1.8 + index * 0.3}s`;
            
            document.body.appendChild(emojiElement);
        });
    }, 1800);
}

function startConfettiShower() {
    // Colors for confetti
    const colors = [
        '#FFD700', '#FF1493', '#00BFFF', '#7CFC00', '#FF4500', 
        '#9400D3', '#FF8C00', '#1E90FF', '#32CD32', '#FF69B4'
    ];
    
    // Create initial confetti
    createConfettiBatch();
    
    // Continue creating confetti
    const confettiInterval = setInterval(createConfettiBatch, 800);
    
    // Store interval ID globally for cleanup
    window.celebrationConfettiInterval = confettiInterval;
    
    // Function to create a batch of confetti
    function createConfettiBatch() {
        for (let i = 0; i < 60; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            
            // Random properties
            const size = 5 + Math.random() * 15;
            const color = colors[Math.floor(Math.random() * colors.length)];
            const left = Math.random() * 100;
            const delay = Math.random() * 3;
            const duration = 3 + Math.random() * 4;
            const isSquare = Math.random() > 0.5;
            
            confetti.style.width = `${size}px`;
            confetti.style.height = `${size}px`;
            confetti.style.backgroundColor = color;
            confetti.style.left = `${left}vw`;
            confetti.style.animationDuration = `${duration}s`;
            confetti.style.animationDelay = `${delay}s`;
            confetti.style.borderRadius = isSquare ? '0' : '50%';
            
            document.body.appendChild(confetti);
            
            // Remove after animation
            setTimeout(() => {
                confetti.remove();
            }, (duration + delay) * 1000);
        }
    }
}

function finishCelebrationAndGoHome() {
    // Clean up celebration elements
    document.querySelector('.celebration-overlay')?.remove();
    document.querySelector('.home-button-container')?.remove();
    
    // Clear confetti interval
    if (window.celebrationConfettiInterval) {
        clearInterval(window.celebrationConfettiInterval);
    }
    
    // Remove ALL emojis, confetti and winner entries
    document.querySelectorAll('.confetti, .celebration-emoji, .winner-entry.celebrating').forEach(el => el.remove());
    
    // Clean up moderator tracking
    cleanupModeratorInactivityMonitoring();
    
    // Reset arcade session and flag
    currentArcadeSession = {
        eventId: null,
        otp: null,
        wordPool: [],
        participants: [],
        teacherId: null,
        wordGoal: 50,
        state: 'pre-start',
        completedPlayers: [],
        playerRank: null,
        winnerScreenShown: false,
        startTime: null,
        endTime: null,
        celebrationTriggered: false
    };
    
    // Go home with a clean state
    showScreen('welcome-screen');
}

// Move this handler into a function that will be called after channel initialization
function setupCelebrationHandler() {
    if (!window.arcadeChannel) return;
    
    window.arcadeChannel.on('broadcast', { event: 'celebration' }, ({ payload }) => {
        if (!payload.winners) return;
        
        // Check if current player is one of the winners
        if (currentArcadeSession.playerName) {
            const winnerEntry = payload.winners.find(w => w.username === currentArcadeSession.playerName);
            
            if (winnerEntry) {
                // Show personal victory celebration
                showPersonalVictoryCelebration(winnerEntry.rank);
            }
        }
    });
}

function showPersonalVictoryCelebration(rank) {
    // Don't show if already celebrating
    if (currentArcadeSession.winnerScreenShown) return;
    currentArcadeSession.winnerScreenShown = true;
    
    // Create celebration screen
    const overlay = document.createElement('div');
    overlay.className = 'personal-victory-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        z-index: 2000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.5s ease;
    `;
    
    // Define content based on rank
    const rankContent = {
        1: {
            title: " CHAMPION! ",
            message: "Incredible! You've claimed the top spot!",
            emoji: "",
            color: "var(--gold)"
        },
        2: {
            title: " RUNNER UP! ",
            message: "Amazing job! You've secured second place!",
            emoji: "",
            color: "var(--silver)"
        },
        3: {
            title: " BRONZE MEDALIST! ",
            message: "Well done! You've earned third place!",
            emoji: "",
            color: "var(--bronze)"
        }
    };
    
    const content = rankContent[rank] || {
        title: "GREAT PERFORMANCE!",
        message: "You've completed the challenge!",
        emoji: "",
        color: "var(--accent)"
    };
    
    overlay.innerHTML = `
        <div style="font-size: 8rem; margin-bottom: 1rem;">${content.emoji}</div>
        <h1 style="color: ${content.color}; font-size: 3rem; margin-bottom: 1rem;">${content.title}</h1>
        <p style="font-size: 1.5rem; margin-bottom: 2rem; text-align: center; max-width: 80%;">
            ${content.message}
        </p>
        <div style="margin: 2rem 0; display: flex; gap: 2rem;">
            <div style="text-align: center;">
                <div style="font-size: 1.2rem; color: var(--text); opacity: 0.8;">YOUR RANK</div>
                <div style="font-size: 3rem; color: ${content.color};">${rank}</div>
            </div>
            <div style="text-align: center;">
                <div style="font-size: 1.2rem; color: var(--text); opacity: 0.8;">WORDS COMPLETED</div>
                <div style="font-size: 3rem; color: var(--text);">${currentGame.wordsCompleted || 0}</div>
            </div>
            <div style="text-align: center;">
                <div style="font-size: 1.2rem; color: var(--text); opacity: 0.8;">COINS EARNED</div>
                <div style="font-size: 3rem; color: var(--gold);">${currentGame.coins || 0}</div>
            </div>
        </div>
        <button class="start-button" style="margin-top: 2rem; padding: 1rem 2rem;" onclick="closePersonalVictory()">
            Continue
        </button>
    `;
    
    document.body.appendChild(overlay);
    
    // Fade in
    setTimeout(() => {
        overlay.style.opacity = '1';
        
        // Start player confetti
        startPlayerConfetti();
    }, 100);
}

function startPlayerConfetti() {
    // Colors for player confetti
    const colors = [
        '#FFD700', '#FF1493', '#00BFFF', '#7CFC00', '#FF4500',
        '#9400D3', '#FF8C00', '#1E90FF', '#32CD32', '#FF69B4'
    ];
    
    function createPlayerConfettiBatch() {
        for (let i = 0; i < 40; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'player-confetti';
            confetti.style.cssText = `
                position: fixed;
                width: ${5 + Math.random() * 10}px;
                height: ${5 + Math.random() * 10}px;
                background-color: ${colors[Math.floor(Math.random() * colors.length)]};
                top: -20px;
                left: ${Math.random() * 100}vw;
                opacity: 1;
                z-index: 2001;
                border-radius: ${Math.random() > 0.5 ? '0' : '50%'};
                animation: confettiFall ${3 + Math.random() * 3}s linear ${Math.random() * 2}s forwards;
            `;
            
            document.body.appendChild(confetti);
            
            // Remove after animation
            setTimeout(() => {
                confetti.remove();
            }, 5000);
        }
    }
    
    // Initial batch
    createPlayerConfettiBatch();
    
    // Continue creating batches
    const interval = setInterval(createPlayerConfettiBatch, 1000);
    
    // Store for cleanup
    window.playerConfettiInterval = interval;
    
    // Stop after 10 seconds
    setTimeout(() => {
        clearInterval(interval);
    }, 10000);
}

function closePersonalVictory() {
    // Clear confetti interval
    if (window.playerConfettiInterval) {
        clearInterval(window.playerConfettiInterval);
    }
    
    // Remove all player confetti
    document.querySelectorAll('.player-confetti').forEach(el => el.remove());
    
    // Remove victory overlay
    const overlay = document.querySelector('.personal-victory-overlay');
    if (overlay) {
        overlay.style.opacity = '0';
        setTimeout(() => {
            overlay.remove();
            
            // Go to welcome screen
            showScreen('welcome-screen');
        }, 500);
    }
}


// REPLACE: Just the handleCustomLevelCompletion function
function handleCustomLevelCompletion() {
    clearTimer();
    
    console.log("Custom level completion: Level " + customGameState.currentLevel);
    console.log("Words count in list: " + customGameState.words.length);
    
    const isPerfect = currentGame.streakBonus && currentGame.correctAnswers === currentGame.words.length;
    
    if (isPerfect) {
        const bonus = currentGame.firstAttempt ? 5 : 3;
        CoinsManager.updateCoins(bonus).then(() => {
            pulseCoins(bonus);
            customGameState.wordsCompleted += currentGame.words.length;
            customGameState.completedLevels.add(customGameState.currentLevel);
            
            // Calculate max level for this list size
            const wordCount = customGameState.words.length;
            const maxLevel = wordCount >= 12 ? 9 : 
                             wordCount >= 9 ? 6 : 3;
            
            console.log("Max level for this list: " + maxLevel);
            console.log("Current level: " + customGameState.currentLevel);
            
            // CRITICAL FIX: If this is level 3 and we have 6 or fewer words, show completion
            if (customGameState.currentLevel === 3 && wordCount <= 6) {
                console.log("Level 3 completed with 6 or fewer words - showing completion");
                setTimeout(() => showCustomCompletionScreen(), 1500);
                return;
            }
            
            // CRITICAL FIX: If this is level 6 and we have 7-9 words, show completion
            if (customGameState.currentLevel === 6 && wordCount <= 9) {
                console.log("Level 6 completed with 7-9 words - showing completion");
                setTimeout(() => showCustomCompletionScreen(), 1500);
                return;
            }
            
            // CRITICAL FIX: If this is level 9 and we have 10+ words, show completion
            if (customGameState.currentLevel === 9 && wordCount >= 10) {
                console.log("Level 9 completed with 10+ words - showing completion");
                setTimeout(() => showCustomCompletionScreen(), 1500);
                return;
            }
            
            // CRITICAL FIX: If this is the max level for any list size, show completion
            if (customGameState.currentLevel >= maxLevel) {
                console.log("Max level reached - showing completion");
                setTimeout(() => showCustomCompletionScreen(), 1500);
                return;
            }
            
            const nextLevel = customGameState.currentLevel + 1;
            const nextLevelData = customGameState.getWordsForLevel(nextLevel);
            
            const screenRect = document.getElementById('question-screen').getBoundingClientRect();
            createParticles(screenRect.left + screenRect.width / 2, screenRect.top + screenRect.height / 2);
            
            if (!nextLevelData || nextLevelData.words.length === 0) {
                console.log("No valid data for next level - showing completion");
                setTimeout(() => showCustomCompletionScreen(), 1500);
            } else {
                console.log("Moving to next level: " + nextLevel);
                customGameState.currentLevel = nextLevel;
                setTimeout(() => startCustomLevel(nextLevel), 1500);
            }
        });
    } else {
        // If not perfect, restart the same level
        console.log("Level not completed perfectly - restarting level " + customGameState.currentLevel);
        setTimeout(() => startCustomLevel(customGameState.currentLevel), 1500);
    }
    
    saveProgress();
}

function showCustomCompletionScreen() {
    const overlay = document.createElement('div');
    overlay.className = 'completion-overlay';
    
    // Calculate coins earned
    const coinsEarned = gameState.coins - customGameState.startCoins;
    
    overlay.innerHTML = `
        <div class="completion-content">
            <h2>Practice Complete!</h2>
            <div class="completion-stats">
                <div class="stat-item">
                    <i class="fas fa-book"></i>
                    <span>Words Practiced: ${customGameState.wordsCompleted}</span>
                </div>
                <div class="stat-item">
                    <i class="fas fa-coins"></i>
                    <span>Coins Earned: ${coinsEarned}</span>
                </div>
            </div>
            <button onclick="exitCustomPractice()" class="start-button">Continue</button>
        </div>
    `;
    
    document.body.appendChild(overlay);
}


async function handleCustomPracticeAnswer(e, t = false) {
  if (e) {
    // Increment index after correct answer
    currentGame.currentIndex++;
    
    if (!t) {
      let coinReward = 0;
      const timeBonus = awardTimeBonus();
      if (timeBonus > 0) {
        coinReward += timeBonus;
        pulseCoins(timeBonus);
      }
      
      if (currentGame.firstAttempt) {
        coinReward += 3;
        pulseCoins(3);
      } else {
        coinReward += 1;
        pulseCoins(1);
      }
      
      try {
        await CoinsManager.updateCoins(coinReward);
        updatePerkButtons();
      } catch (e) {
        console.error("Error updating total coins:", e);
      }
      
      currentGame.correctAnswers++;
      
      if (currentUser && currentUser.status === "premium") {
        const wordIndex = currentGame.currentIndex - 1; // Since we already incremented
        const word = currentGame.isHebrewToEnglish
          ? currentGame.words[wordIndex]
          : currentGame.translations[wordIndex];
        await trackWordEncounter(word, "custom");
      }
    }
  } else {
    currentGame.firstAttempt = false;
    currentGame.streakBonus = false;
    currentGame.wrongStreak++;
    
    try {
      await CoinsManager.updateCoins(-3);
      updatePerkButtons();
    } catch (e) {
      console.error("Error updating coins:", e);
    }
    
    if (currentGame.currentIndex > 0) {
      currentGame.progressLost++;
      currentGame.currentIndex = Math.max(0, currentGame.currentIndex - 1);
    }
    
    if (currentGame.wrongStreak >= 3) {
      showGameOverOverlay();
      document.querySelector(".restart-button").onclick = () => {
        document.querySelector(".failure-overlay").style.display = "none";
        startCustomLevel(currentGame.customLevel);
      }
      return;
    }
  }
  
  // Get current question's correct answer (before loading next)
  const currentCorrectAnswer = currentGame.isHebrewToEnglish
    ? currentGame.words[Math.max(0, currentGame.currentIndex - 1)]
    : currentGame.translations[Math.max(0, currentGame.currentIndex - 1)];
  
  // Highlight correct/wrong answer only for current question
  const allButtons = document.querySelectorAll(".buttons button");
  allButtons.forEach((button) => {
    if (button.textContent === currentCorrectAnswer) {
      button.classList.add("correct");
    } else if (!e && event && event.target && button.textContent === event.target.textContent) {
      button.classList.add("wrong");
    }
  });
  
  updateProgressCircle();
  saveProgress();
  
  // Wait for animation before loading next
  setTimeout(() => {
    // Clear all button classes before loading next question
    allButtons.forEach(btn => {
      btn.classList.remove("correct", "wrong");
    });
    
    if (currentGame.currentIndex < currentGame.words.length) {
      loadNextQuestion();
      updatePerkButtons();
    } else {
      handleCustomLevelCompletion();
    }
  }, 333);
}

function showReviveOverlay() {
    const overlay = document.createElement('div');
    overlay.className = 'revive-overlay';
    overlay.innerHTML = `
        <div class="revive-content">
            <div class="ankh-symbol"></div>
            <h2 class="revive-title">Revive?</h2>
            <div class="revive-timer">5</div>
            <button class="revive-button">Revive</button>
        </div>
    `;
    
    document.body.appendChild(overlay);
    
    // Fade in animation
    requestAnimationFrame(() => {
        overlay.classList.add('show');
    });
    
    // Set up countdown
    let seconds = 5;
    const timerDisplay = overlay.querySelector('.revive-timer');
    
    const countdownInterval = setInterval(() => {
        seconds--;
        timerDisplay.textContent = seconds;
        
        if (seconds <= 0) {
            clearInterval(countdownInterval);
            handleReviveTimeout();
        }
    }, 1000);
    
    // Handle revive button click
    const reviveButton = overlay.querySelector('.revive-button');
    reviveButton.onclick = () => {
        clearInterval(countdownInterval);
        handleRevive();
    };
    
    // Store interval for cleanup
    overlay.dataset.intervalId = countdownInterval;
}

function handleReviveTimeout() {
    const overlay = document.querySelector('.revive-overlay');
    
    if (overlay) {
        overlay.classList.remove('show');
        setTimeout(() => {
            overlay.remove();
            showScreen('welcome-screen');
        }, 500);
    }
}

function handleRevive() {
    const overlay = document.querySelector('.revive-overlay');
    
    if (overlay) {
        // First change content to show resurrection animation
        const content = overlay.querySelector('.revive-content');
        content.innerHTML = `
            <div class="resurrection-animation">
                <div class="progress-circle resurrection-circle">
                    <svg width="100%" height="100%" viewBox="0 0 120 120">
                        <circle class="bg" cx="60" cy="60" r="54" stroke-width="8"/>
                        <circle class="resurrection-progress" cx="60" cy="60" r="54" stroke-width="8"/>
                    </svg>
                    <div class="ankh-symbol resurrection-ankh"></div>
                </div>
            </div>
        `;
        
        // Start resurrection animation
        const progressCircle = overlay.querySelector('.resurrection-progress');
        const circumference = 2 * Math.PI * 54;
        progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
        progressCircle.style.strokeDashoffset = circumference;
        
        // Create light particles effect
        createResurrectionParticles();
        
        // Animate progress circle filling
        setTimeout(() => {
            progressCircle.style.transition = 'stroke-dashoffset 2s cubic-bezier(0.4, 0, 0.2, 1)';
            progressCircle.style.strokeDashoffset = '0';
        }, 100);
        
        // After animation completes, restart level
        setTimeout(() => {
            overlay.classList.remove('show');
            setTimeout(() => {
                overlay.remove();
                
                // Reset game state
                currentGame.wrongStreak = 0;
                timeRemaining = currentGame.initialTimeRemaining;
                
                // If in custom practice, handle specially
                if (currentGame.isCustomPractice) {
                    startCustomLevel(currentGame.customLevel);
                } else {
                    startLevel(gameState.currentLevel);
                }
            }, 500);
        }, 2500);
    }
}

function createResurrectionParticles() {
    const container = document.querySelector('.resurrection-animation');
    if (!container) return;
    
    // Get center of container
    const rect = container.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    // Create particles
    for (let i = 0; i < 40; i++) {
        const particle = document.createElement('div');
        particle.className = 'resurrection-particle';
        
        // Random angle and distance
        const angle = Math.random() * Math.PI * 2;
        const distance = 100 + Math.random() * 150;
        const duration = 1 + Math.random() * 1.5;
        const delay = Math.random() * 0.5;
        const size = 3 + Math.random() * 7;
        
        // Calculate end position
        const endX = Math.cos(angle) * distance;
        const endY = Math.sin(angle) * distance;
        
        // Set particle style
        particle.style.cssText = `
            position: fixed;
            left: ${centerX}px;
            top: ${centerY}px;
            width: ${size}px;
            height: ${size}px;
            background: #FFD700;
            border-radius: 50%;
            opacity: 0;
            z-index: 1001;
            box-shadow: 0 0 ${size}px #FFD700;
            transform: translate(-50%, -50%);
            animation: particleFlow ${duration}s ease-out ${delay}s forwards;
        `;
        
        // Set custom properties for animation
        particle.style.setProperty('--end-x', `${endX}px`);
        particle.style.setProperty('--end-y', `${endY}px`);
        
        document.body.appendChild(particle);
        
        // Clean up after animation
        setTimeout(() => {
            particle.remove();
        }, (duration + delay) * 1000 + 100);
    }
}

function updateSidePanelLink() {
    const levelMapLink = document.querySelector('.nav-link[onclick*="stage-screen"]');
    if (levelMapLink) {
        levelMapLink.setAttribute('onclick', "showScreen('stage-cascade-screen'); return false;");
    }
}

// Call the function immediately after defining it
updateSidePanelLink();

// Also call it when DOM is loaded to ensure it works
document.addEventListener('DOMContentLoaded', () => {
    updateSidePanelLink();
});


function renderStageCascadeScreen() {
  const stagesContainer = document.querySelector(".stages-container");
  if (!stagesContainer) return;
  
  // Clear the container
  stagesContainer.innerHTML = "";
  
  // Debug: Log the current state of unlocked sets
  console.log("Current unlocked sets:", gameState.unlockedSets);
  
  // Render stages and sets
  gameStructure.stages.forEach(stage => {
    const stageWrapper = document.createElement("div");
    stageWrapper.className = "stage-wrapper";
    stageWrapper.dataset.stage = stage.id;
    
    const numSets = stage.numSets;
    const unlockedSets = gameState.unlockedSets[stage.id] || new Set();
    const unlockedSetCount = unlockedSets.size;
    
    let completedSets = 0;
    if (unlockedSetCount > 0) {
      unlockedSets.forEach(setNum => {
        // Check if this set is completed
        if (isSetCompleted(stage.id, setNum)) {
          completedSets++;
        }
      });
    }
    
    const stageIcon = getStageIcon(stage.id);
    const stageHebrewName = getStageHebrewName(stage.id);
    const stageDescription = getStageDescription(stage.id);
    const stageStatus = getStageStatus(stage.id, completedSets, numSets);
    
    stageWrapper.innerHTML = `
      <div class="stage-button">
        <div class="stage-info">
          <div class="stage-icon">
            <i class="${stageIcon}"></i>
          </div>
          <div class="stage-text">
            <div class="stage-name">${stageHebrewName} - Stage ${stage.id}</div>
            <div class="stage-desc">${stageDescription}</div>
          </div>
        </div>
        <div class="stage-status">${stageStatus}</div>
        <div class="stage-toggle">
          <i class="fas fa-chevron-down"></i>
        </div>
      </div>
      
      <div class="sets-container">
        <div class="sets-grid" id="sets-grid-${stage.id}"></div>
      </div>
    `;
    
    stagesContainer.appendChild(stageWrapper);
    
    // Populate the sets grid for this stage
    populateSetsGrid(stage.id);
  });
  
  // Add toggle listeners for stage expansion
  addStageToggleListeners();
  
  // Auto-expand the current stage
  if (gameState.currentStage) {
    const currentStageWrapper = document.querySelector(`.stage-wrapper[data-stage="${gameState.currentStage}"]`);
    if (currentStageWrapper) {
      currentStageWrapper.classList.add("open");
    }
  }
  
  // Show the stage cascade screen
  const stageCascadeScreen = document.getElementById("stage-cascade-screen");
  if (stageCascadeScreen) {
    document.querySelectorAll(".screen").forEach(screen => {
      screen.classList.remove("visible");
    });
    stageCascadeScreen.classList.add("visible");
  }
}

// Function to build and display the stage-set cascade UI
function showStageCascadeScreen() {
    // First, ensure we have the latest game state
    if (currentUser) {
        // For logged-in users, optionally refresh from database
        const savedProgress = localStorage.getItem("simploxProgress");
        if (savedProgress) {
            try {
                const progress = JSON.parse(savedProgress);
                updateGameStateFromProgress(progress);
            } catch (error) {
                console.error("Error parsing local progress:", error);
            }
        }
    }
    
    console.log("Showing stage cascade screen, current game state:", {
        currentStage: gameState.currentStage,
        unlockedSets: gameState.unlockedSets,
        completedLevels: gameState.completedLevels ? Array.from(gameState.completedLevels).length : 0
    });
    
    const container = document.querySelector('.stages-container');
    if (!container) return;
    
    // Clear existing content
    container.innerHTML = '';
    
    // Create stage wrappers for each stage
    gameStructure.stages.forEach(stage => {
        // Create stage wrapper
        const stageWrapper = document.createElement('div');
        stageWrapper.className = 'stage-wrapper';
        stageWrapper.dataset.stage = stage.id;
        
        // Get stage completion data
        const totalSets = stage.numSets;
        const unlockedSets = gameState.unlockedSets[stage.id] || new Set();
        
        console.log(`Stage ${stage.id} unlocked sets:`, Array.from(unlockedSets));
        
        const unlockedCount = unlockedSets.size;
        let completedSets = 0;
        
        // Count completed sets
        if (unlockedSets.size > 0) {
            unlockedSets.forEach(setId => {
                const setKey = `${stage.id}_${setId}`;
                const levelCount = gameStructure.stages[stage.id - 1].levelsPerSet;
                const completedLevels = new Set();
                
                // Count levels that are in completedLevels or perfectLevels
                for (let level = 1; level <= levelCount; level++) {
                    const levelKey = `${stage.id}_${setId}_${level}`;
                    if (gameState.completedLevels.has(levelKey) || gameState.perfectLevels.has(levelKey)) {
                        completedLevels.add(level);
                    }
                }
                
                // If all levels in a set are completed, count it as a completed set
                if (completedLevels.size === levelCount) {
                    completedSets++;
                    console.log(`Set ${stage.id}-${setId} is fully completed`);
                }
            });
        }
        
        // Stage button content
        const stageIcon = getStageIcon(stage.id);
        const stageName = getStageHebrewName(stage.id);
        const stageDesc = getStageDescription(stage.id);
        const stageStatus = getStageStatus(stage.id, completedSets, totalSets);
        
        // Create stage button
        stageWrapper.innerHTML = `
            <div class="stage-button">
                <div class="stage-info">
                    <div class="stage-icon">
                        <i class="${stageIcon}"></i>
                    </div>
                    <div class="stage-text">
                        <div class="stage-name">${stageName} - Stage ${stage.id}</div>
                        <div class="stage-desc">${stageDesc}</div>
                    </div>
                </div>
                <div class="stage-status">${stageStatus}</div>
                <div class="stage-toggle">
                    <i class="fas fa-chevron-down"></i>
                </div>
            </div>
            
            <div class="sets-container">
                <div class="sets-grid" id="sets-grid-${stage.id}"></div>
            </div>
        `;
        
        container.appendChild(stageWrapper);
        
        // Populate sets grid
        populateSetsGrid(stage.id);
    });
    
    // Add event listeners to stage buttons
    addStageToggleListeners();
    
    // Initial state: open the current stage
    if (gameState.currentStage) {
        const currentStageWrapper = document.querySelector(`.stage-wrapper[data-stage="${gameState.currentStage}"]`);
        if (currentStageWrapper) {
            currentStageWrapper.classList.add('open');
        }
    }
    
    const cascadeScreen = document.getElementById('stage-cascade-screen'); 
    if (cascadeScreen) {
        document.querySelectorAll('.screen').forEach(screen => {
            screen.classList.remove('visible');
        });
        cascadeScreen.classList.add('visible');
    }
}

// Helper function to update game state from saved progress
function updateGameStateFromProgress(progress) {
    console.log("Updating game state from saved progress");
    
    // Update unlocked sets
    if (progress.unlocked_sets) {
        console.log("Updating unlocked sets from:", progress.unlocked_sets);
        gameState.unlockedSets = {};
        Object.entries(progress.unlocked_sets).forEach(([stage, sets]) => {
            gameState.unlockedSets[stage] = new Set(Array.isArray(sets) ? sets : []);
        });
    }
    
    // Update unlocked levels
    if (progress.unlocked_levels) {
        console.log("Updating unlocked levels from saved data");
        gameState.unlockedLevels = {};
        Object.entries(progress.unlocked_levels).forEach(([setKey, levels]) => {
            gameState.unlockedLevels[setKey] = new Set(Array.isArray(levels) ? levels : []);
        });
    }
    
    // Update completed levels
    if (progress.completed_levels) {
        console.log("Updating completed levels from saved data");
        gameState.completedLevels = new Set(progress.completed_levels);
    }
    
    // Update perfect levels
    if (progress.perfect_levels) {
        console.log("Updating perfect levels from saved data");
        gameState.perfectLevels = new Set(progress.perfect_levels);
    }
}


function getStageIcon(stageId) {
    const icons = {
        1: 'fas fa-book',
        2: 'fas fa-graduation-cap',
        3: 'fas fa-school',
        4: 'fas fa-university',
        5: 'fas fa-brain'
    };
    return icons[stageId] || 'fas fa-star';
}

function getStageHebrewName(stageId) {
    const names = {
        1: '',
        2: '',
        3: ' ',
        4: '',
        5: ''
    };
    return names[stageId] || `Stage ${stageId}`;
}

function getStageDescription(stageId) {
    const descriptions = {
        1: 'Beginner level words and simple phrases',
        2: 'Elementary level vocabulary and structures',
        3: 'Middle school level vocabulary',
        4: 'High school level vocabulary',
        5: 'University level vocabulary'
    };
    return descriptions[stageId] || 'Advanced vocabulary';
}

function getStageStatus(stageId, completedSets, totalSets) {
    // For premium stages, show premium status for non-premium users
    if (stageId > 2 && (!currentUser || currentUser.status !== 'premium')) {
        return 'Premium Feature';
    }
    
    // For unlocked stages, show completion status
    return `${completedSets}/${totalSets} Sets Completed`;
}

function populateSetsGrid(stage) {
  const setsGrid = document.getElementById(`sets-grid-${stage}`);
  if (!setsGrid) return;
  
  console.log(`Populating sets grid for stage ${stage}`);
  console.log(`Unlocked sets:`, gameState.unlockedSets);
  
  const stageData = gameStructure.stages[stage-1];
  const unlockedSets = gameState.unlockedSets[stage] || new Set();
  const userStatus = currentUser ? currentUser.status : "unregistered";
  
  // Debug: Log all unlocked sets for this stage
  console.log(`Stage ${stage} unlocked sets:`, Array.from(unlockedSets));
  
  // Clear previous content
  setsGrid.innerHTML = '';
  
  for (let setNum = 1; setNum <= stageData.numSets; setNum++) {
    const setButton = document.createElement('div');
    
    // Check if this set is unlocked
    const isUnlocked = unlockedSets.has(setNum);
    
    // Premium restriction: Stage 1 is always available, but other stages 
    // require premium for sets beyond set 1
    let isPremiumLocked = false;
    if (stage >= 2 && setNum > 1 && userStatus !== "premium") {
      isPremiumLocked = true;
    }
    
    setButton.className = 'set-button';
    if (isUnlocked && !isPremiumLocked) {
      setButton.classList.add('active');
    } else {
      setButton.classList.add('locked');
    }
    
    // Check if set is fully completed
    const isCompleted = isSetCompleted(stage, setNum);
    
    setButton.innerHTML = `
      <span>Set ${setNum}</span>
      ${isCompleted ? `
      <div class="completed-indicator">
        <i class="fas fa-check-circle"></i>
      </div>` : ""}
      ${!isUnlocked || isPremiumLocked ? `
      <div class="lock-icon">
        <i class="fas ${isPremiumLocked ? "fa-crown" : "fa-lock"}"></i>
      </div>` : ""}
    `;
    
    // Add click handler
    if (isUnlocked && !isPremiumLocked) {
      setButton.onclick = () => {
        gameState.currentStage = stage;
        gameState.currentSet = setNum;
        showLevelScreen(setNum);
      };
    } else if (isPremiumLocked) {
      setButton.onclick = () => showUpgradePrompt();
    }
    
    setsGrid.appendChild(setButton);
  }
}

function isSetCompleted(stage, set) {
  const stageData = gameStructure.stages;
  if (!stageData || !stageData[stage-1]) {
    console.warn(`Invalid stage ${stage} in isSetCompleted`);
    return false;
  }
  
  const totalLevels = stageData[stage-1].levelsPerSet;
  let completedCount = 0;
  
  console.log(`Checking if set ${stage}-${set} is completed. Total levels: ${totalLevels}`);
  
  for (let level = 1; level <= totalLevels; level++) {
    const levelKey = `${stage}_${set}_${level}`;
    if (gameState.completedLevels.has(levelKey) || gameState.perfectLevels.has(levelKey)) {
      completedCount++;
      console.log(`Level ${levelKey} is completed`);
    }
  }
  
  const isComplete = completedCount === totalLevels;
  console.log(`Set ${stage}-${set} completion check: ${completedCount}/${totalLevels} = ${isComplete}`);
  
  return isComplete;
}

function addStageToggleListeners() {
    document.querySelectorAll('.stage-wrapper .stage-button').forEach(button => {
        button.addEventListener('click', (e) => {
            const wrapper = button.closest('.stage-wrapper');
            wrapper.classList.toggle('open');
            e.stopPropagation(); // Prevent event bubbling
        });
    });
}

// Add this helper function to ensure the screen exists
function ensureScreenExists(screenId) {
    if (!document.getElementById(screenId)) {
        console.warn(`Screen ${screenId} doesn't exist. Creating it.`);
        const screen = document.createElement('div');
        screen.id = screenId;
        screen.className = 'screen';
        document.body.appendChild(screen);
    }
}

// Call this before showScreen
function safeShowScreen(screenId, forceRefresh = false) {
    ensureScreenExists(screenId);
    showScreen(screenId, forceRefresh);
}

// Update the navigation link in the side panel
function updateSidePanelLinks() {
    const levelMapLink = document.querySelector('.nav-link[onclick*="stage-screen"]');
    if (levelMapLink) {
        levelMapLink.setAttribute('onclick', "safeShowScreen('stage-cascade-screen'); return false;");
    }
    
    // Update any other links that might go to this screen
    document.querySelectorAll('button[onclick*="stage-screen"]').forEach(button => {
        const onclick = button.getAttribute('onclick');
        if (onclick && onclick.includes('stage-screen')) {
            button.setAttribute('onclick', onclick.replace('stage-screen', 'stage-cascade-screen'));
        }
    });
}

// Add to document ready function
document.addEventListener('DOMContentLoaded', () => {
    // Make sure all the necessary screens exist
    ensureScreenExists('stage-cascade-screen');
    
    // Update navigation links
    updateSidePanelLinks();
    
    // If any other initialization is needed for stage-cascade-screen
    initializeStageCascadeScreen();
});

// Simple initialization function for the stage cascade screen
function initializeStageCascadeScreen() {
    const screen = document.getElementById('stage-cascade-screen');
    if (!screen.querySelector('.stages-container')) {
        const container = document.createElement('div');
        container.className = 'stages-container';
        screen.appendChild(container);
    }
}

function toggleSidePanel() {
    const sidePanel = document.querySelector('.side-panel');
    const hamburgerButton = document.querySelector('.hamburger-button');
    const modalOverlay = document.querySelector('.modal-overlay');
    
    if (sidePanel.classList.contains('open')) {
        sidePanel.classList.remove('open');
        hamburgerButton.classList.remove('open');
        if (modalOverlay) modalOverlay.classList.remove('open');
    } else {
        sidePanel.classList.add('open');
        hamburgerButton.classList.add('open');
        if (modalOverlay) modalOverlay.classList.add('open');
    }
}

function hasExistingProgress() {
    // Check if we have any completed levels or stage progress
    if (gameState.completedLevels.size > 0 || gameState.perfectLevels.size > 0) {
        return true;
    }
    
    // Check if we have unlocked any sets beyond the defaults
    for (let stage = 1; stage <= 5; stage++) {
        const unlockedSets = gameState.unlockedSets[stage];
        // For stage 1, having just the default 9 sets doesn't count as progress
        if (stage === 1 && unlockedSets && unlockedSets.size === 9) {
            continue;
        }
        // For other stages, having more than set 1 unlocked counts as progress
        if (unlockedSets && unlockedSets.size > 1) {
            return true;
        }
    }
    
    // Check localStorage for previously saved progress
    const savedProgress = localStorage.getItem('simploxProgress');
    if (savedProgress) {
        const parsed = JSON.parse(savedProgress);
        if (parsed.completedLevels && parsed.completedLevels.length > 0) {
            return true;
        }
        if (parsed.perfectLevels && parsed.perfectLevels.length > 0) {
            return true;
        }
    }
    
    return false;
}

function findFurthestLevelInStage(stage) {
    if (!gameState.unlockedSets[stage]) return null;
    
    const sets = Array.from(gameState.unlockedSets[stage]).sort((a, b) => b - a); // Sort descending
    
    for (const set of sets) {
        const setKey = `${stage}_${set}`;
        if (!gameState.unlockedLevels[setKey]) continue;
        
        const levels = Array.from(gameState.unlockedLevels[setKey]).sort((a, b) => b - a); // Sort descending
        
        for (const level of levels) {
            const levelKey = `${stage}_${set}_${level}`;
            // If level is not completed, this is the furthest progress
            if (!gameState.perfectLevels.has(levelKey) && !gameState.completedLevels.has(levelKey)) {
                return { stage, set, level };
            }
        }
    }
    
    // If all levels in all sets are completed, return the first level of the next set
    // or first level of next stage if this was the last set
    const stageConfig = gameStructure.stages[stage - 1];
    const currentSetIndex = sets[0];
    
    if (currentSetIndex < stageConfig.numSets) {
        // Next set in current stage
        return { stage, set: currentSetIndex + 1, level: 1 };
    } else if (stage < 5) {
        // First set of next stage
        return { stage: stage + 1, set: 1, level: 1 };
    }
    
    // Fallback: return last known position
    return { stage, set: sets[0], level: 1 };
}

function showGradeLevelSelector() {
    // Create overlay and modal
    const overlay = document.createElement('div');
    overlay.className = 'modal-backdrop';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(5px);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
    const modal = document.createElement('div');
    modal.className = 'grade-level-modal';
    modal.style.cssText = `
        background: var(--glass);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 2rem;
        max-width: 500px;
        width: 90%;
        text-align: center;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
    `;
    
    modal.innerHTML = `
        <h2 style="color: var(--gold); margin-bottom: 1.5rem;">What grade level are you?</h2>
        <p style="margin-bottom: 2rem; opacity: 0.9;">Choose your education level for the best learning experience:</p>
        <div class="grade-options" style="display: flex; flex-direction: column; gap: 1rem;">
            <button class="grade-option" data-stage="2" style="padding: 1rem; border-radius: 10px; background: rgba(255,255,255,0.1); border: none; color: var(--text); cursor: pointer; transition: all 0.3s ease;">
                <i class="fas fa-school" style="margin-right: 0.5rem;"></i> Elementary School
            </button>
            <button class="grade-option" data-stage="3" style="padding: 1rem; border-radius: 10px; background: rgba(255,255,255,0.1); border: none; color: var(--text); cursor: pointer; transition: all 0.3s ease;">
                <i class="fas fa-graduation-cap" style="margin-right: 0.5rem;"></i> Junior High School
            </button>
            <button class="grade-option" data-stage="4" style="padding: 1rem; border-radius: 10px; background: rgba(255,255,255,0.1); border: none; color: var(--text); cursor: pointer; transition: all 0.3s ease;">
                <i class="fas fa-user-graduate" style="margin-right: 0.5rem;"></i> High School
            </button>
            <button class="grade-option" data-stage="5" style="padding: 1rem; border-radius: 10px; background: rgba(255,255,255,0.1); border: none; color: var(--text); cursor: pointer; transition: all 0.3s ease;">
                <i class="fas fa-university" style="margin-right: 0.5rem;"></i> University
            </button>
        </div>
    `;
    
    document.body.appendChild(overlay);
    overlay.appendChild(modal);
    
    // Add hover effect
    const buttons = modal.querySelectorAll('.grade-option');
    buttons.forEach(button => {
        button.addEventListener('mouseover', () => {
            button.style.background = 'rgba(255,255,255,0.2)';
            button.style.transform = 'translateY(-2px)';
        });
        
        button.addEventListener('mouseout', () => {
            button.style.background = 'rgba(255,255,255,0.1)';
            button.style.transform = 'translateY(0)';
        });
        
        button.addEventListener('click', () => {
            const stage = parseInt(button.dataset.stage);
            localStorage.setItem('preferredStage', stage);
            overlay.remove();
            
            // Set current stage and start first level
            gameState.currentStage = stage;
            gameState.currentSet = 1;
            startLevel(1);
        });
    });
}

function setupDefaultUnlocks() {
    console.log('Setting up default unlocks...');
    console.log('Before setup:', gameState.unlockedSets, gameState.unlockedLevels);
    
    // Stage 1: Level 1 of all sets should be unlocked
    if (!gameState.unlockedSets[1]) {
        gameState.unlockedSets[1] = new Set();
    }
    
    for (let i = 1; i <= 9; i++) {
        gameState.unlockedSets[1].add(i);
        const setKey = `1_${i}`;
        if (!gameState.unlockedLevels[setKey]) {
            gameState.unlockedLevels[setKey] = new Set([1]);
        }
    }

    // Stages 2-5: Level 1 of Set 1 should be unlocked
    for (let stage = 2; stage <= 5; stage++) {
        if (!gameState.unlockedSets[stage]) {
            gameState.unlockedSets[stage] = new Set([1]);
        }
        const setKey = `${stage}_1`;
        if (!gameState.unlockedLevels[setKey]) {
            gameState.unlockedLevels[setKey] = new Set([1]);
        }
    }
    
    // Handle progressed levels - ensure continuity
    // If level 5 is unlocked, make sure 1-4 are also unlocked
    Object.entries(gameState.unlockedLevels).forEach(([setKey, levels]) => {
        const maxLevel = Math.max(...Array.from(levels));
        for (let i = 1; i < maxLevel; i++) {
            levels.add(i);
        }
    });
    
    console.log('After setup:', gameState.unlockedSets, gameState.unlockedLevels);
}

function saveProgress() {
  console.log("Saving game progress");
  
  // Prepare the data to save
  const progressData = {
    stage: gameState.currentStage || 1,
    set_number: gameState.currentSet || 1,
    level: gameState.currentLevel || 1,
    coins: gameState.coins || 0,
    perks: gameState.perks || {}
  };
  
  // Add unlocked sets
  if (gameState.unlockedSets) {
    progressData.unlocked_sets = {};
    Object.entries(gameState.unlockedSets).forEach(([stage, sets]) => {
      progressData.unlocked_sets[stage] = Array.from(sets || []);
    });
  }
  
  // Add unlocked levels
  if (gameState.unlockedLevels) {
    progressData.unlocked_levels = {};
    Object.entries(gameState.unlockedLevels).forEach(([setKey, levels]) => {
      progressData.unlocked_levels[setKey] = Array.from(levels || []);
    });
  }
  
  // Add completed and perfect levels
  if (gameState.completedLevels && gameState.completedLevels.size > 0) {
    progressData.completed_levels = Array.from(gameState.completedLevels);
  }
  
  if (gameState.perfectLevels && gameState.perfectLevels.size > 0) {
    progressData.perfect_levels = Array.from(gameState.perfectLevels);
  }
  
  console.log("Progress data to save:", progressData);
  
  // Save to appropriate storage
  if (currentUser) {
    console.log("Saving progress to Supabase for user:", currentUser.id);
    
    // First check the database schema to ensure compatibility
    supabaseClient.from("game_progress")
      .select("*")
      .eq("user_id", currentUser.id)
      .single()
      .then(({ data, error }) => {
        if (error) {
          console.error("Error checking progress schema:", error);
          saveProgressToLocalStorage(progressData);
          return;
        }
        
        // Check for necessary columns
        const hasPerfectLevels = 'perfect_levels' in data;
        const hasCompletedLevels = 'completed_levels' in data;
        
        // Remove fields that aren't in the schema
        if (!hasCompletedLevels) {
          delete progressData.completed_levels;
          console.warn("Database schema missing completed_levels column, removing from save data");
        }
        
        if (!hasPerfectLevels) {
          delete progressData.perfect_levels;
          console.warn("Database schema missing perfect_levels column, removing from save data");
        }
        
        // Save to database
        supabaseClient.from("game_progress")
          .update(progressData)
          .eq("user_id", currentUser.id)
          .then(({ data, error }) => {
            if (error) {
              console.error("Failed to save to database, using localStorage:", error);
              saveProgressToLocalStorage(progressData);
            } else {
              console.log("Progress successfully saved to database");
              saveProgressToLocalStorage(progressData);
              
              // Notify any open screens that might need to update
              document.dispatchEvent(new CustomEvent('progressSaved', { 
                detail: { gameState }
              }));
            }
          });
      });
  } else {
    console.log("Saving progress to localStorage (guest user)");
    saveProgressToLocalStorage(progressData);
  }
  
  // Save the current game context for quick reference
  const gameContext = {
    stage: gameState.currentStage,
    set: gameState.currentSet,
    level: gameState.currentLevel,
    timestamp: Date.now()
  };
  
  localStorage.setItem("gameContext", JSON.stringify(gameContext));
  console.log("Game context saved:", gameContext);
}

// Helper function to save to localStorage
function saveProgressToLocalStorage(progressData) {
    localStorage.setItem("simploxProgress", JSON.stringify(progressData));
}

function debugGameProgress() {
    console.group("Game Progress Debug");
    console.log("Current Stage:", gameState.currentStage);
    console.log("Current Set:", gameState.currentSet);
    console.log("Current Level:", gameState.currentLevel);
    
    console.log("Unlocked Sets:");
    Object.entries(gameState.unlockedSets).forEach(([stage, sets]) => {
        console.log(`Stage ${stage}:`, Array.from(sets).sort((a, b) => a - b));
    });
    
    console.log("Unlocked Levels:");
    Object.entries(gameState.unlockedLevels).forEach(([setKey, levels]) => {
        console.log(`Set ${setKey}:`, Array.from(levels).sort((a, b) => a - b));
    });
    
    console.log("Completed Levels:", Array.from(gameState.completedLevels).sort());
    console.log("Perfect Levels:", Array.from(gameState.perfectLevels).sort());
    console.groupEnd();
}

// Add to existing performance-related functions
function optimizeMobileRendering() {
    // Throttle particle generation
    ParticleSystem.maxParticles = 20; // Reduce from 50
    
    // Debounce heavy function calls
    const debouncedShowScreen = debounce(showScreen, 200);
    
    // Limit complex animations on mobile
    if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
        document.body.classList.add('mobile-device');
        
        // Reduce complex CSS animations
        document.head.insertAdjacentHTML('beforeend', `
            <style>
                @media (max-width: 768px) {
                    .confetti, .particle {
                        display: none;
                    }
                }
            </style>
        `);
    }
}

// Utility debounce function
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Modify existing event listeners
function optimizeMobileEvents() {
    // Use passive event listeners
    document.addEventListener('touchstart', () => {}, { passive: true });
    document.addEventListener('touchmove', () => {}, { passive: true });
    
    // Remove unnecessary event listeners
    const cleanupEventListeners = () => {
        document.querySelectorAll('.screen').forEach(screen => {
            screen.removeEventListener('touchstart', () => {});
            screen.removeEventListener('touchmove', () => {});
        });
    };
}



// Add to the end of the <body> section after all other scripts
// Accessibility Menu Functionality
document.addEventListener('DOMContentLoaded', function() {
    // Initialize accessibility menu
    initAccessibilityMenu();
});

function initAccessibilityMenu() {
    // Set up toggle button
    const toggleButton = document.querySelector('.accessibility-toggle');
    const modal = document.querySelector('.accessibility-modal');
    const closeButton = document.querySelector('.close-accessibility');
    
    // Load saved settings
    loadAccessibilitySettings();
    
    // Toggle modal visibility
    if (toggleButton && modal) {
        toggleButton.addEventListener('click', function() {
            modal.classList.add('show');
        });
    }
    
    // Close modal
    if (closeButton && modal) {
        closeButton.addEventListener('click', function() {
            modal.classList.remove('show');
        });
        
        // Close when clicking outside the content
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                modal.classList.remove('show');
            }
        });
    }
    
    // Add event listeners to all accessibility buttons
    const accessibilityButtons = document.querySelectorAll('.accessibility-button');
    accessibilityButtons.forEach(button => {
        button.addEventListener('click', function() {
            const action = this.getAttribute('data-action');
            const value = this.getAttribute('data-value');
            
            applyAccessibilitySetting(action, value);
            
            // Update active state on buttons
            if (action !== 'fontSize' && action !== 'reset') {
                const siblings = document.querySelectorAll(`[data-action="${action}"]`);
                siblings.forEach(sibling => sibling.classList.remove('active'));
                this.classList.add('active');
            }
        });
    });
}

function applyAccessibilitySetting(action, value) {
    const body = document.body;
    
    // Handle each setting type
    switch(action) {
        case 'contrast':
            body.classList.remove('high-contrast', 'inverted-colors');
            if (value === 'high') body.classList.add('high-contrast');
            if (value === 'inverted') body.classList.add('inverted-colors');
            break;
            
        case 'theme':
            body.classList.remove('light-theme', 'dark-theme');
            if (value === 'light') body.classList.add('light-theme');
            if (value === 'dark') body.classList.add('dark-theme');
            break;
            
        case 'saturation':
            body.classList.remove('grayscale');
            if (value === 'grayscale') body.classList.add('grayscale');
            break;
            
        case 'fontSize':
            let currentScale = parseFloat(getComputedStyle(body).getPropertyValue('--font-scale') || 1);
            
            if (value === 'increase') {
                currentScale = Math.min(currentScale + 0.1, 1.8);
                body.style.setProperty('--font-scale', currentScale);
                body.style.fontSize = `calc(1rem * ${currentScale})`;
            } else if (value === 'decrease') {
                currentScale = Math.max(currentScale - 0.1, 0.8);
                body.style.setProperty('--font-scale', currentScale);
                body.style.fontSize = `calc(1rem * ${currentScale})`;
            } else if (value === 'reset') {
                body.style.removeProperty('--font-scale');
                body.style.fontSize = '';
            }
            break;
            
        case 'fontFamily':
            body.classList.remove('dyslexic-font');
            if (value === 'dyslexic') body.classList.add('dyslexic-font');
            break;
            
        case 'letterSpacing':
            body.classList.remove('increased-letter-spacing');
            if (value === 'increased') body.classList.add('increased-letter-spacing');
            break;
            
        case 'animations':
            body.classList.remove('no-animations', 'reduced-animations');
            if (value === 'disabled') body.classList.add('no-animations');
            if (value === 'reduced') body.classList.add('reduced-animations');
            break;
            
        case 'focus':
            body.classList.remove('high-focus');
            if (value === 'high') body.classList.add('high-focus');
            break;
            
        case 'buttonSize':
            body.classList.remove('large-buttons');
            if (value === 'large') body.classList.add('large-buttons');
            break;
            
        case 'cursorSize':
            body.classList.remove('large-cursor');
            if (value === 'large') body.classList.add('large-cursor');
            break;
            
        case 'reset':
            if (value === 'all') resetAllAccessibilitySettings();
            break;
    }
    
    // Save settings
    saveAccessibilitySettings();
}

function saveAccessibilitySettings() {
    const body = document.body;
    const settings = {
        classNames: body.className,
        fontSize: body.style.fontSize,
        fontScale: body.style.getPropertyValue('--font-scale')
    };
    
    localStorage.setItem('accessibilitySettings', JSON.stringify(settings));
}

function loadAccessibilitySettings() {
    const savedSettings = localStorage.getItem('accessibilitySettings');
    if (savedSettings) {
        const settings = JSON.parse(savedSettings);
        const body = document.body;
        
        // Apply saved class names
        if (settings.classNames) {
            body.className = settings.classNames;
        }
        
        // Apply font size
        if (settings.fontSize) {
            body.style.fontSize = settings.fontSize;
        }
        
        // Apply font scale
        if (settings.fontScale) {
            body.style.setProperty('--font-scale', settings.fontScale);
        }
        
        // Mark active buttons
        updateActiveButtons();
    }
}

function updateActiveButtons() {
    const body = document.body;
    
    // Check classes and update button states
    const classesToCheck = {
        'high-contrast': { action: 'contrast', value: 'high' },
        'inverted-colors': { action: 'contrast', value: 'inverted' },
        'light-theme': { action: 'theme', value: 'light' },
        'dark-theme': { action: 'theme', value: 'dark' },
        'grayscale': { action: 'saturation', value: 'grayscale' },
        'dyslexic-font': { action: 'fontFamily', value: 'dyslexic' },
        'increased-letter-spacing': { action: 'letterSpacing', value: 'increased' },
        'no-animations': { action: 'animations', value: 'disabled' },
        'reduced-animations': { action: 'animations', value: 'reduced' },
        'high-focus': { action: 'focus', value: 'high' },
        'large-buttons': { action: 'buttonSize', value: 'large' },
        'large-cursor': { action: 'cursorSize', value: 'large' }
    };
    
    // Loop through possible classes and update buttons
    Object.entries(classesToCheck).forEach(([className, buttonData]) => {
        const hasClass = body.classList.contains(className);
        const button = document.querySelector(`[data-action="${buttonData.action}"][data-value="${buttonData.value}"]`);
        
        if (button) {
            if (hasClass) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
        }
    });
    
    // Set default buttons if no special settings
    if (!document.querySelector('[data-action="contrast"].active')) {
        document.querySelector('[data-action="contrast"][data-value="normal"]')?.classList.add('active');
    }
    
    if (!document.querySelector('[data-action="theme"].active')) {
        document.querySelector('[data-action="theme"][data-value="default"]')?.classList.add('active');
    }
    
    if (!document.querySelector('[data-action="saturation"].active')) {
        document.querySelector('[data-action="saturation"][data-value="normal"]')?.classList.add('active');
    }
    
    if (!document.querySelector('[data-action="fontFamily"].active')) {
        document.querySelector('[data-action="fontFamily"][data-value="default"]')?.classList.add('active');
    }
    
    if (!document.querySelector('[data-action="letterSpacing"].active')) {
        document.querySelector('[data-action="letterSpacing"][data-value="normal"]')?.classList.add('active');
    }
    
    if (!document.querySelector('[data-action="animations"].active')) {
        document.querySelector('[data-action="animations"][data-value="enabled"]')?.classList.add('active');
    }
    
    if (!document.querySelector('[data-action="focus"].active')) {
        document.querySelector('[data-action="focus"][data-value="normal"]')?.classList.add('active');
    }
    
    if (!document.querySelector('[data-action="buttonSize"].active')) {
        document.querySelector('[data-action="buttonSize"][data-value="normal"]')?.classList.add('active');
    }
    
    if (!document.querySelector('[data-action="cursorSize"].active')) {
        document.querySelector('[data-action="cursorSize"][data-value="normal"]')?.classList.add('active');
    }
}

function resetAllAccessibilitySettings() {
    const body = document.body;
    
    // Remove all accessibility classes
    body.classList.remove(
        'high-contrast', 'inverted-colors', 'light-theme', 'dark-theme',
        'grayscale', 'dyslexic-font', 'increased-letter-spacing',
        'no-animations', 'reduced-animations', 'high-focus',
        'large-buttons', 'large-cursor'
    );
    
    // Reset inline styles
    body.style.fontSize = '';
    body.style.removeProperty('--font-scale');
    
    // Reset active buttons
    document.querySelectorAll('.accessibility-button.active').forEach(button => {
        button.classList.remove('active');
    });
    
    // Set default buttons as active
    document.querySelector('[data-action="contrast"][data-value="normal"]')?.classList.add('active');
    document.querySelector('[data-action="theme"][data-value="default"]')?.classList.add('active');
    document.querySelector('[data-action="saturation"][data-value="normal"]')?.classList.add('active');
    document.querySelector('[data-action="fontFamily"][data-value="default"]')?.classList.add('active');
    document.querySelector('[data-action="letterSpacing"][data-value="normal"]')?.classList.add('active');
    document.querySelector('[data-action="animations"][data-value="enabled"]')?.classList.add('active');
    document.querySelector('[data-action="focus"][data-value="normal"]')?.classList.add('active');
    document.querySelector('[data-action="buttonSize"][data-value="normal"]')?.classList.add('active');
    document.querySelector('[data-action="cursorSize"][data-value="normal"]')?.classList.add('active');
    
    // Clear saved settings
    localStorage.removeItem('accessibilitySettings');
}

async function trackWordEncounter(word, mode) {
  if (currentUser) {  // Remove status check - allow for all registered users
    try {
      // Check if word exists in history
      const { data, error } = await supabaseClient.from("word_practice_history")
        .select("*")
        .eq("user_id", currentUser.id)
        .eq("word", word)
        .single();
      
      if (error && error.code !== 'PGRST116') {
        return console.error("Error fetching word history:", error);
      }
      
      let isNewWord = false;
      let coinReward = 0;
      
      if (data) {
        // Word exists, update count
        const newCount = data.practice_count + 1;
        coinReward = newCount <= 5 ? 3 : 1;
        
        const { error } = await supabaseClient.from("word_practice_history")
          .update({
            practice_count: newCount,
            last_practiced_at: new Date().toISOString(),
            game_mode: mode,
            coins_earned: data.coins_earned + coinReward
          })
          .eq("user_id", currentUser.id)
          .eq("word", word);
          
        if (error) return console.error("Error updating word history:", error);
      } else {
        // New word, insert record
        isNewWord = true;
        coinReward = 3;
        
        const { error } = await supabaseClient.from("word_practice_history")
          .insert([{
            user_id: currentUser.id,
            word: word,
            practice_count: 1,
            game_mode: mode,
            coins_earned: coinReward
          }]);
          
        if (error) return console.error("Error inserting word history:", error);
        
        // Update unique words count
        const { data, error: statsError } = await supabaseClient.from("player_stats")
          .select("unique_words_practiced")
          .eq("user_id", currentUser.id)
          .single();
          
        if (!statsError) {
          const newWordCount = (data?.unique_words_practiced || 0) + 1;
          const { error } = await supabaseClient.from("player_stats")
            .update({ unique_words_practiced: newWordCount })
            .eq("user_id", currentUser.id);
            
          if (error) console.error("Error updating player stats:", error);
          else {
            // Update UI word count immediately
            document.querySelectorAll("#totalWords").forEach(el => {
              animateNumber(el, parseInt(el.textContent) || 0, newWordCount);
            });
          }
        }
      }
      
      if (coinReward > 0) {
        await CoinsManager.updateCoins(coinReward);
      }
      
      return { isNewWord, coinReward };
    } catch (e) {
      console.error("Error in trackWordEncounter:", e);
    }
  }
}

function createRainingParticles() {
  const questionScreen = document.getElementById('question-screen');
  if (!questionScreen) return;
  
  const letters = [..."ABCDEFGHIJKLMNOPQRSTUVWXYZ",...""];
  const containerWidth = questionScreen.clientWidth;
  
  // Clear any existing interval
  if (window.rainingLettersInterval) {
    clearInterval(window.rainingLettersInterval);
  }
  
  // Create raining letters
  window.rainingLettersInterval = setInterval(() => {
    // Create between 1 and 3 letters each interval
    const count = Math.floor(Math.random() * 3) + 1;
    
    for (let i = 0; i < count; i++) {
      const letter = document.createElement('div');
      letter.className = 'raining-letter';
      letter.textContent = letters[Math.floor(Math.random() * letters.length)];
      
      // Random position and speed
      const left = Math.random() * containerWidth;
      const duration = 5 + Math.random() * 5; // 5-10 seconds
      
      letter.style.left = `${left}px`;
      letter.style.animationDuration = `${duration}s`;
      
      questionScreen.appendChild(letter);
      
      // Remove letter after animation completes
      setTimeout(() => {
        if (letter.parentNode === questionScreen) {
          questionScreen.removeChild(letter);
        }
      }, duration * 1000);
    }
  }, 300);
}

function updateBossHealthBar() {
  // Only update if we're in boss level
  if (!currentGame.isBossLevel) return;
  
  console.log("Updating boss health bar");

  const progressCircle = document.querySelector('.progress-circle');
  if (!progressCircle) {
    console.error("Progress circle not found");
    return;
  }
  
  const progress = progressCircle.querySelector('.progress');
  if (!progress) {
    console.error("Progress element not found");
    return;
  }
  
  // Calculate health values
  const totalWords = currentGame.words.length;
  const currentIndex = currentGame.currentIndex || 0;
  const remainingWords = Math.max(0, totalWords - currentIndex);
  const remainingPercentage = remainingWords / totalWords;
  
  console.log(`Boss health: ${remainingPercentage.toFixed(2) * 100}% (${remainingWords}/${totalWords})`);
  
  // Calculate the circumference
  const circumference = 2 * Math.PI * 54;
  
  // Update the stroke dash offset (reverse of normal progress)
  progress.style.strokeDashoffset = circumference * (1 - remainingPercentage);
  
  // Add boss-health class if not already present
  if (!progress.classList.contains('boss-health')) {
    progress.classList.add('boss-health');
  }
  
  // Change color based on health
  if (remainingPercentage > 0.66) {
    // Full health - green
    progress.style.stroke = '#4CAF50';
    progress.classList.remove('warning');
  } else if (remainingPercentage > 0.33) {
    // Medium health - yellow/orange
    progress.style.stroke = '#FFA500';
    progress.classList.remove('warning');
    
    // Boss health restoration at 2/3 health (once)
    if (remainingPercentage <= 0.66 && !currentGame.bossFirstHealthRestored) {
      currentGame.bossFirstHealthRestored = true;
      console.log("First boss health restoration");
      
      // Partially restore health (reduce current index)
      const newIndex = Math.floor(totalWords * 0.25); // 75% health
      currentGame.currentIndex = newIndex;
      
      // Show visual effect
      const bossOrb = document.querySelector('.boss-orb-inner');
      if (bossOrb) {
        bossOrb.style.background = 'radial-gradient(circle at 30% 30%, #FFEB3B, #FFA500)';
        setTimeout(() => {
          bossOrb.style.background = 'radial-gradient(circle at 30% 30%, #ff3333, #990000)';
        }, 1000);
      }
      
      // Update health bar after restoring
      setTimeout(() => updateBossHealthBar(), 100);
    }
  } else {
    // Low health - red
    progress.style.stroke = '#FF3333';
    progress.classList.add('warning');
    
    // Boss health restoration at 1/3 health (once)
    if (remainingPercentage <= 0.33 && !currentGame.bossSecondHealthRestored) {
      currentGame.bossSecondHealthRestored = true;
      console.log("Second boss health restoration");
      
      // Partially restore health (reduce current index)
      const newIndex = Math.floor(totalWords * 0.5); // 50% health
      currentGame.currentIndex = newIndex;
      
      // Show visual effect
      const bossOrb = document.querySelector('.boss-orb-inner');
      if (bossOrb) {
        bossOrb.style.background = 'radial-gradient(circle at 30% 30%, #4CAF50, #388E3C)';
        setTimeout(() => {
          bossOrb.style.background = 'radial-gradient(circle at 30% 30%, #ff3333, #990000)';
        }, 1000);
      }
      
      // Update health bar after restoring
      setTimeout(() => updateBossHealthBar(), 100);
    }
  }
}

function healBoss(newHealthPercentage, flashColor) {
  const progressCircle = document.querySelector('.progress-circle');
  const progress = progressCircle ? progressCircle.querySelector('.progress') : null;
  const bossOrb = document.querySelector('.boss-orb-inner');
  
  if (!progress || !bossOrb) return;
  
  // Flash the boss orb with the specified color
  const originalColor = bossOrb.style.background;
  bossOrb.style.background = flashColor;
  bossOrb.classList.add('boss-restore-health');
  
  // Flash the screen
  const questionScreen = document.querySelector('.question-screen');
  if (questionScreen) {
    questionScreen.style.animation = 'none';
    questionScreen.offsetHeight; // Trigger reflow
    questionScreen.style.animation = 'bossRestoreHealth 1s';
  }
  
  // Calculate new offset
  const circumference = 2 * Math.PI * 54;
  const newOffset = circumference * (1 - newHealthPercentage);
  
  // Animate health bar filling
  setTimeout(() => {
    progress.style.transition = 'stroke-dashoffset 1s ease-out';
    progress.style.strokeDashoffset = newOffset;
    
    // Reset boss orb
    setTimeout(() => {
      bossOrb.style.background = originalColor;
      bossOrb.classList.remove('boss-restore-health');
    }, 1000);
  }, 300);
}

function showBossHitEffect(randomColor = false) {
  const bossOrb = document.querySelector('.boss-orb-inner');
  if (!bossOrb) return;
  
  // Store original background
  const originalBg = bossOrb.style.background;
  
  // Apply random color if requested
  if (randomColor) {
    const colors = ['yellow', 'purple', 'turquoise', 'darkgreen', 'brown'];
    const randomColorChoice = colors[Math.floor(Math.random() * colors.length)];
    bossOrb.style.background = `radial-gradient(circle at 30% 30%, ${randomColorChoice}, #990000)`;
  }
  
  // Add hit effect
  bossOrb.classList.add('boss-orb-hit');
  
  // Reset after animation
  setTimeout(() => {
    bossOrb.classList.remove('boss-orb-hit');
    // Reset background only if we changed it
    if (randomColor) {
      bossOrb.style.background = originalBg;
    }
  }, 300);
}


function applyBossLevelStyles() {
  console.log("Forcefully applying boss level styles");
  
  const questionScreen = document.getElementById("question-screen");
  if (questionScreen) {
    questionScreen.style.setProperty("background", "linear-gradient(135deg, #800000, #3a0000)", "important");
    questionScreen.style.setProperty("animation", "pulseBg 4s infinite", "important");
  }
  
  // Add boss animations stylesheet if not already present
  if (!document.getElementById("boss-animations")) {
    const styleElem = document.createElement("style");
    styleElem.id = "boss-animations";
    styleElem.textContent = `
      @keyframes pulseBg {
        0%, 100% { filter: brightness(1); }
        50% { filter: brightness(1.2); }
      }
      
      @keyframes pulseOrb {
        0%, 100% { transform: scale(1); filter: brightness(1); }
        50% { transform: scale(1.3); filter: brightness(1.4); }
      }
      
      @keyframes pulseWord {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
      }
    `;
    document.head.appendChild(styleElem);
  }
  
  // Style the question word
  const questionWord = document.getElementById("question-word");
  if (questionWord) {
    questionWord.style.setProperty("color", "#ff3333", "important");
    questionWord.style.setProperty("text-shadow", "0 0 10px rgba(255, 0, 0, 0.5)", "important");
    questionWord.style.setProperty("animation", "pulseWord 2s infinite", "important");
  }
  
  // Replace coins container with boss orb
  const coinsContainer = document.querySelector(".coins-container");
  if (coinsContainer) {
    if (!window.originalCoinsHTML) {
      window.originalCoinsHTML = coinsContainer.innerHTML;
    }
    
    coinsContainer.innerHTML = `
    <div class="boss-orb" style="
      width: 85px;
      height: 85px;
      top: 50%;
      left: 50%;
      transform: translate(-75%, -75%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    ">
      <div class="boss-orb-inner" style="
        width: 50px;
        height: 50px;
        background: radial-gradient(circle at 30% 30%, #ff3333, #990000);
        border-radius: 50%;
        box-shadow: 0 0 20px #ff3333, inset 0 0 10px rgba(255,255,255,0.3);
        animation: pulseOrb 1s infinite;
      "></div>
    </div>
  `;
  }
}

function handleBossAnswer(correct) {
  if (correct) {
    // Make progress bar flicker
    const progressCircle = document.querySelector(".progress-circle");
    const progressBar = progressCircle?.querySelector(".progress");
    
    if (progressBar) {
      // Save original stroke color
      const originalColor = progressBar.style.stroke;
      
      // Create and apply flicker animation
      const flickerColors = ["#ffffff", "#ffff00", "#800080", "#990000"];
      const randomColor = flickerColors[Math.floor(Math.random() * flickerColors.length)];
      
      progressBar.style.transition = "stroke 0.2s ease";
      progressBar.style.stroke = randomColor;
      
      // Reset back to green after flicker
      setTimeout(() => {
        progressBar.style.stroke = originalColor;
      }, 200);
    }
  }
}

// Boss Level Visual and Interaction Enhancements

function createBossTimer() {
    const timerContainer = document.createElement('div');
    timerContainer.id = 'boss-timer';
    timerContainer.style.cssText = `
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        justify-content: center;
        z-index: 10;
    `;
    
    const timerDisplay = document.createElement('div');
    timerDisplay.style.cssText = `
        background-color: rgba(255, 215, 0, 0.8);
        color: #000;
        font-family: 'Digital', monospace;
        font-size: 2rem;
        padding: 5px 10px;
        border-radius: 5px;
        letter-spacing: 3px;
    `;
    
    timerContainer.appendChild(timerDisplay);
    return { container: timerContainer, display: timerDisplay };
}

function updateBossTimer(timerDisplay, timeRemaining) {
    if (timerDisplay) {
        const minutes = Math.floor(timeRemaining / 60);
        const seconds = timeRemaining % 60;
        timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
}

function createLightningEffect() {
    const lightningContainer = document.createElement('div');
    lightningContainer.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.8);
        z-index: 1000;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.1s ease;
    `;
    document.body.appendChild(lightningContainer);

    const flickerCount = Math.floor(Math.random() * 3) + 1;
    let delay = 0;

    for (let i = 0; i < flickerCount; i++) {
        setTimeout(() => {
            lightningContainer.style.opacity = '1';
            setTimeout(() => {
                lightningContainer.style.opacity = '0';
            }, 50);
        }, delay);
        delay += 200;
    }

    setTimeout(() => {
        document.body.removeChild(lightningContainer);
    }, delay + 500);
}

function createBossRainingLetters() {
    const questionScreen = document.getElementById('question-screen');
    if (!questionScreen) return;

    // Clear any existing intervals
    if (window.rainingLettersInterval) {
        clearInterval(window.rainingLettersInterval);
    }

    const letters = [...'ABCDEFGHIJKLMNOPQRSTUVWXYZ', ...''];
    const screenWidth = questionScreen.clientWidth;

    window.rainingLettersInterval = setInterval(() => {
        const particleCount = Math.floor(Math.random() * 3) + 1;
        
        for (let i = 0; i < particleCount; i++) {
            const letter = document.createElement('div');
            letter.className = 'boss-raining-letter';
            letter.textContent = letters[Math.floor(Math.random() * letters.length)];
            
            letter.style.cssText = `
                position: absolute;
                top: -20px;
                left: ${Math.random() * screenWidth}px;
                color: rgba(255, 0, 0, 0.4);
                font-size: 16px;
                animation: boss-letter-rain 5s linear forwards;
                z-index: 1;
                text-shadow: 0 0 5px rgba(255, 0, 0, 0.3);
            `;

            questionScreen.appendChild(letter);

            // Remove letter after animation
            setTimeout(() => {
                if (letter.parentNode === questionScreen) {
                    questionScreen.removeChild(letter);
                }
            }, 5000);
        }
    }, 300);
}

function stopBossRainingLetters() {
    if (window.rainingLettersInterval) {
        clearInterval(window.rainingLettersInterval);
        window.rainingLettersInterval = null;
    }
}

function createBossStyleSheet() {
  const styleElem = document.createElement("style");
  styleElem.id = "boss-level-styles";
  styleElem.textContent = `
    @keyframes boss-letter-rain {
      0% { 
        transform: translateY(-20px);
        opacity: 0.6;
      }
      100% { 
        transform: translateY(100vh);
        opacity: 0;
      }
    }

    @keyframes boss-shrink {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(0.8); opacity: 0.8; }
      100% { transform: scale(0); opacity: 0; }
    }

    @keyframes fade-to-blue {
      0% { background: linear-gradient(135deg, #800000, #3a0000); }
      20% { background: linear-gradient(135deg, #800000, #3a0000); }
      60% { background: linear-gradient(135deg, #4a1582, #0d47a1); }
      100% { background: radial-gradient(circle at center, var(--secondary) 0%, var(--primary-dark) 100%); }
    }
    
    @keyframes incinerateEffect {
      0% { transform: scale(0); opacity: 0; }
      10% { transform: scale(0.5); opacity: 0.8; }
      50% { transform: scale(1.5); opacity: 1; }
      100% { transform: scale(3); opacity: 0; }
    }
    
    .incineration-effect {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(circle, #ff9900, #ff3300);
      opacity: 0;
      transform: scale(0);
      animation: incinerateEffect 1.5s forwards;
    }
  `;
  document.head.appendChild(styleElem);
}

function showModernBossVictoryScreen() {
    const victoryOverlay = document.createElement('div');
    victoryOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
        opacity: 0;
        transition: opacity 0.5s ease;
    `;

    const victoryContent = document.createElement('div');
    victoryContent.style.cssText = `
        background: linear-gradient(135deg, #00c6ff, #0072ff);
        padding: 2rem;
        border-radius: 20px;
        text-align: center;
        max-width: 500px;
        width: 90%;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    `;

    victoryContent.innerHTML = `
        <h2 style="color: white; font-size: 2.5rem; margin-bottom: 1rem;"> Boss Defeated!</h2>
        <div class="victory-stats" style="display: flex; justify-content: space-around; margin: 1.5rem 0; color: white;">
            <div>
                <div style="font-size: 1.2rem; opacity: 0.7;">Words Learned</div>
                <div style="font-size: 2rem; font-weight: bold;">${currentGame.words.length}</div>
            </div>
            <div>
                <div style="font-size: 1.2rem; opacity: 0.7;">Coins Earned</div>
                <div style="font-size: 2rem; font-weight: bold;">100</div>
            </div>
        </div>
        <div style="display: flex; justify-content: center; gap: 1rem;">
            <button class="continue-btn" style="
                background: #4CAF50; 
                color: white; 
                border: none; 
                padding: 1rem 2rem; 
                border-radius: 50px; 
                font-size: 1rem; 
                cursor: pointer;
                transition: transform 0.3s ease;
            ">Continue to Next Set</button>
            <button class="home-btn" style="
                background: rgba(255,255,255,0.2); 
                color: white; 
                border: 2px solid white; 
                padding: 1rem 2rem; 
                border-radius: 50px; 
                font-size: 1rem; 
                cursor: pointer;
                transition: transform 0.3s ease;
            ">Return Home</button>
        </div>
    `;

    const continueBtn = victoryContent.querySelector('.continue-btn');
    const homeBtn = victoryContent.querySelector('.home-btn');

    [continueBtn, homeBtn].forEach(btn => {
        btn.addEventListener('mouseenter', () => {
            btn.style.transform = 'scale(1.05)';
        });
        btn.addEventListener('mouseleave', () => {
            btn.style.transform = 'scale(1)';
        });
    });

    continueBtn.addEventListener('click', () => {
        victoryOverlay.style.opacity = '0';
        setTimeout(() => {
            victoryOverlay.remove();
            unlockNextSet();
            const nextSet = gameState.currentSet + 1;
            gameState.currentSet = nextSet;
            gameState.currentLevel = 1;
            startLevel(1);
        }, 500);
    });

    homeBtn.addEventListener('click', () => {
        victoryOverlay.style.opacity = '0';
        setTimeout(() => {
            victoryOverlay.remove();
            unlockNextSet();
            showScreen('welcome-screen');
        }, 500);
    });

    victoryOverlay.appendChild(victoryContent);
    document.body.appendChild(victoryOverlay);

    // Trigger fade-in
    requestAnimationFrame(() => {
        victoryOverlay.style.opacity = '1';
    });
}

function showBossDefeatEffect() {
  console.log("Starting boss defeat effect sequence");
  
  // 1. Start with a delay
  setTimeout(() => {
    const questionScreen = document.querySelector(".question-screen");
    const bossOrb = document.querySelector(".boss-orb-inner");
    
    // 2. Make boss orb disintegrate
    if (bossOrb) {
      console.log("Disintegrating boss orb");
      
      // Add explosion effect to the orb
      const explosionEffect = document.createElement("div");
      explosionEffect.className = "incineration-effect";
      bossOrb.appendChild(explosionEffect);
      
      // Shrink the orb while exploding
      bossOrb.style.animation = "boss-shrink 1.5s forwards";
      
      // After orb disintegrates, restore coin counter to its place
      setTimeout(() => {
        console.log("Restoring coin counter");
        const coinsContainer = document.querySelector(".coins-container");
        if (coinsContainer && window.originalCoinsHTML) {
          coinsContainer.innerHTML = window.originalCoinsHTML;
          
          // Animate coin return
          const coinIcon = coinsContainer.querySelector(".coin-icon");
          const coinCount = coinsContainer.querySelector(".coin-count");
          
          if (coinIcon) {
            coinIcon.style.transform = "scale(0)";
            setTimeout(() => {
              coinIcon.style.transition = "transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)";
              coinIcon.style.transform = "scale(1)";
            }, 100);
          }
          
          if (coinCount) {
            coinCount.textContent = gameState.coins + 100; // Add the boss defeat reward
            coinCount.style.transform = "scale(0)";
            setTimeout(() => {
              coinCount.style.transition = "transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)";
              coinCount.style.transform = "scale(1)";
            }, 300);
          }
        }
      }, 1500);
    }
    
    // 3. Explicitly animate background with a custom element to ensure smooth transition
    if (questionScreen) {
      console.log("Starting background transition");
      
      // Create a full-screen overlay for the transition
      const transitionOverlay = document.createElement("div");
      transitionOverlay.className = "background-transition-overlay";
      transitionOverlay.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #800000, #3a0000);
        z-index: -1;
        transition: background 5s ease-in-out;
        pointer-events: none;
      `;
      
      // Insert before other elements but after question screen
      questionScreen.insertBefore(transitionOverlay, questionScreen.firstChild);
      
      // Force a reflow
      void transitionOverlay.offsetWidth;
      
      // Start transition after a small delay
      setTimeout(() => {
        console.log("Transitioning to purple");
        transitionOverlay.style.background = "linear-gradient(135deg, #4a1582, #0d47a1)";
        
        // Complete transition to blue
        setTimeout(() => {
          console.log("Transitioning to normal blue");
          transitionOverlay.style.background = "radial-gradient(circle at center, var(--secondary) 0%, var(--primary-dark) 100%)";
          
          // Switch particles back to normal
          if (typeof stopBossRainingLetters === 'function') {
            stopBossRainingLetters();
          }
          initializeParticles(questionScreen);
          
          // After background transition completes, show victory notification
          setTimeout(() => {
            console.log("Showing victory notification");
            showBossVictoryNotification();
          }, 1000);
        }, 2500);
      }, 500);
    } else {
      // Fallback if question screen isn't found
      setTimeout(() => showBossVictoryNotification(), 4000);
    }
    
  }, 2000); // Initial delay
}

function showBossVictoryNotification() {
  CoinsManager.updateCoins(100);
  updateAllCoinDisplays(); // Add this to update coin display immediately
  
  const e = document.createElement("div");
  e.className = "arcade-completion-modal";
  e.innerHTML = `
    <div class="completion-modal-content">
      <h2 style="color: var(--gold)">Boss Defeated!</h2>
      <p style="font-size: 1.2rem; margin: 1rem 0;">Congratulations! You've conquered this challenge!</p>
      
      <div class="completion-stats">
        <div class="stat-item">
          <i class="fas fa-skull" style="font-size: 2rem; color: var(--gold); margin-bottom: 0.5rem;"></i>
          <span style="display: block; margin-bottom: 0.25rem;">Boss Defeated</span>
          <strong style="font-size: 1.5rem;"></strong>
        </div>
        <div class="stat-item">
          <i class="fas fa-coins" style="font-size: 2rem; color: var(--gold); margin-bottom: 0.5rem;"></i>
          <span style="display: block; margin-bottom: 0.25rem;">Bonus Coins</span>
          <strong style="font-size: 1.5rem;">100</strong>
        </div>
        <div class="stat-item">
          <i class="fas fa-unlock" style="font-size: 2rem; color: var(--gold); margin-bottom: 0.5rem;"></i>
          <span style="display: block; margin-bottom: 0.25rem;">New Set</span>
          <strong style="font-size: 1.5rem;">Unlocked</strong>
        </div>
      </div>
      
      <div style="display: flex; justify-content: space-around; margin-top: 2rem; gap: 1rem;">
        <button onclick="handleBossVictoryContinue()" class="start-button" style="
          background: var(--accent);
          color: var(--text);
          border: none;
          padding: 1rem 2rem;
          border-radius: 50px;
          font-size: 1.1rem;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.3s ease;
          box-shadow: 0 5px 15px rgba(30, 144, 255, 0.3);
        ">
          Next Set
        </button>
        <button onclick="handleBossVictoryHome()" class="start-button" style="
          background: transparent;
          color: var(--text);
          border: 2px solid var(--accent);
          padding: 1rem 2rem;
          border-radius: 50px;
          font-size: 1.1rem;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.3s ease;
        ">
          Return Home
        </button>
      </div>
    </div>
  `;
  document.body.appendChild(e);
  requestAnimationFrame(() => e.classList.add("show"));
}

function handleBossVictoryContinue() {
  console.log("Boss victory continue button clicked");
  const e = document.querySelector(".arcade-completion-modal");
  updateAllCoinDisplays(); // Add this line to update coin display immediately
  
  e && (e.classList.remove("show"), 
    setTimeout((()=>{
      e.remove();
      const t = document.querySelector(".background-transition-overlay");
      t ? (console.log("Using existing transition overlay for smooth transition"),
      t.style.background = "radial-gradient(circle at center, var(--secondary) 0%, var(--primary-dark) 100%)",
      resetBossStyles(!0)) : resetBossStyles(),
      unlockNextSet();
      const n = gameState.currentSet + 1;
      gameState.currentSet = n,
      gameState.currentLevel = 1,
      updateAllCoinDisplays(), // Add this line to update coin display before next level
      setTimeout((()=>{
        console.log("Starting next level"),
        t && t.parentNode && t.parentNode.removeChild(t),
        startLevel(1)
      }), 500)
    }), 300)
  )
}

function resetBossStyles(e = false) {
  console.log("Resetting boss styles", e ? "(preserving overlay)" : "");

  // Reset boss health bar styling
  const progressCircle = document.querySelector('.progress-circle');
  if (progressCircle) {
    const progress = progressCircle.querySelector('.progress');
    if (progress) {
      progress.classList.remove('warning', 'boss-health');
      progress.style.stroke = '';  // Reset to default color
      progress.style.animation = 'none';
      
      // Force reflow to make sure animation removal takes effect
      void progress.offsetWidth;
      progress.style.animation = '';
    }
  }
  
  const t = document.getElementById("question-screen");
  if (t) {
    const n = t.querySelector(".background-transition-overlay");
    e && n && n.remove();
    t.removeAttribute("style");
    e && n && t.insertBefore(n, t.firstChild);
    e || (t.querySelectorAll(".background-transition-overlay").forEach(e => e.remove()),
    setTimeout(() => {
      t.style.background = "radial-gradient(circle at center, var(--secondary) 0%, var(--primary-dark) 100%)";
    }, 10));
  }
  
  const n = document.getElementById("question-word");
  n && n.removeAttribute("style");
  
  "function" == typeof stopBossRainingLetters && stopBossRainingLetters();
  
  const r = e ? ".incineration-effect, .boss-orb" : ".incineration-effect, .boss-orb, .background-transition-overlay";
  document.querySelectorAll(r).forEach(e => {
    e.parentNode && e.parentNode.removeChild(e);
  });
}

function handleBossVictoryHome() {
  console.log("Boss victory home button clicked");
  const e = document.querySelector(".arcade-completion-modal");
  updateAllCoinDisplays(); // Add this line to update coin display immediately
  
  e && (e.classList.remove("show"), 
    setTimeout((()=>{
      e.remove(),
      resetBossStyles(),
      unlockNextSet();
      const t = gameState.currentSet + 1;
      gameState.currentSet = t,
      gameState.currentLevel = 1,
      saveProgress(),
      showScreen("welcome-screen")
    }), 300)
  )
}

// ADD this function to check if the current user is the admin
function isAdminUser() {
  return currentUser && currentUser.email === "admin123@gmail.com";
}

// ADD this function to create the admin skip button
function addAdminSkipButton() {
  // Only add for admin user
  if (!isAdminUser()) return;
  
  // Remove any existing admin skip button first
  const existingButton = document.getElementById("admin-skip-10-button");
  if (existingButton) existingButton.remove();
  
  // Create the admin skip button
  const skipButton = document.createElement("button");
  skipButton.id = "admin-skip-10-button";
  skipButton.innerHTML = '<i class="fas fa-forward"></i> Skip 10';
  skipButton.style.cssText = `
    position: fixed;
    bottom: 80px;
    right: 20px;
    background: #9c27b0;
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 5px;
    cursor: pointer;
    z-index: 2000;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    font-weight: bold;
  `;
  
  // Add the click handler
  skipButton.onclick = function() {
    console.log("Admin skip-10 button clicked");
    handleAdminSkip10();
  };
  
  // Add the button to the question screen
  const questionScreen = document.getElementById("question-screen");
  if (questionScreen) {
    questionScreen.appendChild(skipButton);
  }
}

// ADD this function to handle the skip-10 action
function handleAdminSkip10() {
  // Only work for admin user
  if (!isAdminUser()) return;
  
  // Check if we're in an active game
  if (!currentGame || !currentGame.words || !currentGame.words.length) {
    console.error("No active game found");
    return;
  }
  
  // Skip 10 questions or all remaining if less than 10 left
  const skipCount = Math.min(10, currentGame.words.length - currentGame.currentIndex);
  console.log(`Skipping ${skipCount} questions`);
  
  // If this is a boss level, handle it differently
  if (currentGame.isBossLevel) {
    // For boss levels, we directly set the index near the end
    // This will trigger the boss defeat sequence on the next answer
    currentGame.currentIndex = Math.max(0, currentGame.words.length - 1);
    updateBossHealthBar();
    loadNextBossQuestion();
    showNotification(`Boss almost defeated! One more hit!`, "success");
    return;
  }
  
  // For regular levels
  currentGame.currentIndex += skipCount;
  
  // If we've reached the end of the level
  if (currentGame.currentIndex >= currentGame.words.length) {
    handleLevelCompletion();
    return;
  }
  
  // Otherwise update progress and load the next question
  updateProgressCircle();
  loadNextQuestion();
  showNotification(`Skipped ${skipCount} questions!`, "success");
}

// MODIFY addAdminTestButton function to call our new function
function addAdminTestButton() {
  console.log("Checking for admin user...");
  
  // Remove any existing button
  const existingButton = document.getElementById("admin-test-button");
  if (existingButton) {
    existingButton.remove();
  }
  
  console.log("Current user:", currentUser ? currentUser.email : "No user");
  
  // Check if the current user is admin
  if (!currentUser || (currentUser.email !== "admin123@gmail.com" && !currentUser.email?.includes("admin123"))) {
    console.log("Not admin user, not adding button");
    return;
  }
  
  console.log("Admin user detected, adding test buttons");
  
  // Add level 20 button
  const button = document.createElement("button");
  button.id = "admin-test-button";
  button.textContent = "Jump to Level 20";
  button.style.cssText = `
    position: fixed;
    top: 80px;
    right: 20px;
    background: #ff5722;
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 5px;
    cursor: pointer;
    z-index: 2000;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    font-weight: bold;
  `;
  
  button.onclick = function() {
    console.log("Admin button clicked, jumping to level 20");
    gameState.currentLevel = 21;
    startLevel(21);
  };
  
  document.body.appendChild(button);
  console.log("Admin test button added to body");
  
  // Now also add our skip button
  addAdminSkipButton();
}


createBossStyleSheet();

/**
 * CustomListsManager - Manages all custom word lists operations
 */
 const CustomListsManager = {
  lists: [],
  currentList: null,

  /**
   * Initialize the lists manager
   */
  async initialize() {
    try {
      if (currentUser) {
        await this.loadFromSupabase();
      } else {
        this.loadFromLocalStorage();
      }

      if (!this.lists || this.lists.length === 0) {
        console.log("No lists found, initializing empty array");
        this.lists = [];
      }
    } catch (error) {
      console.error("Custom Lists Initialization Error:", error);
      this.lists = [];
    }
  },

  /**
   * Load lists from Supabase database
   */
  async loadFromSupabase() {
    try {
      const { data, error } = await supabaseClient
        .from("custom_lists")
        .select("*")
        .or(`user_id.eq.${currentUser.id},shared_with.cs.{${currentUser.id}}`);

      if (error) throw error;

      this.lists = data.map(list => ({
        id: list.id,
        name: list.name,
        words: list.words || [],
        translations: list.translations || [],
        isShared: list.is_shared,
        sharedBy: list.shared_by,
        userId: list.user_id,
        createdAt: list.created_at
      }));
    } catch (error) {
      console.error("Error loading lists from Supabase:", error);
      this.lists = [];
    }
  },

  /**
   * Load lists from local storage
   */
  loadFromLocalStorage() {
    try {
      const storedLists = localStorage.getItem("simploxCustomLists");
      this.lists = storedLists ? JSON.parse(storedLists) : [];
      console.log("Loaded lists from localStorage:", this.lists.length);
    } catch (error) {
      console.error("Error loading lists from localStorage:", error);
      this.lists = [];
    }
  },

  /**
   * Save a list to storage
   * @param {Object} list - The list to save
   * @returns {Object|null} - The saved list or null if failed
   */
  async save(list) {
    if (!list) return null;

    return currentUser ? 
      await this.saveToSupabase(list) : 
      this.saveToLocalStorage(list);
  },

  /**
   * Save a list to Supabase
   * @param {Object} list - The list to save
   * @returns {Object|null} - The saved list or null if failed
   */
  async saveToSupabase(list) {
    try {
      const listData = {
        name: list.name,
        words: list.words || [],
        translations: list.translations || [],
        user_id: currentUser.id
      };

      // Update existing list
      if (list.id && typeof list.id === 'string' && list.id.length === 36) {
        const { data, error } = await supabaseClient
          .from("custom_lists")
          .update(listData)
          .eq("id", list.id)
          .select()
          .single();

        if (error) throw error;
        return data;
      } 
      // Create new list
      else {
        const { data, error } = await supabaseClient
          .from("custom_lists")
          .insert(listData)
          .select()
          .single();

        if (error) throw error;

        // Update lists array
        const index = this.lists.findIndex(item => 
          item.id === list.id || (item.tempId && item.tempId === list.tempId)
        );

        if (index !== -1) {
          this.lists[index] = {
            ...data,
            words: data.words || [],
            translations: data.translations || []
          };
        } else {
          this.lists.push({
            ...data,
            words: data.words || [],
            translations: data.translations || []
          });
        }

        return data;
      }
    } catch (error) {
      console.error("Error saving list to Supabase:", error);
      return null;
    }
  },

  /**
   * Save a list to local storage
   * @param {Object} list - The list to save
   * @returns {Object|null} - The saved list or null if failed
   */
  saveToLocalStorage(list) {
    try {
      const newList = {
        ...list,
        id: list.id || Date.now(),
        tempId: list.tempId || Date.now()
      };

      const index = this.lists.findIndex(item => 
        item.id === list.id || (item.tempId && item.tempId === list.tempId)
      );

      if (index !== -1) {
        this.lists[index] = newList;
      } else {
        this.lists.push(newList);
      }

      localStorage.setItem("simploxCustomLists", JSON.stringify(this.lists));
      return newList;
    } catch (error) {
      console.error("Error saving list to localStorage:", error);
      return null;
    }
  },

  /**
   * Delete a list
   * @param {string|number} id - The list ID to delete
   * @returns {boolean} - Success status
   */
  async delete(id) {
    if (!currentUser) {
      // For guest users, delete from local storage
      this.lists = this.lists.filter(list => list.id !== id);
      localStorage.setItem("simploxCustomLists", JSON.stringify(this.lists));
      return true;
    }

    try {
      // For logged in users, delete from Supabase
      if (typeof id === 'string' && id.length === 36) {
        const { error } = await supabaseClient
          .from("custom_lists")
          .delete()
          .eq("id", id);

        if (error) throw error;
      }

      this.lists = this.lists.filter(list => list.id !== id);
      return true;
    } catch (error) {
      console.error("Error deleting list from Supabase:", error);
      return false;
    }
  },

  /**
   * Share a list with another user
   * @param {string|number} listId - The list ID to share
   * @param {string} targetUserId - The user ID to share with
   * @returns {boolean} - Success status
   */
  async share(listId, targetUserId) {
    if (!currentUser) return false;

    try {
      const listIdStr = String(listId);
      const list = this.lists.find(list => String(list.id) === listIdStr);
      
      if (!list) {
        console.error("List not found for sharing:", listIdStr);
        return false;
      }

      console.log("Sharing list:", list.name);

      const { data, error } = await supabaseClient.rpc(
        "insert_shared_list",
        {
          p_user_id: targetUserId,
          p_name: `${list.name} (Shared by ${currentUser.user_metadata?.username || "User"})`,
          p_words: list.words || [],
          p_translations: list.translations || [],
          p_is_shared: true,
          p_local_id: Date.now(),
          p_shared_with: [targetUserId],
          p_shared_by: currentUser.id
        }
      );

      if (error) {
        console.error("Error sharing list via RPC:", error);
        return false;
      }

      console.log("List shared successfully:", data);
      return true;
    } catch (error) {
      console.error("Error in share method:", error);
      return false;
    }
  },

  /**
   * Get the limits for lists based on user status
   * @returns {Object} - Limits object
   */
  getListLimits() {
    if (!currentUser) {
      return {
        maxLists: 3,
        maxWords: 10,
        maxPlays: 5,
        canShare: false,
        playDisplay: "5"
      };
    }

    switch (currentUser.status || "free") {
      case "premium":
        return {
          maxLists: 30,
          maxWords: 50,
          maxPlays: Infinity,
          canShare: true,
          playDisplay: ""
        };
      case "pending":
        return {
          maxLists: 30,
          maxWords: 50,
          maxPlays: Infinity,
          canShare: false,
          playDisplay: ""
        };
      case "free":
        return {
          maxLists: 5,
          maxWords: 20,
          maxPlays: 10,
          canShare: false,
          playDisplay: "10"
        };
      default:
        return {
          maxLists: 3,
          maxWords: 10,
          maxPlays: 5,
          canShare: false,
          playDisplay: "5"
        };
    }
  },

  /**
   * Check if user can create more lists
   * @returns {boolean} - True if more lists can be created
   */
  canCreateMoreLists() {
    const limits = this.getListLimits();
    return this.lists.length < limits.maxLists;
  },

  /**
   * Validate if a list can be practiced
   * @param {Object} list - The list to validate
   * @returns {Object} - Validation result with valid flag and message
   */
  validateListForPractice: (list) => {
    if (!list || !list.words || !list.translations) {
      return { valid: false, message: "Invalid list format" };
    }
    
    if (list.words.length < 6) {
      return { valid: false, message: "Lists need at least 6 words to practice" };
    }
    
    return { valid: true };
  }
};

/**
 * Custom game state for practice mode
 */
const customGameState = {
  isCustomPractice: false,
  currentList: null,
  currentLevel: 1,
  levelData: null,
  words: [],
  translations: [],
  wordsCompleted: 0,
  correctStreak: 0,
  wrongStreak: 0,
  startCoins: 0,
  completedLevels: new Set(),

  /**
   * Reset the custom game state
   */
  reset() {
    this.isCustomPractice = false;
    this.currentList = null;
    this.currentLevel = 1;
    this.levelData = null;
    this.words = [];
    this.translations = [];
    this.wordsCompleted = 0;
    this.correctStreak = 0;
    this.wrongStreak = 0;
    this.startCoins = 0;
    this.completedLevels = new Set();
  },

  /**
   * Initialize custom game from a list
   * @param {Object} list - The list to initialize from
   * @returns {boolean} - Success status
   */
  initializeFromList(list) {
    if (!list || !list.words || !list.translations) {
      console.error("Invalid list provided to custom game:", list);
      return false;
    }

    this.reset();
    this.isCustomPractice = true;
    this.currentList = list;
    this.words = [...list.words];
    this.translations = [...list.translations];
    this.startCoins = gameState.coins;
    this.currentLevel = 1;
    return true;
  },

  /**
   * Get words for a specific level
   * @param {number} level - The level number
   * @returns {Object|null} - Level data or null if invalid
   */
  getWordsForLevel(level) {
    if (!this.words.length) return null;

    // Determine maximum level based on word count
    const maxLevels = this.words.length >= 12 ? 9 : 
                      this.words.length >= 9 ? 6 : 3;
    
    if (level > maxLevels) return null;

    // Define level structure based on word count and level number
    const levelConfig = {
      1: { start: 0, count: Math.min(3, this.words.length), isTest: false },
      2: { start: 3, count: Math.min(3, Math.max(0, this.words.length - 3)), isTest: false },
      3: { start: 0, count: Math.min(6, this.words.length), isTest: true },
      4: { start: 6, count: Math.min(3, Math.max(0, this.words.length - 6)), isTest: false },
      5: { start: 9, count: Math.min(3, Math.max(0, this.words.length - 9)), isTest: false },
      6: { start: 6, count: Math.min(6, Math.max(0, this.words.length - 6)), isTest: true },
      7: { start: 12, count: Math.min(4, Math.max(0, this.words.length - 12)), isTest: false },
      8: { start: 16, count: Math.min(4, Math.max(0, this.words.length - 16)), isTest: false },
      9: { start: 12, count: Math.min(8, Math.max(0, this.words.length - 12)), isTest: true }
    };

    const config = levelConfig[level] || levelConfig[1];
    
    // If no words available for this level, try the next one
    if (config.count <= 0) {
      return this.getWordsForLevel(level + 1);
    }

    this.levelData = {
      words: this.words.slice(config.start, config.start + config.count),
      translations: this.translations.slice(config.start, config.start + config.count),
      isTest: config.isTest,
      isFinal: level === maxLevels
    };

    return this.levelData;
  }
};

/**
 * Process custom words from input field
 */
function processCustomWords() {
  const inputField = document.getElementById("custom-word-input");
  const resultsDiv = document.getElementById("translation-results");
  const wordList = document.getElementById("word-translation-list");
  const limits = CustomListsManager.getListLimits();
  
  const inputText = inputField.value.trim();
  if (!inputText) {
    showNotification("Please enter at least one word.", "error");
    return;
  }
  
  // Split input by commas or newlines
  let words = inputText.includes(',') ? 
    inputText.split(',').map(word => word.trim()) : 
    inputText.split(/\s+/).filter(word => word.length > 0);
  
  // Handle phrases (words with spaces)
  words = words.map(word => word.includes(' ') ? [word] : word.split(/\s+/)).flat();
  
  // Apply word limit based on user status
  const maxWords = currentUser ? limits.maxWords : 10;
  if (words.length > maxWords) {
    showNotification(`Maximum ${maxWords} words allowed.`, "error");
    words = words.slice(0, maxWords);
  }
  
  // Clear previous word list
  wordList.innerHTML = "";
  resultsDiv.style.display = "block";
  
  // Create word items with translations
  words.forEach(word => {
    const wordItem = createWordItem(word, findTranslation(word));
    wordList.appendChild(wordItem);
    initializeDragAndDrop(wordItem);
  });
  
  makeWordListDraggable();
}

/**
 * Find a translation for a given word
 * @param {string} word - The word to translate
 * @returns {string} - The translation or empty string
 */
function findTranslation(word) {
  // Look through vocabulary sets for matching word
  for (const setKey in vocabularySets) {
    const index = vocabularySets[setKey].words.indexOf(word.toLowerCase());
    if (index !== -1) {
      return vocabularySets[setKey].translations[index];
    }
  }
  return "";
}

/**
 * Create a word item element
 * @param {string} word - The word
 * @param {string} translation - The translation
 * @returns {HTMLElement} - The word item element
 */
function createWordItem(word, translation) {
  const div = document.createElement("div");
  div.className = "word-translation-item";
  div.draggable = true;
  div.innerHTML = `
    <div class="drag-handle">
      <i class="fas fa-grip-vertical"></i>
    </div>
    <span class="source-word" contenteditable="true">${word}</span>
    <input type="text" class="target-word" value="${translation}" placeholder="Hebrew translation">
    <button class="delete-word-btn" onclick="deleteWord(this)"></button>
  `;
  return div;
}

/**
 * Add a new word to the list
 */
function addNewWord() {
  const wordList = document.getElementById("word-translation-list");
  if (!wordList) return;
  
  const wordItem = document.createElement("div");
  wordItem.className = "word-translation-item";
  wordItem.draggable = true;
  wordItem.innerHTML = `
    <div class="drag-handle">
      <i class="fas fa-grip-vertical"></i>
    </div>
    <span class="source-word" contenteditable="true"></span>
    <input type="text" class="target-word" placeholder="Hebrew translation">
    <button class="delete-word-btn" onclick="deleteWord(this)"></button>
  `;
  
  const newItem = wordList.appendChild(wordItem);
  initializeDragAndDrop(newItem);
  
  if (wordList.children.length === 1) {
    makeWordListDraggable();
  }
  
  // Focus on the new word field
  newItem.querySelector(".source-word").focus();
}

/**
 * Delete a word from the list
 * @param {HTMLElement} element - The button element that triggered the deletion
 */
function deleteWord(element) {
  if (!element) return;
  
  const wordItem = element.closest(".word-translation-item");
  if (wordItem) {
    wordItem.remove();
  }
}

/**
 * Initialize drag and drop for a word item
 * @param {HTMLElement} element - The element to make draggable
 * @returns {HTMLElement} - The initialized element
 */
function initializeDragAndDrop(element) {
  if (!element) return;
  
  // Clone the element to remove any existing listeners
  const clone = element.cloneNode(true);
  if (element.parentNode) {
    element.parentNode.replaceChild(clone, element);
  }
  
  // The element is now the clone
  element = clone;
  
  element.setAttribute("draggable", "true");
  
  element.addEventListener("dragstart", (event) => {
    event.stopPropagation();
    element.classList.add("dragging");
    event.dataTransfer.setData("text/plain", "");
  });
  
  element.addEventListener("dragend", (event) => {
    event.stopPropagation();
    element.classList.remove("dragging");
  });
  
  // Setup delete button
  const deleteBtn = element.querySelector(".delete-word-btn");
  if (deleteBtn) {
    deleteBtn.onclick = () => deleteWord(deleteBtn);
  }
  
  return element;
}

/**
 * Make the word list draggable
 */
function makeWordListDraggable() {
  const wordList = document.getElementById("word-translation-list");
  if (!wordList) return;
  
  wordList.addEventListener("dragover", (event) => {
    event.preventDefault();
    const draggingElement = wordList.querySelector(".dragging");
    if (!draggingElement) return;
    
    const afterElement = getDragAfterElement(wordList, event.clientY);
    if (afterElement) {
      wordList.insertBefore(draggingElement, afterElement);
    } else {
      wordList.appendChild(draggingElement);
    }
  });
  
  // Initialize all existing items
  wordList.querySelectorAll(".word-translation-item").forEach(item => 
    initializeDragAndDrop(item)
  );
}

/**
 * Get the element to insert after when dragging
 * @param {HTMLElement} container - The container element
 * @param {number} y - The Y coordinate
 * @returns {HTMLElement|null} - The element to insert after
 */
function getDragAfterElement(container, y) {
  if (!container) return null;
  
  const draggableElements = [...container.querySelectorAll(".word-translation-item:not(.dragging)")];
  
  if (!draggableElements.length) return null;
  
  return draggableElements.reduce((closest, child) => {
    const box = child.getBoundingClientRect();
    const offset = y - box.top - box.height / 2;
    
    if (offset < 0 && offset > closest.offset) {
      return { offset: offset, element: child };
    } else {
      return closest;
    }
  }, { offset: Number.NEGATIVE_INFINITY }).element;
}

/**
 * Setup keyboard navigation for word list
 */
function setupWordListKeyNavigation() {
  const wordList = document.getElementById("word-translation-list");
  if (!wordList) return;
  
  wordList.addEventListener("keydown", (event) => {
    const wordItem = document.activeElement.closest(".word-translation-item");
    if (!wordItem) return;
    
    let nextElement;
    
    switch (event.key) {
      case "ArrowUp":
        event.preventDefault();
        nextElement = wordItem.previousElementSibling?.querySelector(".source-word");
        break;
      case "ArrowDown":
        event.preventDefault();
        nextElement = wordItem.nextElementSibling?.querySelector(".source-word");
        break;
      case "ArrowRight":
        event.preventDefault();
        nextElement = wordItem.querySelector(".target-word");
        break;
      case "ArrowLeft":
        event.preventDefault();
        nextElement = wordItem.querySelector(".source-word");
        break;
    }
    
    if (nextElement) nextElement.focus();
  });
}

/**
 * Save the current list
 */
async function saveCurrentList() {
  const nameInput = document.getElementById("custom-list-name");
  const wordList = document.getElementById("word-translation-list");
  
  // Get list name (use default if empty)
  const name = nameInput.value.trim() || 
               (CustomListsManager.currentList ? 
                CustomListsManager.currentList.name : 
                `List ${CustomListsManager.lists.length + 1}`);
  
  // Collect words and translations
  const words = [];
  const translations = [];
  
  wordList.querySelectorAll(".word-translation-item").forEach(item => {
    const word = item.querySelector(".source-word").textContent.trim();
    const translation = item.querySelector(".target-word").value.trim();
    
    if (word && translation) {
      words.push(word);
      translations.push(translation);
    }
  });
  
  // Check word limit
  const limits = CustomListsManager.getListLimits();
  if (words.length > limits.maxWords) {
    showNotification(`You can only create lists with up to ${limits.maxWords} words`, "error");
    return;
  }
  
  // Handle list editing vs creation
  let listToSave;
  const isEditing = CustomListsManager.currentList !== null;
  
  if (!isEditing && !CustomListsManager.canCreateMoreLists()) {
    showNotification(`Maximum lists limit reached`, "error");
    return;
  }
  
  if (isEditing) {
    listToSave = {
      ...CustomListsManager.currentList,
      name: name,
      words: words,
      translations: translations
    };
  } else {
    listToSave = {
      tempId: Date.now(),
      name: name,
      words: words,
      translations: translations
    };
  }
  
  // Save the list
  const savedList = await CustomListsManager.save(listToSave);
  
  if (savedList) {
    // Reset form
    nameInput.value = "";
    wordList.innerHTML = "";
    document.getElementById("translation-results").style.display = "none";
    CustomListsManager.currentList = null;
    
    // Refresh lists
    if (currentUser) {
      await CustomListsManager.loadFromSupabase();
    } else {
      CustomListsManager.loadFromLocalStorage();
    }
    
    showNotification("List saved successfully", "success");
    showScreen("custom-practice-screen");
    updateListsDisplay();
  } else {
    showNotification("Failed to save list", "error");
  }
}

/**
 * Edit a custom list
 * @param {string|number} id - The list ID
 */
function editCustomList(id) {
  const list = CustomListsManager.lists.find(list => list.id === id);
  if (!list) {
    showNotification("List not found", "error");
    return;
  }
  
  showScreen("custom-practice-screen");
  
  const nameInput = document.getElementById("custom-list-name");
  if (nameInput) {
    nameInput.value = list.name || "";
  }
  
  const resultsDiv = document.getElementById("translation-results");
  const wordList = document.getElementById("word-translation-list");
  
  if (wordList) {
    wordList.innerHTML = "";
    
    if (Array.isArray(list.words)) {
      list.words.forEach((word, index) => {
        const translation = list.translations && index < list.translations.length ? 
                            list.translations[index] : "";
        
        const wordItem = document.createElement("div");
        wordItem.className = "word-translation-item";
        wordItem.draggable = true;
        wordItem.innerHTML = `
          <div class="drag-handle">
            <i class="fas fa-grip-vertical"></i>
          </div>
          <span class="source-word" contenteditable="true">${word}</span>
          <input type="text" class="target-word" value="${translation}" placeholder="Hebrew translation">
          <button class="delete-word-btn" onclick="deleteWord(this)"></button>
        `;
        
        wordList.appendChild(wordItem);
        
        const deleteBtn = wordItem.querySelector(".delete-word-btn");
        if (deleteBtn) {
          deleteBtn.onclick = function() { deleteWord(this); };
        }
        
        initializeDragAndDrop(wordItem);
      });
    }
    
    if (resultsDiv) {
      resultsDiv.style.display = "block";
    }
    
    CustomListsManager.currentList = list;
    makeWordListDraggable();
  }
}

/**
 * Delete a custom list
 * @param {string|number} id - The list ID
 */
async function deleteCustomList(id) {
  const success = await CustomListsManager.delete(id);
  
  if (success) {
    showNotification("List deleted successfully", "success");
    updateListsDisplay();
  } else {
    showNotification("Failed to delete list", "error");
  }
}

/**
 * Show the modal to share a list
 * @param {string|number} id - The list ID
 */
function showShareModal(id) {
  console.log("Opening share modal for list:", id);
  
  // Remove existing modal if any
  const existingModal = document.querySelector(".share-modal");
  const existingBackdrop = document.querySelector(".modal-backdrop");
  if (existingModal) existingModal.remove();
  if (existingBackdrop) existingBackdrop.remove();
  
  // Create backdrop
  const backdrop = document.createElement("div");
  backdrop.className = "modal-backdrop";
  backdrop.onclick = closeShareModal;
  document.body.appendChild(backdrop);
  
  // Create modal
  const modal = document.createElement("div");
  modal.className = "share-modal";
  modal.innerHTML = `
    <h3 class="share-modal-header">Share List</h3>
    <div class="users-list">Loading users...</div>
    <button class="start-button modal-close" onclick="closeShareModal()">Cancel</button>
  `;
  document.body.appendChild(modal);
  
// Load users
const usersList = modal.querySelector(".users-list");

supabaseClient
  .from("user_profiles")
  .select("id, username")
  .neq("id", currentUser.id)
  .then(({ data, error }) => {
    if (error) {
      console.error("Error fetching users:", error);
      usersList.innerHTML = '<div class="user-item"><span>Error loading users</span></div>';
      return;
    }
    
    if (data && data.length > 0) {
      usersList.innerHTML = data.map(user => `
        <div class="user-item">
          <span>${user.username || "Unnamed User"}</span>
          <button class="main-button small-button share-with-user-btn" data-user-id="${user.id}">
            <i class="fas fa-share-alt"></i> Share
          </button>
        </div>
      `).join("");
      
      // Setup share buttons
      modal.querySelectorAll(".share-with-user-btn").forEach(button => {
        button.onclick = async () => {
          const userId = button.getAttribute("data-user-id");
          button.disabled = true;
          
          const originalHTML = button.innerHTML;
          button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Sharing...';
          
          const success = await CustomListsManager.share(id, userId);
          if (!success) {
            button.disabled = false;
            button.innerHTML = originalHTML;
          } else {
            showNotification("List shared successfully!", "success");
            closeShareModal();
          }
        };
      });
    } else {
      usersList.innerHTML = '<div class="user-item"><span>No users found to share with</span></div>';
    }
  });

/**
 * Close the share modal
 */
 function closeShareModal() {
  const modal = document.querySelector(".share-modal");
  const backdrop = document.querySelector(".modal-backdrop");
  
  if (modal) modal.remove();
  if (backdrop) backdrop.remove();
}

/**
 * Update the display of custom lists
 */
function updateListsDisplay() {
  const container = document.getElementById("custom-lists-container");
  if (!container) return;
  
  const limits = CustomListsManager.getListLimits();
  const userStatus = currentUser?.status || "unregistered";
  
  container.innerHTML = "";
  
  if (!CustomListsManager.lists || !Array.isArray(CustomListsManager.lists) || CustomListsManager.lists.length === 0) {
    container.innerHTML = '<p style="color: white; text-align: center;">No custom lists created yet. Create your first list!</p>';
    return;
  }
  
  CustomListsManager.lists.forEach(list => {
    if (!list || !list.id) return;
    
    const listWithSchema = updateCustomListSchema(list);
    const wordCount = listWithSchema.words?.length || 0;
    const hasEnoughWords = wordCount >= 6;
    
    const listElement = document.createElement("div");
    listElement.className = "custom-list-item collapsed " + (list.isShared ? "shared-list" : "");
    listElement.dataset.listId = list.id;
    
    listElement.innerHTML = `
      <div class="list-actions">
        <button class="main-button practice-button" ${hasEnoughWords ? "" : "disabled"}>
          ${hasEnoughWords ? "Practice" : `Need ${6 - wordCount} more`}
        </button>
        <button class="main-button edit-button">Edit</button>
        <button class="main-button delete-button">Delete</button>
        ${userStatus === "premium" ? `
          <button class="main-button share-button">
            <i class="fas fa-share-alt"></i> Share
          </button>
        ` : ""}
      </div>
      <div class="list-header">
        <h3>${list.name || "Unnamed List"}</h3>
        <div class="list-summary">
          <span class="word-count ${hasEnoughWords ? "" : "insufficient"}">${wordCount} words</span>
          ${hasEnoughWords ? "" : '<span class="warning-text">(Minimum 6 needed)</span>'}
          <span style="margin-left: 1rem;">${limits.playDisplay} plays available</span>
          ${listWithSchema.max_levels > 0 ? `<span class="level-info">Supports ${listWithSchema.max_levels} levels</span>` : ""}
          <p class="word-preview">${Array.isArray(list.words) ? list.words.slice(0, 5).join(", ") : ""}${list.words && list.words.length > 5 ? "..." : ""}</p>
        </div>
      </div>
    `;
    
    container.appendChild(listElement);
    
    // Set up practice button
    const practiceButton = listElement.querySelector(".practice-button");
    if (practiceButton) {
      if (hasEnoughWords) {
        practiceButton.onclick = function() {
          startCustomListPractice(list.id);
        };
      } else {
        practiceButton.style.opacity = "0.6";
        practiceButton.style.cursor = "not-allowed";
      }
    }
    
    // Set up edit button
    const editButton = listElement.querySelector(".edit-button");
    if (editButton) {
      editButton.onclick = function() {
        console.log("Edit button clicked for list:", list.id);
        editCustomList(list.id);
      };
    }
    
    // Set up delete button
    const deleteButton = listElement.querySelector(".delete-button");
    if (deleteButton) {
      deleteButton.onclick = function() {
        console.log("Delete button clicked for list:", list.id);
        deleteCustomList(list.id);
      };
    }
    
    // Set up share button
    const shareButton = listElement.querySelector(".share-button");
    if (shareButton) {
      shareButton.onclick = function() {
        showShareModal(list.id);
      };
    }
    
    // Set up header collapse
    const headerElement = listElement.querySelector(".list-header");
    if (headerElement) {
      headerElement.onclick = function() {
        toggleListCollapse(list.id);
      };
    }
  });
  
  // Add CSS for styling
  if (!document.getElementById("custom-list-styles")) {
    const style = document.createElement("style");
    style.id = "custom-list-styles";
    style.textContent = `
      .word-count.insufficient {
        color: #ff6b6b;
        font-weight: bold;
      }
      .warning-text {
        color: #ff6b6b;
        font-size: 0.85rem;
        margin-left: 0.5rem;
      }
      .level-info {
        color: var(--accent);
        font-size: 0.85rem;
        margin-left: 0.5rem;
      }
      .practice-button[disabled] {
        opacity: 0.6;
        cursor: not-allowed;
      }
    `;
    document.head.appendChild(style);
  }
}

/**
 * Toggle the collapse/expand state of a list
 * @param {string|number} id - The list ID
 */
function toggleListCollapse(id) {
  const listItem = document.querySelector(`.custom-list-item[data-list-id="${id}"]`);
  listItem.classList.toggle("collapsed");
}

/**
 * Start practicing a custom list
 * @param {string|number} id - The list ID
 */
function startCustomListPractice(id) {
  const list = CustomListsManager.lists.find(list => list.id === id);
  if (!list) return;
  
  const validation = CustomListsManager.validateListForPractice(list);
  if (!validation.valid) {
    showNotification(validation.message, "error");
    return;
  }
  
  if (customGameState.initializeFromList(list)) {
    startCustomLevel(1);
  } else {
    showNotification("Failed to initialize practice", "error");
  }
}

/**
 * Start a level in custom practice mode
 * @param {number} level - The level number
 */
function startCustomLevel(level) {
  // Hide powerups in custom practice
  const powerupsContainer = document.querySelector(".powerups-container");
  if (powerupsContainer) {
    powerupsContainer.style.display = "none";
  }
  
  // Get words for this level
  const levelData = customGameState.getWordsForLevel(level);
  if (!levelData || !levelData.words.length) {
    showNotification("Practice completed!", "success");
    showScreen("custom-practice-screen");
    return;
  }
  
  // Set up the current level
  customGameState.currentLevel = level;
  
  // Initialize game state
  currentGame = {
    words: levelData.words,
    translations: levelData.translations,
    currentIndex: 0,
    correctAnswers: 0,
    firstAttempt: true,
    isHebrewToEnglish: levelData.isTest ? Math.random() < 0.5 : false,
    mixed: levelData.isTest,
    speedChallenge: false,
    isCustomPractice: true,
    startingCoins: gameState.coins,
    startingPerks: { ...gameState.perks },
    timeBonus: 0,
    initialTimeRemaining: null,
    streakBonus: true,
    levelStartTime: Date.now(),
    questionStartTime: 0,
    wrongStreak: 0,
    progressLost: 0,
    customList: customGameState.currentList,
    customLevel: level,
    isFinalLevel: levelData.isFinal
  };
  
  // Show level intro and start the level
  showLevelIntro(level, () => {
    showScreen("question-screen");
    updateProgressCircle();
    loadNextQuestion();
    startTimer(10 * currentGame.words.length);
  });
}

/**
 * Handle completion of a custom level
 */
function handleCustomLevelCompletion() {
  // Clear the timer
  clearTimer();
  
  // Check if level was completed successfully
  const isPerfect = currentGame.streakBonus && currentGame.correctAnswers === currentGame.words.length;
  
  if (isPerfect) {
    // Award bonus coins for perfect completion
    const coinsToAward = currentGame.firstAttempt ? 5 : 3;
    
    CoinsManager.updateCoins(coinsToAward).then(() => {
      pulseCoins(coinsToAward);
      
      // Mark level as completed
      customGameState.wordsCompleted += currentGame.words.length;
      customGameState.completedLevels.add(customGameState.currentLevel);
      
      // Create particle effect
      const rect = document.getElementById("question-screen").getBoundingClientRect();
      createParticles(rect.left + rect.width / 2, rect.top + rect.height / 2);
      
      // Check if this was the final level or move to next level
      const nextLevel = customGameState.currentLevel + 1;
      const nextLevelData = customGameState.getWordsForLevel(nextLevel);
      
      if (!nextLevelData || nextLevelData.words.length === 0 || currentGame.isFinalLevel) {
        setTimeout(() => showCustomCompletionScreen(), 1500);
      } else {
        setTimeout(() => startCustomLevel(nextLevel), 1500);
      }
    });
  } else {
    // If not perfect, retry the level
    setTimeout(() => startCustomLevel(customGameState.currentLevel), 1500);
  }
  
  // Save progress
  saveProgress();
}

/**
 * Show the completion screen for custom practice
 */
function showCustomCompletionScreen() {
  const overlay = document.createElement("div");
  overlay.className = "completion-overlay";
  
  const coinsEarned = gameState.coins - customGameState.startCoins;
  
  overlay.innerHTML = `
    <div class="completion-content">
      <h2>Practice Complete!</h2>
      <div class="completion-stats">
        <div class="stat-item">
          <i class="fas fa-book"></i>
          <span>Words Practiced: ${customGameState.wordsCompleted}</span>
        </div>
        <div class="stat-item">
          <i class="fas fa-coins"></i>
          <span>Coins Earned: ${coinsEarned}</span>
        </div>
      </div>
      <button onclick="exitCustomPractice()" class="start-button">Continue</button>
    </div>
  `;
  
  document.body.appendChild(overlay);
}

/**
 * Exit custom practice mode and return to lists screen
 */
function exitCustomPractice() {
  customGameState.reset();
  
  const overlay = document.querySelector(".completion-overlay");
  if (overlay) overlay.remove();
  
  showScreen("custom-practice-screen");
}

/**
 * Handle an answer in custom practice mode
 * @param {boolean} isCorrect - Whether the answer is correct
 * @param {boolean} isSkip - Whether this was a skip action
 */
 async function handleCustomPracticeAnswer(isCorrect, isSkip = false) {
  if (isCorrect) {
    // Handle correct answer
    currentGame.currentIndex++;
    
    if (isCorrect && !isSkip) {
      let coinsToAward = 0;
      
      // Award time bonus
      const timeBonus = awardTimeBonus();
      if (timeBonus > 0) {
        coinsToAward += timeBonus;
        pulseCoins(timeBonus);
      }
      
      // Award correctness bonus
      if (currentGame.firstAttempt) {
        coinsToAward += 3;
        pulseCoins(3);
      } else {
        coinsToAward += 1;
        pulseCoins(1);
      }
      
      try {
        await CoinsManager.updateCoins(coinsToAward);
        updatePerkButtons();
      } catch (error) {
        console.error("Error updating total coins:", error);
      }
      
      currentGame.correctAnswers++;
      
      // Track word for any registered user, not just premium
      if (currentUser) {
        const index = currentGame.currentIndex - 1; // Fix index to get the word that was just answered
        const word = currentGame.isHebrewToEnglish ? 
                    currentGame.words[index] : 
                    currentGame.translations[index];
        
        await trackWordEncounter(word, "custom");
      }
    }
  } else {
    // Handle wrong answer
    currentGame.firstAttempt = false;
    currentGame.streakBonus = false;
    currentGame.wrongStreak++;
    
    try {
      await CoinsManager.updateCoins(-3);
      updatePerkButtons();
    } catch (error) {
      console.error("Error updating coins:", error);
    }
    
    // Move back if too many wrong answers
    if (currentGame.currentIndex > 0) {
      currentGame.progressLost++;
      currentGame.currentIndex = Math.max(0, currentGame.currentIndex - 1);
    }
    
    // Show game over screen if too many wrong answers in a row
    if (currentGame.wrongStreak >= 3) {
      showGameOverOverlay();
      
      // Set up restart button
      document.querySelector(".restart-button").onclick = () => {
        document.querySelector(".failure-overlay").style.display = "none";
        startCustomLevel(currentGame.customLevel);
      };
      
      return;
    }
  }
  
  // Highlight correct/incorrect answers
  const correctWord = currentGame.isHebrewToEnglish ? 
                     currentGame.words[Math.max(0, currentGame.currentIndex - 1)] : 
                     currentGame.translations[Math.max(0, currentGame.currentIndex - 1)];
  
  document.querySelectorAll(".buttons button").forEach(button => {
    if (button.textContent === correctWord) {
      button.classList.add("correct");
    } else if (!isCorrect && event && event.target && button.textContent === event.target.textContent) {
      button.classList.add("wrong");
    }
  });
  
  // Update UI and save progress
  updateProgressCircle();
  saveProgress();
  
  // Load next question or finish level
  setTimeout(() => {
    document.querySelectorAll(".buttons button").forEach(btn => {
      btn.classList.remove("correct", "wrong");
    });
    
    if (currentGame.currentIndex < currentGame.words.length) {
      loadNextQuestion();
      updatePerkButtons();
    } else {
      handleCustomLevelCompletion();
    }
  }, 333);
}

/**
 * Update schema for a custom list
 * @param {Object} list - The list to update
 * @returns {Object} - The updated list
 */
function updateCustomListSchema(list) {
  if (!list) return list;
  
  const wordCount = list.words?.length || 0;
  let maxLevels = 0;
  
  if (wordCount >= 6) {
    maxLevels = wordCount >= 12 ? 9 : 
               wordCount >= 9 ? 6 : 3;
  }
  
  return {
    ...list,
    min_words: 6,
    max_levels: maxLevels
  };
}

/**
 * Show the custom lists manager screen
 */
function showCustomListsManager() {
  showScreen("custom-practice-screen");
  
  Promise.resolve(CustomListsManager.initialize()).then(() => {
    const container = document.getElementById("custom-lists-container");
    if (!container) return;
    
    const limits = CustomListsManager.getListLimits();
    const userStatus = currentUser?.status || "unregistered";
    
    container.innerHTML = "";
    
    const lists = CustomListsManager.lists || [];
    
    if (lists.length === 0) {
      container.innerHTML = '<p style="color: white; text-align: center;">No custom lists created yet. Create your first list!</p>';
      return;
    }
    
    lists.forEach(list => {
      const listPlaysKey = `listPlays_${list.id}`;
      const playsUsed = parseInt(localStorage.getItem(listPlaysKey) || "0");
      const playsLeft = limits.maxPlays - playsUsed;
      
      if (playsLeft <= 0) return;
      
      const listItem = document.createElement("div");
      listItem.className = "custom-list-item collapsed " + (list.is_shared ? "shared-list" : "");
      listItem.dataset.listId = list.id;
      
      listItem.innerHTML = `
        <div class="list-actions">
          <button class="start-button practice-button">Practice</button>
          <button class="edit-button" data-list-id="${list.id}">Edit</button>
          <button class="start-button delete-button">Delete</button>
          ${userStatus === "premium" ? `
            <button class="share-button" onclick="showShareModal(${list.id})">
              <i class="fas fa-share-alt"></i> Share
            </button>
          ` : ""}
        </div>
        <div class="list-header">
          <h3>${list.name}</h3>
          <div class="list-summary">
            <span>${list.words?.length || 0} words</span>
            <span style="color: ${playsLeft <= 2 ? '#ff4444' : '#ffffff'}; margin-left: 1rem;">
              ${limits.playDisplay}
            </span>
            <p class="word-preview">${(list.words || []).slice(0, 5).join(", ")}${list.words?.length > 5 ? "..." : ""}</p>
          </div>
        </div>
      `;
      
      listItem.querySelector(".practice-button").addEventListener("click", () => 
        startCustomListPractice(list.id)
      );
      
      listItem.querySelector(".edit-button").addEventListener("click", () => {
        console.log("Edit button clicked for list:", list.id);
        editCustomList(list.id);
      });
      
      listItem.querySelector(".delete-button").addEventListener("click", () => {
        console.log("Delete button clicked for list:", list.id);
        deleteCustomList(list.id);
      });
      
      listItem.querySelector(".list-header").addEventListener("click", () => 
        toggleListCollapse(list.id)
      );
      
      container.appendChild(listItem);
    });
  }).catch(error => {
    console.error("Failed to initialize custom lists:", error);
    showNotification("Error loading lists", "error");
  });
}

/**
 * Get the user limits based on status
 * @returns {Object} - The limits object
 */
function getUserListLimits() {
  if (!currentUser) {
    return {
      maxLists: 3,
      maxWords: 10,
      maxPlays: 5,
      canShare: false
    };
  }
  
  switch (currentUser.status || "unregistered") {
    case "free":
      return {
        maxLists: 5,
        maxWords: 20,
        maxPlays: 10,
        canShare: false
      };
    case "pending":
      return {
        maxLists: 30,
        maxWords: 50,
        maxPlays: Infinity,
        canShare: false,
        playDisplay: ""
      };
    case "premium":
      return {
        maxLists: 30,
        maxWords: 50,
        maxPlays: Infinity,
        canShare: true,
        playDisplay: ""
      };
    default:
      return {
        maxLists: 3,
        maxWords: 10,
        maxPlays: 5,
        canShare: false
      };
  }
}

/**
 * Validate if a list can be practiced
 * @param {Object} list - The list to validate
 * @returns {Object} - Validation result with valid flag and message
 */
function validateListForPractice(list) {
  if (!list || !list.words || !list.translations) {
    return { valid: false, message: "Invalid list format" };
  }
  
  if (list.words.length < 6) {
    return { valid: false, message: "Lists need at least 6 words to practice" };
  }
  
  return { valid: true };
}

/**
 * Track a list play and handle play limits
 * @param {string|number} id - The list ID
 * @returns {number|boolean} - Plays left or false if limit reached
 */
function trackListPlay(id) {
  const key = `listPlays_${id}`;
  let plays = parseInt(localStorage.getItem(key) || "0");
  plays++;
  
  const limits = getUserListLimits();
  
  localStorage.setItem(key, plays);
  
  if (plays >= limits.maxPlays) {
    deleteCustomList(id);
    return false;
  }
  
  return limits.maxPlays - plays;
}

/**
 * Save a custom list to Supabase
 * @param {Object} list - The list to save
 */
async function saveCustomListToSupabase(list) {
  if (!currentUser || !list) return;
  
  try {
    const { data, error } = await supabaseClient
      .from("custom_lists")
      .upsert(
        {
          user_id: currentUser.id,
          name: list.name,
          words: list.words,
          translations: list.translations,
          status: list.status || currentUser.status
        },
        { onConflict: "id" }
      );
    
    if (error) throw error;
  } catch (error) {
    console.error("Error saving list to Supabase:", error);
    showNotification("Failed to save list", "error");
  }
}

async function loadCustomLists() {
  try {
    await CustomListsManager.initialize();
    updateListsDisplay();
  } catch (error) {
    console.error("Error loading custom lists:", error);
  }
}
}

/**
 * Show the custom lists manager screen
 */
 function showCustomListsManager() {
  // Show the custom practice screen first
  showScreen("custom-practice-screen");
  
  // Initialize the CustomListsManager and update display
  Promise.resolve(CustomListsManager.initialize()).then(() => {
    updateListsDisplay();
  }).catch(error => {
    console.error("Error initializing custom lists:", error);
    showNotification("Failed to load custom lists", "error");
  });
}

/**
 * Update the display of custom lists in the UI
 */
 function updateListsDisplay() {
  const container = document.getElementById("custom-lists-container");
  if (!container) {
    console.error("Custom lists container not found");
    return;
  }
  
  const limits = CustomListsManager.getListLimits();
  const userStatus = currentUser?.status || "unregistered";
  
  // Clear the container
  container.innerHTML = "";
  
  // Check if there are any lists
  if (!CustomListsManager.lists || !Array.isArray(CustomListsManager.lists) || CustomListsManager.lists.length === 0) {
    container.innerHTML = '<p style="color: white; text-align: center;">No custom lists created yet. Create your first list!</p>';
    return;
  }
  
  // Display each list
  CustomListsManager.lists.forEach(list => {
    if (!list || !list.id) return;
    
    const wordCount = list.words?.length || 0;
    const hasEnoughWords = wordCount >= 6;
    
    const listElement = document.createElement("div");
    listElement.className = "custom-list-item collapsed " + (list.isShared ? "shared-list" : "");
    listElement.dataset.listId = list.id;
    
    listElement.innerHTML = `
      <div class="list-actions">
        <button class="main-button practice-button" ${hasEnoughWords ? "" : "disabled"}>
          ${hasEnoughWords ? "Practice" : `Need ${6 - wordCount} more`}
        </button>
        <button class="main-button edit-button">Edit</button>
        <button class="main-button delete-button">Delete</button>
        ${userStatus === "premium" ? `
          <button class="main-button share-button">
            <i class="fas fa-share-alt"></i> Share
          </button>
        ` : ""}
      </div>
      <div class="list-header">
        <h3>${list.name || "Unnamed List"}</h3>
        <div class="list-summary">
          <span class="word-count ${hasEnoughWords ? "" : "insufficient"}">${wordCount} words</span>
          ${hasEnoughWords ? "" : '<span class="warning-text">(Minimum 6 needed)</span>'}
          <span style="margin-left: 1rem;">${limits.playDisplay} plays available</span>
          <p class="word-preview">${Array.isArray(list.words) ? list.words.slice(0, 5).join(", ") : ""}${list.words && list.words.length > 5 ? "..." : ""}</p>
        </div>
      </div>
    `;
    
    container.appendChild(listElement);
    
    // Set up practice button
    const practiceButton = listElement.querySelector(".practice-button");
    if (practiceButton) {
      if (hasEnoughWords) {
        practiceButton.onclick = function() {
          startCustomListPractice(list.id);
        };
      } else {
        practiceButton.style.opacity = "0.6";
        practiceButton.style.cursor = "not-allowed";
      }
    }
    
    // Set up edit button
    const editButton = listElement.querySelector(".edit-button");
    if (editButton) {
      editButton.onclick = function() {
        console.log("Edit button clicked for list:", list.id);
        editCustomList(list.id);
      };
    }
    
    // Set up delete button
    const deleteButton = listElement.querySelector(".delete-button");
    if (deleteButton) {
      deleteButton.onclick = function() {
        console.log("Delete button clicked for list:", list.id);
        deleteCustomList(list.id);
      };
    }
    
    // Set up share button
    const shareButton = listElement.querySelector(".share-button");
    if (shareButton) {
      shareButton.onclick = function() {
        showShareModal(list.id);
      };
    }
    
    // Set up header collapse
    const headerElement = listElement.querySelector(".list-header");
    if (headerElement) {
      headerElement.onclick = function() {
        toggleListCollapse(list.id);
      };
    }
  });
}

/**
 * Toggle the collapse/expand state of a list
 * @param {string|number} id - The list ID
 */
function toggleListCollapse(id) {
  const listItem = document.querySelector(`.custom-list-item[data-list-id="${id}"]`);
  if (listItem) {
    listItem.classList.toggle("collapsed");
  }
}

/**
 * Start practicing a custom list
 * @param {string|number} id - The list ID
 */
 function startCustomListPractice(id) {
  // Find the list by ID
  const list = CustomListsManager.lists.find(list => list.id === id);
  if (!list) {
    showNotification("List not found", "error");
    return;
  }
  
  // Validate the list for practice
  const validation = CustomListsManager.validateListForPractice(list);
  if (!validation.valid) {
    showNotification(validation.message, "error");
    return;
  }
  
  // Track list play if necessary
  const limits = CustomListsManager.getListLimits();
  if (limits.maxPlays !== Infinity) {
    const listPlaysKey = `listPlays_${id}`;
    let playsUsed = parseInt(localStorage.getItem(listPlaysKey) || "0");
    playsUsed++;
    
    if (playsUsed > limits.maxPlays) {
      showNotification("You've reached the maximum plays for this list", "error");
      return;
    }
    
    localStorage.setItem(listPlaysKey, playsUsed);
  }
  
  // Initialize the custom game state with this list
  if (customGameState.initializeFromList(list)) {
    // Start at level 1
    startCustomLevel(1);
  } else {
    showNotification("Failed to initialize practice", "error");
  }
}

/**
 * Start a level in custom practice mode
 * @param {number} level - The level number
 */
function startCustomLevel(level) {
  // Hide powerups in custom practice
  const powerupsContainer = document.querySelector(".powerups-container");
  if (powerupsContainer) {
    powerupsContainer.style.display = "none";
  }
  
  // Reset admin skip button if it exists
  if (typeof addAdminSkipButton === "function") {
    addAdminSkipButton();
  }
  
  // Get words for this level
  const levelData = customGameState.getWordsForLevel(level);
  if (!levelData || !levelData.words.length) {
    showNotification("Practice completed!", "success");
    showScreen("custom-practice-screen");
    return;
  }
  
  // Set up the current level
  customGameState.currentLevel = level;
  
  // Initialize game state
  currentGame = {
    words: levelData.words,
    translations: levelData.translations,
    currentIndex: 0,
    correctAnswers: 0,
    firstAttempt: true,
    isHebrewToEnglish: levelData.isTest ? Math.random() < 0.5 : false,
    mixed: levelData.isTest,
    speedChallenge: false,
    isCustomPractice: true,
    customGameState: true,
    startingCoins: gameState.coins,
    startingPerks: { ...gameState.perks },
    timeBonus: 0,
    initialTimeRemaining: null,
    streakBonus: true,
    levelStartTime: Date.now(),
    questionStartTime: 0,
    wrongStreak: 0,
    progressLost: 0,
    customList: customGameState.currentList,
    customLevel: level,
    isFinalLevel: levelData.isFinal
  };
  
  // Show level intro and start the level
  showLevelIntro(level, () => {
    showScreen("question-screen");
    updateProgressCircle();
    loadNextQuestion();
    startTimer(10 * currentGame.words.length);
  });
}

/**
 * Load custom lists and update the UI
 * @returns {Promise} - Promise that resolves when lists are loaded
 */
async function loadCustomLists() {
  try {
    console.log("Loading custom lists...");
    
    // Initialize the CustomListsManager
    await CustomListsManager.initialize();
    
    // Check if we're on the custom practice screen
    const customPracticeScreen = document.getElementById("custom-practice-screen");
    if (customPracticeScreen && 
        (customPracticeScreen.style.display === "block" || 
         document.querySelector(".screen.active")?.id === "custom-practice-screen")) {
      // Only update the display if we're on the custom lists screen
      updateListsDisplay();
    }
    
    console.log("Custom lists loaded successfully");
    return CustomListsManager.lists;
  } catch (error) {
    console.error("Error loading custom lists:", error);
    showNotification("Failed to load custom lists", "error", 3000);
    return [];
  }
}

/**
 * Share a custom list with another user
 * @param {string|number} listId - The ID of the list to share
 * @param {string} targetUserId - The ID of the user to share with
 * @returns {Promise<boolean>} - Whether the share was successful
 */
 async function shareCustomList(listId, targetUserId) {
  console.log(`Starting share process for list ${listId} with user ${targetUserId}`);
  
  if (!currentUser?.id) {
    showNotification("You must be logged in to share lists", "error");
    return false;
  }
  
  try {
    // Get the list data from local storage or directly from DB
    let list = CustomListsManager.lists.find(l => String(l.id) === String(listId));
    
    // If list not found locally, try fetching from DB
    if (!list) {
      const { data, error } = await supabaseClient
        .from("custom_lists")
        .select("*")
        .eq("id", listId)
        .single();
        
      if (error || !data) {
        console.error("Error fetching list:", error);
        return false;
      }
      
      list = data;
    }
    
    console.log("Found list to share:", list.name);
    
    // Format the shared list name
    const displayName = currentUser.user_metadata?.name || 
                       currentUser.user_metadata?.username || 
                       currentUser.email || 
                       "User";
    const sharedListName = `${list.name} (Shared by ${displayName})`;
    
    // Ensure data is valid
    const words = Array.isArray(list.words) ? list.words : [];
    const translations = Array.isArray(list.translations) ? list.translations : [];
    
    // Insert the shared list directly
    const { error } = await supabaseClient
      .from("custom_lists")
      .insert({
        name: sharedListName,
        words: words,
        translations: translations,
        user_id: targetUserId,
        is_shared: true,
        shared_by: currentUser.id
      });
      
    if (error) {
      console.error("Error sharing list:", error);
      return false;
    }
    
    console.log("List shared successfully");
    showNotification("List shared successfully!", "success");
    return true;
  } catch (error) {
    console.error("Unexpected error in shareCustomList:", error);
    showNotification("Failed to share list", "error");
    return false;
  }
}

/**
 * Show modal to share a list with other users
 * @param {string|number} listId - The ID of the list to share
 */
function showShareModal(listId) {
  console.log("Opening share modal for list:", listId);
  
  // Remove any existing modals
  const existingModal = document.querySelector(".share-modal-container");
  if (existingModal) existingModal.remove();
  
  // Create modal container with backdrop
  const modalContainer = document.createElement("div");
  modalContainer.className = "share-modal-container";
  modalContainer.style.position = "fixed";
  modalContainer.style.top = "0";
  modalContainer.style.left = "0";
  modalContainer.style.width = "100%";
  modalContainer.style.height = "100%";
  modalContainer.style.backgroundColor = "rgba(0,0,0,0.7)";
  modalContainer.style.display = "flex";
  modalContainer.style.justifyContent = "center";
  modalContainer.style.alignItems = "center";
  modalContainer.style.zIndex = "1000";
  
  // Create actual modal content
  const modal = document.createElement("div");
  modal.className = "share-modal";
  modal.style.backgroundColor = "#1e1e2e";
  modal.style.borderRadius = "10px";
  modal.style.padding = "20px";
  modal.style.maxWidth = "400px";
  modal.style.width = "90%";
  modal.style.maxHeight = "80vh";
  modal.style.overflowY = "auto";
  
  modal.innerHTML = `
    <h3 style="text-align: center; margin-bottom: 20px; color: white;">Share List</h3>
    <div id="share-users-list" style="margin-bottom: 15px;">Loading users...</div>
    <button id="close-share-modal" style="width: 100%; padding: 10px; background-color: #7e3ab3; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 10px;">Close</button>
  `;
  
  modalContainer.appendChild(modal);
  document.body.appendChild(modalContainer);
  
  // Close button functionality
  document.getElementById("close-share-modal").onclick = function() {
    modalContainer.remove();
  };
  
  // Also close when clicking backdrop, but not when clicking the modal itself
  modalContainer.addEventListener("click", function(event) {
    if (event.target === modalContainer) {
      modalContainer.remove();
    }
  });
  
  // Show users
  const usersList = document.getElementById("share-users-list");
  
  if (!currentUser) {
    usersList.innerHTML = '<div style="padding: 10px; color: white;">You must be logged in to share lists</div>';
    return;
  }
  
  // Fetch users to share with
  supabaseClient
    .from("user_profiles")
    .select("id, username, email")
    .neq("id", currentUser.id)
    .then(({ data, error }) => {
      if (error) {
        console.error("Error fetching users:", error);
        usersList.innerHTML = '<div style="padding: 10px; color: white;">Error loading users</div>';
        return;
      }
      
      if (!data || data.length === 0) {
        usersList.innerHTML = '<div style="padding: 10px; color: white;">No other users found</div>';
        return;
      }
      
      // Render users
      let html = '';
      data.forEach(user => {
        const displayName = user.username || user.email || user.id.substring(0, 8);
        html += `
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid rgba(255,255,255,0.1); color: white;">
            <span>${displayName}</span>
            <button 
              class="share-with-user-btn" 
              data-user-id="${user.id}" 
              style="padding: 5px 10px; background-color: #7e3ab3; color: white; border: none; border-radius: 5px; cursor: pointer;">
              Share
            </button>
          </div>
        `;
      });
      
      usersList.innerHTML = html;
      
      // Add click handlers
      document.querySelectorAll(".share-with-user-btn").forEach(button => {
        button.onclick = async function() {
          const userId = this.getAttribute("data-user-id");
          const originalText = this.innerText;
          
          this.innerText = "Sharing...";
          this.disabled = true;
          
          const success = await shareCustomList(listId, userId);
          
          if (success) {
            this.innerText = "Shared ";
            this.style.backgroundColor = "#28a745";
          } else {
            this.innerText = originalText;
            this.disabled = false;
          }
        };
      });
    });
}

/**
 * Exit the custom practice mode and return to the list screen
 * Called when the user clicks "Continue" on the completion screen
 */
 function exitCustomPractice() {
  console.log("Exiting custom practice mode");
  
  // Remove the completion overlay if it exists
  const overlay = document.querySelector(".completion-overlay");
  if (overlay) {
    overlay.remove();
  }
  
  // Reset custom game state
  if (customGameState) {
    customGameState.reset();
  }
  
  // Reset current game
  currentGame = null;
  
  // Return to the custom practice screen
  showScreen("custom-practice-screen");
  
  // If needed, refresh the lists display
  if (typeof refreshCustomLists === 'function') {
    refreshCustomLists();
  }
}

function generateAnswerOptions(correctAnswer) {
  const buttonsContainer = document.querySelector(".buttons");
  if (!buttonsContainer) return;
  
  buttonsContainer.innerHTML = "";
  
  // Create a set of options including the correct answer
  let options = [correctAnswer];
  const isHebrewAnswer = isHebrewWord(correctAnswer);
  
  // Get additional options based on whether we need Hebrew or English words
  const additionalOptions = getRandomAnswerOptions(correctAnswer, isHebrewAnswer, 3);
  options = options.concat(additionalOptions);
  
  // Shuffle the options
  options = shuffleArray(options);
  
  // Create buttons for each option
  options.forEach(option => {
    const button = document.createElement("button");
    button.textContent = option;
    button.className = isHebrewAnswer ? "hebrew-text" : "";
    button.onclick = function(event) {
      handleAnswer(event);
    };
    buttonsContainer.appendChild(button);
  });
}

async function ensureUserInitialization(userId) {
  try {
    console.log("Ensuring proper user initialization for:", userId);
    
    // Check if player_stats exists
    const { data: statsData, error: statsError } = await supabaseClient
      .from("player_stats")
      .select("user_id")
      .eq("user_id", userId)
      .single();
    
    // If player_stats doesn't exist, create it
    if (statsError && statsError.code === "PGRST116") {
      console.log("Creating player_stats record for user");
      const { error: createStatsError } = await supabaseClient
        .from("player_stats")
        .insert([{
          user_id: userId,
          total_levels_completed: 0,
          unique_words_practiced: 0
        }]);
      
      if (createStatsError) {
        console.error("Error creating player_stats:", createStatsError);
      }
    }
    
    // Check if game_progress exists
    const { data: progressData, error: progressError } = await supabaseClient
      .from("game_progress")
      .select("user_id")
      .eq("user_id", userId)
      .single();
    
    // If game_progress doesn't exist, create it
    if (progressError && progressError.code === "PGRST116") {
      console.log("Creating game_progress record for user");
      const { error: createProgressError } = await supabaseClient
        .from("game_progress")
        .insert([{
          user_id: userId,
          stage: 1,
          set_number: 1,
          level: 1,
          coins: 0,
          perks: {},
          unlocked_sets: {1: [1]},
          unlocked_levels: {"1_1": [1]},
          perfect_levels: [],
          completed_levels: []
        }]);
      
      if (createProgressError) {
        console.error("Error creating game_progress:", createProgressError);
      }
    }
    
    return true;
  } catch (error) {
    console.error("Error in ensureUserInitialization:", error);
    return false;
  }
}

// Global variables to track custom lists
let teacherCustomLists = [];
let selectedCustomLists = [];
let customWordsCount = 0;

// Function to fetch teacher's custom lists from Supabase
async function fetchTeacherCustomLists() {
    if (!currentUser) return;
    
    try {
        const { data, error } = await supabaseClient
            .from('custom_lists')
            .select('id, name, words, translations')
            .eq('user_id', currentUser.id);
            
        if (error) throw error;
        
        teacherCustomLists = data || [];
        renderCustomLists();
    } catch (error) {
        console.error('Error fetching custom lists:', error);
    }
}

// Function to render the custom lists in the UI
function renderCustomLists() {
    const checkboxesContainer = document.getElementById('custom-lists-checkboxes');
    const noListsMessage = document.getElementById('no-custom-lists');
    
    if (!checkboxesContainer || !noListsMessage) return;
    
    // Clear previous content
    checkboxesContainer.innerHTML = '';
    
    // Show/hide appropriate elements based on whether lists exist
    if (!teacherCustomLists || teacherCustomLists.length === 0) {
        noListsMessage.style.display = 'block';
        checkboxesContainer.style.display = 'none';
        return;
    }
    
    noListsMessage.style.display = 'none';
    checkboxesContainer.style.display = 'block';
    
    // Create checkbox for each list
    teacherCustomLists.forEach(list => {
        const label = document.createElement('label');
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = list.id;
        checkbox.dataset.wordCount = list.words ? list.words.length : 0;
        checkbox.addEventListener('change', updateWordCount);
        
        const labelText = document.createTextNode(` ${list.name} (${list.words ? list.words.length : 0} words)`);
        
        label.appendChild(checkbox);
        label.appendChild(labelText);
        
        checkboxesContainer.appendChild(label);
    });
}

// Function to update the count of selected custom words
function updateWordCount() {
    // Reset
    selectedCustomLists = [];
    customWordsCount = 0;
    
    // Get all checked checkboxes
    const checkedBoxes = document.querySelectorAll('#custom-lists-checkboxes input[type="checkbox"]:checked');
    
    // Add up words from all selected lists
    checkedBoxes.forEach(checkbox => {
        selectedCustomLists.push(checkbox.value);
        customWordsCount += parseInt(checkbox.dataset.wordCount || 0);
    });
    
    // Update the display
    const countElement = document.getElementById('custom-words-count');
    if (countElement) {
        countElement.textContent = `Selected custom words: ${customWordsCount}`;
    }
}

// Function to initialize the word goal slider
function initializeWordGoalSlider() {
    const slider = document.getElementById('wordGoalSlider');
    const display = document.getElementById('wordGoalDisplay');
    const input = document.getElementById('wordGoalInput');
    const stops = document.querySelectorAll('.slider-stop');
    
    if (slider && display && input) {
        slider.min = 0;
        slider.max = 200;
        slider.value = 50;
        display.textContent = 50;
        input.value = 50;
        
        slider.addEventListener('input', function() {
            const value = parseInt(this.value);
            display.textContent = value;
            input.value = value;
        });
        
        input.addEventListener('input', function() {
            let value = parseInt(this.value) || 0;
            value = Math.max(0, Math.min(200, value));
            slider.value = value;
            display.textContent = value;
            this.value = value;
        });
        
        if (stops) {
            stops.forEach(stop => {
                stop.addEventListener('click', function() {
                    const value = parseInt(this.dataset.value);
                    slider.value = value;
                    display.textContent = value;
                    input.value = value;
                });
            });
        }
    }
}

// Function to show the arcade modal
async function showArcadeModal() {
    const arcadeModal = document.getElementById('arcade-modal');
    const teacherView = document.getElementById('teacher-view');
    const playerView = document.getElementById('player-view');
    const arcadeUsername = document.getElementById('arcadeUsername');
    const inputGroup = arcadeUsername ? arcadeUsername.closest('.input-group') : null;
    
    try {
        if (currentUser) {
            const { data } = await supabaseClient
                .from('user_profiles')
                .select('role')
                .eq('id', currentUser.id)
                .single();
                
            if (data?.role === 'teacher') {
                // Generate OTP code
                const otpCode = Math.floor(1000 + Math.random() * 9000).toString();
                currentArcadeSession.otp = otpCode;
                currentArcadeSession.teacherId = currentUser.id;
                currentArcadeSession.participants = [];
                currentArcadeSession.isInitialized = false;
                
                // Set up WebSocket channel
                window.arcadeChannel = supabaseClient.channel(`arcade:${otpCode}`, {
                    config: {
                        broadcast: {
                            self: true
                        }
                    }
                });
                
                // Handle player join events
                window.arcadeChannel.on('broadcast', { event: 'player_join' }, ({ payload }) => {
                    console.log('Player join event received:', payload);
                    if (!currentArcadeSession.participants.find(p => p.username === payload.username)) {
                        currentArcadeSession.participants.push({
                            username: payload.username,
                            wordsCompleted: 0,
                            coins: 0
                        });
                        
                        document.getElementById('player-count').textContent = 
                            currentArcadeSession.participants.length;
                            
                        const arcadeLeaderboard = document.getElementById('arcade-leaderboard');
                        if (arcadeLeaderboard && arcadeLeaderboard.offsetParent !== null) {
                            updateAllPlayersProgress();
                        }
                    }
                }).subscribe();
                
                // Create QR code for joining
                generateQRCode(otpCode);
                
                // Show teacher view
                document.getElementById('otp').textContent = otpCode;
                teacherView.style.display = 'block';
                playerView.style.display = 'none';
                
                // Initialize slider for word goal
                initializeWordGoalSlider();
                
                // Fetch teacher's custom lists
                fetchTeacherCustomLists();
            } else {
                // Show player view
                teacherView.style.display = 'none';
                playerView.style.display = 'block';
                
                // If current user exists, pre-fill username
                if (arcadeUsername && inputGroup) {
                    const username = currentUser.user_metadata?.username || 
                                     currentUser.email.split('@')[0];
                                     
                    arcadeUsername.value = username;
                    arcadeUsername.readOnly = true;
                    arcadeUsername.style.display = 'none';
                    
                    const usernameDisplay = document.createElement('div');
                    usernameDisplay.className = 'username-display';
                    usernameDisplay.textContent = `Joining as: ${username}`;
                    inputGroup.insertBefore(usernameDisplay, arcadeUsername);
                }
            }
        } else {
            // For non-logged in users, show player view
            teacherView.style.display = 'none';
            playerView.style.display = 'block';
            
            // Reset and enable username input
            if (arcadeUsername) {
                arcadeUsername.readOnly = false;
                arcadeUsername.style.display = 'block';
                
                const usernameDisplay = inputGroup?.querySelector('.username-display');
                if (usernameDisplay) usernameDisplay.remove();
            }
        }
        
        arcadeModal.style.display = 'block';
    } catch (error) {
        console.error('Arcade setup error:', error);
        alert('Failed to initialize arcade');
    }
}

// Function to generate word pool from selected stages with added support for custom lists
function generateWordPool(selectedStages) {
    let wordPool = [];
    
    // First add words from custom lists if any are selected
    if (selectedCustomLists && selectedCustomLists.length > 0) {
        selectedCustomLists.forEach(listId => {
            const list = teacherCustomLists.find(l => String(l.id) === String(listId));
            if (list && list.words && list.translations) {
                for (let i = 0; i < list.words.length; i++) {
                    if (i < list.translations.length) {
                        wordPool.push({
                            word: list.words[i],
                            translation: list.translations[i]
                        });
                    }
                }
            }
        });
    }
    
    // Then add words from selected stages
    selectedStages.forEach(stage => {
        Object.keys(vocabularySets).forEach(key => {
            if (key.startsWith(`${stage}_`)) {
                const set = vocabularySets[key];
                set.words.forEach((word, index) => {
                    wordPool.push({
                        word: word, 
                        translation: set.translations[index]
                    });
                });
            }
        });
    });
    
    // Shuffle the word pool
    wordPool.sort(() => Math.random() - 0.5);
    
    return wordPool;
}

// Function to start the arcade
async function startArcade() {
    // Get selected stages
    const selectedStages = Array.from(document.querySelectorAll('.stage-checkboxes input[type="checkbox"]:checked'))
        .map(checkbox => parseInt(checkbox.value));
        
    // Validate at least one stage or custom list is selected
    if (selectedStages.length === 0 && selectedCustomLists.length === 0) {
        document.querySelector('.stage-warning').style.display = 'block';
        return;
    }
    
    document.querySelector('.stage-warning').style.display = 'none';
    
    // Get word goal
    const wordGoal = parseInt(document.getElementById('wordGoalInput').value);
    
    // Generate word pool from selected stages and custom lists
    let wordPool = generateWordPool(selectedStages);
    
    // If we have more words than needed, trim the pool
    if (wordPool.length > wordGoal) {
        wordPool = wordPool.slice(0, wordGoal);
    }
    
    // If we have fewer words than needed, show a warning
    if (wordPool.length < wordGoal) {
        console.warn(`Only ${wordPool.length} words available from selected sources`);
    }
    
    // Create OTP code
    const otpCode = Math.floor(1000 + Math.random() * 9000).toString();
    
    try {
        // Create the arcade event in Supabase
        const { data, error } = await supabaseClient
            .from('arcade_events')
            .insert({
                teacher_id: currentUser.id,
                otp: otpCode,
                status: 'waiting',
                game_state: {
                    wordPool: wordPool,
                    wordGoal: wordGoal,
                    selectedStages: selectedStages,
                    selectedCustomLists: selectedCustomLists,
                    timestamp: Date.now()
                }
            })
            .select();
            
        if (error) throw error;
        
        // Update current arcade session
        currentArcadeSession.eventId = data[0].id;
        currentArcadeSession.otp = otpCode;
        currentArcadeSession.wordPool = wordPool;
        currentArcadeSession.wordGoal = wordGoal;
        
        // Display OTP
        document.getElementById('otp').textContent = otpCode;
        
        // Switch to moderator view
        document.getElementById('arcade-modal').style.display = 'none';
        showModeratorScreen();
        
    } catch (error) {
        console.error('Error creating arcade event:', error);
        alert('Failed to create arcade event. Please try again.');
    }
}

async function initializeArcade() {
    try {
        const initializeButton = document.querySelector('.initialize-button');
        const endArcadeButton = document.querySelector('.end-arcade-button');
        
        // Hide initialize button and show end button
        if (initializeButton) initializeButton.style.display = 'none';
        if (endArcadeButton) endArcadeButton.classList.add('visible');
        
        // Set arcade as active
        currentArcadeSession.state = 'active';
        currentArcadeSession.isInitialized = true;
        
        // Reset participant progress
        currentArcadeSession.participants = currentArcadeSession.participants.map(player => ({
            ...player,
            wordsCompleted: 0,
            coins: player.coins || 0
        }));
        
        // Update leaderboard
        updateAllPlayersProgress();
        
        // Start inactivity timer for moderator
        initializeModeratorInactivityTimer();
        
        // Broadcast game start event
        await window.arcadeChannel.send({
            type: 'broadcast',
            event: 'game_playing',
            payload: {
                wordPool: currentArcadeSession.wordPool,
                wordGoal: currentArcadeSession.wordGoal,
                state: 'active',
                timestamp: Date.now()
            }
        });
    } catch (error) {
        console.error('Initialize error:', error);
        alert('Failed to start game');
    }
}

function initializeModeratorInactivityTimer() {
    moderatorActivityTimer && clearTimeout(moderatorActivityTimer);
    countdownTimer && clearInterval(countdownTimer);
    lastLeaderboardUpdate = Date.now();
    isCountingDown = false;
    
    createInactivityOverlay();
    startInactivityMonitoring();
    trackLeaderboardUpdates();
}

function initializeArcadeParticipation() {
    // Set up activity tracking
    let lastActive = Date.now();
    const INACTIVE_THRESHOLD = 60000; // 1 minute

    // Heartbeat interval
    const intervalId = setInterval(() => {
        if (Date.now() - lastActive > INACTIVE_THRESHOLD) {
            removeInactivePlayer();
        }
    }, 10000); // Check every 10 seconds
    
    // Store interval ID for cleanup
    window.arcadeIntervals = window.arcadeIntervals || [];
    window.arcadeIntervals.push(intervalId);

    // Track user activity
    ['mousemove', 'keypress', 'click'].forEach(event => {
        document.addEventListener(event, () => {
            lastActive = Date.now();
        });
    });

    // Handle page refresh/close
    window.addEventListener('beforeunload', () => {
        if (window.arcadeChannel) {
            window.arcadeChannel.send({
                type: 'broadcast',
                event: 'player_left',
                payload: {
                    username: currentArcadeSession.playerName
                }
            });
        }
    });
}

function removeInactivePlayer() {
    if (window.arcadeChannel) {
        window.arcadeChannel.send({
            type: 'broadcast',
            event: 'player_inactive',
            payload: {
                username: currentArcadeSession.playerName
            }
        });
    }
}

function initializeModeratorInactivityTimer() {
    // Only proceed if we're on the moderator screen and game has been initialized
    if (!isModeratorScreenActive() || !currentArcadeSession.isInitialized) {
        return;
    }
    
    // Set game as active
    moderatorInactivity.isGameActive = true;
    
    // Clear any existing timers
    if (moderatorActivityTimer) clearTimeout(moderatorActivityTimer);
    if (countdownTimer) clearInterval(countdownTimer);
    if (moderatorInactivity.activityTimer) clearTimeout(moderatorInactivity.activityTimer);
    if (moderatorInactivity.countdownTimer) clearInterval(moderatorInactivity.countdownTimer);
    
    // Reset state
    lastLeaderboardUpdate = Date.now();
    moderatorInactivity.lastLeaderboardUpdate = Date.now();
    isCountingDown = false;
    moderatorInactivity.isCountingDown = false;
    moderatorInactivity.isInitialized = true;
    
    // Create overlay for inactivity warning
    createInactivityOverlay();
    
    // Start monitoring for inactivity
    startInactivityMonitoring();
    
    // Track leaderboard updates
    trackLeaderboardUpdates();
    
    console.log('Moderator inactivity timer initialized');
}


</script>
</body>
</html>