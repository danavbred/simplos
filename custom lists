
const CustomListsManager = {
    lists: [],
    currentList: null,
    
    async initialize() {
        // Always try to load lists, regardless of user status
        try {
            if (currentUser) {
                await this.loadFromSupabase();
            } else {
                this.loadFromLocalStorage();
            }
            
            // Ensure lists are populated
            if (!this.lists || this.lists.length === 0) {
                console.log('No lists found, initializing empty array');
                this.lists = [];
            }
        } catch (error) {
            console.error('Custom Lists Initialization Error:', error);
            this.lists = [];
        }
    },
    
    async loadFromSupabase() {
        try {
            const { data, error } = await supabaseClient
                .from('custom_lists')
                .select('*')
                .or(`user_id.eq.${currentUser.id},shared_with.cs.{${currentUser.id}}`);
                
            if (error) throw error;
            
            this.lists = data.map(item => ({
                id: item.id,
                name: item.name,
                words: item.words || [],
                translations: item.translations || [], 
                isShared: item.is_shared,
                sharedBy: item.shared_by,
                userId: item.user_id,
                createdAt: item.created_at
            }));
        } catch (error) {
            console.error('Error loading lists from Supabase:', error);
            this.lists = [];
        }
    },
    
    loadFromLocalStorage() {
        try {
            const savedLists = localStorage.getItem('simploxCustomLists');
            this.lists = savedLists ? JSON.parse(savedLists) : [];
        } catch (error) {
            console.error('Error loading lists from localStorage:', error);
            this.lists = [];
        }
    },
    
    async save(list) {
        if (!list) return null;
        
        if (currentUser) {
            return await this.saveToSupabase(list);
        } else {
            return this.saveToLocalStorage(list);
        }
    },
    
    async saveToSupabase(list) {
        try {
            // Prepare data for Supabase
            const listData = {
                name: list.name,
                words: list.words || [],
                translations: list.translations || [],
                user_id: currentUser.id
            };
            
            // If updating existing list
            if (list.id && typeof list.id === 'string' && list.id.length === 36) {
                const { data, error } = await supabaseClient
                    .from('custom_lists')
                    .update(listData)
                    .eq('id', list.id)
                    .select()
                    .single();
                    
                if (error) throw error;
                return data;
            } 
            // Creating new list
            else {
                const { data, error } = await supabaseClient
                    .from('custom_lists')
                    .insert(listData)
                    .select()
                    .single();
                    
                if (error) throw error;
                
                // Update local array with the newly created list
                const index = this.lists.findIndex(l => 
                    l.id === list.id || 
                    (l.tempId && l.tempId === list.tempId));
                    
                if (index !== -1) {
                    this.lists[index] = {
                        ...data,
                        words: data.words || [],
                        translations: data.translations || []
                    };
                } else {
                    this.lists.push({
                        ...data,
                        words: data.words || [],
                        translations: data.translations || []
                    });
                }
                
                return data;
            }
        } catch (error) {
            console.error('Error saving list to Supabase:', error);
            return null;
        }
    },
    
    saveToLocalStorage(list) {
        try {
            // For new lists or lists with tempId
            const newList = {
                ...list,
                id: list.id || Date.now(),
                tempId: list.tempId || Date.now()
            };
            
            // Find if list already exists
            const index = this.lists.findIndex(l => 
                l.id === list.id || 
                (l.tempId && l.tempId === list.tempId));
                
            if (index !== -1) {
                this.lists[index] = newList;
            } else {
                this.lists.push(newList);
            }
            
            // Save all lists
            localStorage.setItem('simploxCustomLists', JSON.stringify(this.lists));
            return newList;
        } catch (error) {
            console.error('Error saving list to localStorage:', error);
            return null;
        }
    },
    
    async delete(listId) {
        if (currentUser) {
            try {
                // Check if this is a Supabase UUID
                if (typeof listId === 'string' && listId.length === 36) {
                    const { error } = await supabaseClient
                        .from('custom_lists')
                        .delete()
                        .eq('id', listId);
                        
                    if (error) throw error;
                }
                
                // Remove from local array regardless
                this.lists = this.lists.filter(list => list.id !== listId);
                return true;
            } catch (error) {
                console.error('Error deleting list from Supabase:', error);
                return false;
            }
        } else {
            // Just remove from local array and storage
            this.lists = this.lists.filter(list => list.id !== listId);
            localStorage.setItem('simploxCustomLists', JSON.stringify(this.lists));
            return true;
        }
    },
    
    async share(listId, recipientId) {
        if (!currentUser) return false;
        
        try {
            const list = this.lists.find(l => l.id === listId);
            if (!list) return false;
            
            const result = await supabaseClient.rpc('insert_shared_list', {
                p_user_id: recipientId,
                p_name: `${list.name} (Shared by ${currentUser.user_metadata?.username || 'User'})`,
                p_words: list.words || [],
                p_translations: list.translations || [],
                p_is_shared: true,
                p_local_id: Date.now(),
                p_shared_with: [recipientId],
                p_shared_by: currentUser.id
            });
            
            return !result.error;
        } catch (error) {
            console.error('Error sharing list:', error);
            return false;
        }
    },
    
    getListLimits() {
        if (!currentUser) {
            return {
                maxLists: 3,
                maxWords: 10,
                maxPlays: 5,
                canShare: false,
                playDisplay: '5'
            };
        }
        
        const userStatus = currentUser.status || 'free';
        
        switch(userStatus) {
            case 'premium':
                return {
                    maxLists: 30,
                    maxWords: 50,
                    maxPlays: Infinity,
                    canShare: true,
                    playDisplay: '∞'
                };
            case 'pending':
                return {
                    maxLists: 30,
                    maxWords: 50,
                    maxPlays: Infinity,
                    canShare: false,
                    playDisplay: '∞'
                };
            case 'free':
                return {
                    maxLists: 5,
                    maxWords: 20,
                    maxPlays: 10,
                    canShare: false,
                    playDisplay: '10'
                };
            default:
                return {
                    maxLists: 3,
                    maxWords: 10,
                    maxPlays: 5,
                    canShare: false,
                    playDisplay: '5'
                };
        }
    },
    
    canCreateMoreLists() {
        const limits = this.getListLimits();
        return this.lists.length < limits.maxLists;
    },
    
    validateListForPractice(list) {
        const MIN_WORDS_REQUIRED = 6;
        
        if (!list || !list.words || !list.translations) {
            return {
                valid: false,
                message: 'Invalid list format'
            };
        }
        
        if (list.words.length < MIN_WORDS_REQUIRED) {
            return {
                valid: false,
                message: `Lists need at least ${MIN_WORDS_REQUIRED} words to practice`
            };
        }
        
        return { valid: true };
    }
};

// REPLACE customGameState with consolidated functionality
const customGameState = {
    isCustomPractice: false,
    currentList: null,
    currentLevel: 1,
    levelData: null,
    words: [],
    translations: [],
    wordsCompleted: 0,
    correctStreak: 0,
    wrongStreak: 0,
    startCoins: 0,
    completedLevels: new Set(),
    
    reset() {
        this.isCustomPractice = false;
        this.currentList = null;
        this.currentLevel = 1;
        this.levelData = null;
        this.words = [];
        this.translations = [];
        this.wordsCompleted = 0;
        this.correctStreak = 0;
        this.wrongStreak = 0;
        this.startCoins = 0;
        this.completedLevels = new Set();
    },
    
    initializeFromList(list) {
        if (!list || !list.words || !list.translations) {
            console.error('Invalid list provided to custom game:', list);
            return false;
        }
        
        this.reset();
        this.isCustomPractice = true;
        this.currentList = list;
        this.words = [...list.words];
        this.translations = [...list.translations];
        this.startCoins = gameState.coins;
        this.currentLevel = 1;
        
        return true;
    },
    
    getWordsForLevel(level) {
        if (!this.words.length) return null;
        
        // Calculate max levels based on word count
        const maxLevels = this.words.length >= 12 ? 9 : 
                         (this.words.length >= 9 ? 6 : 3);
        
        // Return null if requested level exceeds max
        if (level > maxLevels) return null;
        
        const levelConfigs = {
            1: { start: 0, count: Math.min(3, this.words.length), isTest: false },
            2: { start: 3, count: Math.min(3, Math.max(0, this.words.length - 3)), isTest: false },
            3: { start: 0, count: Math.min(6, this.words.length), isTest: true },
            4: { start: 6, count: Math.min(3, Math.max(0, this.words.length - 6)), isTest: false },
            5: { start: 9, count: Math.min(3, Math.max(0, this.words.length - 9)), isTest: false },
            6: { start: 6, count: Math.min(6, Math.max(0, this.words.length - 6)), isTest: true },
            7: { start: 12, count: Math.min(4, Math.max(0, this.words.length - 12)), isTest: false },
            8: { start: 16, count: Math.min(4, Math.max(0, this.words.length - 16)), isTest: false },
            9: { start: 12, count: Math.min(8, Math.max(0, this.words.length - 12)), isTest: true }
        };
        
        const config = levelConfigs[level] || levelConfigs[1];
        
        // Skip levels with no words
        if (config.count <= 0) {
            return this.getWordsForLevel(level + 1);
        }
        
        this.levelData = {
            words: this.words.slice(config.start, config.start + config.count),
            translations: this.translations.slice(config.start, config.start + config.count),
            isTest: config.isTest,
            isFinal: level === maxLevels
        };
        
        return this.levelData;
    }
};





// REPLACE handleLevelCompletion to support custom practice routing
function handleLevelCompletion() {
    clearTimer();
    
    // CHECK IF THIS IS A CUSTOM PRACTICE SESSION
    if (currentGame.isCustomPractice) {
        handleCustomLevelCompletion();
        return;
    }
    
    // Regular game level completion logic...
    const levelKey = `${gameState.currentStage}_${gameState.currentSet}_${gameState.currentLevel}`;
    console.log(`Completing level: ${levelKey}`);

    const isLevelCompleted = gameState.perfectLevels.has(levelKey) || gameState.completedLevels.has(levelKey);
    console.log(`Level was previously completed: ${isLevelCompleted}`);

    const isPerfectRun = !isLevelCompleted && 
                        currentGame.streakBonus && 
                        currentGame.correctAnswers === currentGame.words.length;

    if (isPerfectRun) {
        const finalCoins = gameState.coins;
        const bonusAmount = 5;
        
        CoinsManager.updateCoins(bonusAmount).then(() => {
            gameState.perfectLevels.add(levelKey);
            gameState.completedLevels.add(levelKey);
            
            const questionScreen = document.getElementById('question-screen');
            const rect = questionScreen.getBoundingClientRect();
            createParticles(rect.left + (rect.width / 2), rect.top + (rect.height / 2));
        });
    } else if (!isLevelCompleted) {
        // Mark as completed even if not perfect
        gameState.completedLevels.add(levelKey);
    }

    pulseCoins(5);
    updatePerkButtons();

    const currentStageConfig = gameStructure.stages[gameState.currentStage - 1];
    const isLastLevelInSet = gameState.currentLevel === currentStageConfig.levelsPerSet;
    const isLastSetInStage = gameState.currentSet === currentStageConfig.numSets;
    const userStatus = currentUser ? currentUser.status : 'unregistered';

    // Mark current level as completed
    if (!gameState.unlockedLevels[`${gameState.currentStage}_${gameState.currentSet}`]) {
        gameState.unlockedLevels[`${gameState.currentStage}_${gameState.currentSet}`] = new Set();
    }
    gameState.unlockedLevels[`${gameState.currentStage}_${gameState.currentSet}`].add(gameState.currentLevel);
    
    // Unlock next level if not last in set
    if (!isLastLevelInSet) {
        gameState.unlockedLevels[`${gameState.currentStage}_${gameState.currentSet}`].add(gameState.currentLevel + 1);
        saveProgress();
        setTimeout(() => startLevel(gameState.currentLevel + 1), 1500);
        return;
    }
    
    // Handle set completion
    if (isLastLevelInSet) {
        // Unlock next set for premium users or stage 1
        if ((!isLastSetInStage && userStatus === 'premium') || gameState.currentStage === 1) {
            // Unlock next set
            if (!gameState.unlockedSets[gameState.currentStage]) {
                gameState.unlockedSets[gameState.currentStage] = new Set();
            }
            gameState.unlockedSets[gameState.currentStage].add(gameState.currentSet + 1);
            
            // Initialize first level of next set
            const nextSetKey = `${gameState.currentStage}_${gameState.currentSet + 1}`;
            if (!gameState.unlockedLevels[nextSetKey]) {
                gameState.unlockedLevels[nextSetKey] = new Set([1]);
            }
            
            // Progress to next set
            saveProgress();
            setTimeout(() => {
                gameState.currentSet++;
                startLevel(1);
            }, 1500);
        }
        // Handle last set in stage
        else if (isLastSetInStage && userStatus === 'premium' && gameState.currentStage < 5) {
            // Progress to next stage
            if (!gameState.unlockedSets[gameState.currentStage + 1]) {
                gameState.unlockedSets[gameState.currentStage + 1] = new Set([1]);
            }
            const newSetKey = `${gameState.currentStage + 1}_1`;
            if (!gameState.unlockedLevels[newSetKey]) {
                gameState.unlockedLevels[newSetKey] = new Set([1]);
            }
            
            saveProgress();
            setTimeout(() => {
                gameState.currentStage++;
                gameState.currentSet = 1;
                startLevel(1);
            }, 1500);
        }
        // Handle all other cases (non-premium or completed all)
        else {
            // For non-premium users who completed a set, show upgrade prompt
            if (!isLastSetInStage && userStatus !== 'premium') {
                saveProgress();
                setTimeout(() => showUpgradePrompt(), 1500);
            } else {
                // Return to stage selection
                saveProgress();
                setTimeout(() => showScreen('stage-cascade-screen'), 1500);
            }
        }
    }

    saveProgress();
    updateAllCoinDisplays();
    updatePerkButtons();
}





function editCustomList(listId) {
    // Find the list in CustomListsManager
    const list = CustomListsManager.lists.find(l => l.id === listId);
    if (!list) {
        showNotification('List not found', 'error');
        return;
    }
   
    // Switch to custom practice screen
    showScreen('custom-practice-screen');
   
    // Set the list name
    const listNameInput = document.getElementById('custom-list-name');
    if (listNameInput) {
        listNameInput.value = list.name || '';
    }
   
    // Get translation results container and word list
    const translationResults = document.getElementById('translation-results');
    const wordList = document.getElementById('word-translation-list');
    
    if (!wordList) {
        console.error('Word translation list element not found');
        return;
    }
   
    // Clear previous translations
    wordList.innerHTML = '';
   
    // Create translation items for each word
    if (Array.isArray(list.words)) {
        list.words.forEach((word, index) => {
            const translation = list.translations && index < list.translations.length ? 
                list.translations[index] : '';
                
            const wordItem = document.createElement('div');
            wordItem.className = 'word-translation-item';
            wordItem.draggable = true;
           
            wordItem.innerHTML = `
                <div class="drag-handle">
                    <i class="fas fa-grip-vertical"></i>
                </div>
                <span class="source-word" contenteditable="true">${escapeHTML(word)}</span>
                <input type="text" class="target-word" value="${escapeHTML(translation)}" placeholder="Hebrew translation">
                <button class="delete-word-btn" aria-label="Delete word">❌</button>
            `;
           
            wordList.appendChild(wordItem);
            
            // Set up delete button functionality
            const deleteBtn = wordItem.querySelector('.delete-word-btn');
            if (deleteBtn) {
                deleteBtn.onclick = function() { deleteWord(this); };
            }
            
            // Initialize drag functionality for this item
            initializeDragAndDrop(wordItem);
        });
    }
   
    // Show the translation results section
    if (translationResults) {
        translationResults.style.display = 'block';
    }
   
    // Store the current list for later saving
    customPracticeLists.currentList = list;
   
    // Initialize drag functionality for the whole list
    makeWordListDraggable();
    
    // Setup keyboard navigation
    wordList.addEventListener('keydown', handleWordListKeydown);
    
    // Focus on the first word input
    setTimeout(() => {
        const firstWord = wordList.querySelector('.source-word');
        if (firstWord) {
            firstWord.focus();
            // Place cursor at the end
            const range = document.createRange();
            const selection = window.getSelection();
            range.selectNodeContents(firstWord);
            range.collapse(false);
            selection.removeAllRanges();
            selection.addRange(range);
        }
    }, 100);
}

function createWordTranslationItem(word = '', translation = '', isEditable = true) {
    const wordList = document.getElementById('word-translation-list');
    if (!wordList) return;
    
    const wordItem = document.createElement('div');
    wordItem.className = 'word-translation-item';
    wordItem.draggable = true;
    
    wordItem.innerHTML = `
        <div class="drag-handle">
            <i class="fas fa-grip-vertical"></i>
        </div>
        <span class="source-word ${isEditable ? 'editable' : ''}" 
              contenteditable="${isEditable}">${word}</span>
        <input 
            type="text" 
            class="target-word ${isEditable ? 'editable' : ''}"
            value="${translation}" 
            data-original="${translation}"
            ${isEditable ? '' : 'readonly'}
            placeholder="Hebrew translation">
        <button class="delete-word-btn" onclick="deleteWord(this)">❌</button>
    `;
    
    const newItem = wordList.appendChild(wordItem);
    initializeDragAndDrop(newItem);
    
    return newItem;
}

function deleteWord(button) {
    if (!button) return;
    
    const item = button.closest('.word-translation-item');
    if (item) {
        item.remove();
    }
}

function addNewWord() {
    createWordTranslationItem('', '', true);
    
    // Ensure the translation results container is visible
    const translationResults = document.getElementById('translation-results');
    if (translationResults) {
        translationResults.style.display = 'block';
    }
    
    // Focus on the new word's source input
    const items = document.querySelectorAll('.word-translation-item');
    const lastItem = items[items.length - 1];
    if (lastItem) {
        const sourceWord = lastItem.querySelector('.source-word');
        if (sourceWord) sourceWord.focus();
    }
}

async function saveCurrentList() {
    const listNameInput = document.getElementById('custom-list-name');
    const wordList = document.getElementById('word-translation-list');
    
    if (!wordList) {
        showNotification('Word list container not found', 'error');
        return;
    }
    
    // Get current list name
    const name = listNameInput.value.trim() || 
        (CustomListsManager.currentList ? 
            CustomListsManager.currentList.name : 
            `List ${CustomListsManager.lists.length + 1}`);
            
    const words = [];
    const translations = [];
    
    const items = wordList.querySelectorAll('.word-translation-item');
    items.forEach(item => {
        const word = item.querySelector('.source-word').textContent.trim();
        const translation = item.querySelector('.target-word').value.trim();
        
        if (word && translation) {
            words.push(word);
            translations.push(translation);
        }
    });
    
    // Validate word count
    if (words.length === 0) {
        showNotification('Please add at least one word', 'error');
        return;
    }
    
    // Validate word count limit
    const limits = CustomListsManager.getListLimits();
    if (words.length > limits.maxWords) {
        showNotification(`You can only create lists with up to ${limits.maxWords} words`, 'error');
        return;
    }
    
    let listToSave;
    const isEditing = CustomListsManager.currentList !== null;
    
    // Skip the list count check if we're editing an existing list
    if (!isEditing && !CustomListsManager.canCreateMoreLists()) {
        showNotification(`You can only create ${CustomListsManager.getListLimits().maxLists} custom lists`, 'error');
        return;
    }
    
    if (isEditing) {
        // Updating existing list
        listToSave = {
            ...CustomListsManager.currentList,
            name,
            words,
            translations
        };
    } else {
        // Creating new list 
        listToSave = {
            tempId: Date.now(),  // Temporary ID until saved to Supabase
            name,
            words,
            translations
        };
    }
    
    // Save the list
    const savedList = await CustomListsManager.save(listToSave);
    
    if (savedList) {
        // Clear form
        listNameInput.value = '';
        wordList.innerHTML = '';
        document.getElementById('translation-results').style.display = 'none';
        
        // Reset current list
        CustomListsManager.currentList = null;
        
        // Force immediate reload of lists from appropriate source
        if (currentUser) {
            await CustomListsManager.loadFromSupabase();
        } else {
            CustomListsManager.loadFromLocalStorage();
        }
        
        showNotification('List saved successfully', 'success');
        
        // Show screen after data refresh
        showScreen('custom-practice-screen');
        updateListsDisplay();
    } else {
        showNotification('Failed to save list', 'error');
    }
}

function processCustomWords() {
    const wordInput = document.getElementById('custom-word-input');
    const translationResults = document.getElementById('translation-results');
    const wordList = document.getElementById('word-translation-list');
    
    if (!wordInput || !translationResults || !wordList) {
        showNotification('Required UI elements not found', 'error');
        return;
    }
    
    const limits = CustomListsManager.getListLimits();
    const rawInput = wordInput.value.trim();
    
    if (!rawInput) {
        showNotification('Please enter at least one word.', 'error');
        return;
    }

    // Parse input based on format
    let words = [];
    
    // Check if the input contains commas
    if (rawInput.includes(',')) {
        // Split by commas
        words = rawInput.split(',').map(word => word.trim()).filter(word => word.length > 0);
    } else if (rawInput.includes('\n')) {
        // Split by newlines
        words = rawInput.split('\n').map(word => word.trim()).filter(word => word.length > 0);
    } else {
        // Split by spaces, but handle phrases
        words = rawInput.split(/\s+/).filter(word => word.length > 0);
    }

    // Apply limits
    const maxWords = limits.maxWords;
    if (words.length > maxWords) {
        showNotification(`Maximum ${maxWords} words allowed.`, 'error');
        words = words.slice(0, maxWords);
    }

    // Clear and prepare container
    wordList.innerHTML = '';
    translationResults.style.display = 'block';

    // Process and create word items
    words.forEach(word => {
        const foundTranslation = findTranslation(word);
        createWordTranslationItem(word, foundTranslation, true);
    });

    makeWordListDraggable();
}

function findTranslation(word) {
    // Check if word exists in any vocabulary set
    for (const setKey in vocabularySets) {
        const index = vocabularySets[setKey].words.findIndex(w => 
            w.toLowerCase() === word.toLowerCase());
            
        if (index !== -1) {
            return vocabularySets[setKey].translations[index];
        }
    }
    return '';
}

function initializeDragAndDrop(item) {
    if (!item) return;
    
    // Remove existing listeners to prevent duplicates
    const newItem = item.cloneNode(true);
    if (item.parentNode) {
        item.parentNode.replaceChild(newItem, item);
    }
    item = newItem;
    
    // Set draggable attribute
    item.setAttribute('draggable', 'true');
    
    // Add event listeners
    item.addEventListener('dragstart', (e) => {
        e.stopPropagation();
        item.classList.add('dragging');
        e.dataTransfer.setData('text/plain', ''); // Firefox compatibility
    });
    
    item.addEventListener('dragend', (e) => {
        e.stopPropagation();
        item.classList.remove('dragging');
    });
    
    // Re-attach delete button functionality
    const deleteBtn = item.querySelector('.delete-word-btn');
    if (deleteBtn) {
        deleteBtn.onclick = () => deleteWord(deleteBtn);
    }
    
    return item;
}

function makeWordListDraggable() {
    const wordList = document.getElementById('word-translation-list');
    if (!wordList) return;
    
    // Clean up existing event listeners
    const newWordList = wordList.cloneNode(true);
    if (wordList.parentNode) {
        wordList.parentNode.replaceChild(newWordList, wordList);
    }
    
    // Re-initialize all items in the list
    newWordList.querySelectorAll('.word-translation-item').forEach(item => {
        initializeDragAndDrop(item);
    });
    
    // Add dragover event listener to the container
    newWordList.addEventListener('dragover', e => {
        e.preventDefault();
        const draggable = newWordList.querySelector('.dragging');
        if (!draggable) return;
        
        const afterElement = getDragAfterElement(newWordList, e.clientY);
        if (afterElement) {
            newWordList.insertBefore(draggable, afterElement);
        } else {
            newWordList.appendChild(draggable);
        }
    });
    
    // Add drop event listener
    newWordList.addEventListener('drop', e => {
        e.preventDefault();
    });
    
    // Set up keyboard navigation
    setupWordListKeyNavigation(newWordList);
}

function getDragAfterElement(container, y) {
    if (!container) return null;
    
    const draggableItems = [...container.querySelectorAll('.word-translation-item:not(.dragging)')];
    if (!draggableItems.length) return null;
    
    return draggableItems.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

function setupWordListKeyNavigation(container) {
    if (!container) return;
    
    container.addEventListener('keydown', (e) => {
        const currentItem = e.target.closest('.word-translation-item');
        if (!currentItem) return;
        
        let targetElement;
        
        switch(e.key) {
            case 'Tab':
                if (!e.shiftKey && e.target.classList.contains('source-word')) {
                    e.preventDefault();
                    targetElement = currentItem.querySelector('.target-word');
                } else if (e.shiftKey && e.target.classList.contains('target-word')) {
                    e.preventDefault();
                    targetElement = currentItem.querySelector('.source-word');
                } else if (!e.shiftKey && e.target.classList.contains('target-word')) {
                    // Move to next row source-word if exists
                    const nextItem = currentItem.nextElementSibling;
                    if (nextItem) {
                        e.preventDefault();
                        targetElement = nextItem.querySelector('.source-word');
                    }
                }
                break;
                
            case 'Enter':
                if (!e.shiftKey && !e.ctrlKey) {
                    // Create new item below current
                    e.preventDefault();
                    const newItem = createWordTranslationItem('', '', true);
                    container.insertBefore(newItem, currentItem.nextSibling);
                    targetElement = newItem.querySelector('.source-word');
                }
                break;
                
            case 'ArrowUp':
                e.preventDefault();
                const prevItem = currentItem.previousElementSibling;
                if (prevItem) {
                    if (e.target.classList.contains('source-word')) {
                        targetElement = prevItem.querySelector('.source-word');
                    } else {
                        targetElement = prevItem.querySelector('.target-word');
                    }
                }
                break;
                
            case 'ArrowDown':
                e.preventDefault();
                const nextItem = currentItem.nextElementSibling;
                if (nextItem) {
                    if (e.target.classList.contains('source-word')) {
                        targetElement = nextItem.querySelector('.source-word');
                    } else {
                        targetElement = nextItem.querySelector('.target-word');
                    }
                }
                break;
                
            case 'Delete':
                if (e.ctrlKey) {
                    e.preventDefault();
                    // Delete current item and focus next item or previous if no next
                    const nextItem = currentItem.nextElementSibling;
                    const prevItem = currentItem.previousElementSibling;
                    deleteWord(currentItem.querySelector('.delete-word-btn'));
                    
                    // Focus on an appropriate element after deletion
                    if (nextItem) {
                        targetElement = nextItem.querySelector('.source-word');
                    } else if (prevItem) {
                        targetElement = prevItem.querySelector('.source-word');
                    }
                }
                break;
        }
        
        if (targetElement) {
            targetElement.focus();
            
            // If it's a content editable element, put cursor at the end
            if (targetElement.hasAttribute('contenteditable')) {
                const range = document.createRange();
                const selection = window.getSelection();
                range.selectNodeContents(targetElement);
                range.collapse(false); // Collapse to end
                selection.removeAllRanges();
                selection.addRange(range);
            }
        }
    });
}





function ensureCustomStyles() {
    // Only add styles if they don't already exist
    if (!document.getElementById('custom-list-styles')) {
        const newStyle = document.createElement('style');
        newStyle.id = 'custom-list-styles';
        newStyle.textContent = `
            .word-count.insufficient {
                color: #ff6b6b;
                font-weight: bold;
            }
            .warning-text {
                color: #ff6b6b;
                font-size: 0.85rem;
                margin-left: 0.5rem;
            }
            .level-info {
                color: var(--accent);
                font-size: 0.85rem;
                margin-left: 0.5rem;
            }
            .practice-button[disabled] {
                opacity: 0.6;
                cursor: not-allowed;
            }
            .new-list-button {
                border: 1px dashed rgba(255,255,255,0.3);
                background: rgba(255,255,255,0.05);
                cursor: pointer;
                transition: all 0.3s ease;
            }
            .new-list-button:hover {
                background: rgba(255,255,255,0.1);
                transform: translateY(-2px);
            }
        `;
        document.head.appendChild(newStyle);
    }
}

function toggleListCollapse(listId) {
    const listItem = document.querySelector(`.custom-list-item[data-list-id="${listId}"]`);
    if (!listItem) return;
    
    // Don't toggle if currently in edit mode
    if (CustomListsManager.currentList && CustomListsManager.currentList.id === listId) {
        return;
    }
    
    listItem.classList.toggle('collapsed');
}

function confirmDeleteList(listId) {
    // Create a confirmation dialog
    const overlay = document.createElement('div');
    overlay.className = 'modal-backdrop';
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
    overlay.style.zIndex = '1000';
    overlay.style.display = 'flex';
    overlay.style.alignItems = 'center';
    overlay.style.justifyContent = 'center';
    
    const modal = document.createElement('div');
    modal.className = 'delete-confirmation-modal';
    modal.style.background = 'var(--glass)';
    modal.style.backdropFilter = 'blur(10px)';
    modal.style.padding = '2rem';
    modal.style.borderRadius = '15px';
    modal.style.textAlign = 'center';
    modal.style.maxWidth = '400px';
    modal.style.width = '90%';
    
    const list = CustomListsManager.lists.find(l => l.id === listId);
    const listName = list ? list.name : 'this list';
    
    modal.innerHTML = `
        <h3 style="margin-bottom: 1.5rem; color: var(--gold);">Delete List</h3>
        <p style="margin-bottom: 2rem;">Are you sure you want to delete "${listName}"? This action cannot be undone.</p>
        <div style="display: flex; gap: 1rem; justify-content: center;">
            <button class="main-button" id="confirm-delete">Delete</button>
            <button class="main-button" id="cancel-delete">Cancel</button>
        </div>
    `;
    
    document.body.appendChild(overlay);
    overlay.appendChild(modal);
    
    // Add event listeners
    document.getElementById('confirm-delete').addEventListener('click', async () => {
        const success = await CustomListsManager.delete(listId);
        overlay.remove();
        
        if (success) {
            showNotification('List deleted successfully', 'success');
            updateListsDisplay();
        } else {
            showNotification('Failed to delete list', 'error');
        }
    });
    
    document.getElementById('cancel-delete').addEventListener('click', () => {
        overlay.remove();
    });
    
    // Also close on background click
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            overlay.remove();
        }
    });
}

function showShareModal(listId) {
    // Create modal HTML
    const modal = document.createElement('div');
    modal.innerHTML = `
        <div class="modal-backdrop" onclick="closeShareModal()"></div>
        <div class="share-modal">
            <h3 class="share-modal-header">Share List</h3>
            <div class="users-list">Loading users...</div>
            <button class="main-button modal-close" onclick="closeShareModal()">Cancel</button>
        </div>
    `;
    document.body.appendChild(modal);

    // Fetch users directly from user_profiles
    supabaseClient
        .from('user_profiles')
        .select('id, username')
        .neq('id', currentUser.id)
        .then(({ data, error }) => {
            if (error) {
                console.error('Error fetching users:', error);
                return;
            }
            
            console.log('Users data:', data);
            
            const availableUsers = data || [];
            const usersList = modal.querySelector('.users-list');
            usersList.innerHTML = '';

            if (availableUsers.length === 0) {
                usersList.innerHTML = `<div class="user-item"><span>No other users available</span></div>`;
                return;
            }

            usersList.innerHTML = availableUsers.map(user => `
                <div class="user-item">
                    <span>${user.username || 'Unnamed User'}</span>
                    <button class="main-button small-button share-with-user-btn" data-id="${user.id}">
                        <i class="fas fa-share-alt"></i> Share
                    </button>
                </div>
            `).join('');
            
            // Add click handlers to all share buttons
            const shareButtons = usersList.querySelectorAll('.share-with-user-btn');
            shareButtons.forEach(button => {
                button.addEventListener('click', async () => {
                    const recipientId = button.getAttribute('data-id');
                    
                    // Disable button and show loading state
                    button.disabled = true;
                    const originalText = button.innerHTML;
                    button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Sharing...';
                    
                    try {
                        const result = await CustomListsManager.share(listId, recipientId);
                        if (result) {
                            showNotification('List shared successfully!', 'success');
                            closeShareModal();
                        } else {
                            showNotification('Failed to share list', 'error');
                            // Reset button
                            button.disabled = false;
                            button.innerHTML = originalText;
                        }
                    } catch (error) {
                        console.error('Error in share handler:', error);
                        showNotification('Error sharing list', 'error');
                        // Reset button
                        button.disabled = false;
                        button.innerHTML = originalText;
                    }
                });
            });
        });
}

function closeShareModal() {
    const modal = document.querySelector('.share-modal');
    const backdrop = document.querySelector('.modal-backdrop');
    
    if (modal) modal.remove();
    if (backdrop) backdrop.remove();
}

// Clear all custom practice UI elements and reset state
function clearCustomPracticeUI() {
    // Clear form inputs
    const listNameInput = document.getElementById('custom-list-name');
    const wordInput = document.getElementById('custom-word-input');
    const translationResults = document.getElementById('translation-results');
    const wordList = document.getElementById('word-translation-list');
    
    if (listNameInput) listNameInput.value = '';
    if (wordInput) wordInput.value = '';
    if (translationResults) translationResults.style.display = 'none';
    if (wordList) wordList.innerHTML = '';
    
    // Reset custom game state
    customGameState.reset();
    
    // Clear any timers or intervals
    if (timer) clearInterval(timer);
}

// Show custom completion screen with appropriate stats
function showCustomCompletionScreen() {
    const overlay = document.createElement('div');
    overlay.className = 'completion-overlay victory-screen';
    
    // Calculate coins earned during this practice session
    const coinsEarned = gameState.coins - customGameState.startCoins;
    
    overlay.innerHTML = `
        <div class="completion-modal-content">
            <div class="victory-header">
                <span class="rank-emoji">🎓</span>
                <h2>Practice Complete!</h2>
            </div>
            
            <div class="victory-message">
                Great job! You've completed all practice levels for this list.
            </div>
            
            <div class="completion-stats">
                <div class="stat-item">
                    <i class="fas fa-language stat-icon"></i>
                    <span class="stat-label">Words Learned</span>
                    <span class="stat-value">${customGameState.wordsCompleted}</span>
                </div>
                <div class="stat-item">
                    <i class="fas fa-coins stat-icon"></i>
                    <span class="stat-label">Coins Earned</span>
                    <span class="stat-value">${coinsEarned}</span>
                </div>
                <div class="stat-item">
                    <i class="fas fa-star stat-icon"></i>
                    <span class="stat-label">Levels Completed</span>
                    <span class="stat-value">${customGameState.completedLevels.size}</span>
                </div>
            </div>
            
            <button onclick="exitCustomPractice()" class="victory-button">
                Return to My Lists
            </button>
        </div>
    `;
    
    document.body.appendChild(overlay);
}

// Exit custom practice mode and return to lists screen
function exitCustomPractice() {
    // Clean up any states
    customGameState.reset();
    
    // Remove completion overlay if present
    const overlay = document.querySelector('.completion-overlay');
    if (overlay) overlay.remove();
    
    // Return to custom lists screen
    showScreen('custom-practice-screen');
    // Refresh the lists display
    updateListsDisplay();
}

// Handle answer for custom practice questions
async function handleCustomPracticeAnswer(isCorrect, fromPerk = false) {
    const now = Date.now();
    const lastAnswerTime = currentGame.lastAnswerTime || 0;
    
    // Enforce a cooldown between answers to prevent rapid clicking
    if (now - lastAnswerTime < 1000) {
        console.warn('Answer too quickly. Please wait a moment.');
        return;
    }
    
    // Update last answer time to prevent rapid subsequent clicks
    currentGame.lastAnswerTime = now;
    
    try {
        // Handle incorrect answer
        if (!isCorrect) {
            currentGame.firstAttempt = false;
            currentGame.streakBonus = false;
            currentGame.wrongStreak++;
            
            try {
                await CoinsManager.updateCoins(-3);
                updatePerkButtons();
            } catch (error) {
                console.error('Error updating coins:', error);
            }

            // Move progress bar backwards
            if (currentGame.currentIndex > 0) {
                currentGame.progressLost++;
                currentGame.currentIndex = Math.max(0, currentGame.currentIndex - 1);
            }

            // Check for game over condition
            if (currentGame.wrongStreak >= 3) {
                showCustomGameOverOverlay();
                return;
            }
        } 
        // Handle correct answer
        else if (isCorrect && !fromPerk) {
            let totalCoinsEarned = 0;

            // Award time bonus
            const timeBonus = awardTimeBonus();
            if (timeBonus > 0) {
                totalCoinsEarned += timeBonus;
                pulseCoins(timeBonus);
            }

            // Award coins based on first attempt
            if (currentGame.firstAttempt) {
                totalCoinsEarned += 3;
                pulseCoins(3);
            } else {
                totalCoinsEarned += 1;
                pulseCoins(1);
            }

            try {
                await CoinsManager.updateCoins(totalCoinsEarned);
                updatePerkButtons();
            } catch (error) {
                console.error('Error updating total coins:', error);
            }
            
            currentGame.correctAnswers++;
        }

        // Highlight correct and wrong answers
        const correctAnswer = currentGame.isHebrewToEnglish ? 
            currentGame.words[currentGame.currentIndex] : 
            currentGame.translations[currentGame.currentIndex];

        document.querySelectorAll('.buttons button').forEach(btn => {
            if (btn.textContent === correctAnswer) {
                btn.classList.add('correct');
            } else if (!isCorrect && btn.textContent === event.target.textContent) {
                btn.classList.add('wrong');
            }
        });

        // Advance to next word if correct
        if (isCorrect) {
            currentGame.currentIndex++;
        }
        
        updateProgressCircle();
        saveProgress();
       
        // Use setTimeout for consistent timing and to prevent rapid subsequent calls
        setTimeout(() => {
            if (currentGame.currentIndex < currentGame.words.length) {
                loadNextQuestion();
                updatePerkButtons();
            } else {
                handleCustomLevelCompletion();
            }
        }, 333);

    } catch (error) {
        console.error('Unexpected error in handleCustomPracticeAnswer:', error);
        // Provide a fallback to prevent complete game breakdown
        loadNextQuestion();
    }
}

// Show custom game over overlay specific to custom practice
function showCustomGameOverOverlay() {
    clearTimer();
    const overlay = document.querySelector('.failure-overlay');
    const title = overlay.querySelector('.failure-title');
    title.textContent = 'Practice Failed!';
    
    overlay.style.display = 'flex';
    setTimeout(() => {
        overlay.classList.add('show');
    }, 100);
    
    // Set up restart button for custom practice
    document.querySelector('.restart-button').onclick = () => {
        overlay.classList.remove('show');
        setTimeout(() => {
            overlay.style.display = 'none';
            startCustomLevel(customGameState.currentLevel);
        }, 1000);
    };
    
    // Set up home button
    document.querySelector('.home-button').onclick = () => {
        overlay.classList.remove('show');
        setTimeout(() => {
            overlay.style.display = 'none';
            exitCustomPractice();
        }, 1000);
    };
}

// Validate custom list before allowing practice
function validateCustomListForPractice(list) {
    const MIN_WORDS_REQUIRED = 6;
    
    if (!list || !list.words || !list.translations) {
        return {
            valid: false,
            message: 'Invalid list format. Please check your list and try again.'
        };
    }
    
    if (!Array.isArray(list.words) || !Array.isArray(list.translations)) {
        return {
            valid: false,
            message: 'Word list format is invalid. Please recreate your list.'
        };
    }
    
    if (list.words.length !== list.translations.length) {
        return {
            valid: false,
            message: 'Words and translations do not match. Please edit your list.'
        };
    }
    
    if (list.words.length < MIN_WORDS_REQUIRED) {
        return {
            valid: false,
            message: `Lists need at least ${MIN_WORDS_REQUIRED} words to practice.`
        };
    }
    
    return { valid: true };
}

// Error handling wrapper for custom list operations
async function safeCustomListOperation(operation, fallbackMessage = 'Operation failed') {
    try {
        return await operation();
    } catch (error) {
        console.error(`Custom list operation error: ${error.message || error}`);
        showNotification(fallbackMessage, 'error');
        return null;
    }
}

// Show toast notification for list operations
function showListNotification(message, type = 'info') {
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    // Animate in
    setTimeout(() => toast.classList.add('show'), 10);
    
    // Animate out after delay
    setTimeout(() => {
        toast.classList.add('hide');
        setTimeout(() => document.body.removeChild(toast), 600);
    }, 3000);
}

// Generic function to handle list operation errors
function handleListOperationError(operation, result, successMessage, errorMessage) {
    if (result !== false && result !== null && result !== undefined) {
        showListNotification(successMessage, 'success');
        return true;
    } else {
        console.error(`Failed during: ${operation}`);
        showListNotification(errorMessage, 'error');
        return false;
    }
}

// Add responsive styling for mobile devices
function initializeCustomListsResponsive() {
    // Check if mobile-specific styles already exist
    if (document.getElementById('custom-lists-responsive-styles')) return;
    
    // Create style element for custom list responsiveness
    const style = document.createElement('style');
    style.id = 'custom-lists-responsive-styles';
    
    // Define responsive styles for different screen sizes
    style.textContent = `
        /* Tablet and smaller screens */
        @media (max-width: 768px) {
            .custom-practice-container {
                flex-direction: column;
                gap: 1.5rem;
                padding: 1rem;
            }
            
            .practice-section, .lists-section {
                width: 100%;
                padding: 1.5rem;
            }
            
            .list-actions {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.5rem;
            }
            
            .word-translation-item {
                display: flex;
                flex-direction: column;
                padding: 0.75rem;
                gap: 0.5rem;
            }
            
            .word-translation-item .source-word,
            .word-translation-item .target-word {
                width: 100%;
                min-height: 44px;
                font-size: 16px;
            }
            
            .drag-handle {
                display: none;
            }
        }
        
        /* Mobile phones */
        @media (max-width: 480px) {
            .custom-practice-container {
                padding: 0.5rem;
            }
            
            .practice-section, .lists-section {
                padding: 1rem;
            }
            
            .list-actions {
                grid-template-columns: 1fr;
            }
            
            .word-input-actions {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .word-input-actions .main-button {
                width: 100%;
            }
            
            .custom-list-item {
                padding: 1rem;
            }
            
            .custom-list-item h3 {
                font-size: 1.1rem;
            }
            
            .word-translation-item {
                padding: 0.5rem;
            }
        }
        
        /* Touch-friendly enhancements */
        @media (pointer: coarse) {
            .word-translation-item .source-word,
            .word-translation-item .target-word {
                padding: 0.75rem;
                min-height: 48px;
            }
            
            .list-actions button,
            .word-input-actions button {
                padding: 0.75rem !important;
                min-height: 48px;
            }
            
            .custom-list-item {
                margin-bottom: 1rem;
            }
        }
    `;
    
    // Add styles to document
    document.head.appendChild(style);
}

// Initialize custom practice components
function initializeCustomPractice() {
    // Initialize responsive design
    initializeCustomListsResponsive();
    
    // Initialize drag and drop functionality
    setupDragAndDrop();
    
    // Initialize keyboard navigation
    setupWordListKeyNavigation();
    
    // Load lists on initialization
    loadCustomLists().then(() => {
        console.log('Custom lists loaded during initialization');
    }).catch(error => {
        console.error('Failed to load custom lists:', error);
    });
    
    // Initialize list limit indicators
    updateListLimitIndicators();
}

// Setup drag and drop functionality for word list
function setupDragAndDrop() {
    // Global drag state
    let draggedItem = null;
    
    // Helper function to add drag events to an item
    function addDragEvents(item) {
        item.addEventListener('dragstart', handleDragStart);
        item.addEventListener('dragend', handleDragEnd);
    }
    
    // Handler for drag start
    function handleDragStart(e) {
        draggedItem = this;
        this.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', ''); // Required for Firefox
    }
    
    // Handler for drag end
    function handleDragEnd(e) {
        this.classList.remove('dragging');
        draggedItem = null;
    }
    
    // Set up container drag over handler
    document.addEventListener('dragover', function(e) {
        e.preventDefault(); // Allow drop
        
        const container = document.getElementById('word-translation-list');
        if (!container || !draggedItem) return;
        
        const draggingItem = document.querySelector('.dragging');
        if (!draggingItem) return;
        
        const afterElement = getDragAfterElement(container, e.clientY);
        if (afterElement) {
            container.insertBefore(draggingItem, afterElement);
        } else {
            container.appendChild(draggingItem);
        }
    });
    
    // Handle drop events
    document.addEventListener('drop', function(e) {
        e.preventDefault();
        const draggingElement = document.querySelector('.dragging');
        if (draggingElement) {
            draggingElement.classList.remove('dragging');
        }
    });
    
    // Find the element to insert after based on mouse position
    function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('.word-translation-item:not(.dragging)')];
        
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }
    
    // Apply drag events to existing items
    document.querySelectorAll('.word-translation-item').forEach(addDragEvents);
    
    // Expose function to initialize new items
    window.initializeDragAndDrop = function(item) {
        if (!item) return;
        
        // Clone to remove old listeners
        const newItem = item.cloneNode(true);
        if (item.parentNode) {
            item.parentNode.replaceChild(newItem, item);
        }
        
        // Add new listeners
        addDragEvents(newItem);
        
        // Re-attach any needed event handlers for child elements
        const deleteBtn = newItem.querySelector('.delete-word-btn');
        if (deleteBtn) {
            deleteBtn.addEventListener('click', function() {
                if (this.closest('.word-translation-item')) {
                    this.closest('.word-translation-item').remove();
                }
            });
        }
        
        return newItem;
    };
}

// Update list limit indicators based on user tier
function updateListLimitIndicators() {
    const limits = CustomListsManager.getListLimits();
    
    // Find or create limit indicator element
    let limitIndicator = document.getElementById('list-limits-indicator');
    if (!limitIndicator) {
        limitIndicator = document.createElement('div');
        limitIndicator.id = 'list-limits-indicator';
        limitIndicator.className = 'list-limits-indicator';
        
        // Add to practice section if it exists
        const practiceSection = document.querySelector('.practice-section');
        if (practiceSection) {
            practiceSection.appendChild(limitIndicator);
        }
    }
    
    // Set limit indicator content
    limitIndicator.innerHTML = `
        <div class="limit-item">
            <span class="limit-label">Max Lists:</span>
            <span class="limit-value">${CustomListsManager.lists.length}/${limits.maxLists}</span>
        </div>
        <div class="limit-item">
            <span class="limit-label">Max Words Per List:</span>
            <span class="limit-value">${limits.maxWords}</span>
        </div>
        <div class="limit-item">
            <span class="limit-label">Practice Sessions:</span>
            <span class="limit-value">${limits.playDisplay}</span>
        </div>
    `;
    
    // Add a style element if needed
    if (!document.getElementById('list-limits-styles')) {
        const style = document.createElement('style');
        style.id = 'list-limits-styles';
        style.textContent = `
            .list-limits-indicator {
                display: flex;
                justify-content: space-around;
                padding: 0.75rem;
                margin: 1rem 0;
                background: rgba(255,255,255,0.05);
                border-radius: 10px;
                border: 1px solid rgba(255,255,255,0.1);
                font-size: 0.9rem;
            }
            
            .limit-item {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 0.25rem;
            }
            
            .limit-label {
                color: var(--text);
                opacity: 0.8;
            }
            
            .limit-value {
                color: var(--gold);
                font-weight: bold;
            }
            
            @media (max-width: 768px) {
                .list-limits-indicator {
                    flex-direction: column;
                    padding: 1rem;
                    gap: 0.75rem;
                }
                
                .limit-item {
                    flex-direction: row;
                    justify-content: space-between;
                    width: 100%;
                }
            }
        `;
        document.head.appendChild(style);
    }
}

// Initialize on DOMContentLoaded
document.addEventListener('DOMContentLoaded', () => {
    initializeCustomPractice();
});

// Process words from text input into structured list
function processCustomWords() {
    const wordInput = document.getElementById('custom-word-input');
    const translationResults = document.getElementById('translation-results');
    const wordList = document.getElementById('word-translation-list');
    const limits = CustomListsManager.getListLimits();
    const rawInput = wordInput.value.trim();
    
    if (!rawInput) {
        showNotification('Please enter at least one word.', 'error');
        return;
    }

    // Parse input based on format (commas or newlines)
    let words = rawInput.includes(',') ?
        rawInput.split(',').map(word => word.trim()) :
        rawInput.split(/\s*\n\s*/).filter(word => word.length > 0);

    // Handle phrase entries properly (preserve spaces within entries)
    words = words.filter(word => word.trim().length > 0);

    // Validate word count against user's limit
    const maxWords = limits.maxWords;
    if (words.length > maxWords) {
        showNotification(`Maximum ${maxWords} words allowed.`, 'error');
        words = words.slice(0, maxWords);
    }

    // Clear and prepare container
    wordList.innerHTML = '';
    translationResults.style.display = 'block';

    // Process and create word items
    words.forEach(word => {
        const foundTranslation = findTranslation(word.trim());
        createWordTranslationItem(word.trim(), foundTranslation, true);
    });

    // Initialize drag and drop for new items
    makeWordListDraggable();
}

// Helper function to find translation from built-in vocabulary
function findTranslation(word) {
    if (!word) return '';
    
    // Normalize input word for comparison
    const normalizedWord = word.toLowerCase().trim();
    
    // Search all vocabulary sets for matching word
    for (const setKey in vocabularySets) {
        const set = vocabularySets[setKey];
        if (!set.words || !Array.isArray(set.words)) continue;
        
        const index = set.words.findIndex(w => 
            w.toLowerCase().trim() === normalizedWord
        );
        
        if (index !== -1 && set.translations && set.translations[index]) {
            return set.translations[index];
        }
    }
    
    // Check user's existing lists for translations
    const allLists = CustomListsManager.lists || [];
    for (const list of allLists) {
        if (!list.words || !Array.isArray(list.words)) continue;
        
        const index = list.words.findIndex(w => 
            w.toLowerCase().trim() === normalizedWord
        );
        
        if (index !== -1 && list.translations && list.translations[index]) {
            return list.translations[index];
        }
    }
    
    return '';
}

// Create a new word translation item in the list
function createWordTranslationItem(word = '', translation = '', isEditable = true) {
    const wordList = document.getElementById('word-translation-list');
    if (!wordList) return null;
    
    const wordItem = document.createElement('div');
    wordItem.className = 'word-translation-item';
    wordItem.draggable = true;
    
    wordItem.innerHTML = `
        <div class="drag-handle">
            <i class="fas fa-grip-vertical"></i>
        </div>
        <span class="source-word" ${isEditable ? 'contenteditable="true"' : 'readonly'}>${word}</span>
        <input 
            type="text" 
            class="target-word" 
            value="${translation}" 
            ${isEditable ? '' : 'readonly'}
            placeholder="Hebrew translation"
        >
        <button class="delete-word-btn">❌</button>
    `;
    
    // Add to word list
    const newItem = wordList.appendChild(wordItem);
    
    // Add event listener to delete button
    newItem.querySelector('.delete-word-btn').addEventListener('click', function() {
        newItem.remove();
    });
    
    // Initialize drag functionality
    window.initializeDragAndDrop(newItem);
    
    return newItem;
}

// Add a new blank word item to the list
function addNewWord() {
    createWordTranslationItem('', '', true);
    
    // Ensure translation results container is visible
    const translationResults = document.getElementById('translation-results');
    if (translationResults) {
        translationResults.style.display = 'block';
    }
    
    // Make sure the word list is draggable
    makeWordListDraggable();
}

// Save the current list (create new or update existing)
async function saveCurrentList() {
    const listNameInput = document.getElementById('custom-list-name');
    const wordList = document.getElementById('word-translation-list');
    const limits = CustomListsManager.getListLimits();
    
    // Get current list name
    const name = listNameInput.value.trim() || 
        (customPracticeLists.currentList ? 
            customPracticeLists.currentList.name : 
            `List ${CustomListsManager.lists.length + 1}`);
            
    // Extract words and translations
    const words = [];
    const translations = [];
    
    const items = wordList.querySelectorAll('.word-translation-item');
    items.forEach(item => {
        const word = item.querySelector('.source-word').textContent.trim();
        const translation = item.querySelector('.target-word').value.trim();
        
        if (word && translation) {
            words.push(word);
            translations.push(translation);
        }
    });
    
    // Validate word count
    if (words.length === 0) {
        showNotification('Please add at least one word to your list', 'error');
        return;
    }
    
    if (words.length > limits.maxWords) {
        showNotification(`You can only create lists with up to ${limits.maxWords} words`, 'error');
        return;
    }
    
    // Determine if we're creating or updating
    const isEditing = customPracticeLists.currentList !== null;
    
    // Check list limit for new lists
    if (!isEditing && !CustomListsManager.canCreateMoreLists()) {
        showNotification(`You can only create ${limits.maxLists} custom lists`, 'error');
        return;
    }
    
    // Prepare list data
    let listToSave;
    if (isEditing) {
        // Updating existing list
        listToSave = {
            ...customPracticeLists.currentList,
            name,
            words,
            translations
        };
    } else {
        // Creating new list
        listToSave = {
            tempId: Date.now(),  // Temporary ID until saved to database
            name,
            words,
            translations
        };
    }
    
    // Wrap save operation in error handler
    const savedList = await safeCustomListOperation(
        async () => await CustomListsManager.save(listToSave),
        'Failed to save list. Please try again.'
    );
    
    if (savedList) {
        // Clear form
        listNameInput.value = '';
        wordList.innerHTML = '';
        document.getElementById('translation-results').style.display = 'none';
        
        // Reset current list reference
        customPracticeLists.currentList = null;
        
        // Reload lists from appropriate source
        await CustomListsManager.initialize();
        
        showNotification('List saved successfully', 'success');
        
        // Show screen after data refresh
        showScreen('custom-practice-screen');
        updateListsDisplay();
    }
}
function setupWordListKeyNavigation() {
    const container = document.getElementById('word-translation-list');
    if (!container) return;
    
    container.addEventListener('keydown', (e) => {
        const currentItem = document.activeElement.closest('.word-translation-item');
        if (!currentItem) return;
        
        let targetElement;
        
        switch(e.key) {
            case 'ArrowUp':
                e.preventDefault();
                if (currentItem.previousElementSibling) {
                    const field = document.activeElement.classList.contains('source-word') ? 
                        'source-word' : 'target-word';
                    targetElement = currentItem.previousElementSibling.querySelector(`.${field}`);
                }
                break;
                
            case 'ArrowDown':
                e.preventDefault();
                if (currentItem.nextElementSibling) {
                    const field = document.activeElement.classList.contains('source-word') ? 
                        'source-word' : 'target-word';
                    targetElement = currentItem.nextElementSibling.querySelector(`.${field}`);
                }
                break;
                
            case 'ArrowRight':
                e.preventDefault();
                if (document.activeElement.classList.contains('source-word')) {
                    targetElement = currentItem.querySelector('.target-word');
                }
                break;
                
            case 'ArrowLeft':
                e.preventDefault();
                if (document.activeElement.classList.contains('target-word')) {
                    targetElement = currentItem.querySelector('.source-word');
                }
                break;
                
            case 'Enter':
                // When pressing Enter in the last field of the last item, add a new item
                if (document.activeElement.classList.contains('target-word') && 
                    !currentItem.nextElementSibling) {
                    e.preventDefault();
                    addNewWord();
                    // Focus the source-word of the newly added item
                    setTimeout(() => {
                        const newItem = container.lastElementChild;
                        if (newItem) {
                            newItem.querySelector('.source-word').focus();
                        }
                    }, 0);
                    return;
                }
                break;
                
            case 'Tab':
                // When tabbing from the last field of the last item, add a new item
                if (!e.shiftKey && 
                    document.activeElement.classList.contains('target-word') && 
                    !currentItem.nextElementSibling) {
                    e.preventDefault();
                    addNewWord();
                    // Focus the source-word of the newly added item
                    setTimeout(() => {
                        const newItem = container.lastElementChild;
                        if (newItem) {
                            newItem.querySelector('.source-word').focus();
                        }
                    }, 0);
                    return;
                }
                break;
                
            case 'Delete':
                // Allow deletion with keyboard if modifier is pressed
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    const deleteBtn = currentItem.querySelector('.delete-word-btn');
                    if (deleteBtn) deleteBtn.click();
                }
                break;
        }
        
        if (targetElement) {
            targetElement.focus();
            
            // For contenteditable elements, place cursor at the end
            if (targetElement.getAttribute('contenteditable') === 'true') {
                const range = document.createRange();
                const selection = window.getSelection();
                range.selectNodeContents(targetElement);
                range.collapse(false); // false means collapse to end
                selection.removeAllRanges();
                selection.addRange(range);
            }
        }
    });
    
    // Enhance the contenteditable fields behavior
    container.querySelectorAll('.source-word[contenteditable="true"]').forEach(element => {
        // Prevent enter key from creating new lines
        element.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                // Move focus to the adjacent target field
                const targetField = element.closest('.word-translation-item').querySelector('.target-word');
                if (targetField) targetField.focus();
            }
        });
        
        // Auto-resize as content changes
        element.addEventListener('input', () => {
            element.style.width = Math.max(100, Math.min(300, element.scrollWidth)) + 'px';
        });
    });
}

// Call this when word list is populated
function initializeWordListBehavior() {
    setupWordListKeyNavigation();
    
    // Make contenteditable fields work more like inputs
    document.querySelectorAll('.source-word[contenteditable="true"]').forEach(element => {
        element.addEventListener('blur', () => {
            // Trim content on blur
            element.textContent = element.textContent.trim();
        });
        
        // Prevent pasting formatted content
        element.addEventListener('paste', (e) => {
            e.preventDefault();
            const text = (e.clipboardData || window.clipboardData).getData('text/plain');
            document.execCommand('insertText', false, text);
        });
    });
    
    // Set up autofocus for newly added items
    document.querySelectorAll('.add-word-button').forEach(button => {
        button.addEventListener('click', () => {
            setTimeout(() => {
                const newItem = document.getElementById('word-translation-list').lastElementChild;
                if (newItem) {
                    const sourceWord = newItem.querySelector('.source-word');
                    if (sourceWord) sourceWord.focus();
                }
            }, 0);
        });
    });
}

function makeWordListDraggable() {
    const wordList = document.getElementById('word-translation-list');
    if (!wordList) return;
    
    // Remove existing listeners to prevent duplicates
    const newWordList = wordList.cloneNode(true);
    wordList.parentNode.replaceChild(newWordList, wordList);
    
    // Re-initialize all word items
    newWordList.querySelectorAll('.word-translation-item').forEach(item => {
        initializeDragAndDrop(item);
    });
    
    // Add dragover event listener for list container
    newWordList.addEventListener('dragover', e => {
        e.preventDefault();
        const draggable = newWordList.querySelector('.dragging');
        if (!draggable) return;
        
        const afterElement = getDragAfterElement(newWordList, e.clientY);
        if (afterElement) {
            newWordList.insertBefore(draggable, afterElement);
        } else {
            newWordList.appendChild(draggable);
        }
    });

    // Handle drop completion
    newWordList.addEventListener('drop', e => {
        e.preventDefault();
        const draggingElement = document.querySelector('.dragging');
        if (draggingElement) {
            draggingElement.classList.remove('dragging');
            
            // Add subtle feedback animation
            draggingElement.style.transition = 'background-color 0.3s ease';
            draggingElement.style.backgroundColor = 'rgba(255,255,255,0.2)';
            setTimeout(() => {
                draggingElement.style.backgroundColor = '';
                setTimeout(() => {
                    draggingElement.style.transition = '';
                }, 300);
            }, 300);
        }
    });
    
    // Enhance drag handles
    newWordList.querySelectorAll('.drag-handle').forEach(handle => {
        // Add visual feedback on hover
        handle.addEventListener('mouseenter', () => {
            handle.style.cursor = 'grab';
            handle.style.opacity = '1';
        });
        
        handle.addEventListener('mouseleave', () => {
            handle.style.cursor = '';
            handle.style.opacity = '0.7';
        });
        
        // Change cursor on mousedown
        handle.addEventListener('mousedown', () => {
            handle.style.cursor = 'grabbing';
        });
        
        handle.addEventListener('mouseup', () => {
            handle.style.cursor = 'grab';
        });
    });
    
    return newWordList;
}

function initializeDragAndDrop(item) {
    if (!item) return;
    
    // Remove existing listeners to prevent duplicates
    const newItem = item.cloneNode(true);
    if (item.parentNode) {
        item.parentNode.replaceChild(newItem, item);
    }
    item = newItem;
    
    // Reset draggable state
    item.setAttribute('draggable', 'true');
    
    // Add event listeners with better error handling
    item.addEventListener('dragstart', e => {
        try {
            e.stopPropagation();
            item.classList.add('dragging');
            
            // Set required data for Firefox compatibility
            e.dataTransfer.setData('text/plain', '');
            
            // Show custom drag image
            const dragIcon = document.createElement('div');
            dragIcon.textContent = item.querySelector('.source-word')?.textContent || 'Word';
            dragIcon.style.cssText = `
                position: absolute; 
                top: -1000px; 
                background: rgba(0,0,0,0.7); 
                color: white; 
                padding: 5px 10px; 
                border-radius: 4px;
                font-size: 14px;
            `;
            document.body.appendChild(dragIcon);
            e.dataTransfer.setDragImage(dragIcon, 0, 0);
            
            // Clean up drag icon after a delay
            setTimeout(() => document.body.removeChild(dragIcon), 0);
        } catch (error) {
            console.error('Drag start error:', error);
        }
    });
    
    item.addEventListener('dragend', e => {
        try {
            e.stopPropagation();
            item.classList.remove('dragging');
        } catch (error) {
            console.error('Drag end error:', error);
        }
    });
    
    // Re-attach delete button functionality
    const deleteBtn = item.querySelector('.delete-word-btn');
    if (deleteBtn) {
        deleteBtn.onclick = function() { deleteWord(this); };
    }
    
    return item;
}

function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.word-translation-item:not(.dragging)')];
    
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

function validateCustomList(list) {
    const MIN_WORDS_REQUIRED = 6;
    const MAX_WORDS_ALLOWED = CustomListsManager.getListLimits().maxWords;
    
    if (!list || !list.name) {
        return {
            valid: false,
            message: 'Please provide a name for your list'
        };
    }
    
    if (!Array.isArray(list.words) || !Array.isArray(list.translations)) {
        return {
            valid: false,
            message: 'Invalid list format'
        };
    }
    
    if (list.words.length === 0) {
        return {
            valid: false,
            message: 'Please add at least one word to your list'
        };
    }
    
    if (list.words.length < MIN_WORDS_REQUIRED) {
        return {
            valid: false,
            message: `Lists need at least ${MIN_WORDS_REQUIRED} words to practice`
        };
    }
    
    if (list.words.length > MAX_WORDS_ALLOWED) {
        return {
            valid: false,
            message: `Lists can have at most ${MAX_WORDS_ALLOWED} words`
        };
    }
    
    // Check for empty entries
    const hasEmptyWords = list.words.some(word => !word || word.trim() === '');
    const hasEmptyTranslations = list.translations.some(translation => !translation || translation.trim() === '');
    
    if (hasEmptyWords || hasEmptyTranslations) {
        return {
            valid: false,
            message: 'Some words or translations are empty'
        };
    }
    
    return { valid: true };
}

function showEmptyListState() {
    const container = document.getElementById('custom-lists-container');
    if (!container) return;
    
    container.innerHTML = `
    <div class="empty-state">
        <i class="fas fa-list-alt" style="font-size: 3rem; color: var(--accent); margin-bottom: 1rem;"></i>
        <h3>No custom lists yet</h3>
        <p>Create your first list to start practicing!</p>
        <button class="main-button" onclick="addNewListForm()">
            <i class="fas fa-plus"></i> Create New List
        </button>
    </div>
    `;
    
    // Style the empty state
    const style = document.createElement('style');
    style.textContent = `
    .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 3rem;
        background: rgba(255,255,255,0.05);
        border-radius: 15px;
        text-align: center;
    }
    
    .empty-state h3 {
        color: var(--text);
        margin: 0.5rem 0;
    }
    
    .empty-state p {
        color: var(--text);
        opacity: 0.8;
        margin-bottom: 1.5rem;
    }
    `;
    
    // Only add the style if it doesn't already exist
    if (!document.getElementById('empty-list-style')) {
        style.id = 'empty-list-style';
        document.head.appendChild(style);
    }
}

function addNewListForm() {
    // Reset current list state
    customGameState.currentList = null;
    
    // Clear form fields
    const listNameInput = document.getElementById('custom-list-name');
    const wordInput = document.getElementById('custom-word-input');
    const translationResults = document.getElementById('translation-results');
    const wordList = document.getElementById('word-translation-list');
    
    if (listNameInput) listNameInput.value = '';
    if (wordInput) wordInput.value = '';
    if (wordList) wordList.innerHTML = '';
    if (translationResults) translationResults.style.display = 'none';
    
    // Show custom practice screen in creation mode
    showScreen('custom-practice-screen');
    
    // Add default word entries
    addNewWord();
    addNewWord();
    
    // Focus the list name input
    if (listNameInput) {
        setTimeout(() => listNameInput.focus(), 100);
    }
}

function showNoWordsMessage() {
    const wordList = document.getElementById('word-translation-list');
    if (!wordList) return;
    
    wordList.innerHTML = `
    <div class="no-words-message">
        <p>No words added yet. Add your first word to get started!</p>
        <button class="main-button small-button" onclick="addNewWord()">
            <i class="fas fa-plus"></i> Add Word
        </button>
    </div>
    `;
    
    // Style the message
    const style = document.createElement('style');
    style.textContent = `
    .no-words-message {
        padding: 2rem;
        text-align: center;
        background: rgba(255,255,255,0.05);
        border-radius: 10px;
        margin: 1rem 0;
    }
    
    .no-words-message p {
        margin-bottom: 1rem;
        color: var(--text);
        opacity: 0.8;
    }
    `;
    
    // Only add the style if it doesn't already exist
    if (!document.getElementById('no-words-message-style')) {
        style.id = 'no-words-message-style';
        document.head.appendChild(style);
    }
}

function optimizeCustomListsForMobile() {
    // Add responsive styles if not already present
    if (!document.getElementById('custom-lists-mobile-styles')) {
        const style = document.createElement('style');
        style.id = 'custom-lists-mobile-styles';
        style.textContent = `
        @media (max-width: 768px) {
            .custom-practice-container {
                flex-direction: column;
                gap: 1.5rem;
                padding: 1rem;
            }
            
            .practice-section, 
            .lists-section {
                width: 100%;
                padding: 1.5rem;
            }
            
            .word-translation-item {
                flex-direction: column;
                gap: 0.5rem;
                padding: 1rem;
            }
            
            .source-word, 
            .target-word {
                width: 100% !important;
                min-height: 44px;
                font-size: 16px;
                padding: 0.75rem;
                margin: 0.25rem 0;
            }
            
            .drag-handle {
                display: none;
            }
            
            .delete-word-btn {
                position: absolute;
                top: 0.5rem;
                right: 0.5rem;
                font-size: 1.2rem;
            }
            
            .custom-list-item {
                padding: 1rem;
            }
            
            .list-actions {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }
            
            .word-input-actions {
                flex-direction: column;
                width: 100%;
            }
            
            .word-input-actions .main-button {
                width: 100%;
            }
            
            #custom-word-input {
                font-size: 16px;
                min-height: 100px;
            }
            
            /* Touch-friendly buttons */
            .main-button, 
            .start-button, 
            .edit-button, 
            .practice-button, 
            .delete-button {
                min-height: 44px;
                padding: 0.75rem;
                font-size: 1rem;
            }
            
            /* Optimize drag and drop for touch */
            .word-translation-item {
                position: relative;
                padding-right: 3rem;
            }
        }
        
        /* Even smaller screens */
        @media (max-width: 480px) {
            .practice-section, 
            .lists-section {
                padding: 1rem;
            }
            
            .welcome-title {
                font-size: 1.75rem;
            }
            
            .custom-list-item h3 {
                font-size: 1.1rem;
            }
            
            .list-summary {
                font-size: 0.85rem;
            }
        }
        `;
        
        document.head.appendChild(style);
    }
    
    // Add touch-specific event handlers
    function addTouchHandlers() {
        // Handle touch events for custom list items
        document.querySelectorAll('.custom-list-item').forEach(item => {
            let touchStartX = 0;
            let touchEndX = 0;
            
            item.addEventListener('touchstart', e => {
                touchStartX = e.changedTouches[0].screenX;
            }, { passive: true });
            
            item.addEventListener('touchend', e => {
                touchEndX = e.changedTouches[0].screenX;
                handleSwipe(item, touchStartX, touchEndX);
            }, { passive: true });
        });
        
        // Handle touch events for word items
        document.querySelectorAll('.word-translation-item').forEach(item => {
            let touchStartY = 0;
            let touchEndY = 0;
            
            item.addEventListener('touchstart', e => {
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });
            
            item.addEventListener('touchend', e => {
                touchEndY = e.changedTouches[0].screenY;
                handleVerticalSwipe(item, touchStartY, touchEndY);
            }, { passive: true });
        });
    }
    
    // Handle horizontal swipe gesture
    function handleSwipe(element, startX, endX) {
        const threshold = 100; // Minimum distance for swipe
        const swipeDistance = endX - startX;
        
        if (Math.abs(swipeDistance) > threshold) {
            if (swipeDistance > 0) {
                // Swipe right - edit
                const editButton = element.querySelector('.edit-button');
                if (editButton) editButton.click();
            } else {
                // Swipe left - delete
                const deleteButton = element.querySelector('.delete-button');
                if (deleteButton) {
                    // Show confirmation first
                    if (confirm('Delete this list?')) {
                        deleteButton.click();
                    }
                }
            }
        }
    }
    
    // Handle vertical swipe gesture for word items
    function handleVerticalSwipe(element, startY, endY) {
        const threshold = 70; // Minimum distance for swipe
        const swipeDistance = endY - startY;
        
        if (Math.abs(swipeDistance) > threshold) {
            if (swipeDistance > 0) {
                // Swipe down - add new word after this one
                const wordList = element.parentNode;
                const newItem = createWordItem('', '');
                
                if (element.nextSibling) {
                    wordList.insertBefore(newItem, element.nextSibling);
                } else {
                    wordList.appendChild(newItem);
                }
                
                initializeDragAndDrop(newItem);
                const sourceWord = newItem.querySelector('.source-word');
                if (sourceWord) sourceWord.focus();
            } else {
                // Swipe up - delete word
                const deleteBtn = element.querySelector('.delete-word-btn');
                if (deleteBtn) deleteBtn.click();
            }
        }
    }
    
    // Initialize for current screen
    addTouchHandlers();
    
    // Return function to be called when screen changes
    return addTouchHandlers;
}

function showCustomListsManager() {
    showScreen('custom-practice-screen');
    
    // Reset state
    customGameState.reset();
    
    // First load lists using the manager
    Promise.resolve(CustomListsManager.initialize())
        .then(() => {
            updateListsDisplay();
            
            // Enable mobile optimizations
            optimizeCustomListsForMobile();
        })
        .catch(error => {
            console.error('Error initializing custom lists:', error);
            showNotification('Failed to load custom lists', 'error');
        });
}

function updateListsDisplay() {
    const container = document.getElementById('custom-lists-container');
    if (!container) {
        console.error('Custom lists container not found');
        return;
    }
    
    // Clear container
    container.innerHTML = '';
    
    // Get user limits
    const limits = CustomListsManager.getListLimits();
    const userStatus = currentUser?.status || 'unregistered';
    
    // Show add list button/message if no lists or below limit
    const canCreateMore = CustomListsManager.canCreateMoreLists();
    const listsCount = CustomListsManager.lists.length;
    
    // Show appropriate header with count and limits
    container.innerHTML = `
    <div class="lists-header" style="margin-bottom: 1.5rem; display: flex; justify-content: space-between; align-items: center;">
        <div class="lists-stats">
            <span>Lists: ${listsCount}/${limits.maxLists}</span>
        </div>
        ${canCreateMore ? `
        <button class="main-button small-button" onclick="addNewListForm()">
            <i class="fas fa-plus"></i> New List
        </button>
        ` : `
        <button class="main-button small-button" disabled style="opacity: 0.5;">
            <i class="fas fa-plus"></i> Limit Reached
        </button>
        `}
    </div>
    `;
    
    // Check if we have lists to display
    if (!CustomListsManager.lists || CustomListsManager.lists.length === 0) {
        showEmptyListState();
        return;
    }
    
    // Create lists container
    const listsContainer = document.createElement('div');
    listsContainer.className = 'lists-container';
    container.appendChild(listsContainer);
    
    // Create and add each list item
    CustomListsManager.lists.forEach(list => {
        if (!list || !list.id) return; // Skip invalid list entries
        
        // Update list with max levels info
        const enhancedList = updateCustomListSchema(list);
        const wordCount = enhancedList.words?.length || 0;
        const MIN_WORDS = enhancedList.min_words || 6;
        const hasEnoughWords = wordCount >= MIN_WORDS;
        
        // Create list item container
        const listItem = document.createElement('div');
        listItem.className = `custom-list-item collapsed ${list.isShared ? 'shared-list' : ''}`;
        listItem.dataset.listId = list.id;
        
        // Create list item content
        listItem.innerHTML = `
            <div class="list-actions">
                <button class="main-button practice-button" ${!hasEnoughWords ? 'disabled' : ''}>
                    ${hasEnoughWords ? 'Practice' : `Need ${MIN_WORDS - wordCount} more`}
                </button>
                <button class="main-button edit-button">Edit</button>
                <button class="main-button delete-button">Delete</button>
                ${userStatus === 'premium' ? `
                    <button class="main-button share-button">
                        <i class="fas fa-share-alt"></i> Share
                    </button>
                ` : ''}
            </div>
            <div class="list-header">
                <h3>${list.name || 'Unnamed List'}</h3>
                <div class="list-summary">
                    <span class="word-count ${!hasEnoughWords ? 'insufficient' : ''}">${wordCount} words</span>
                    ${!hasEnoughWords ? `<span class="warning-text">(Minimum ${MIN_WORDS} needed)</span>` : ''}
                    <span style="margin-left: 1rem;">${limits.playDisplay} plays available</span>
                    ${enhancedList.max_levels > 0 ? `<span class="level-info">Supports ${enhancedList.max_levels} levels</span>` : ''}
                </div>
                <p class="word-preview">${Array.isArray(list.words) ? list.words.slice(0,5).join(', ') : ''}${list.words && list.words.length > 5 ? '...' : ''}</p>
            </div>
        `;
        
        // Add item to container
        listsContainer.appendChild(listItem);
        
        // Set up event listeners for buttons
        const practiceButton = listItem.querySelector('.practice-button');
        if (practiceButton) {
            if (hasEnoughWords) {
                practiceButton.onclick = function() {
                    startCustomListPractice(list.id);
                };
            } else {
                practiceButton.style.opacity = '0.6';
                practiceButton.style.cursor = 'not-allowed';
            }
        }
        
        const editButton = listItem.querySelector('.edit-button');
        if (editButton) {
            editButton.onclick = function() {
                editCustomList(list.id);
            };
        }
        
        const deleteButton = listItem.querySelector('.delete-button');
        if (deleteButton) {
            deleteButton.onclick = function() {
                if (confirm('Are you sure you want to delete this list?')) {
                    deleteCustomList(list.id);
                }
            };
        }
        
        const shareButton = listItem.querySelector('.share-button');
        if (shareButton) {
            shareButton.onclick = function() {
                showShareModal(list.id);
            };
        }
        
        const header = listItem.querySelector('.list-header');
        if (header) {
            header.onclick = function() {
                toggleListCollapse(list.id);
            };
        }
    });
    
    // Add custom CSS for styling if not already present
    if (!document.getElementById('custom-list-styles')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'custom-list-styles';
        styleEl.textContent = `
            .word-count.insufficient {
                color: #ff6b6b;
                font-weight: bold;
            }
            .warning-text {
                color: #ff6b6b;
                font-size: 0.85rem;
                margin-left: 0.5rem;
            }
            .level-info {
                color: var(--accent);
                font-size: 0.85rem;
                margin-left: 0.5rem;
            }
            .practice-button[disabled] {
                opacity: 0.6;
                cursor: not-allowed;
            }
            .shared-list {
                border-left: 3px solid var(--accent);
            }
            .word-preview {
                font-style: italic;
                opacity: 0.7;
                margin-top: 0.5rem;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 100%;
            }
        `;
        document.head.appendChild(styleEl);
    }
}

function startCustomListPractice(listId) {
    // Find the list in the manager
    const list = CustomListsManager.lists.find(l => l.id === listId);
    if (!list) {
        showNotification('List not found', 'error');
        return;
    }
    
    // Validate the list for practice
    const validation = CustomListsManager.validateListForPractice(list);
    if (!validation.valid) {
        showNotification(validation.message, 'error');
        return;
    }
    
    // Reset game state and initialize from list
    const initialized = customGameState.initializeFromList(list);
    if (!initialized) {
        showNotification('Failed to initialize practice', 'error');
        return;
    }
    
    // Start first level
    startCustomLevel(1);
}

// Main initialization function for custom list practice
function initializeCustomListPractice(listId) {
    // Find the list
    const list = CustomListsManager.lists.find(l => l.id === listId);
    if (!list) {
        showNotification('List not found', 'error');
        return;
    }
    
    // Validate list has minimum required words
    const validation = CustomListsManager.validateListForPractice(list);
    if (!validation.valid) {
        showNotification(validation.message, 'error');
        return;
    }
    
    // Initialize custom game state
    const initialized = customGameState.initializeFromList(list);
    if (!initialized) {
        showNotification('Failed to initialize practice', 'error');
        return;
    }
    
    // Get play count for this list
    const playCountKey = `listPlays_${listId}`;
    let playsUsed = parseInt(localStorage.getItem(playCountKey) || '0');
    
    // Check play limits
    const limits = CustomListsManager.getListLimits();
    if (playsUsed >= limits.maxPlays) {
        showNotification('You have reached the maximum plays for this list', 'warning');
        // Optionally delete the list if it's exhausted
        if (!currentUser || currentUser.status !== 'premium') {
            CustomListsManager.delete(listId).then(() => {
                showNotification('List has been removed as you reached the play limit', 'info');
                updateListsDisplay();
            });
        }
        return;
    }

    // Increment play count
    playsUsed++;
    localStorage.setItem(playCountKey, playsUsed);
    
    // Show play count information
    showNotification(`Play ${playsUsed}/${limits.maxPlays === Infinity ? '∞' : limits.maxPlays}`, 'info');
    
    // Start the first level
    startCustomLevel(1);
}

// Function to start a specific custom practice level
function startCustomLevel(levelId) {
    // Update UI elements for custom practice
    const powerupsContainer = document.querySelector('.powerups-container');
    if (powerupsContainer) {
        powerupsContainer.style.display = 'none';
    }
    
    const perksContainer = document.querySelector('.perks-container');
    if (perksContainer) {
        perksContainer.style.display = 'flex';
    }
    
    // Update current level in game state
    customGameState.currentLevel = levelId;
    
    // Get level data
    const levelData = customGameState.getWordsForLevel(levelId);
    if (!levelData || !levelData.words.length) {
        // No more words - user completed all levels
        showNotification('Practice completed!', 'success');
        showScreen('custom-practice-screen');
        return;
    }
    
    // Set up current game object for the question screen
    currentGame = {
        words: levelData.words,
        translations: levelData.translations,
        currentIndex: 0,
        correctAnswers: 0,
        firstAttempt: true,
        isHebrewToEnglish: levelData.isTest ? Math.random() < 0.5 : false,
        mixed: levelData.isTest,
        speedChallenge: false,
        isCustomPractice: true,  // Critical flag for routing logic
        startingCoins: gameState.coins,
        startingPerks: { ...gameState.perks },
        timeBonus: 0,
        initialTimeRemaining: null,
        streakBonus: true,
        levelStartTime: Date.now(),
        questionStartTime: 0,
        wrongStreak: 0,
        progressLost: 0,
        customList: customGameState.currentList,
        customLevel: levelId,
        isFinalLevel: levelData.isFinal
    };
    
    // Show level intro with callback to start the level
    showLevelIntro(levelId, () => {
        showScreen('question-screen');
        updateProgressCircle();
        loadNextQuestion();
        startTimer(currentGame.words.length * 10); // 10 seconds per word
    });
}



// Function to display the completion screen
function showCustomCompletionScreen() {
    const overlay = document.createElement('div');
    overlay.className = 'completion-overlay';
    
    // Calculate coins earned
    const coinsEarned = gameState.coins - customGameState.startCoins;
    
    overlay.innerHTML = `
        <div class="completion-content">
            <h2>Practice Complete!</h2>
            <div class="completion-stats">
                <div class="stat-item">
                    <i class="fas fa-book"></i>
                    <span>Words Practiced: ${customGameState.wordsCompleted}</span>
                </div>
                <div class="stat-item">
                    <i class="fas fa-coins"></i>
                    <span>Coins Earned: ${coinsEarned}</span>
                </div>
            </div>
            <button onclick="exitCustomPractice()" class="start-button">Continue</button>
        </div>
    `;
    
    document.body.appendChild(overlay);
}

// Function to exit custom practice
function exitCustomPractice() {
    // Clean up
    customGameState.reset();
    
    // Hide completion overlay
    const overlay = document.querySelector('.completion-overlay');
    if (overlay) overlay.remove();
    
    // Return to custom lists screen
    showScreen('custom-practice-screen');
}

// Update startCustomListPractice to use the new initialization flow
function startCustomListPractice(listId) {
    initializeCustomListPractice(listId);
}

// Fix potential side effects from competing state objects
function reconcileCustomListState() {
    // If both state objects exist, consolidate to CustomListsManager
    if (window.customPracticeLists && CustomListsManager) {
        // Transfer any lists that might be in the old object but not the new one
        if (Array.isArray(customPracticeLists.lists)) {
            customPracticeLists.lists.forEach(list => {
                // Check if list already exists in CustomListsManager
                const existingList = CustomListsManager.lists.find(l => 
                    l.id === list.id || 
                    (l.name === list.name && 
                     JSON.stringify(l.words) === JSON.stringify(list.words))
                );
                
                if (!existingList) {
                    // Add missing list to CustomListsManager
                    CustomListsManager.lists.push(list);
                }
            });
        }
        
        // If there's a current list in the old object, transfer it
        if (customPracticeLists.currentList) {
            customGameState.currentList = customPracticeLists.currentList;
        }
        
        // Save consolidated lists
        CustomListsManager.saveToLocalStorage();
        
        // Clean up old object to prevent further usage
        window.customPracticeLists = {
            lists: [],
            currentList: null,
            get maxLists() {
                console.warn('Deprecated: Use CustomListsManager.getListLimits() instead');
                return CustomListsManager.getListLimits().maxLists;
            }
        };
    }
}

// Ensure smooth transition between game modes
function integrateCustomGameFlows() {
    // Patch the main handleLevelCompletion function to properly route
    const originalHandleLevelCompletion = window.handleLevelCompletion;
    
    if (originalHandleLevelCompletion) {
        window.handleLevelCompletion = function() {
            // Check if we're in custom practice mode
            if (currentGame && currentGame.isCustomPractice) {
                // Route to custom completion handler
                handleCustomLevelCompletion();
            } else {
                // Use standard completion handler
                originalHandleLevelCompletion.apply(this, arguments);
            }
        };
    }
    
    // Patch the startLevel function to ensure proper game mode detection
    const originalStartLevel = window.startLevel;
    
    if (originalStartLevel) {
        window.startLevel = function(levelId) {
            // Check if custom practice is active
            if (customGameState.isCustomPractice) {
                // Start custom level instead
                startCustomLevel(levelId);
            } else {
                // Use standard level start
                originalStartLevel.apply(this, arguments);
            }
        };
    }
}

// Ensure all list-related UI components correctly use CustomListsManager
function updateUIReferences() {
    // Fix any direct references to customPracticeLists in DOM
    document.querySelectorAll('[data-list-id]').forEach(element => {
        const listId = element.dataset.listId;
        
        // Update stored data attributes with list from correct source
        const list = CustomListsManager.lists.find(l => l.id == listId);
        if (list) {
            element.dataset.listName = list.name;
            element.dataset.wordCount = list.words?.length || 0;
        }
    });
    
    // Update event handlers for list-related actions
    document.querySelectorAll('.practice-button, .edit-button, .delete-button, .share-button').forEach(button => {
        // Get the list ID from the closest parent with data-list-id
        const listItem = button.closest('[data-list-id]');
        if (!listItem) return;
        
        const listId = listItem.dataset.listId;
        
        // Replace event handlers with those that use CustomListsManager
        if (button.classList.contains('practice-button')) {
            button.onclick = () => startCustomListPractice(listId);
        } else if (button.classList.contains('edit-button')) {
            button.onclick = () => editCustomList(listId);
        } else if (button.classList.contains('delete-button')) {
            button.onclick = () => deleteCustomList(listId);
        } else if (button.classList.contains('share-button')) {
            button.onclick = () => showShareModal(listId);
        }
    });
}

// Fix styling inconsistencies
function fixStylingIssues() {
    // Add consistent styling for custom list items
    const style = document.createElement('style');
    style.id = 'custom-list-fixes';
    style.textContent = `
        /* Ensure consistent button styling */
        .custom-list-item .main-button,
        .custom-list-item .start-button,
        .custom-list-item button {
            transition: all 0.3s ease;
            box-shadow: none;
            min-height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Fix word-translation-item layout */
        .word-translation-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            margin: 0.5rem 0;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            transition: all 0.3s ease;
        }
        
        /* Consistent drag handle */
        .drag-handle {
            cursor: grab;
            opacity: 0.7;
            width: 24px;
            text-align: center;
        }
        
        /* Fix incorrect source/target input styling */
        .source-word,
        .target-word {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5rem;
            border-radius: 8px;
            min-width: 0;
            flex: 1;
        }
        
        /* Fix issues with editable content in RTL languages */
        [contenteditable] {
            unicode-bidi: plaintext;
        }
        
        /* Fix mobile display issues */
        @media (max-width: 768px) {
            .custom-practice-container {
                padding: 1rem 0.5rem;
            }
            
            .word-translation-item {
                flex-direction: column;
                padding: 0.5rem;
            }
            
            .word-translation-item > * {
                width: 100%;
            }
            
            .drag-handle {
                display: none;
            }
        }
    `;
    
    // Add style to head if it doesn't exist
    if (!document.getElementById('custom-list-fixes')) {
        document.head.appendChild(style);
    }
}

// Fix any remaining duplicate state issues
function cleanupDuplicateState() {
    // Remove any outdated storage keys
    const keysToClean = [
        'simploxCustomListsTemp',
        'customListCurrentEdit'
    ];
    
    keysToClean.forEach(key => {
        if (localStorage.getItem(key)) {
            localStorage.removeItem(key);
        }
    });
    
    // Ensure only one state object exists for current list
    if (window.customPracticeLists && window.CustomListsManager) {
        // Transfer current list if needed
        if (customPracticeLists.currentList && !CustomListsManager.currentList) {
            CustomListsManager.currentList = customPracticeLists.currentList;
        }
        
        // Clear old object's current list
        customPracticeLists.currentList = null;
    }
}

// Integrate all final fixes
function applyFinalIntegrationFixes() {
    // First reconcile any competing state
    reconcileCustomListState();
    
    // Update game flow to properly handle custom practice
    integrateCustomGameFlows();
    
    // Update UI references to use CustomListsManager
    updateUIReferences();
    
    // Fix styling issues
    fixStylingIssues();
    
    // Clean up duplicate state
    cleanupDuplicateState();
    
    console.log('Custom list integration fixes applied');
}

// Run integration fixes on DOM ready
document.addEventListener('DOMContentLoaded', () => {
    // Give a small delay to ensure all components are loaded
    setTimeout(applyFinalIntegrationFixes, 100);
});

// Provide a global reset function for troubleshooting
window.resetCustomListState = function() {
    console.log('Resetting custom list state...');
    
    // Reset CustomListsManager
    CustomListsManager.lists = [];
    CustomListsManager.currentList = null;
    
    // Reset customGameState
    customGameState.reset();
    
    // Reset localStorage
    localStorage.removeItem('simploxCustomLists');
    
    // Clear UI
    const container = document.getElementById('custom-lists-container');
    if (container) {
        container.innerHTML = '<p style="color: white; text-align: center;">No custom lists created yet. Create your first list!</p>';
    }
    
    const wordList = document.getElementById('word-translation-list');
    if (wordList) {
        wordList.innerHTML = '';
    }
    
    const listNameInput = document.getElementById('custom-list-name');
    if (listNameInput) {
        listNameInput.value = '';
    }
    
    const customWordInput = document.getElementById('custom-word-input');
    if (customWordInput) {
        customWordInput.value = '';
    }
    
    console.log('Custom list state reset complete');
};

// Fix for auto-reload when switching between screens
const originalShowScreen = window.showScreen;
if (originalShowScreen) {
    window.showScreen = function(screenId, forceRefresh = false) {
        // Special handling for custom practice screen
        if (screenId === 'custom-practice-screen') {
            // Ensure CustomListsManager is initialized
            CustomListsManager.initialize().then(() => {
                // Update lists display
                updateListsDisplay();
                
                // Call original function
                originalShowScreen.call(this, screenId, forceRefresh);
            }).catch(error => {
                console.error('Failed to initialize CustomListsManager:', error);
                // Still show screen even if initialization fails
                originalShowScreen.call(this, screenId, forceRefresh);
            });
        } else {
            // Normal behavior for other screens
            originalShowScreen.call(this, screenId, forceRefresh);
        }
    };
}


// Helper to recover from corrupt list data
function recoverCorruptList(list) {
    console.warn('Attempting to recover corrupt list:', list);
    
    const recovered = {
        id: list.id || Date.now(),
        name: list.name || 'Recovered List',
        words: [],
        translations: []
    };
    
    // Try to recover words and translations
    if (Array.isArray(list.words)) {
        recovered.words = list.words.filter(word => word && typeof word === 'string');
    }
    
    if (Array.isArray(list.translations)) {
        recovered.translations = list.translations.filter(trans => trans && typeof trans === 'string');
    }
    
    // Ensure arrays are same length
    const minLength = Math.min(recovered.words.length, recovered.translations.length);
    recovered.words = recovered.words.slice(0, minLength);
    recovered.translations = recovered.translations.slice(0, minLength);
    
    console.log('List recovery result:', recovered);
    return recovered;
}

// Enhanced error handling for list operations
const ListOperationResult = {
    success: (data = null, message = 'Operation successful') => ({
        success: true,
        data,
        message
    }),
    
    error: (message = 'Operation failed', code = 'UNKNOWN_ERROR') => ({
        success: false,
        message,
        code
    })
};

// Add these methods to CustomListsManager
Object.assign(CustomListsManager, {
    validateList: validateCustomList,
    
    recoverList: recoverCorruptList,
    
    // Enhanced save with validation and error recovery
    saveWithValidation: async function(list) {
        // Validate list
        const validation = this.validateList(list);
        
        if (!validation.valid) {
            console.error('List validation failed:', validation.errors);
            return ListOperationResult.error(validation.errors.join(', '), 'VALIDATION_ERROR');
        }
        
        try {
            const result = await this.save(list);
            if (result) {
                return ListOperationResult.success(result);
            } else {
                throw new Error('Save operation returned falsy result');
            }
        } catch (error) {
            console.error('Error saving list:', error);
            return ListOperationResult.error(error.message, 'SAVE_ERROR');
        }
    },
    
    // Helper to verify all lists and recover corrupt ones
    verifyAndRepairLists: async function() {
        if (!this.lists || !Array.isArray(this.lists)) {
            this.lists = [];
            return;
        }
        
        const validatedLists = [];
        const repairedLists = [];
        
        for (const list of this.lists) {
            const validation = this.validateList(list, { 
                requireTranslations: true,
                minWords: 0 // Don't enforce min words during repair
            });
            
            if (validation.valid) {
                validatedLists.push(list);
            } else {
                console.warn(`Invalid list detected: ${list.name || 'Unnamed'}`, validation.errors);
                const repairedList = this.recoverList(list);
                repairedLists.push(repairedList);
            }
        }
        
        // Replace lists with valid ones plus repaired ones
        this.lists = [...validatedLists, ...repairedLists];
        
        // Save repaired lists
        if (currentUser) {
            for (const list of repairedLists) {
                try {
                    await this.saveToSupabase(list);
                } catch (error) {
                    console.error('Failed to save repaired list:', error);
                }
            }
        } else {
            this.saveToLocalStorage();
        }
        
        return {
            totalLists: this.lists.length,
            repaired: repairedLists.length
        };
    }
});

// Run verification on initialization
const originalInitialize = CustomListsManager.initialize;
CustomListsManager.initialize = async function() {
    await originalInitialize.call(this);
    return this.verifyAndRepairLists();
};

// Fix the handleCustomLevelCompletion function to properly handle all completion scenarios
function handleCustomLevelCompletion() {
    clearTimer();
    
    // Store completion status
    const completedPerfectly = currentGame.streakBonus && 
        currentGame.correctAnswers === currentGame.words.length;
        
    // Update custom game state
    customGameState.wordsCompleted += currentGame.words.length;
    
    if (completedPerfectly) {
        // Mark level as completed
        customGameState.completedLevels.add(customGameState.currentLevel);
        
        // Award coins
        const bonusAmount = currentGame.firstAttempt ? 5 : 3;
        CoinsManager.updateCoins(bonusAmount).then(() => {
            // Create particle effect for completion
            const questionScreen = document.getElementById('question-screen');
            if (questionScreen) {
                const rect = questionScreen.getBoundingClientRect();
                createParticles(rect.left + (rect.width / 2), rect.top + (rect.height / 2));
            }
            
            // Determine next level
            const nextLevel = customGameState.currentLevel + 1;
            const nextLevelData = customGameState.getWordsForLevel(nextLevel);
            
            // Check if there are more levels or we're done
            if (!nextLevelData || nextLevelData.isFinal || !nextLevelData.words.length) {
                // Completed all levels - show completion
                setTimeout(() => showCustomCompletionScreen(), 1500);
            } else {
                // Continue to next level
                customGameState.currentLevel = nextLevel;
                setTimeout(() => startCustomLevel(nextLevel), 1500);
            }
        });
    } else {
        // Not completed perfectly, retry the level
        setTimeout(() => startCustomLevel(customGameState.currentLevel), 1500);
    }
    
    // Always save progress
    saveProgress();
}

// Enhanced completion screen with better stats
function showCustomCompletionScreen() {
    // Calculate stats
    const coinsEarned = gameState.coins - customGameState.startCoins;
    const totalWords = customGameState.wordsCompleted;
    const correctPercent = Math.round((totalWords / (totalWords + currentGame.wrongStreak)) * 100);
    
    // Create overlay
    const overlay = document.createElement('div');
    overlay.className = 'completion-overlay victory-screen';
    
    overlay.innerHTML = `
        <div class="completion-modal-content">
            <div class="victory-header">
                <span class="rank-emoji">🎓</span>
                <h2>Practice Complete!</h2>
            </div>
            <div class="victory-message">
                <p>You've completed practicing "${customGameState.currentList?.name || 'Custom List'}"</p>
            </div>
            <div class="completion-stats">
                <div class="stat-item">
                    <i class="fas fa-book stat-icon"></i>
                    <span class="stat-label">Words</span>
                    <span class="stat-value">${totalWords}</span>
                </div>
                <div class="stat-item">
                    <i class="fas fa-coins stat-icon"></i>
                    <span class="stat-label">Coins</span>
                    <span class="stat-value">${coinsEarned}</span>
                </div>
                <div class="stat-item">
                    <i class="fas fa-check stat-icon"></i>
                    <span class="stat-label">Accuracy</span>
                    <span class="stat-value">${correctPercent}%</span>
                </div>
            </div>
            <button onclick="exitCustomPractice()" class="victory-button">
                Continue
            </button>
        </div>
    `;
    
    document.body.appendChild(overlay);
    
    // Update word stats if logged in
    if (currentUser) {
        WordsManager.updateWords(totalWords).catch(err => 
            console.error('Failed to update word stats:', err)
        );
    }
}

// Improved exit function with proper cleanup
function exitCustomPractice() {
    // Clean up game state
    customGameState.reset();
    
    // Update coins display
    CoinsManager.updateDisplays();
    
    // Hide completion overlay
    const overlay = document.querySelector('.completion-overlay');
    if (overlay) overlay.remove();
    
    // Reset any UI state
    document.querySelectorAll('.perk-button').forEach(button => {
        const disabledIcon = button.querySelector('.perk-disabled');
        if (disabledIcon) disabledIcon.remove();
        button.disabled = false;
        button.style.opacity = '1';
    });
    
    // Return to custom lists screen
    showScreen('custom-practice-screen');
}

// Add self-test function to verify integration
function testCustomListIntegration() {
    console.group('Custom Lists Integration Test');
    
    // Test 1: Check CustomListsManager exists and has required methods
    console.log('1. Testing CustomListsManager API...');
    const requiredMethods = [
        'initialize', 'loadFromSupabase', 'loadFromLocalStorage', 
        'save', 'delete', 'validateList', 'getListLimits'
    ];
    
    const missingMethods = requiredMethods.filter(method => 
        !CustomListsManager || typeof CustomListsManager[method] !== 'function'
    );
    
    if (missingMethods.length > 0) {
        console.error('❌ CustomListsManager is missing required methods:', missingMethods);
    } else {
        console.log('✓ CustomListsManager API is complete');
    }
    
    // Test 2: Check customGameState exists and has required methods
    console.log('2. Testing customGameState API...');
    const requiredGameStateMethods = [
        'reset', 'initializeFromList', 'getWordsForLevel'
    ];
    
    const missingGameStateMethods = requiredGameStateMethods.filter(method => 
        !customGameState || typeof customGameState[method] !== 'function'
    );
    
    if (missingGameStateMethods.length > 0) {
        console.error('❌ customGameState is missing required methods:', missingGameStateMethods);
    } else {
        console.log('✓ customGameState API is complete');
    }
    
    // Test 3: Check DOM elements
    console.log('3. Testing required DOM elements...');
    const requiredElements = [
        'custom-lists-container', 'custom-list-name', 
        'custom-word-input', 'word-translation-list'
    ];
    
    const missingElements = requiredElements.filter(id => !document.getElementById(id));
    
    if (missingElements.length > 0) {
        console.error('❌ Missing required DOM elements:', missingElements);
    } else {
        console.log('✓ All required DOM elements found');
    }
    
    // Test 4: Verify game flow functions
    console.log('4. Testing game flow functions...');
    const flowFunctions = [
        'startCustomListPractice', 'startCustomLevel', 
        'handleCustomLevelCompletion', 'exitCustomPractice'
    ];
    
    const missingFunctions = flowFunctions.filter(func => typeof window[func] !== 'function');
    
    if (missingFunctions.length > 0) {
        console.error('❌ Missing required game flow functions:', missingFunctions);
    } else {
        console.log('✓ All required game flow functions found');
    }
    
    console.groupEnd();
    
    return {
        customListsManager: missingMethods.length === 0,
        customGameState: missingGameStateMethods.length === 0,
        domElements: missingElements.length === 0,
        flowFunctions: missingFunctions.length === 0,
        overall: missingMethods.length === 0 && 
                missingGameStateMethods.length === 0 && 
                missingElements.length === 0 && 
                missingFunctions.length === 0
    };
}

// Run integration test on DOM ready
document.addEventListener('DOMContentLoaded', () => {
    // Give time for all scripts to load
    setTimeout(() => {
        const testResult = testCustomListIntegration();
        
        if (!testResult.overall) {
            console.warn('⚠️ Custom list integration test failed. Some functionality may not work correctly.');
        } else {
            console.log('✅ Custom list integration test passed successfully.');
        }
    }, 1000);
});

function handleWordListKeydown(e) {
    const currentItem = e.target.closest('.word-translation-item');
    if (!currentItem) return;
    
    let targetElement;
    
    switch(e.key) {
        case 'ArrowUp':
            e.preventDefault();
            targetElement = currentItem.previousElementSibling?.querySelector('.source-word');
            break;
        case 'ArrowDown':
            e.preventDefault();
            targetElement = currentItem.nextElementSibling?.querySelector('.source-word');
            break;
        case 'ArrowRight':
            e.preventDefault();
            targetElement = currentItem.querySelector('.target-word');
            break;
        case 'ArrowLeft':
            e.preventDefault();
            targetElement = currentItem.querySelector('.source-word');
            break;
        case 'Tab':
            // If Shift+Tab, we don't need to do anything special as the browser handles it
            if (!e.shiftKey && e.target.classList.contains('source-word')) {
                e.preventDefault();
                targetElement = currentItem.querySelector('.target-word');
            } else if (e.shiftKey && e.target.classList.contains('target-word')) {
                e.preventDefault();
                targetElement = currentItem.querySelector('.source-word');
            }
            break;
        case 'Enter':
            if (currentItem.nextElementSibling) {
                e.preventDefault();
                if (e.target.classList.contains('source-word')) {
                    targetElement = currentItem.nextElementSibling.querySelector('.source-word');
                } else {
                    targetElement = currentItem.nextElementSibling.querySelector('.target-word');
                }
            } else {
                // At the last item, add a new word when Enter is pressed
                e.preventDefault();
                addNewWord();
                // After adding, focus the source-word of the new item
                setTimeout(() => {
                    const items = document.querySelectorAll('.word-translation-item');
                    const lastItem = items[items.length - 1];
                    if (lastItem) {
                        targetElement = lastItem.querySelector('.source-word');
                        if (targetElement) targetElement.focus();
                    }
                }, 10);
                return;
            }
            break;
    }
    
    if (targetElement) {
        targetElement.focus();
        
        // If it's a contenteditable, place cursor at the end
        if (targetElement.getAttribute('contenteditable') === 'true') {
            const range = document.createRange();
            const selection = window.getSelection();
            range.selectNodeContents(targetElement);
            range.collapse(false); // false means collapse to end
            selection.removeAllRanges();
            selection.addRange(range);
        }
    }
}

function loadNextQuestion() {
    // Check if we've reached the end of the words
    if (currentGame.currentIndex >= currentGame.words.length) {
        // If in custom practice, route to custom completion handler
        if (currentGame.isCustomPractice) {
            handleCustomLevelCompletion();
        } else {
            // Otherwise use standard completion
            handleLevelCompletion();
        }
        return;
    }

    // Get the elements
    const questionWord = document.getElementById('question-word');
    const buttonsDiv = document.getElementById('buttons');
    
    if (!questionWord || !buttonsDiv) {
        console.error("Question UI elements not found");
        return;
    }
    
    // Clear previous question state
    buttonsDiv.innerHTML = '';
    
    // Determine question type based on game state
    const isHebrewToEnglish = currentGame.mixed ? 
        Math.random() < 0.5 : 
        currentGame.isHebrewToEnglish;
    
    // Get current word pair
    const wordIndex = currentGame.currentIndex;
    const questionText = isHebrewToEnglish ? 
        currentGame.translations[wordIndex] : 
        currentGame.words[wordIndex];
    
    // Set question word with animation
    questionWord.textContent = '';
    questionWord.classList.remove('fade-in');
    
    // Use setTimeout to trigger animation
    setTimeout(() => {
        questionWord.textContent = questionText;
        questionWord.classList.add('fade-in');
    }, 50);

    // Generate answer choices including correct answer
    const correctAnswer = isHebrewToEnglish ? 
        currentGame.words[wordIndex] : 
        currentGame.translations[wordIndex];
    
    // Create a set with the correct answer
    const choices = new Set([correctAnswer]);
    
    // Get all possible answers from the current game
    const allAnswers = isHebrewToEnglish ? 
        currentGame.words : 
        currentGame.translations;
    
    // Add random wrong answers until we have 3 choices
    while(choices.size < 3) {
        const randomIndex = Math.floor(Math.random() * allAnswers.length);
        const randomAnswer = allAnswers[randomIndex];
        
        // Only add if it's not the correct answer
        if (randomAnswer !== correctAnswer) {
            choices.add(randomAnswer);
        }
    }

    // Shuffle and create answer buttons
    Array.from(choices)
        .sort(() => Math.random() - 0.5)
        .forEach(choice => {
            const button = document.createElement('button');
            button.textContent = choice;
            button.className = 'answer-button';
            
            // Set click event based on practice type
            if (currentGame.isCustomPractice) {
                button.onclick = () => handleCustomPracticeAnswer(choice === correctAnswer);
            } else {
                button.onclick = () => handleAnswer(choice === correctAnswer);
            }
            
            buttonsDiv.appendChild(button);
        });
    
    // Reset timer for this question
    currentGame.questionStartTime = Date.now();
    
    // Update progress circle
    updateProgressCircle();
}