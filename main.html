<!DOCTYPE html>
<html lang="en" translate="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <title>Simplos</title>
    
    <!-- Fonts and Styles -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2.39.7"></script>
    <script src="vocabs.js"></script>
    <style>


:root {
  --primary-dark: #1a1a2e;
  --primary: #16213e;
  --secondary: #0f3460;
  --accent: #1E90FF;
  --text: #ffffff;
  --gold: #ffd700;
  --silver: #c0c0c0;
  --bronze: #cd7f32;
  --success: #4CAF50;
  --error: #f44336;
  --gradient: linear-gradient(135deg, var(--secondary), var(--primary-dark));
  --glass: rgba(255, 255, 255, 0.1);
  --locked: #808080;
  --royal-gradient: linear-gradient(135deg, var(--gold), var(--accent));
  --blue-gradient: linear-gradient(135deg, var(--secondary), var(--accent));
  --gold-gradient: linear-gradient(135deg, var(--gold), #ffa500);
}

* {
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  touch-action: manipulation;
}

body, html {
  overscroll-behavior-y: contain;
  overflow-x: hidden;
  max-width: 100%;
  position: relative;
}

.screen {
  transition: opacity 0.3s ease-in-out;
  opacity: 0;
}

.screen.visible {
  opacity: 1;
}

.auth-modal-content {
  background: var(--glass);
  border: 1px solid var(--accent);
}

.side-panel {
  background: linear-gradient(135deg, rgba(22, 33, 62, 0.95), rgba(15, 52, 96, 0.95));
}

.user-profile-section {
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.05), rgba(30, 144, 255, 0.05));
  border: 1px solid rgba(30, 144, 255, 0.1);
}

.status-badge.premium {
  background: var(--royal-gradient);
}

.status-badge.pending {
  background: var(--blue-gradient);
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: Montserrat, sans-serif;
}

body {
  margin: 0;
  padding: 0;
  min-height: 100vh;
  background: var(--gradient);
  color: var(--text);
  overflow-x: hidden;
}

.screen {
  display: none;
  min-height: 100vh;
  padding: 2rem;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  background: radial-gradient(circle at center, var(--secondary) 0%, var(--primary-dark) 100%);
}

.screen.visible {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.5s ease-in-out;
}

.welcome-title {
  font-size: 4rem;
  font-weight: 700;
  margin-bottom: 2rem;
  background: linear-gradient(to right, var(--gold), var(--accent));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
  animation: shimmer 2s infinite;
  font-size: 2.5rem;
  margin-bottom: 1.5rem;
}

/* Upgrade Modal */
.upgrade-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(5px);
  z-index: 1000;
}

.upgrade-form {
  width: 100%;
  max-width: 500px;
  padding: 2rem;
  background: var(--glass);
  backdrop-filter: blur(10px);
  border-radius: 20px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  text-align: right;
  direction: rtl;
}

.upgrade-form h2 {
  font-size: 1.5rem;
  font-weight: 700;
  text-align: center;
  margin-bottom: 1.5rem;
  background: linear-gradient(to right, var(--gold), var(--accent));
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
}

.form-group {
  margin-bottom: 1rem;
}

.form-group label {
  display: block;
  margin-bottom: 0.5rem;
  color: var(--text);
}

.form-group input[type="tel"],
.form-group select {
  width: 100%;
  padding: 0.75rem;
  border-radius: 25px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: var(--text);
}

.form-group input[type="checkbox"] {
  margin-right: 0.5rem;
}

.submit-button {
  width: 100%;
  padding: 1rem;
  border: 2px solid var(--accent);
  background: transparent;
  color: var(--text);
  border-radius: 25px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.3s ease;
  margin-top: 1rem;
}

.submit-button:hover {
  box-shadow: 0 0 15px var(--accent), 0 0 30px var(--accent);
}

.upgrade-form p {
  text-align: center;
  color: var(--text);
  margin-top: 1rem;
  font-size: 0.9rem;
  opacity: 0.8;
}

/* Auth Container */
.auth-container {
  position: fixed;
  top: 20%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.3);
  backdrop-filter: blur(10px);
  padding: 1rem 2rem;
  border-radius: 1rem;
  display: flex;
  gap: 1rem;
  align-items: center;
  z-index: 100;
  width: 90%;
  max-width: 320px;
}

.auth-input:focus {
  border-color: var(--accent);
}

.auth-button:hover {
  background: rgba(233, 69, 96, 0.1);
}

@keyframes pulse-glow {
  0%, 100% {
    box-shadow: 0 0 10px var(--accent), 0 0 5px var(--accent);
    transform: translate(-50%, -50%) scale(1.02);
  }
  50% {
    box-shadow: 0 0 20px var(--accent), 0 0 10px var(--accent);
    transform: translate(-50%, -50%) scale(1.05);
  }
}

.auth-container.highlight {
  animation: pulse-glow 1.5s ease-in-out infinite;
  background: rgba(233, 69, 96, 0.1);
}

.auth-toggle {
  color: rgba(255, 255, 255, 0.6);
  font-size: 0.85rem;
  background: none;
  border: none;
  cursor: pointer;
  transition: color 0.3s ease;
}

.auth-toggle:hover {
  color: var(--text);
}

.user-info {
  position: fixed;
  top: 2rem;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
  z-index: 100;
}

#userEmail {
  font-size: 1.5rem;
  color: var(--gold);
  margin-bottom: 0.5rem;
}

.student-mode {
  color: var(--text);
  font-size: 1rem;
  opacity: 0.8;
  display: block;
}

@media (max-width: 768px) {
  .auth-container {
    flex-direction: column;
    padding: 1rem;
    width: 90%;
    max-width: 320px;
  }
  .auth-input {
    width: 100%;
  }
}

.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
}

.modal-content {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: var(--glass);
  padding: 2rem;
  border-radius: 20px;
  backdrop-filter: blur(10px);
  text-align: center;
}

/* Stage, Set, Level Navigation */
.stage-selector {
  margin: 2rem 0;
  text-align: left;
  width: 100%;
}

.stage-checkboxes {
  display: flex;
  flex-wrap: wrap;
  gap: 1.5rem;
  margin: 1rem 0;
  justify-content: center;
}

.stage-checkboxes label {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  cursor: pointer;
  font-size: 1.2rem;
  padding: 1rem;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 15px;
  transition: all 0.3s ease;
}

.stage-checkboxes label:hover {
  background: rgba(255, 255, 255, 0.2);
}

.stage-checkboxes input[type="checkbox"] {
  width: 24px;
  height: 24px;
  cursor: pointer;
}

.word-goal {
  margin: 2rem 0;
  text-align: center;
}

#wordGoal {
  padding: 0.75rem;
  border-radius: 10px;
  background: rgba(255, 255, 255, 0.1);
  color: var(--text);
  border: 1px solid rgba(255, 255, 255, 0.2);
  width: 120px;
  font-size: 1.1rem;
  text-align: center;
}

.navigation-button.initialize-button {
  background: var(--accent);
  color: var(--text);
}

.navigation-button.initialize-button:hover {
  filter: brightness(1.2);
}

.upgrade-confirmation-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 2000;
}

.modal-backdrop {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
}

.confirmation-content {
  background: var(--glass);
  backdrop-filter: blur(10px);
  border-radius: 20px;
  padding: 2rem;
  text-align: center;
  max-width: 400px;
  z-index: 2001;
}

.confirmation-content h2 {
  color: var(--gold);
  margin-bottom: 1rem;
}

.continue-button {
  margin-top: 1rem;
  padding: 0.75rem 1.5rem;
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: 25px;
  cursor: pointer;
  transition: background 0.3s ease;
}

.continue-button:hover {
  background: color-mix(in srgb, var(--accent) 90%, #fff);
}

.confirmation-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.7);
  opacity: 0;
  transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
  z-index: 1001;
  pointer-events: none;
  width: 90%;
  max-width: 500px;
  background: var(--primary-dark);
  padding: 2rem;
  border-radius: 20px;
  box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
  border: 2px solid var(--accent);
  text-align: center;
}

.confirmation-popup.show {
  transform: translate(-50%, -50%) scale(1);
  opacity: 1;
  pointer-events: auto;
  animation: popupAppear 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.confirmation-popup h2 {
  color: var(--gold);
  margin-bottom: 1.5rem;
}

.confirmation-popup p {
  color: var(--text);
  margin-bottom: 2rem;
}

.confirmation-popup button {
  position: relative;
  padding: 0.875rem 2rem;
  border: 2px solid var(--accent);
  background: transparent;
  color: var(--text);
  border-radius: 50px;
  font-size: 1.1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
}

.confirmation-popup button:hover {
  box-shadow: 0 0 15px var(--accent), 0 0 30px var(--accent);
}

/* Side Panel */
.side-panel {
  position: fixed;
  top: 0;
  right: -100%;
  width: 320px;
  height: 100vh;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(10px);
  padding: 2rem 1.5rem;
  transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  z-index: 1000;
  display: flex;
  flex-direction: column;
  box-shadow: -5px 0 20px rgba(0, 0, 0, 0.3);
}

.side-panel.open {
  right: 0;
}

.side-panel .welcome-buttons {
  display: flex;
  flex-direction: column;
  margin-top: 1rem;
  gap: 0.5rem;
  align-items: stretch;
}

.side-panel .nav-link {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.875rem 1rem;
  transition: all 0.3s ease;
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
  justify-content: flex-start;
  text-align: left;
  color: var(--text);
  text-decoration: none;
  background: transparent;
  border-radius: 10px;
  cursor: pointer;
  opacity: 0.8;
}

.side-panel .nav-link:hover {
  background: rgba(255, 255, 255, 0.1);
  opacity: 1;
  transform: translateX(5px);
}

.side-panel .nav-link i {
  color: var(--gold);
  margin-right: 0.5rem;
  opacity: 0.7;
  transition: all 0.3s ease;
}

.side-panel .nav-link:hover i {
  opacity: 1;
  color: var(--accent);
}

.side-panel .nav-link:hover {
  opacity: 1;
  color: var(--gold);
  transform: translateX(10px);
}

.side-panel .nav-link i {
  min-width: 20px;
  text-align: center;
  opacity: 0.7;
}

.nav-link {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.875rem 1rem;
  transition: all 0.3s ease;
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
  justify-content: flex-start;
  text-align: left;
  color: var(--text);
  text-decoration: none;
  background: transparent;
  border-radius: 10px;
  cursor: pointer;
  opacity: 0.8;
}

.side-panel .logout-top-button {
  display: flex;
  align-items: center;
  padding: 0.875rem 1rem;
  text-align: center;
  color: var(--text);
  background: transparent;
  border-radius: 10px;
  cursor: pointer;
  opacity: 0.8;
}

.side-panel .logout-top-button i {
  min-width: 20px;
  text-align: center;
  color: #bbff10;
  opacity: 1;
}

.side-panel .logout-top-button:hover i {
  opacity: 1;
}

.side-panel-content {
  display: flex;
  flex-direction: column;
  height: 100%;
  align-items: center;
}

.user-profile-bottom {
  margin-top: auto;
  padding: 1rem;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.user-profile-section {
  margin-top: 3rem;
  text-align: center;
  padding: 1.5rem;
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
  border-radius: 15px;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.username-display {
  font-size: 1.4rem;
  color: var(--gold);
  margin-bottom: 0.5rem;
  font-weight: 600;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.status-badge {
  display: inline-block;
  padding: 0.4rem 1.2rem;
  border-radius: 50px;
  font-size: 0.9rem;
  font-weight: 500;
  margin-top: 0.5rem;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.status-badge.premium {
  background: linear-gradient(135deg, gold, orange);
  color: #000;
  box-shadow: 0 2px 10px rgba(255, 215, 0, 0.3);
}

.status-badge.pending {
  background: linear-gradient(135deg, #00bcd4, #03a9f4);
  color: #fff;
  animation: pendingPulse 2s infinite;
}

.status-badge.trial {
  background: linear-gradient(135deg, #9c27b0, #673ab7);
  color: #fff;
}

@media (max-width: 768px) {
  .side-panel {
    width: 85%;
    padding: 1.5rem 1rem;
  }
  .hamburger-button.open {
    right: 87%;
  }
  .main-buttons {
    padding: 0 1rem;
  }
}

@media (max-width: 360px) {
  .side-panel {
    width: 90%;
    padding: 1.25rem 0.75rem;
  }
}

.user-stats {
  margin-top: 2rem;
  display: flex;
  justify-content: space-around;
  padding: 1rem 0;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.stat-item {
  text-align: center;
}

.stat-value {
  font-size: 1.2rem;
  color: var(--text);
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.coin-icon {
  color: var(--gold);
}

.hamburger-button {
  position: fixed;
  top: 1rem;
  right: 1rem;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: var(--glass);
  border: 1px solid rgba(255, 255, 255, 0.1);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(10px);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  z-index: 1001;
}

.hamburger-button:hover {
  transform: scale(1.1);
  background: rgba(255, 255, 255, 0.15);
}

.hamburger-button.open {
  right: 290px;
}

.hamburger-button i {
  color: var(--text);
  font-size: 1.25rem;
  transition: transform 0.3s ease;
}

.hamburger-button.open i {
  transform: rotate(90deg);
}

.main-buttons {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1.25rem;
  width: 100%;
  max-width: 260px;
  margin: 0 auto;
}

.main-button {
  position: relative;
  padding: 0.875rem 2rem;
  background: transparent;
  color: var(--text);
  border: none;
  border-radius: 12px;
  font-size: 1rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s ease;
  width: 100%;
  overflow: hidden;
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
  backdrop-filter: blur(5px);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.main-button::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, var(--accent), #ff6b6b);
  opacity: 0;
  transition: opacity 0.3s ease;
  border-radius: inherit;
  z-index: -1;
}

.main-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 5px 15px rgba(233, 69, 96, 0.2);
}

.main-button:hover::before {
  opacity: 1;
}

@media (max-width: 768px) {
  .side-panel {
    width: 85%;
    padding: 1.5rem 1rem;
  }
  .hamburger-button.open {
    right: 87%;
  }
  .main-buttons {
    padding: 0 1rem;
  }
}

@media (max-width: 360px) {
  .side-panel {
    width: 90%;
    padding: 1.25rem 0.75rem;
  }
}

/* Auth Modal */
.auth-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s ease;
}

.auth-modal.show {
  opacity: 1;
  visibility: visible;
}

.auth-modal-content {
  background: var(--glass);
  backdrop-filter: blur(10px);
  border-radius: 20px;
  padding: 2rem;
  width: 90%;
  max-width: 400px;
  transform: scale(0.9);
  transition: transform 0.3s ease;
}

.auth-modal.show .auth-modal-content {
  transform: scale(1);
}

.auth-form {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.auth-input {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 25px;
  padding: 0.75rem 1rem;
  color: var(--text);
  width: 100%;
}

.auth-input:focus {
  outline: 0;
  border-color: var(--accent);
}

.auth-button {
  background: var(--accent);
  color: var(--text);
  border: none;
  border-radius: 25px;
  padding: 0.75rem;
  cursor: pointer;
  transition: all 0.3s ease;
}

.auth-toggle {
  background: none;
  border: none;
  color: var(--text);
  opacity: 0.7;
  cursor: pointer;
  transition: opacity 0.3s ease;
}

.auth-toggle:hover {
  opacity: 1;
}

.hidden {
  display: none;
}

/* Question Screen */
.question-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1.5rem;
  height: 100vh;
  padding: 1rem 1rem 2rem;
  min-height: 100vh;
  height: auto;
  justify-content: space-between;
  gap: 0.5rem;
  justify-content: space-between;
  padding: 1rem 1rem 2rem;
  overflow: hidden;
}

.question-word {
  font-size: 4rem;
  font-weight: 700;
  color: var(--gold);
  text-shadow: 0 2px 10px rgba(255, 215, 0, 0.3);
  animation: float 3s ease-in-out infinite;
  margin: 0;
  padding: 1rem;
}

.progress-circle {
  width: 200px;
  height: 200px;
  position: relative;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 1rem 0;
}

.progress-circle svg {
  position: absolute;
  width: 100%;
  height: 100%;
  transform: rotate(-90deg);
}

.progress-circle circle {
  fill: none;
  stroke-linecap: round;
}

.progress-circle .bg {
  stroke: rgba(255, 255, 255, 0.1);
}

.progress-circle .progress {
  stroke: var(--gold);
  transition: stroke-dashoffset 0.5s ease;
}

.progress-circle.completed {
  animation: pulseGrow 0.4s ease-in-out infinite;
}

.progress-circle.completed circle.progress {
  animation: colorShift 0.4s ease-in-out infinite;
  transition: stroke 0.3s linear;
}

@keyframes colorShift {
  0%, 100% {
    stroke: var(--gold);
    filter: brightness(1.5);
  }
  50% {
    stroke: #1E90FF;
    filter: brightness(1.2);
  }
}

.progress-circle[data-progress="low"] .progress {
  stroke: var(--gold);
}

.progress-circle[data-progress="medium"] .progress {
  stroke: #FFA500;
}

.progress-circle[data-progress="high"] .progress {
  stroke: var(--success);
}

.progress-circle[data-progress="complete"] .progress {
  stroke: #1E90FF;
}

.completion-ripple {
  position: absolute;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  border: 2px solid var(--gold);
  animation: rippleOut 1s ease-out forwards;
}

@keyframes rippleOut {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  100% {
    transform: scale(1.5);
    opacity: 0;
  }
}

@keyframes pulseGrow {
  0%, 100% {
    transform: scale(1);
    filter: brightness(1);
  }
  50% {
    transform: scale(1.05);
    filter: brightness(1.2);
  }
}

.failure-overlay .failure-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2rem;
}

.failure-overlay .restart-button {
  margin: 0 auto;
}

.failure-overlay .home-button {
  display: none;
}

.game-notification {
  position: fixed;
  top: 20px;
  left: 20px;
  padding: 1rem 2rem;
  border-radius: 10px;
  color: var(--text);
  background: var(--glass);
  backdrop-filter: blur(10px);
  z-index: 1100;
  transform: translateX(-100%);
  opacity: 0;
  transition: all 0.3s ease;
}

.game-notification.show {
  transform: translateX(0);
  opacity: 1;
}

.game-notification.success {
  border-left: 4px solid var(--success);
}

.game-notification.error {
  border-left: 4px solid var(--error);
}

/* Perks */
.perks-container {
  display: flex;
  gap: 1rem;
  margin: 1rem 0;
  background: var(--glass);
  padding: 0.75rem;
  border-radius: 25px;
  backdrop-filter: blur(10px);
}

.perk-button {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.25rem;
  padding: 0.5rem;
  border-radius: 15px;
  cursor: pointer;
  transition: all 0.3s ease;
  background: rgba(255, 255, 255, 0.1);
  border: none;
  color: var(--text);
}

.perk-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.perk-button:not(:disabled):hover {
  background: rgba(255, 255, 255, 0.2);
  transform: translateY(-2px);
}

.perk-icon {
  font-size: 1.5rem;
  color: var(--gold);
}

.perk-count {
  font-size: 0.8rem;
  font-weight: 700;
}

.timer-container {
  position: absolute;
  visibility: hidden;
  opacity: 0;
  pointer-events: none;
  height: 0;
  margin: 0;
}

.timer-value {
  font-size: 0;
  padding: 0;
}

.timer-value.warning {
  color: var(--error);
  text-shadow: 0 0 15px rgba(244, 67, 54, 0.5);
  animation: warningPulse 1s infinite;
}

.buttons {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
  max-width: 800px;
  width: 100%;
  margin: 1rem auto;
  margin-bottom: 0;
  padding: 0 1rem;
}

.buttons button {
  padding: 1rem 2rem;
  font-size: 1.2rem;
  font-weight: 600;
  color: var(--primary);
  background: var(--text);
  border: none;
  border-radius: 15px;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}

.buttons button:hover {
  transform: translateY(-5px);
  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
}

.buttons button.correct {
  background: var(--success);
  color: var(--text);
  animation: correctAnswer 0.5s ease;
}

.buttons button.wrong {
  background: var(--error);
  color: var(--text);
  animation: wrongAnswer 0.5s ease;
}

.failure-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background 1s ease;
  z-index: 1000;
}

.failure-overlay.show {
  background: rgba(0, 0, 0, 0.9);
}

.failure-content {
  text-align: center;
  transform: translateY(50px);
  opacity: 0;
  transition: all 1s ease;
}

.failure-overlay.show .failure-content {
  transform: translateY(0);
  opacity: 1;
}

.failure-title {
  font-size: 3rem;
  color: var(--error);
  margin-bottom: 2rem;
  text-shadow: 0 2px 10px rgba(244, 67, 54, 0.3);
}

.failure-buttons {
  display: flex;
  gap: 2rem;
  justify-content: center;
}

.home-button, .restart-button {
  padding: 1rem;
  width: 80px;
  height: 80px;
  font-size: 2rem;
  color: var(--text);
  background: var(--accent);
  border: none;
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 10px 20px rgba(233, 69, 96, 0.3);
}

.home-button:hover, .restart-button:hover {
  transform: translateY(-5px);
  box-shadow: 0 15px 30px rgba(233, 69, 96, 0.4);
}

.coins-container {
  position: absolute;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 2;
}

.coins-container .coin-icon {
  color: var(--gold);
  font-size: 2rem;
  filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.5));
}

.coins-container .coin-count {
  font-size: 1.2rem;
  font-weight: 700;
  color: var(--text);
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
}

.coin-pulse {
  animation: coinPulse 0.5s ease-in-out 3;
}

.skip-button {
  position: absolute;
  top: 1rem;
  left: 1rem;
  padding: 0.5rem 1rem;
  border: none;
  background: rgba(255, 255, 255, 0.1);
  color: var(--text);
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.skip-button:hover {
  background: rgba(255, 255, 255, 0.2);
}

.coins-header {
  position: fixed;
  top: 2rem;
  right: 2rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  background: var(--glass);
  padding: 0.75rem 1.5rem;
  border-radius: 25px;
  backdrop-filter: blur(10px);
  z-index: 100;
}

.user-tier {
  position: relative;
  top: 2rem;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 100;
  min-width: 200px;
  text-align: center;
  backdrop-filter: blur(10px);
  padding: 0;
  border-radius: 0;
}

.user-info {
  position: fixed;
  top: 2rem;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
  z-index: 100;
}

#userEmail {
  font-size: 1.5rem;
  color: var(--gold);
  margin-bottom: 0.5rem;
}

.tier-text {
  font-weight: 600;
  font-size: 1.1rem;
}

.tier-text.unregistered {
  color: #f44;
}

.tier-text.trial {
  color: orange;
}

.tier-text.pending {
  color: #00bfff;
  animation: pendingBlink 2s infinite;
}

.tier-text.premium {
  color: #4caf50;
}

@keyframes pendingBlink {
  0%, 100% {
    opacity: 0.7;
  }
  50% {
    opacity: 1;
  }
}

.user-tier {
  display: block;
  text-align: center;
  margin-top: 0.5rem;
}

.tier-text {
  font-weight: 600;
  font-size: 1rem;
  padding: 0.25rem 0.5rem;
  border-radius: 15px;
  background: rgba(255, 255, 255, 0.1);
}

.tier-text.unregistered {
  color: #f44;
}

.tier-text.trial {
  color: orange;
}

.tier-text.pending {
  color: #00bfff;
  animation: pendingBlink 2s infinite;
}

.tier-text.premium {
  color: #4caf50;
}

@keyframes pendingBlink {
  0%, 100% {
    opacity: 0.7;
  }
  50% {
    opacity: 1;
  }
}

/* Set and Level Screens */
.set-container,
.stage-container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 2rem;
  width: 100%;
  max-width: 1200px;
  padding: 2rem;
  z-index: 1;
}

.stage-name {
  font-size: 1.2rem;
  margin-bottom: 0.5rem;
  color: var(--text);
  text-transform: uppercase;
  letter-spacing: 1px;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.test-badge {
  background: rgba(255, 255, 255, 0.1);
  padding: 0.5rem 1rem;
  border-radius: 15px;
  margin-top: 1rem;
  font-size: 0.9rem;
  animation: pulse 2s infinite;
}

@keyframes rotate {
  from {
    transform: translate(-50%, -50%) rotate(0);
  }
  to {
    transform: translate(-50%, -50%) rotate(360deg);
  }
}

@keyframes pulse {
  0%, 100% {
    opacity: 0.6;
  }
  50% {
    opacity: 1;
  }
}

.level-announcement.test-level h1 {
  color: #4facfe;
  text-shadow: 0 0 10px rgba(79, 172, 254, 0.5);
}

.level-announcement.boss-level {
  background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%);
}

@keyframes switchDirection {
  0%, 100% {
    transform: scaleX(1);
  }
  50% {
    transform: scaleX(-1);
  }
}

.level-container {
  width: 100%;
  max-width: 1200px;
  padding: 2rem;
  display: flex;
  flex-direction: column;
  gap: 2rem;
}

.level-header {
  background: var(--glass);
  backdrop-filter: blur(10px);
  border-radius: 16px;
  padding: 1.5rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.level-title-area {
  display: flex;
  align-items: center;
  gap: 1.25rem;
}

.set-icon {
  width: 64px;
  height: 64px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.75rem;
  background: linear-gradient(135deg, var(--accent), rgba(30, 144, 255, 0.7));
  border-radius: 12px;
  box-shadow: 0 5px 15px rgba(30, 144, 255, 0.3);
}

.set-details {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.set-name {
  font-size: 1.4rem;
  font-weight: 700;
  color: var(--text);
}

.set-desc {
  opacity: 0.8;
  font-size: 0.9rem;
}

.set-progress {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.progress-bar {
  width: 150px;
  height: 6px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 3px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: var(--gold);
  border-radius: 3px;
  transition: width 0.3s ease;
}

.progress-text {
  font-size: 0.9rem;
  opacity: 0.9;
}

.level-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
  gap: 1rem;
  background: var(--glass);
  backdrop-filter: blur(10px);
  border-radius: 16px;
  padding: 1.5rem;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.level-item {
  aspect-ratio: 1;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 12px;
  font-size: 1.2rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  color: var(--text);
  overflow: hidden;
}

.level-item.unlocked {
  background: linear-gradient(135deg, var(--accent), rgba(30, 144, 255, 0.7));
  box-shadow: 0 5px 15px rgba(30, 144, 255, 0.2);
}

.level-item.completed {
  background: linear-gradient(135deg, var(--success), #45b649);
  border: 2px solid var(--gold);
  box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
}

.level-item.perfect {
  background: linear-gradient(135deg, var(--gold), orange);
  box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
}

.level-item.boss {
  background: linear-gradient(135deg, var(--gold), var(--accent));
  box-shadow: 0 0 25px rgba(255, 215, 0, 0.5);
}

.level-item.locked {
  background: rgba(128, 128, 128, 0.2);
  cursor: not-allowed;
}

.level-item.locked::before {
  content: '\f023';
  font-family: 'Font Awesome 6 Free';
  font-weight: 900;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.5rem;
  color: rgba(255, 255, 255, 0.5);
  z-index: 1;
}

.level-item.test::after {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 0 25px 25px 0;
  border-color: transparent var(--gold) transparent transparent;
}

.level-item.unlocked:hover {
  transform: translateY(-5px);
  box-shadow: 0 10px 20px rgba(30, 144, 255, 0.3);
}

.level-item.completed:hover {
  transform: translateY(-5px);
  box-shadow: 0 10px 20px rgba(76, 175, 80, 0.3);
}

.level-item.perfect:hover {
  transform: translateY(-5px);
  box-shadow: 0 10px 25px rgba(255, 215, 0, 0.5);
}

.level-type-legend {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  margin-top: 1rem;
  justify-content: center;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.9rem;
}

.legend-color {
  width: 16px;
  height: 16px;
  border-radius: 4px;
}

@media (max-width: 768px) {
  .level-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 1rem;
  }
  .set-icon {
    width: 48px;
    height: 48px;
    font-size: 1.4rem;
  }
  .set-name {
    font-size: 1.2rem;
  }
  .level-grid {
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
    gap: 0.75rem;
    padding: 1rem;
  }
  .level-item {
    font-size: 1rem;
  }
}

@media (max-width: 480px) {
  .level-container {
    padding: 1rem;
  }
  .level-grid {
    grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
    gap: 0.5rem;
  }
  .set-progress {
    flex-direction: column;
    align-items: flex-start;
  }
}

/* Stage Cascade Screen */
.stages-container {
  width: 100%;
  max-width: 800px;
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  padding: 1rem;
  margin: 0 auto;
  margin-top: 3rem;
}

.stage-wrapper {
  width: 100%;
}

.stage-wrapper .stage-button {
  width: 100%;
  padding: 1.25rem;
  border-radius: 16px;
  background: var(--glass);
  backdrop-filter: blur(10px);
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border: 1px solid rgba(255, 255, 255, 0.1);
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.stage-wrapper .stage-button::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.15) 0%, transparent 70%);
  opacity: 0;
  transition: opacity 0.3s ease;
}

.stage-wrapper .stage-button:hover::before {
  opacity: 1;
}

.stage-wrapper .stage-button:hover {
  transform: translateY(-5px);
  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
}

.stage-info {
  display: flex;
  align-items: center;
  gap: 1.25rem;
}

.stage-icon {
  width: 64px;
  height: 64px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.75rem;
  background: linear-gradient(135deg, var(--accent), rgba(30, 144, 255, 0.7));
  border-radius: 12px;
  box-shadow: 0 5px 15px rgba(30, 144, 255, 0.3);
}

.stage-text {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.stage-wrapper .stage-name {
  font-size: 1.2rem;
  font-weight: 700;
  color: var(--text);
}

.stage-desc {
  font-size: 0.9rem;
  opacity: 0.8;
}

.stage-status {
  font-size: 0.85rem;
  padding: 0.25rem 0.75rem;
  border-radius: 50px;
  background: rgba(255, 255, 255, 0.1);
}

.stage-toggle {
  font-size: 1.25rem;
  transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
}

.stage-wrapper.open .stage-toggle {
  transform: rotate(180deg);
}

.sets-container {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  background: rgba(0, 0, 0, 0.2);
  border-radius: 0 0 16px 16px;
  margin-top: 2px;
  border: 1px solid rgba(255, 255, 255, 0.05);
  border-top: none;
}

.stage-wrapper.open .sets-container {
  max-height: 800px;
}

.sets-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 1rem;
  padding: 1.5rem;
}

.sets-grid .set-button {
  aspect-ratio: 16/9;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 1rem;
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.05);
  backdrop-filter: blur(5px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  cursor: pointer;
  transition: all 0.3s ease;
  font-weight: 600;
  overflow: hidden;
}

.sets-grid .set-button.active {
  background: linear-gradient(135deg, var(--accent), rgba(30, 144, 255, 0.7));
  border: 1px solid rgba(255, 255, 255, 0.3);
  box-shadow: 0 5px 15px rgba(30, 144, 255, 0.2);
}

.sets-grid .set-button.locked {
  background: rgba(128, 128, 128, 0.2);
  cursor: not-allowed;
}

.sets-grid .set-button:not(.locked):hover {
  transform: translateY(-3px) scale(1.03);
  box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
}

.sets-grid .set-button::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, transparent 80%);
  opacity: 0;
  transition: opacity 0.3s ease;
}

.sets-grid .set-button:not(.locked):hover::before {
  opacity: 1;
}

.lock-icon {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.5rem;
  color: rgba(255, 255, 255, 0.5);
}

.completed-indicator {
  position: absolute;
  top: 0.5rem;
  right: 0.5rem;
  font-size: 0.75rem;
  color: var(--gold);
}

.stage-wrapper.closed .sets-container {
  max-height: 0;
}

.stage-wrapper.open .stage-button {
  border-radius: 16px 16px 0 0;
  transform: translateY(0);
  box-shadow: none;
}

.stage-wrapper[data-stage="1"] .stage-icon {
  background: linear-gradient(135deg, #ff416c, #ff4b2b);
}

.stage-wrapper[data-stage="2"] .stage-icon {
  background: linear-gradient(135deg, #4facfe, #00f2fe);
}

.stage-wrapper[data-stage="3"] .stage-icon {
  background: linear-gradient(135deg, #a18cd1, #fbc2eb);
}

.stage-wrapper[data-stage="4"] .stage-icon {
  background: linear-gradient(135deg, #84fab0, #8fd3f4);
}

.stage-wrapper[data-stage="5"] .stage-icon {
  background: linear-gradient(135deg, #fad0c4, #ffd1ff);
}

@media (max-width: 768px) {
  .stages-container {
    max-width: 100%;
    padding: 0.5rem;
  }
  .stage-icon {
    width: 48px;
    height: 48px;
    font-size: 1.4rem;
  }
  .stage-wrapper .stage-name {
    font-size: 1rem;
  }
  .stage-desc {
    font-size: 0.8rem;
  }
  .sets-grid {
    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    padding: 1rem;
    gap: 0.75rem;
  }
}

/* Navigation */
.navigation-container {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  margin: 1rem 0;
  background: var(--glass);
  padding: 0.75rem;
  border-radius: 25px;
  backdrop-filter: blur(10px);
  position: fixed;
  top: 1rem;
  left: 1rem;
  z-index: 100;
}

.navigation-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  padding: 0;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.1);
  border: none;
  cursor: pointer;
  transition: background-color 0.3s ease;
  box-shadow: none;
}

.navigation-button:hover {
  background: transparent !important;
  box-shadow: none !important;
  transform: none !important;
}

.navigation-button:hover svg {
  fill: var(--text) !important;
  stroke: var(--text) !important;
}

.navigation-icon {
  font-size: 1.5rem;
  color: var(--text);
}

.navigation-button.restart-level {
  color: var(--text);
  animation: none;
}

.navigation-button.restart-level:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: translateY(-2px);
}

.navigation-button.disabled {
  cursor: pointer;
  opacity: 0.3;
}

/* Common Animations */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes shimmer {
  0% {
    background-position: -200% center;
  }
  100% {
    background-position: 200% center;
  }
}

@keyframes shine {
  to {
    transform: rotate(45deg) translate(100%, 100%);
  }
}

@keyframes pulse {
  0% {
    box-shadow: 0 0 30px var(--gold);
  }
  50% {
    box-shadow: 0 0 50px var(--gold);
  }
  100% {
    box-shadow: 0 0 30px var(--gold);
  }
}

@keyframes float {
  0% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-10px);
  }
  100% {
    transform: translateY(0);
  }
}

@keyframes correctAnswer {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.1);
  }
  100% {
    transform: scale(1);
  }
}

@keyframes wrongAnswer {
  0%, 100% {
    transform: translateX(0);
  }
  20%, 60% {
    transform: translateX(-5px);
  }
  40%, 80% {
    transform: translateX(5px);
  }
}

@keyframes unlockSet {
  0% {
    transform: scale(1);
    background: var(--locked);
  }
  50% {
    transform: scale(1.1);
    background: var(--gold);
    box-shadow: 0 0 50px var(--gold);
  }
  100% {
    transform: scale(1);
    background: linear-gradient(135deg, var(--gold), orange);
  }
}

@keyframes unlockLevel {
  0% {
    transform: scale(1);
    background: var(--locked);
  }
  50% {
    transform: scale(1.1);
    background: var(--accent);
    box-shadow: 0 0 50px var(--accent);
  }
  100% {
    transform: scale(1);
    background: linear-gradient(135deg, var(--accent), #1e90ff);
  }
}

@keyframes progressPulsate {
  0% {
    transform: scale(1);
    filter: brightness(1);
  }
  50% {
    transform: scale(1.1);
    filter: brightness(1.5);
  }
  100% {
    transform: scale(1);
    filter: brightness(1);
  }
}

@keyframes warningPulse {
  0% {
    opacity: 1;
    transform: scale(1);
  }
  50% {
    opacity: 0.8;
    transform: scale(1.05);
  }
  100% {
    opacity: 1;
    transform: scale(1);
  }
}

@keyframes coinPulse {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.2);
    filter: drop-shadow(0 0 20px var(--gold));
  }
  100% {
    transform: scale(1);
  }
}

/* Responsive Adjustments */
@media (max-width: 768px) {
  .question-screen {
    padding-top: 2rem;
    gap: 1rem;
  }
  .welcome-title {
    font-size: 3rem;
  }
  .stage-container {
    grid-template-columns: repeat(2, 1fr);
    padding: 1rem;
    gap: 1rem;
  }
  .set-container {
    grid-template-columns: repeat(3, 1fr);
    gap: 0.75rem;
    padding: 0.75rem;
  }
  .level {
    max-width: none;
    aspect-ratio: 1;
    font-size: 1.5rem;
  }
  .question-word {
    font-size: 2.5rem;
    margin: 0.5rem 0;
  }
  .progress-circle {
    width: 150px;
    height: 150px;
    margin: 0.5rem 0;
  }
  .progress-circle .timer-progress.warning {
    stroke: #f44336;
    filter: drop-shadow(0 0 5px rgba(244, 67, 54, 0.5));
    transition: stroke 0.3s ease, stroke-dashoffset 1s linear;
  }
  .timer-value {
    font-size: 2.5rem;
  }
  .buttons {
    grid-template-columns: 1fr;
    gap: 0.75rem;
  }
  .buttons button {
    min-height: 3.5rem;
    font-size: 1rem;
    padding: 0.75rem;
    line-height: 1.2;
  }
  .coins-header {
    top: 1rem;
    right: 1rem;
    padding: 0.5rem 1rem;
  }
  .perks-container {
    padding: 0.5rem;
    gap: 0.5rem;
    margin: 0.5rem 0;
  }
  .perk-button {
    padding: 0.35rem;
  }
  .perk-icon {
    font-size: 1.2rem;
  }
  .perk-count {
    font-size: 0.7rem;
  }
}

@media (max-width: 480px) {
  .welcome-title {
    font-size: 2.5rem;
    text-align: center;
    padding: 0 1rem;
  }
  .stage-container {
    grid-template-columns: 1fr;
  }
  .set-container {
    grid-template-columns: repeat(2, 1fr);
  }
  .question-word {
    font-size: 2rem;
  }
  .progress-circle {
    width: 120px;
    height: 120px;
    margin: 0.5rem 0;
  }
  .timer-value {
    font-size: 2rem;
  }
}

@supports (padding: max(0px)) {
  .screen {
    padding-left: max(2rem, env(safe-area-inset-left));
    padding-right: max(2rem, env(safe-area-inset-right));
    padding-bottom: max(2rem, env(safe-area-inset-bottom));
  }
}

/* Stage Colors */
.stage-1 {
  background: linear-gradient(135deg, var(--stage1-primary), var(--stage1-secondary));
}
.stage-1 .set-button.active,
.stage-1 .stage-button {
  background: var(--stage1-accent);
}

.stage-2 {
  background: linear-gradient(135deg, var(--stage2-primary), var(--stage2-secondary));
}
.stage-2 .set-button.active,
.stage-2 .stage-button {
  background: var(--stage2-accent);
}

.stage-3 {
  background: linear-gradient(135deg, var(--stage3-primary), var(--stage3-secondary));
}
.stage-3 .set-button.active,
.stage-3 .stage-button {
  background: var(--stage3-accent);
}

.stage-4 {
  background: linear-gradient(135deg, var(--stage4-primary), var(--stage4-secondary));
}
.stage-4 .set-button.active,
.stage-4 .stage-button {
  background: var(--stage4-accent);
}

.stage-5 {
  background: linear-gradient(135deg, var(--stage5-primary), var(--stage5-secondary));
}
.stage-5 .set-button.active,
.stage-5 .stage-button {
  background: var(--stage5-accent);
}

/* Safari padding */
.screen {
  padding-left: max(2rem, env(safe-area-inset-left));
  padding-right: max(2rem, env(safe-area-inset-right));
  padding-bottom: max(2rem, env(safe-area-inset-bottom));
}

/* Accessibility Options */
.accessibility-toggle {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: var(--primary);
  border: 2px solid var(--accent);
  color: var(--text);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 9999;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
  transition: all 0.3s ease;
}

.accessibility-toggle:hover {
  transform: scale(1.1);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
}

.accessibility-toggle i {
  font-size: 24px;
}

.accessibility-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(5px);
  z-index: 10000;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s ease;
}

.accessibility-modal.show {
  opacity: 1;
  visibility: visible;
}

.accessibility-content {
  width: 90%;
  max-width: 600px;
  max-height: 90vh;
  overflow-y: auto;
  background: var(--primary-dark);
  border-radius: 20px;
  padding: 2rem;
  color: var(--text);
  border: 1px solid var(--accent);
}

.accessibility-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.accessibility-header h2 {
  margin: 0;
  color: var(--gold);
  font-size: 1.8rem;
}

.close-accessibility {
  background: none;
  border: none;
  color: var(--text);
  font-size: 1.5rem;
  cursor: pointer;
  opacity: 0.8;
  transition: opacity 0.3s ease;
}

.close-accessibility:hover {
  opacity: 1;
}

.accessibility-options {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.accessibility-section {
  margin-bottom: 1rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.accessibility-section h3 {
  margin-top: 0;
  margin-bottom: 1rem;
  color: var(--accent);
  font-size: 1.3rem;
}

.option-group {
  margin-bottom: 1rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.option-group label {
  font-size: 1rem;
  color: var(--text);
  opacity: 0.9;
}

.controls {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.accessibility-button {
  padding: 0.5rem 1rem;
  border-radius: 8px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: var(--text);
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 0.9rem;
}

.accessibility-button:hover {
  background: rgba(255, 255, 255, 0.2);
}

.accessibility-button.active {
  background: var(--accent);
  border-color: var(--accent);
  color: var(--primary-dark);
  box-shadow: 0 0 10px rgba(30, 144, 255, 0.5);
}

.accessibility-footer {
  margin-top: 1.5rem;
  padding-top: 1rem;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
  text-align: center;
}

.reset-all {
  width: 100%;
  padding: 0.75rem !important;
  background: rgba(244, 67, 54, 0.2) !important;
  border: 1px solid rgba(244, 67, 54, 0.4) !important;
  color: #f44336 !important;
}

.reset-all:hover {
  background: rgba(244, 67, 54, 0.3) !important;
}

/* Accessibility classes */
body.high-contrast {
  --primary-dark: #000000;
  --primary: #000000;
  --secondary: #000000;
  --text: #ffffff;
  --accent: #ffff00;
}

body.inverted-colors {
  filter: invert(1) hue-rotate(180deg);
}

body.grayscale {
  filter: grayscale(1);
}

body.large-font {
  --font-scale: 1.2;
  font-size: calc(1rem * var(--font-scale));
}

body.larger-font {
  --font-scale: 1.4;
  font-size: calc(1rem * var(--font-scale));
}

body.largest-font {
  --font-scale: 1.6;
  font-size: calc(1rem * var(--font-scale));
}

body.dyslexic-font {
  font-family: OpenDyslexic, 'Comic Sans MS', sans-serif;
}

body.increased-letter-spacing {
  letter-spacing: 0.1em;
}

body.no-animations * {
  animation: none !important;
  transition: none !important;
}

body.reduced-animations * {
  animation-duration: 1ms !important;
  transition-duration: 1ms !important;
}

body.high-focus :focus {
  outline: 3px solid var(--accent) !important;
  outline-offset: 3px !important;
  box-shadow: 0 0 0 3px var(--accent) !important;
}

body.large-buttons .main-button,
body.large-buttons .nav-link,
body.large-buttons button,
body.large-buttons input[type="submit"] {
  padding: calc(0.75rem * 1.3) calc(1.5rem * 1.3) !important;
  font-size: calc(1rem * 1.3) !important;
  min-height: 44px !important;
}

body.large-cursor,
body.large-cursor * {
  cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'%3E%3Ccircle cx='16' cy='16' r='15' fill='white' stroke='black' stroke-width='2'/%3E%3C/svg%3E") 16 16, auto !important;
}

body.light-theme {
  --primary-dark: #ffffff;
  --primary: #f5f5f5;
  --secondary: #e0e0e0;
  --text: #333333;
  --accent: #1E90FF;
  --gradient: linear-gradient(135deg, #f5f5f5, #e0e0e0);
}

body.dark-theme {
  --primary-dark: #1a1a2e;
  --primary: #16213e;
  --secondary: #0f3460;
  --text: #ffffff;
  --accent: #1E90FF;
  --gradient: linear-gradient(135deg, var(--secondary), var(--primary-dark));
}

@font-face {
  font-family: OpenDyslexic;
  src: url('https://cdn.jsdelivr.net/npm/open-dyslexic@1.0.3/woff/OpenDyslexic-Regular.woff') format('woff');
  font-weight: 400;
  font-style: normal;
}

@media (max-width: 768px) {
  .accessibility-content {
    width: 95%;
    padding: 1.5rem;
  }
  .accessibility-toggle {
    bottom: 15px;
    right: 15px;
    width: 45px;
    height: 45px;
  }
  .accessibility-button {
    padding: 0.5rem 0.75rem;
    font-size: 0.85rem;
  }
}

/* Premium Celebration */
.premium-celebration {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, rgba(26, 26, 46, 0.95), rgba(22, 33, 62, 0.95));
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 2000;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.5s ease;
}

.premium-celebration.show {
  opacity: 1;
  pointer-events: auto;
}

.celebration-content {
  text-align: center;
  transform: translateY(30px);
  transition: transform 0.5s ease;
}

.premium-celebration.show .celebration-content {
  transform: translateY(0);
}

.celebration-title {
  font-size: 3rem;
  color: var(--gold);
  margin-bottom: 2rem;
  text-shadow: 0 2px 10px rgba(255, 215, 0, 0.3);
}

.celebration-message {
  font-size: 1.5rem;
  color: var(--text);
  margin-bottom: 2rem;
  line-height: 1.5;
}

.celebration-button {
  padding: 1rem 2rem;
  font-size: 1.2rem;
  background: var(--gold);
  color: var(--primary-dark);
  border: none;
  border-radius: 50px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.celebration-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 5px 15px rgba(255, 215, 0, 0.3);
}

/* Level Intro */
.slide-transition {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 9999;
  pointer-events: none;
  display: flex;
  justify-content: center;
  align-items: center;
  background: transparent;
}

.slide-panel-left, .slide-panel-right {
  position: absolute;
  width: 50%;
  height: 100%;
  background: linear-gradient(135deg, var(--primary-dark), var(--secondary));
  transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.slide-panel-left {
  left: 0;
  transform: translateX(-100%);
  border-right: 2px solid var(--gold);
}

.slide-panel-right {
  right: 0;
  transform: translateX(100%);
  border-left: 2px solid var(--gold);
}

.slide-transition.show .slide-panel-left {
  transform: translateX(0);
  box-shadow: 5px 0 15px rgba(0, 0, 0, 0.3);
}

.slide-transition.show .slide-panel-right {
  transform: translateX(0);
  box-shadow: -5px 0 15px rgba(0, 0, 0, 0.3);
}

.level-announcement {
  position: absolute;
  z-index: 10000;
  color: var(--text);
  text-align: center;
  opacity: 0;
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  transform: scale(0.9);
  background: rgba(0, 0, 0, 0.3);
  padding: 2rem 3rem;
  border-radius: 20px;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
}

.level-announcement.show {
  opacity: 1;
  transform: scale(1);
}

.level-announcement h1 {
  font-size: 2.5rem;
  background: linear-gradient(to right, var(--gold), orange);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  margin-bottom: 1rem;
  position: relative;
  text-transform: uppercase;
  letter-spacing: 2px;
  font-weight: 700;
}

.level-announcement h1::after {
  content: '';
  position: absolute;
  bottom: -5px;
  left: 50%;
  transform: translateX(-50%);
  width: 50px;
  height: 2px;
  background: var(--gold);
  box-shadow: 0 0 10px var(--gold);
}

.level-announcement h2 {
  font-size: 2rem;
  color: var(--text);
  font-weight: 500;
  opacity: 0.9;
  letter-spacing: 1px;
}

.slide-panel-left::after, .slide-panel-right::after {
  content: '';
  position: absolute;
  top: 0;
  width: 2px;
  height: 100%;
  background: linear-gradient(to bottom, transparent, var(--gold), transparent);
  opacity: 0.5;
}

.slide-panel-left::after {
  right: 0;
}

.slide-panel-right::after {
  left: 0;
}

.level-announcement::before {
  content: '';
  position: absolute;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  width: 80%;
  height: 1px;
  background: linear-gradient(to right, transparent, var(--gold), transparent);
  animation: lineWidth 2s ease-in-out infinite;
}

@keyframes lineWidth {
  0%, 100% {
    width: 60%;
    opacity: 0.3;
  }
  50% {
    width: 80%;
    opacity: 0.7;
  }
}

</style>
</head>
<body>

    <!DOCTYPE html>
    <html lang="en" translate="no">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <meta name="google" content="notranslate">
        <title>Simplos</title>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600;700&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
        <script src="https://unpkg.com/@supabase/supabase-js@2.39.7"></script>
        <script src="vocabs.js"></script>
    </head>
    <body>
        <div id="welcome-screen" class="screen visible">
            <div class="particle-container" id="particleContainer"></div>
            <h1 class="welcome-title">Simplos</h1>
            <div class="main-buttons">
                <button class="main-button primary" onclick="showAuthModal()">Login / Sign Up</button>
                <button class="main-button guest-play-button" onclick="startGame()">Play as Guest</button>
                <button class="main-button stages-button" onclick="showStageCascadeScreen()">Stages</button>
                <button class="main-button" disabled="disabled">Download the App</button>
            </div>
    
            <div id="authModal" class="auth-modal">
                <div class="auth-modal-content">
                    <div id="loginForm" class="auth-form">
                        <h2>Login</h2>
                        <input type="text" class="auth-input" placeholder="Username or Email" id="loginUsername">
                        <input type="password" class="auth-input" placeholder="Password" id="loginPassword">
                        <button class="auth-button" onclick="handleLogin()">Login</button>
                        <button class="auth-toggle" onclick="toggleAuthMode()">New? Register here</button>
                    </div>
                    <div id="signupForm" class="auth-form hidden">
                        <h2>Sign Up</h2>
                        <input type="email" class="auth-input" placeholder="Email" id="signupEmail">
                        <input type="text" class="auth-input" placeholder="Username" id="signupUsername">
                        <input type="password" class="auth-input" placeholder="Password" id="signupPassword">
                        <button class="auth-button" onclick="handleSignup()">Sign Up</button>
                        <button class="auth-toggle" onclick="toggleAuthMode()">Already have an account?</button>
                    </div>
                </div>
            </div>
    
            <button class="hamburger-button" onclick="toggleSidePanel()">
                <i class="fas fa-bars"></i>
            </button>
    
            <div class="side-panel">
                <div class="side-panel-content">
                    <button class="logout-button logout-top-button">
                        <i class="fas fa-sign-out-alt"></i> Logout
                    </button>
                    <div class="welcome-buttons">
                        <a href="#" class="nav-link" onclick='return showScreen("stage-screen"),!1'>
                            <i class="fas fa-map-marked-alt"></i> Level Map
                        </a>
                        <a href="#" class="nav-link" onclick="return showLeaderboard(),!1">
                            <i class="fas fa-trophy"></i> Speedboard
                        </a>
                        <a href="#" class="nav-link" onclick="return showPricesScreen(),!1">
                            <i class="fas fa-dollar-sign"></i> Prices
                        </a>
                        <a href="#" class="nav-link" onclick="return showRightsAndPolicies(),!1">
                            <i class="fas fa-balance-scale"></i> Rights & Policies
                        </a>
                        <a href="#" class="nav-link" onclick="return showAboutPage(),!1">
                            <i class="fas fa-info-circle"></i> About
                        </a>
                        <a href="#" class="nav-link" onclick="return showContactUs(),!1">
                            <i class="fas fa-envelope"></i> Contact Us
                        </a>
                    </div>
                    <div class="user-profile-section user-profile-bottom">
                        <div class="username-display" id="userEmail"></div>
                        <div class="status-badge" id="userTierText"></div>
                        <div class="user-stats">
                            <div class="stat-item">
                                <div class="stat-label">Words</div>
                                <div class="stat-value" id="totalWords">0</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Coins</div>
                                <div class="stat-value"><i class="fas fa-coins coin-icon"></i> <span id="totalCoins">0</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    
        <div id="stage-cascade-screen" class="screen">
            <div class="particle-container"></div>
            <div class="navigation-container" style="position:fixed;top:1rem;left:50%;transform:translateX(-50%);flex-direction:row;gap:.75rem;background:0 0;margin:0">
                <button class="navigation-button home-button" onclick="navigateHome()">
                    <i class="fas fa-home navigation-icon"></i>
                </button>
                <button class="navigation-button reset-button" onclick="handleResetProgress()">
                    <i class="fas fa-trash-alt navigation-icon"></i>
                </button>
                <button class="navigation-button fullscreen-button" onclick="toggleFullScreen()">
                    <i class="fas fa-expand navigation-icon"></i>
                </button>
            </div>
            <div class="stages-container"></div>
        </div>
    
        <div id="level-screen" class="screen">
            <div class="particle-container"></div>
            <div class="navigation-container">
                <button class="navigation-button home-button" onclick='showScreen("stage-cascade-screen")'>
                    <i class="fas fa-arrow-left navigation-icon"></i>
                </button>
                <button class="navigation-button fullscreen-button" onclick="toggleFullScreen()">
                    <i class="fas fa-expand navigation-icon"></i>
                </button>
            </div>
            <div class="level-container" id="level-container"></div>
        </div>
    
        <div id="question-screen" class="screen">
            <div class="particle-container"></div>
            <div class="navigation-container">
                <button class="navigation-button home-button" onclick='showScreen("welcome-screen")'>
                    <i class="fas fa-home navigation-icon"></i>
                </button>
            </div>
            <div class="question-word" id="question-word"></div>
            <div class="progress-circle">
                <svg width="100%" height="100%" viewBox="0 0 120 120">
                    <circle class="bg" cx="60" cy="60" r="54" stroke-width="8"/>
                    <circle class="progress" cx="60" cy="60" r="54" stroke-width="8"/>
                    <circle class="timer-bg" cx="60" cy="60" r="40" stroke-width="4"/>
                    <circle class="timer-progress" cx="60" cy="60" r="40" stroke-width="4"/>
                </svg>
                <div class="coins-container">
                    <i class="fas fa-coins coin-icon"></i>
                    <span class="coin-count">0</span>
                </div>
            </div>
            <div class="perks-container">
                <button class="perk-button" id="timeFreezePerk">
                    <i class="fas fa-clock perk-icon"></i>
                    <span class="perk-count">0</span>
                </button>
                <button class="perk-button" id="skipPerk">
                    <i class="fas fa-forward perk-icon"></i>
                    <span class="perk-count">0</span>
                </button>
                <button class="perk-button" id="cluePerk">
                    <i class="fas fa-lightbulb perk-icon"></i>
                    <span class="perk-count">0</span>
                </button>
                <button class="perk-button" id="revealPerk">
                    <i class="fas fa-eye perk-icon"></i>
                    <span class="perk-count">0</span>
                </button>
            </div>
            <div class="timer-container">
                <div class="timer-value">00:00</div>
            </div>
            <div class="buttons" id="buttons"></div>
        </div>
    
        <div class="failure-overlay" style="display:none">
            <div class="failure-content">
                <h2 class="failure-title">Time's Up!</h2>
                <div class="failure-buttons">
                    <button class="restart-button"><i class="fas fa-redo"></i></button>
                    <button class="home-button"><i class="fas fa-home"></i></button>
                </div>
            </div>
        </div>
    
        <div id="upgrade-screen" class="screen">
            <div class="upgrade-modal">
                <div class="upgrade-form">
                    <h2>שדרוג לפרימיום</h2>
                    <form id="upgradeForm" onsubmit="handleUpgradeSubmit(event)">
                        <div class="form-group">
                            <label><input type="checkbox" id="isAdult" onchange="toggleParentFields()" name="isAdult"> אני מעל גיל 18</label>
                        </div>
                        <div id="parentInfoSection">
                            <div class="form-group">
                                <label>שם מלא של הורה</label>
                                <input type="text" id="parentName" name="parentName">
                            </div>
                            <div class="form-group">
                                <label>מספר טלפון של הורה</label>
                                <input type="tel" id="parentPhone" name="parentPhone" pattern="[0-9]{10}" placeholder="הזן מספר טלפון של הורה">
                            </div>
                        </div>
                        <div id="adultInfoSection" style="display:none">
                            <div class="form-group">
                                <label>שם מלא</label>
                                <input type="text" id="fullName" name="fullName">
                            </div>
                            <div class="form-group">
                                <label>מספר טלפון</label>
                                <input type="tel" id="phone" name="phone" pattern="[0-9]{10}" placeholder="הזן מספר טלפון">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>איך שמעת עלינו?</label>
                            <select id="referralSource" name="referralSource">
                                <option value="friend">חבר/ה</option>
                                <option value="teacher">מורה</option>
                                <option value="social">רשתות חברתיות</option>
                                <option value="other">אחר</option>
                            </select>
                        </div>
                        <button type="submit" class="submit-button">שלח/י בקשה</button>
                        <button type="button" class="skip-button" onclick="skipUpgrade()">דלג</button>
                    </form>
                    <p>לאחר שליחת הבקשה ניצור איתך קשר בווטסאפ</p>
                </div>
            </div>
        </div>
    
        <div id="leaderboard-screen" class="screen">
            <div class="navigation-container">
                <button class="navigation-button home-button" onclick='showScreen("welcome-screen")'>
                    <i class="fas fa-home navigation-icon"></i>
                </button>
            </div>
            <h1 class="welcome-title">Speedboard</h1>
            <div class="leaderboard-header">
                <div>Rank</div>
                <div>Player</div>
                <div>Status</div>
            </div>
            <div id="leaderboard-entries"></div>
        </div>
    
        <button class="accessibility-toggle" aria-label="Open accessibility menu">
            <i class="fas fa-universal-access"></i>
        </button>
        <div class="accessibility-modal">
            <div class="accessibility-content">
                <div class="accessibility-header">
                    <h2>Accessibility Options</h2>
                    <button class="close-accessibility" aria-label="Close accessibility menu">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="accessibility-options">
                    <div class="accessibility-section">
                        <h3>Display</h3>
                        <div class="option-group">
                            <label for="contrast-setting">Contrast</label>
                            <div class="controls">
                                <button class="accessibility-button" data-action="contrast" data-value="normal">Normal</button>
                                <button class="accessibility-button" data-action="contrast" data-value="high">High</button>
                                <button class="accessibility-button" data-action="contrast" data-value="inverted">Inverted</button>
                            </div>
                        </div>
                        <div class="option-group">
                            <label>Theme</label>
                            <div class="controls">
                                <button class="accessibility-button" data-action="theme" data-value="default">Default</button>
                                <button class="accessibility-button" data-action="theme" data-value="light">Light</button>
                                <button class="accessibility-button" data-action="theme" data-value="dark">Dark</button>
                            </div>
                        </div>
                        <div class="option-group">
                            <label>Saturation</label>
                            <div class="controls">
                                <button class="accessibility-button" data-action="saturation" data-value="normal">Normal</button>
                                <button class="accessibility-button" data-action="saturation" data-value="grayscale">Grayscale</button>
                            </div>
                        </div>
                    </div>
                    <div class="accessibility-section">
                        <h3>Text</h3>
                        <div class="option-group">
                            <label>Font Size</label>
                            <div class="controls">
                                <button class="accessibility-button" data-action="fontSize" data-value="decrease"><i class="fas fa-minus"></i></button>
                                <button class="accessibility-button" data-action="fontSize" data-value="reset">Reset</button>
                                <button class="accessibility-button" data-action="fontSize" data-value="increase"><i class="fas fa-plus"></i></button>
                            </div>
                        </div>
                        <div class="option-group">
                            <label>Font Type</label>
                            <div class="controls">
                                <button class="accessibility-button" data-action="fontFamily" data-value="default">Default</button>
                                <button class="accessibility-button" data-action="fontFamily" data-value="dyslexic">Dyslexia Friendly</button>
                            </div>
                        </div>
                        <div class="option-group">
                            <label>Letter Spacing</label>
                            <div class="controls">
                                <button class="accessibility-button" data-action="letterSpacing" data-value="normal">Normal</button>
                                <button class="accessibility-button" data-action="letterSpacing" data-value="increased">Increased</button>
                            </div>
                        </div>
                    </div>
                    <div class="accessibility-section">
                        <h3>Motion & Navigation</h3>
                        <div class="option-group">
                            <label>Animations</label>
                            <div class="controls">
                                <button class="accessibility-button" data-action="animations" data-value="enabled">Enabled</button>
                                <button class="accessibility-button" data-action="animations" data-value="reduced">Reduced</button>
                                <button class="accessibility-button" data-action="animations" data-value="disabled">Disabled</button>
                            </div>
                        </div>
                        <div class="option-group">
                            <label>Focus Indicator</label>
                            <div class="controls">
                                <button class="accessibility-button" data-action="focus" data-value="normal">Normal</button>
                                <button class="accessibility-button" data-action="focus" data-value="high">Enhanced</button>
                            </div>
                        </div>
                    </div>
                    <div class="accessibility-section">
                        <h3>Interface</h3>
                        <div class="option-group">
                            <label>Button Size</label>
                            <div class="controls">
                                <button class="accessibility-button" data-action="buttonSize" data-value="normal">Normal</button>
                                <button class="accessibility-button" data-action="buttonSize" data-value="large">Large</button>
                            </div>
                        </div>
                        <div class="option-group">
                            <label>Cursor Size</label>
                            <div class="controls">
                                <button class="accessibility-button" data-action="cursorSize" data-value="normal">Normal</button>
                                <button class="accessibility-button" data-action="cursorSize" data-value="large">Large</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="accessibility-footer">
                    <button class="accessibility-button reset-all" data-action="reset" data-value="all">Reset All Settings</button>
                </div>
            </div>
        </div>

<script>

// part 1

// Game structure definition
const gameStructure = {
  stages: [
    { id: 1, numSets: 9, levelsPerSet: 21, bossLevel: 21 },
    { id: 2, numSets: 10, levelsPerSet: 21, bossLevel: 21 },
    { id: 3, numSets: 12, levelsPerSet: 21, bossLevel: 21 },
    { id: 4, numSets: 30, levelsPerSet: 21, bossLevel: 21 },
    { id: 5, numSets: 14, levelsPerSet: 21, bossLevel: 21 }
  ],
  levelTypes: {
    normal: "normal",
    boss: "boss"
  }
};

// Game state object
const gameState = {
  currentStage: null,
  currentSet: null,
  currentLevel: null,
  unlockedSets: {},
  unlockedLevels: {},
  levelScores: {},
  completedLevels: new Set,
  perfectLevels: new Set,
  coins: 0
};

// Perk configuration
const PERK_CONFIG = {
  timeFreeze: {
    name: "Time Freeze",
    description: "Pause the timer for 5 seconds",
    cost: 15,
    icon: "fa-clock",
    duration: 5000
  },
  skip: {
    name: "Skip Question",
    description: "Skip the current word without penalty",
    cost: 1,
    icon: "fa-forward"
  },
  clue: {
    name: "Eliminate Wrong Answer",
    description: "Remove one incorrect answer",
    cost: 35,
    icon: "fa-lightbulb"
  },
  reveal: {
    name: "Reveal Correct Answer",
    description: "Show the correct translation",
    cost: 50,
    icon: "fa-eye"
  }
};

// Current game state
let currentGame = {
  words: [],
  translations: [],
  currentIndex: 0,
  correctAnswers: 0,
  firstAttempt: true,
  isHebrewToEnglish: false,
  mixed: false,
  speedChallenge: false,
  startTime: 0,
  levelStartTime: 0,
  timeBonus: 0,
  streakBonus: true,
  questionStartTime: 0,
  wrongStreak: 0,
  progressLost: 0
};

// Timer variables
let timer = null;
let timeRemaining = 0;
let isFrozen = false;
let resetProgressTimeout = null;
let isFirstResetAttempt = true;

// Initialize Supabase client
const { createClient } = supabase;
const supabaseClient = createClient(
  "https://mczfgzffyyyacisrccqb.supabase.co",
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1jemZnemZmeXl5YWNpc3JjY3FiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzgzODYyMDQsImV4cCI6MjA1Mzk2MjIwNH0.rLga_B29Coz1LMeJzFTGLIhckdcojGXnD1ae1bw-QAI",
  {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true
  }
);

// Particle system for visual effects
const ParticleSystem = {
  particlePool: [],
  maxParticles: 20,
  
  init() {
    for (let i = 0; i < this.maxParticles; i++) {
      const particle = document.createElement('div');
      particle.className = "particle mobile-particle";
      this.particlePool.push(particle);
    }
  },

  createParticle(x, y) {
    if (window.innerWidth <= 768) return; // Skip on mobile
    
    const particle = this.particlePool.pop();
    if (particle) {
      particle.style.left = `${x}px`;
      particle.style.top = `${y}px`;
      setTimeout(() => {
        this.particlePool.push(particle);
      }, 500);
    }
  }
};

// Update UI function
function updateUI() {
  requestAnimationFrame(() => {
    const fragment = document.createDocumentFragment();
    document.body.appendChild(fragment);
  });
}

// Event listeners
document.addEventListener('click', (e) => {
  const target = e.target;
  if (target.matches('.game-btn')) {
    handleButtonClick(target);
  } else if (target.matches('.level')) {
    handleLevelClick(target);
  }
});

// Coins Manager
const CoinsManager = {
  displayElements: new Set(),
  
  initialize() {
    this.displayElements.clear();
    document.querySelectorAll('.coin-count').forEach(element => {
      this.displayElements.add(element);
    });
  },
  
  async loadUserCoins() {
    if (!currentUser) {
      return parseInt(localStorage.getItem('simploxCustomCoins') || '0');
    }
    
    try {
      const { data, error } = await supabaseClient
        .from('game_progress')
        .select('coins')
        .eq('user_id', currentUser.id)
        .single();
        
      if (error) throw error;
      return data.coins || 0;
    } catch (error) {
      console.error('Error loading coins:', error);
      return 0;
    }
  },
  
  async updateCoins(amount) {
    try {
      const oldCoins = gameState.coins;
      const newCoins = oldCoins + amount;
      
      gameState.coins = newCoins;
      
      this.displayElements.forEach(element => {
        let currentValue = oldCoins;
        const startTime = performance.now();
        
        requestAnimationFrame(function updateValue(timestamp) {
          const elapsed = timestamp - startTime;
          const progress = Math.min(elapsed / 1000, 1);
          
          currentValue = oldCoins + (newCoins - oldCoins) * progress;
          element.textContent = Math.round(currentValue);
          
          if (amount > 0) {
            element.style.color = "var(--success)";
          } else if (amount < 0) {
            element.style.color = "var(--error)";
          }
          
          if (progress < 1) {
            requestAnimationFrame(updateValue);
          } else {
            element.textContent = newCoins;
            setTimeout(() => {
              element.style.color = "var(--text)";
            }, 300);
          }
        });
      });
      
      if (currentUser) {
        const { error } = await supabaseClient
          .from('game_progress')
          .update({ coins: newCoins })
          .eq('user_id', currentUser.id);
          
        if (error) throw error;
      } else {
        localStorage.setItem('simploxCustomCoins', newCoins.toString());
      }
      
      updatePerkButtons();
      return true;
    } catch (error) {
      console.error('Failed to update coins:', error);
      this.displayElements.forEach(element => {
        element.textContent = gameState.coins - amount;
      });
      updatePerkButtons();
      return false;
    }
  },
  
  updateDisplays() {
    this.displayElements.forEach(element => {
      element.textContent = gameState.coins;
    });
    updatePerkButtons();
  }
};

// Words Manager
const WordsManager = {
  displayElements: new Set(),
  
  initialize() {
    this.displayElements.clear();
    document.querySelectorAll('#totalWords').forEach(element => {
      this.displayElements.add(element);
    });
    
    if (currentUser) {
      this.loadUserWords().then(count => {
        this.updateDisplays(count);
      });
    }
  },
  
  async loadUserWords() {
    if (!currentUser) return 0;
    
    try {
      const { data, error } = await supabaseClient
        .from('player_stats')
        .select('unique_words_practiced')
        .eq('user_id', currentUser.id)
        .single();
        
      if (error) throw error;
      return data?.unique_words_practiced || 0;
    } catch (error) {
      console.error('Error loading words:', error);
      return 0;
    }
  },
  
  async updateWords(count) {
    try {
      const currentCount = parseInt(document.getElementById('totalWords').textContent) || 0;
      const newCount = currentCount + count;
      
      this.displayElements.forEach(element => {
        let currentValue = currentCount;
        const startTime = performance.now();
        
        requestAnimationFrame(function updateValue(timestamp) {
          const elapsed = timestamp - startTime;
          const progress = Math.min(elapsed / 1000, 1);
          
          currentValue = currentCount + (newCount - currentCount) * progress;
          element.textContent = Math.round(currentValue);
          
          if (progress < 1) {
            requestAnimationFrame(updateValue);
          } else {
            element.textContent = newCount;
          }
        });
      });
      
      if (currentUser) {
        const { error } = await supabaseClient
          .from('player_stats')
          .update({ unique_words_practiced: newCount })
          .eq('user_id', currentUser.id);
          
        if (error) throw error;
      }
      
      return true;
    } catch (error) {
      console.error('Failed to update words:', error);
      return false;
    }
  },
  
  updateDisplays(count) {
    this.displayElements.forEach(element => {
      element.textContent = count;
    });
  }
};

// Perk buttons setup
const perkButtons = {
  timeFreeze: document.getElementById('timeFreezePerk'),
  skip: document.getElementById('skipPerk'),
  clue: document.getElementById('cluePerk'),
  reveal: document.getElementById('revealPerk')
};

Object.entries(perkButtons).forEach(([perk, button]) => {
  if (button) {
    button.onclick = () => buyPerk(perk);
  }
});

// Game Timer
const GameTimer = {
  lastTick: 0,
  update(timestamp) {
    if (!this.lastTick) {
      this.lastTick = timestamp;
    }
    
    if (timestamp - this.lastTick >= 1000) {
      this.updateTimer();
      this.lastTick = timestamp;
    }
    
    requestAnimationFrame(this.update.bind(this));
  }
};

// Clean up level function
function cleanupLevel() {
  document.querySelectorAll('.buttons button').forEach(button => {
    button.onclick = null;
  });
  
  ParticleSystem.clear();
  clearTimeout(levelTimeout);
}

// Screen transition function
async function transitionScreen(screenId) {
  const currentScreen = document.querySelector('.screen.visible');
  if (currentScreen) {
    currentScreen.style.opacity = 0;
    await new Promise(resolve => setTimeout(resolve, 300));
    currentScreen.style.display = 'none';
  }
  
  const newScreen = document.getElementById(`${screenId}-screen`);
  newScreen.style.display = 'flex';
  
  requestAnimationFrame(() => {
    newScreen.style.opacity = 1;
  });
}

// Game Cache for words
const GameCache = {
  words: new Map(),
  
  async getWords(key) {
    if (this.words.has(key)) {
      return this.words.get(key);
    }
    
    const words = await loadWords(key);
    this.words.set(key, words);
    return words;
  }
};

// Game initialization
const gameInit = {
  async init() {
    console.log('Game initialization starting');
    
    await checkExistingSession();
    
    if (currentUser) {
      console.log('User is logged in, checking database schema');
      if (await ensureCorrectSchema()) {
        console.log('Schema is OK, loading progress from database');
        await loadUserGameProgress(currentUser.id);
      } else {
        console.log('Schema issues detected, loading from localStorage and initializing defaults');
        initializeGame();
      }
    } else {
      console.log('No user logged in, initializing local game state');
      initializeGame();
    }
    
    updatePerkButtons();
    initializeParticles(document.getElementById('welcome-screen'));
    
    setupAutoSave();
    
    console.log('Game initialization complete. Game state:', {
      currentStage: gameState.currentStage,
      currentSet: gameState.currentSet,
      currentLevel: gameState.currentLevel,
      unlockedSets: Object.keys(gameState.unlockedSets || {}),
      unlockedLevels: Object.keys(gameState.unlockedLevels || {}),
    });
  }
};

// Document ready event
document.addEventListener('DOMContentLoaded', () => {
  gameInit.init();
});

// Initialize game
function initializeGame() {
  console.log('Initializing game state');
  
  gameState.currentStage = 1;
  gameState.currentSet = 1;
  gameState.currentLevel = 1;
  gameState.coins = 0;
  gameState.perks = {};
  gameState.unlockedSets = {};
  gameState.unlockedLevels = {};
  gameState.perfectLevels = new Set();
  gameState.completedLevels = new Set();
  
  const savedProgress = localStorage.getItem('simploxProgress');
  if (savedProgress) {
    try {
      console.log('Found saved progress in localStorage');
      const progress = JSON.parse(savedProgress);
      
      if (progress.stage) gameState.currentStage = progress.stage;
      if (progress.set_number) gameState.currentSet = progress.set_number;
      if (progress.level) gameState.currentLevel = progress.level;
      if (progress.coins) gameState.coins = progress.coins;
      if (progress.perks) gameState.perks = progress.perks;
      
      if (progress.unlocked_sets) {
        Object.entries(progress.unlocked_sets).forEach(([stage, sets]) => {
          gameState.unlockedSets[stage] = new Set(Array.isArray(sets) ? sets : []);
        });
      }
      
      if (progress.unlocked_levels) {
        Object.entries(progress.unlocked_levels).forEach(([set, levels]) => {
          gameState.unlockedLevels[set] = new Set(Array.isArray(levels) ? levels : []);
        });
      }
      
      if (progress.perfect_levels) {
        gameState.perfectLevels = new Set(progress.perfect_levels);
      }
      
      if (progress.completed_levels) {
        gameState.completedLevels = new Set(progress.completed_levels);
      }
      
      console.log('Loaded progress from localStorage:', {
        currentStage: gameState.currentStage,
        currentSet: gameState.currentSet,
        currentLevel: gameState.currentLevel
      });
    } catch (error) {
      console.error('Error parsing saved progress:', error);
    }
  }
  
  const savedContext = localStorage.getItem('gameContext');
  if (savedContext) {
    try {
      const context = JSON.parse(savedContext);
      if (Date.now() - (context.timestamp || 0) < 86400000) { // 24 hours
        console.log('Found recent game context, updating current location:', context);
        if (context.stage) gameState.currentStage = context.stage;
        if (context.set) gameState.currentSet = context.set;
        if (context.level) gameState.currentLevel = context.level;
      }
    } catch (error) {
      console.error('Error parsing saved context:', error);
    }
  }
  
  setupDefaultUnlocks();
  updateAllCoinDisplays();
  updatePerkButtons();
  
  console.log('Game initialized with state:', {
    currentStage: gameState.currentStage,
    currentSet: gameState.currentSet,
    currentLevel: gameState.currentLevel
  });
}

// Set up default unlocks
function setupDefaultUnlocks() {
  if (!gameState.unlockedSets[1]) {
    gameState.unlockedSets[1] = new Set();
  }
  
  // Unlock all sets in stage 1
  for (let i = 1; i <= 9; i++) {
    gameState.unlockedSets[1].add(i);
    
    const setKey = `1_${i}`;
    if (!gameState.unlockedLevels[setKey]) {
      gameState.unlockedLevels[setKey] = new Set([1]);
    }
  }
  
  // Unlock first set in each other stage
  for (let stage = 2; stage <= 5; stage++) {
    if (!gameState.unlockedSets[stage]) {
      gameState.unlockedSets[stage] = new Set([1]);
    }
    
    const setKey = `${stage}_1`;
    if (!gameState.unlockedLevels[setKey]) {
      gameState.unlockedLevels[setKey] = new Set([1]);
    }
  }
}

// Load user game progress
async function loadUserGameProgress(userId) {
  console.log('Loading game progress for user:', userId);
  
  try {
    // Initialize with defaults
    gameState.currentStage = 1;
    gameState.currentSet = 1;
    gameState.currentLevel = 1;
    gameState.coins = 0;
    gameState.perks = {};
    gameState.unlockedSets = { 1: new Set([1]) };
    gameState.unlockedLevels = { '1_1': new Set([1]) };
    gameState.perfectLevels = new Set();
    gameState.completedLevels = new Set();
    
    // Check localStorage first
    const savedProgress = localStorage.getItem('simploxProgress');
    if (savedProgress) {
      try {
        const progress = JSON.parse(savedProgress);
        console.log('Found progress in localStorage:', progress);
        
        if (progress.stage) gameState.currentStage = progress.stage;
        if (progress.set_number) gameState.currentSet = progress.set_number;
        if (progress.level) gameState.currentLevel = progress.level;
        if (progress.coins) gameState.coins = progress.coins;
        if (progress.perks) gameState.perks = progress.perks;
        
        if (progress.unlocked_sets) {
          gameState.unlockedSets = {};
          Object.entries(progress.unlocked_sets).forEach(([stage, sets]) => {
            gameState.unlockedSets[stage] = new Set(sets);
          });
        }
        
        if (progress.unlocked_levels) {
          gameState.unlockedLevels = {};
          Object.entries(progress.unlocked_levels).forEach(([set, levels]) => {
            gameState.unlockedLevels[set] = new Set(levels);
          });
        }
        
        if (progress.perfect_levels) {
          gameState.perfectLevels = new Set(progress.perfect_levels);
        }
        
        if (progress.completed_levels) {
          gameState.completedLevels = new Set(progress.completed_levels);
        }
      } catch (error) {
        console.error('Error parsing localStorage progress:', error);
      }
    }
    
    // Now check database
    const { data, error } = await supabaseClient
      .from('game_progress')
      .select('*')
      .eq('user_id', userId)
      .single();
      
    if (error) {
      if (error.code === 'PGRST116') {
        console.log('No progress record found, creating initial progress');
        const initialProgress = {
          user_id: userId,
          stage: gameState.currentStage,
          set_number: gameState.currentSet,
          level: gameState.currentLevel,
          coins: gameState.coins
        };
        
        const { error: insertError } = await supabaseClient
          .from('game_progress')
          .insert([initialProgress]);
          
        if (insertError) {
          console.error('Error creating initial game progress:', insertError);
        }
      } else {
        console.error('Error loading game progress:', error);
      }
    } else if (data) {
      console.log('Game progress loaded from database:', data);
      
      gameState.currentStage = data.stage || gameState.currentStage;
      gameState.currentSet = data.set_number || gameState.currentSet;
      gameState.currentLevel = data.level || gameState.currentLevel;
      gameState.coins = data.coins || gameState.coins;
      
      try {
        if (data.perks && Object.keys(data.perks).length > 0) {
          gameState.perks = data.perks;
        }
        
        if (data.unlocked_sets && Object.keys(data.unlocked_sets).length > 0) {
          gameState.unlockedSets = {};
          Object.entries(data.unlocked_sets).forEach(([stage, sets]) => {
            gameState.unlockedSets[stage] = new Set(sets);
          });
        }
        
        if (data.unlocked_levels && Object.keys(data.unlocked_levels).length > 0) {
          gameState.unlockedLevels = {};
          Object.entries(data.unlocked_levels).forEach(([set, levels]) => {
            gameState.unlockedLevels[set] = new Set(levels);
          });
        }
        
        if (data.perfect_levels && data.perfect_levels.length > 0) {
          gameState.perfectLevels = new Set(data.perfect_levels);
        }
        
        if (data.completed_levels && data.completed_levels.length > 0) {
          gameState.completedLevels = new Set(data.completed_levels);
        }
      } catch (error) {
        console.error('Error loading extended fields from database:', error);
      }
    }
    
    setupDefaultUnlocks();
    
    console.log('Game state after loading progress:', {
      currentStage: gameState.currentStage,
      currentSet: gameState.currentSet,
      currentLevel: gameState.currentLevel
    });
    
    updateAllCoinDisplays();
    return true;
  } catch (error) {
    console.error('Unexpected error in loadUserGameProgress:', error);
    return false;
  }
}

// Debug unlock state
function debugUnlockState() {
  console.group('Current Game State');
  console.log('Current Stage:', gameState.currentStage);
  console.log('Current Set:', gameState.currentSet);
  console.log('Current Level:', gameState.currentLevel);
  
  console.group('Unlocked Sets');
  Object.entries(gameState.unlockedSets).forEach(([stage, sets]) => {
    console.log(`Stage ${stage}:`, Array.from(sets).sort((a, b) => a - b));
  });
  console.groupEnd();
  
  console.group('Unlocked Levels');
  Object.entries(gameState.unlockedLevels).forEach(([set, levels]) => {
    console.log(`Set ${set}:`, Array.from(levels).sort((a, b) => a - b));
  });
  console.groupEnd();
  
  console.log('Completed Levels:', Array.from(gameState.completedLevels));
  console.log('Perfect Levels:', Array.from(gameState.perfectLevels));
  console.groupEnd();
}

// Setup auto-save function
function setupAutoSave() {
  const interval = setInterval(() => {
    if (gameState.currentStage && gameState.currentSet && gameState.currentLevel) {
      console.log('Auto-saving game progress');
      saveProgress();
    }
  }, 30000);

  window.addEventListener('beforeunload', () => {
    if (gameState.currentStage && gameState.currentSet && gameState.currentLevel) {
      console.log('Saving progress before page unload');
      saveProgress();
    }
  });

  return interval;
}

// Save progress
function saveProgress() {
  console.log('Saving game progress');
  
  if (!gameState.currentStage) {
    console.log('No game state to save');
    return;
  }
  
  const coreData = {
    stage: gameState.currentStage || 1,
    set_number: gameState.currentSet || 1,
    level: gameState.currentLevel || 1,
    coins: gameState.coins || 0
  };
  
  const extendedData = {
    perks: gameState.perks || {},
    unlocked_sets: Object.fromEntries(
      Object.entries(gameState.unlockedSets || {})
        .map(([stage, sets]) => [stage, Array.from(sets || [])])
    ),
    unlocked_levels: Object.fromEntries(
      Object.entries(gameState.unlockedLevels || {})
        .map(([set, levels]) => [set, Array.from(levels || [])])
    ),
    perfect_levels: Array.from(gameState.perfectLevels || []),
    completed_levels: Array.from(gameState.completedLevels || [])
  };
  
  localStorage.setItem('simploxProgress', JSON.stringify({
    ...coreData,
    ...extendedData
  }));
  
  const context = {
    stage: gameState.currentStage,
    set: gameState.currentSet,
    level: gameState.currentLevel,
    timestamp: Date.now()
  };
  
  localStorage.setItem('gameContext', JSON.stringify(context));
  
  if (currentUser) {
    console.log('Saving progress to Supabase for user:', currentUser.id);
    
    supabaseClient
      .from('game_progress')
      .upsert({ user_id: currentUser.id, ...coreData })
      .then(({ error }) => {
        if (error) {
          console.error('Error saving core progress:', error);
        } else {
          console.log('Core progress saved successfully');
          
          const updateField = (fieldName, value) => {
            const updateData = { [fieldName]: value };
            
            supabaseClient
              .from('game_progress')
              .update(updateData)
              .eq('user_id', currentUser.id)
              .then(({ error }) => {
                if (error) {
                  console.warn(`Error saving ${fieldName}:`, error);
                } else {
                  console.log(`${fieldName} saved successfully`);
                }
              });
          };
          
          Object.entries(extendedData).forEach(([field, value]) => {
            updateField(field, value);
          });
        }
      });
  }
}

// part 2

// Check and ensure database schema is correct
async function ensureCorrectSchema() {
  if (!currentUser) return false;
  
  console.log('Checking database schema for user:', currentUser.id);
  
  try {
    const { data, error } = await supabaseClient
      .from('game_progress')
      .select('*')
      .eq('user_id', currentUser.id)
      .single();
      
    if (error) {
      if (error.code === 'PGRST116') {
        console.log('Creating game progress record for user');
        const initialProgress = {
          user_id: currentUser.id,
          stage: 1,
          set_number: 1,
          level: 1,
          coins: 0,
          perks: {},
          unlocked_sets: { 1: [1] },
          unlocked_levels: { '1_1': [1] },
          perfect_levels: [],
          completed_levels: []
        };
        
        const { error: insertError } = await supabaseClient
          .from('game_progress')
          .insert([initialProgress]);
          
        return !insertError;
      }
      
      console.error('Error checking game progress record:', error);
      return false;
    }
    
    let needsUpdate = false;
    const updatedRecord = { ...data };
    
    const requiredFields = [
      { name: 'unlocked_sets', defaultValue: { 1: [1] } },
      { name: 'unlocked_levels', defaultValue: { '1_1': [1] } },
      { name: 'perfect_levels', defaultValue: [] },
      { name: 'completed_levels', defaultValue: [] }
    ];
    
    for (const field of requiredFields) {
      if (!(field.name in data) || data[field.name] === null) {
        updatedRecord[field.name] = field.defaultValue;
        needsUpdate = true;
        console.log(`Field "${field.name}" missing, will add it`);
      }
    }
    
    if (needsUpdate) {
      console.log('Updating record with missing fields');
      const { error: updateError } = await supabaseClient
        .from('game_progress')
        .update(updatedRecord)
        .eq('user_id', currentUser.id);
        
      if (updateError) {
        console.error('Error updating game progress record:', updateError);
        return false;
      }
    }
    
    return true;
  } catch (error) {
    console.error('Unexpected error in ensureCorrectSchema:', error);
    return false;
  }
}

// Switch auth tabs
function switchAuthTab(tab) {
  const loginTab = document.querySelector('.auth-tab[onclick="switchAuthTab(\'login\')"]');
  const signupTab = document.querySelector('.auth-tab[onclick="switchAuthTab(\'signup\')"]');
  const loginForm = document.getElementById('loginForm');
  const signupForm = document.getElementById('signupForm');
  
  if (tab === 'login') {
    loginTab.classList.add('active');
    signupTab.classList.remove('active');
    loginForm.classList.remove('hidden');
    signupForm.classList.add('hidden');
  } else {
    loginTab.classList.remove('active');
    signupTab.classList.add('active');
    loginForm.classList.add('hidden');
    signupForm.classList.remove('hidden');
  }
}

// Update auth UI
function updateAuthUI() {
  const authBox = document.getElementById('authBox');
  const userInfo = document.getElementById('userInfo');
  const userEmail = document.getElementById('userEmail');
  const logoutButton = document.querySelector('.logout-button');
  
  if (currentUser) {
    authBox.classList.add('hidden');
    userInfo.classList.remove('hidden');
    logoutButton.classList.remove('hidden');
    userEmail.textContent = currentUser.user_metadata?.username || currentUser.email;
    
    supabaseClient
      .from('user_profiles')
      .select('status, username')
      .eq('id', currentUser.id)
      .single()
      .then(({ data }) => {
        if (data) {
          if (data.username) {
            userEmail.textContent = data.username;
          }
          updateUserStatusDisplay(data.status);
        }
      })
      .catch(error => console.error('Error fetching user status:', error));
  } else {
    authBox.classList.remove('hidden');
    userInfo.classList.add('hidden');
    logoutButton.classList.add('hidden');
    userEmail.textContent = '';
  }
}

// Handle signup
async function handleSignup() {
  const email = document.getElementById('signupEmail').value;
  const username = document.getElementById('signupUsername').value;
  const password = document.getElementById('signupPassword').value;
  
  if (email && username && password) {
    try {
      const { data, error } = await supabaseClient.auth.signUp({
        email,
        password,
        options: {
          data: {
            username: username,
            full_name: username
          }
        }
      });
      
      if (error) throw error;
      
      // Create user profile
      const { error: profileError } = await supabaseClient
        .from('user_profiles')
        .upsert({
          id: data.user.id,
          username: username,
          email: email,
          status: 'free',
          role: 'student'
        }, { onConflict: 'id' });
        
      if (profileError) {
        console.error('Profile upsert error:', profileError);
      }
      
      // Check if game progress exists
      const { data: progressData, error: progressError } = await supabaseClient
        .from('game_progress')
        .select('user_id')
        .eq('user_id', data.user.id)
        .single();
        
      if (progressError && progressError.code === 'PGRST116') {
        // No progress found, create initial progress
        const initialProgress = {
          user_id: data.user.id,
          stage: 1,
          set_number: 1,
          level: 1,
          coins: 0,
          perks: {},
          unlocked_sets: { 1: [1] },
          unlocked_levels: { '1_1': [1] },
          perfect_levels: [],
          completed_levels: []
        };
        
        const { error: insertError } = await supabaseClient
          .from('game_progress')
          .insert([initialProgress]);
          
        if (insertError && insertError.code !== '23505') {
          console.error('Game progress initialization error:', insertError);
        }
      }
      
      // Check if player stats exists
      const { data: statsData, error: statsError } = await supabaseClient
        .from('player_stats')
        .select('user_id')
        .eq('user_id', data.user.id)
        .single();
        
      if (statsError && statsError.code === 'PGRST116') {
        // No stats found, create initial stats
        const initialStats = {
          user_id: data.user.id,
          total_levels_completed: 0,
          unique_words_practiced: 0
        };
        
        const { error: insertError } = await supabaseClient
          .from('player_stats')
          .insert([initialStats]);
          
        if (insertError && insertError.code !== '23505') {
          console.error('Player stats initialization error:', insertError);
        }
      }
      
      // Sign in
      const { data: signInData, error: signInError } = await supabaseClient.auth.signInWithPassword({
        email,
        password
      });
      
      if (signInError) throw signInError;
      
      hideAuthModal();
      currentUser = signInData.user;
      
      // Initialize game state
      gameState.currentStage = 1;
      gameState.currentSet = 1;
      gameState.currentLevel = 1;
      gameState.coins = 0;
      gameState.perks = {};
      gameState.unlockedSets = { 1: new Set([1]) };
      gameState.unlockedLevels = { '1_1': new Set([1]) };
      gameState.perfectLevels = new Set();
      gameState.completedLevels = new Set();
      
      updateAuthUI();
      showScreen('welcome-screen');
    } catch (error) {
      console.error('Detailed signup error:', error);
      if (error.message && error.message.includes('duplicate key')) {
        alert('This username or email is already taken. Please try another.');
      } else {
        alert('Signup error: ' + error.message);
      }
    }
  } else {
    alert('All fields are required');
  }
}

// Safe upsert record
async function safeUpsertRecord(table, data, keyField = 'user_id') {
  try {
    const { data: existingRecord, error: checkError } = await supabaseClient
      .from(table)
      .select(keyField)
      .eq(keyField, data[keyField])
      .single();
      
    if (checkError && checkError.code === 'PGRST116') {
      // Record not found, insert
      const { error: insertError } = await supabaseClient
        .from(table)
        .insert([data]);
        
      if (insertError) {
        if (insertError.code === '23505') {
          // Handle unique constraint violation
          const { error: updateError } = await supabaseClient
            .from(table)
            .update(data)
            .eq(keyField, data[keyField]);
            
          if (updateError) {
            console.error(`Error updating ${table}:`, updateError);
            return false;
          }
        } else {
          console.error(`Error inserting into ${table}:`, insertError);
          return false;
        }
      }
    } else if (checkError) {
      console.error(`Error checking ${table}:`, checkError);
      return false;
    } else {
      // Record exists, update
      const { error: updateError } = await supabaseClient
        .from(table)
        .update(data)
        .eq(keyField, data[keyField]);
        
      if (updateError) {
        console.error(`Error updating ${table}:`, updateError);
        return false;
      }
    }
    
    return true;
  } catch (error) {
    console.error(`Unexpected error in safeUpsertRecord for ${table}:`, error);
    return false;
  }
}

// Update user coins
async function updateUserCoins(amount) {
  const oldCoins = gameState.coins;
  gameState.coins += amount;
  
  updateAllCoinDisplays();
  updatePerkButtons();
  
  if (currentUser) {
    try {
      const { error } = await supabaseClient
        .from('game_progress')
        .update({ coins: gameState.coins })
        .eq('user_id', currentUser.id);
        
      if (error) {
        console.error('Failed to update coins in database:', error);
        gameState.coins = oldCoins;
        updateAllCoinDisplays();
        updatePerkButtons();
        return false;
      }
    } catch (error) {
      console.error('Error updating coins:', error);
      gameState.coins = oldCoins;
      updateAllCoinDisplays();
      updatePerkButtons();
      return false;
    }
  }
  
  // Update localStorage
  const savedProgress = JSON.parse(localStorage.getItem('simploxProgress') || '{}');
  savedProgress.coins = gameState.coins;
  localStorage.setItem('simploxProgress', JSON.stringify(savedProgress));
  
  return true;
}

// Check and fix database schema
async function checkAndFixDatabaseSchema() {
  if (!currentUser) return false;
  
  try {
    const { data, error } = await supabaseClient
      .from('game_progress')
      .select('*')
      .eq('user_id', currentUser.id)
      .single();
      
    if (error) {
      console.error('Error checking database schema:', error);
      return false;
    }
    
    const needsCompletedLevels = !('completed_levels' in data);
    const needsPerfectLevels = !('perfect_levels' in data);
    
    if (!needsCompletedLevels && !needsPerfectLevels) {
      console.log('Database schema is up to date');
      return true;
    }
    
    console.log('Adding missing columns to database schema');
    
    const updatedData = {
      user_id: currentUser.id,
      stage: data.stage || 1,
      set_number: data.set_number || 1,
      level: data.level || 1
    };
    
    if ('coins' in data) updatedData.coins = data.coins || 0;
    if ('unlocked_sets' in data) updatedData.unlocked_sets = data.unlocked_sets || {};
    if ('unlocked_levels' in data) updatedData.unlocked_levels = data.unlocked_levels || {};
    
    if (needsCompletedLevels) updatedData.completed_levels = [];
    if (needsPerfectLevels) updatedData.perfect_levels = [];
    
    const { error: updateError } = await supabaseClient
      .from('game_progress')
      .update(updatedData)
      .eq('user_id', currentUser.id);
      
    if (updateError) {
      console.error('Failed to update database schema:', updateError);
      return false;
    }
    
    console.log('Database schema successfully updated');
    return true;
  } catch (error) {
    console.error('Error fixing database schema:', error);
    return false;
  }
}

// Initialize game progress for user
async function initializeGameProgressForUser(userId) {
  const { error } = await supabaseClient
    .from('game_progress')
    .insert({
      user_id: userId,
      stage: 1,
      set_number: 1,
      level: 1,
      coins: 0,
      perks: {},
      unlocked_sets: { 1: [1] },
      unlocked_levels: { '1_1': [1] },
      perfect_levels: [],
      completed_levels: []
    });
    
  if (error) {
    console.error('Error initializing game progress:', error);
  }
}

// Handle login
async function handleLogin() {
  const loginInput = document.getElementById('loginUsername').value;
  const password = document.getElementById('loginPassword').value;
  
  if (loginInput && password) {
    try {
      let loginPromise;
      
      if (loginInput.includes('@')) {
        // Email login
        loginPromise = supabaseClient.auth.signInWithPassword({
          email: loginInput,
          password: password
        });
      } else {
        // Username login, lookup email first
        const { data, error } = await supabaseClient
          .from('user_profiles')
          .select('email')
          .eq('username', loginInput)
          .single();
          
        if (error || !data) {
          alert('Username not found');
          return;
        }
        
        loginPromise = supabaseClient.auth.signInWithPassword({
          email: data.email,
          password: password
        });
      }
      
      const { data, error } = await loginPromise;
      
      if (error) {
        console.error('Login Error:', error);
        alert(error.message);
        return;
      }
      
      if (data.user) {
        currentUser = data.user;
        hideAuthModal();
        
        // Get user status
        const { data: profileData } = await supabaseClient
          .from('user_profiles')
          .select('status')
          .eq('id', currentUser.id)
          .single();
          
        if (profileData) {
          currentUser.status = profileData.status;
          updateUserStatusDisplay(profileData.status);
        }
        
        // Load game data
        await loadUserGameProgress(currentUser.id);
        updateAuthUI();
        updateGuestPlayButton();
        showScreen('welcome-screen');
      }
    } catch (error) {
      console.error('Unexpected Login Error:', error);
      alert('An unexpected error occurred during login');
    }
  } else {
    alert('Please enter both username/email and password');
  }
}

// Handle logout
async function handleLogout() {
  try {
    const { error } = await supabaseClient.auth.signOut();
    
    if (error) {
      console.error('Supabase logout error:', error.message);
    }
    
    gameState.coins = 0;
    gameState.unlockedSets = {};
    gameState.unlockedLevels = {};
    gameState.perfectLevels = new Set();
    gameState.completedLevels = new Set();
    
    currentUser = null;
    updateAuthUI();
    updateUserStatusDisplay(null);
    updateGuestPlayButton();
    showScreen('welcome-screen');
  } catch (error) {
    console.error('Unexpected error during logout:', error);
    currentUser = null;
    updateAuthUI();
    updateUserStatusDisplay(null);
    updateGuestPlayButton();
    showScreen('welcome-screen');
  }
}

// Toggle auth mode (login/signup)
function toggleAuthMode() {
  const loginForm = document.getElementById('loginForm');
  const signupForm = document.getElementById('signupForm');
  
  loginForm.classList.toggle('hidden');
  signupForm.classList.toggle('hidden');
}

// Show/hide auth modal
function showAuthModal() {
  const authModal = document.getElementById('authModal');
  authModal && authModal.classList.add('show');
}

function hideAuthModal() {
  const authModal = document.getElementById('authModal');
  authModal && authModal.classList.remove('show');
}

// Check for existing session
async function checkExistingSession() {
  console.log('Checking for existing user session');
  
  try {
    const { data: { session } } = await supabaseClient.auth.getSession();
    
    if (session) {
      console.log('Found existing session for user:', session.user.id);
      currentUser = session.user;
      
      // Get user status
      const { data } = await supabaseClient
        .from('user_profiles')
        .select('status')
        .eq('id', currentUser.id)
        .single();
        
      if (data) {
        currentUser.status = data.status;
        updateUserStatusDisplay(data.status);
      }
      
      initializeStatusCheck();
      updateAuthUI();
      updateGuestPlayButton();
      return true;
    }
    
    console.log('No active session found');
    currentUser = null;
    updateAuthUI();
    updateUserStatusDisplay(null);
    updateGuestPlayButton();
    return false;
  } catch (error) {
    console.error('Session check error:', error);
    currentUser = null;
    updateAuthUI();
    updateUserStatusDisplay(null);
    updateGuestPlayButton();
    return false;
  }
}

// Toggle parent fields in upgrade form
function toggleParentFields() {
  const isAdult = document.getElementById('isAdult').checked;
  const parentInfoSection = document.getElementById('parentInfoSection');
  const adultInfoSection = document.getElementById('adultInfoSection');
  const parentInputs = parentInfoSection.querySelectorAll('input');
  const adultInputs = adultInfoSection.querySelectorAll('input');
  
  if (isAdult) {
    parentInfoSection.style.display = 'none';
    adultInfoSection.style.display = 'block';
    parentInputs.forEach(input => input.required = false);
    adultInputs.forEach(input => input.required = true);
  } else {
    parentInfoSection.style.display = 'block';
    adultInfoSection.style.display = 'none';
    parentInputs.forEach(input => input.required = true);
    adultInputs.forEach(input => input.required = false);
  }
}

// Handle upgrade submit
async function handleUpgradeSubmit(event) {
  event.preventDefault();
  
  const isAdult = document.getElementById('isAdult').checked;
  
  try {
    // Get user info
    const { data: userData } = await supabaseClient
      .from('user_profiles')
      .select('username, created_at')
      .eq('id', currentUser.id)
      .single();
    
    // Create request data
    let requestData = {
      user_id: currentUser.id,
      is_adult: isAdult,
      full_name: isAdult ? document.getElementById('fullName').value : document.getElementById('parentName').value,
      phone: isAdult ? document.getElementById('phone').value : document.getElementById('parentPhone').value,
      parent_name: isAdult ? null : document.getElementById('parentName').value,
      parent_phone: isAdult ? null : document.getElementById('parentPhone').value,
      referral_source: document.getElementById('referralSource').value
    };
    
    if (!validateForm(isAdult)) {
      alert('Please fill in all required fields');
      return;
    }
    
    // Submit request
    const { data, error } = await supabaseClient
      .from('upgrade_requests')
      .insert([requestData])
      .select();
      
    if (error) throw error;
    
    // Update user status
    const { error: updateError } = await supabaseClient
      .from('user_profiles')
      .update({ status: 'pending' })
      .eq('id', currentUser.id);
      
    if (updateError) throw updateError;
    
    // Mark as requested in localStorage
    localStorage.setItem(`upgradeRequested_${currentUser.id}`, 'true');
    
    // Show confirmation popup
    const popup = document.createElement('div');
    popup.className = 'confirmation-popup';
    popup.innerHTML = `
      <h2>Thank You!</h2>
      <p>We've received your upgrade request. We'll contact you soon with payment details.</p>
      <button onclick="continueAfterUpgrade()">Continue Playing</button>
    `;
    document.body.appendChild(popup);
    setTimeout(() => popup.classList.add('show'), 100);
  } catch (error) {
    console.error('Upgrade Request Error:', error);
    alert('Error processing request. Please try again.');
  }
}

// Continue after upgrade
function continueAfterUpgrade() {
  const popup = document.querySelector('.confirmation-popup');
  if (popup) {
    popup.classList.remove('show');
    setTimeout(() => popup.remove(), 300);
  }
  
  const upgradeScreen = document.getElementById('upgrade-screen');
  if (upgradeScreen) {
    upgradeScreen.classList.remove('visible');
  }
  
  const upgradeForm = document.getElementById('upgradeForm');
  if (upgradeForm) {
    upgradeForm.reset();
  }
  
  if (currentUser) {
    updateUserStatusDisplay('pending');
  }
  
  hideUpgradePromptAndContinue();
}

// Validate form
function validateForm(isAdult) {
  if (isAdult) {
    return document.getElementById('fullName').value && document.getElementById('phone').value;
  } else {
    return document.getElementById('parentName').value && document.getElementById('parentPhone').value;
  }
}

// Skip upgrade
function skipUpgrade() {
  hideUpgradePromptAndContinue();
}

// Update user status display
function updateUserStatusDisplay(status) {
  const userProfileSection = document.querySelector('.user-profile-section');
  const userTierText = document.getElementById('userTierText');
  
  if (userProfileSection && userTierText) {
    userTierText.className = 'status-badge';
    
    if (currentUser) {
      userProfileSection.style.display = 'block';
      
      switch (status) {
        case 'free':
        default:
          userTierText.classList.add('trial');
          userTierText.textContent = 'Trial Account';
          break;
        case 'pending':
          userTierText.classList.add('pending');
          userTierText.textContent = 'Premium Pending';
          break;
        case 'premium':
          userTierText.classList.add('premium');
          userTierText.textContent = 'Premium';
          break;
      }
      
      updateUserStats();
    } else {
      userTierText.classList.add('unregistered');
      userTierText.textContent = 'Unregistered';
      userProfileSection.style.display = 'none';
    }
  } else {
    console.warn('User profile elements not found');
  }
}

// Update user stats
async function updateUserStats() {
  try {
    if (!currentUser) return;
    
    const { data: progressData } = await supabaseClient
      .from('game_progress')
      .select('coins')
      .eq('user_id', currentUser.id)
      .single();
      
    const { data: statsData } = await supabaseClient
      .from('player_stats')
      .select('unique_words_practiced')
      .eq('user_id', currentUser.id)
      .single();
      
    if (progressData) {
      document.getElementById('totalCoins').textContent = progressData.coins || 0;
    }
    
    if (statsData) {
      document.getElementById('totalWords').textContent = statsData.unique_words_practiced || 0;
    }
    
    updateAllCoinDisplays();
    WordsManager.updateDisplays(statsData?.unique_words_practiced || 0);
  } catch (error) {
    console.error('Error updating user stats:', error);
  }
}

// Setup user status subscription
function setupUserStatusSubscription() {
  if (!currentUser) return;
  
  const channel = supabaseClient
    .channel('user-status-' + currentUser.id)
    .on('postgres_changes', {
      event: 'UPDATE',
      schema: 'public',
      table: 'user_profiles',
      filter: `id=eq.${currentUser.id}`
    }, (payload) => {
      console.log('Profile update received:', payload.new);
      
      if (payload.new && payload.new.status) {
        updateUserStatusDisplay(payload.new.status);
        
        if (payload.new.status === 'premium') {
          showPremiumCelebration();
        }
      }
    })
    .subscribe(status => {
      console.log('Subscription status:', status);
    });
    
  return channel;
}

// Restore game context
function restoreGameContext() {
  const savedContext = localStorage.getItem('gameContext');
  
  if (savedContext) {
    const context = JSON.parse(savedContext);
    gameState.currentStage = context.stage || 1;
    gameState.currentSet = context.set || 1;
    gameState.currentLevel = context.level;
    
    localStorage.removeItem('gameContext');
    return true;
  }
  
  return false;
}

// Check upgrade status
function checkUpgradeStatus() {
  if (!currentUser) return false;
  
  const requested = localStorage.getItem(`upgradeRequested_${currentUser.id}`);
  const isPremium = currentUser.status === 'premium';
  const isPending = currentUser.status === 'pending';
  
  return requested || isPremium || isPending;
}

// Initialize status check
function initializeStatusCheck() {
  if (window.statusCheckInterval) {
    clearInterval(window.statusCheckInterval);
  }
  
  if (currentUser) {
    const interval = setInterval(async () => {
      try {
        if (!currentUser || !currentUser.id) {
          clearInterval(window.statusCheckInterval);
          return;
        }
        
        const { data, error } = await supabaseClient
          .from('user_profiles')
          .select('status')
          .eq('id', currentUser.id)
          .single();
          
        if (error || !data) {
          clearInterval(window.statusCheckInterval);
          currentUser = null;
          updateAuthUI();
          return;
        }
        
        updateUserStatusDisplay(data.status);
        
        if (data.status === 'premium' && currentUser.status !== 'premium') {
          currentUser.status = 'premium';
          showPremiumCelebration();
        }
      } catch (error) {
        console.error('Status check error:', error);
        clearInterval(window.statusCheckInterval);
        currentUser = null;
        updateAuthUI();
      }
    }, 3000);
    
    window.statusCheckInterval = interval;
  }
}

// Update guest play button
function updateGuestPlayButton() {
  const guestPlayButton = document.querySelector('.guest-play-button');
  
  if (!currentUser || (currentUser && currentUser.status === 'unregistered')) {
    guestPlayButton.textContent = 'Play as Guest';
  } else {
    guestPlayButton.textContent = 'Start Game';
  }
}

// Show premium celebration
function showPremiumCelebration() {
  const element = document.createElement('div');
  element.className = 'premium-celebration';
  element.innerHTML = `
    <div class="celebration-content">
      <h1 class="celebration-title">Congratulations!</h1>
      <p class="celebration-message">You've unlocked Premium Access!</p>
      <button class="celebration-button" onclick="handlePremiumCelebrationComplete()">
        Continue
      </button>
    </div>
  `;
  
  document.body.appendChild(element);
  
  setTimeout(() => {
    element.classList.add('show');
  }, 100);
}

// Handle premium celebration complete
function handlePremiumCelebrationComplete() {
  const element = document.querySelector('.premium-celebration');
  
  if (element) {
    element.classList.remove('show');
    
    setTimeout(() => {
      element.remove();
      showScreen('welcome-screen');
    }, 500);
  }
}

// Show upgrade prompt
function showUpgradePrompt(callback) {
  const currentContext = {
    screen: document.querySelector('.screen.visible')?.id,
    stage: gameState.currentStage,
    set: gameState.currentSet,
    level: gameState.currentLevel
  };
  
  if (currentContext.screen) {
    localStorage.setItem('gameContext', JSON.stringify(currentContext));
  }
  
  if (currentUser) {
    if (checkUpgradeStatus()) {
      if (callback) callback();
    } else {
      showUpgradeScreen();
    }
  } else {
    showUnregisteredWarning(() => {
      if (callback) callback();
    });
  }
}

// Hide upgrade prompt
function hideUpgradePrompt() {
  const element = document.querySelector('.upgrade-prompt');
  
  if (element) {
    element.classList.remove('show');
    setTimeout(() => element.remove(), 300);
  }
}

// Hide upgrade prompt and continue
function hideUpgradePromptAndContinue() {
  const upgradeScreen = document.getElementById('upgrade-screen');
  upgradeScreen && upgradeScreen.classList.remove('visible');
  
  isFrozen = false;
  clearTimer();
  
  if (gameState.currentLevel) {
    proceedWithLevel(gameState.currentLevel);
  } else {
    showScreen('welcome-screen');
  }
}

// Handle upgrade click
function handleUpgradeClick() {
  hideUpgradePrompt();
  showPaymentScreen();
}

// Check user access
async function checkUserAccess() {
  if (!currentUser) {
    return {
      fullAccess: false,
      unlockedStages: { 1: [1], 2: [1], 3: [1], 4: [1], 5: [1] },
      defaultUnlockedLevels: { 1: true }
    };
  }
  
  const { data, error } = await supabaseClient
    .from('user_profiles')
    .select('status, payment_pending')
    .eq('id', currentUser.id)
    .single();
    
  if (error) return null;
  
  if (data.payment_pending || data.status === 'free' || data.status === 'pending') {
    return {
      fullAccess: false,
      unlockedStages: { 1: [1], 2: [1], 3: [1], 4: [1], 5: [1] },
      defaultUnlockedLevels: { 1: true }
    };
  } else if (data.status === 'premium') {
    return {
      fullAccess: true,
      unlockedStages: { 1: [1], 2: [1], 3: [1], 4: [1], 5: [1] },
      defaultUnlockedLevels: { 1: true }
    };
  }
}

// Show upgrade screen
function showUpgradeScreen() {
  if (localStorage.getItem(`upgradeRequested_${currentUser.id}`)) {
    hideUpgradePromptAndContinue();
  } else {
    showScreen('upgrade-screen');
  }
}

function showUnregisteredWarning(callback) {
  if (window.unregisteredWarningShown) {
    if (callback) callback();
    return;
  }
  
  window.unregisteredWarningShown = true;
  
  const warningContainer = document.createElement('div');
  warningContainer.className = 'fullscreen-signup-page';
  warningContainer.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--gradient);
        z-index: 2000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
        padding: 2rem;
        animation: fadeIn 0.3s ease-in-out;
    `;
    
  warningContainer.innerHTML = `
        <div class="signup-header" style="width: 100%; display: flex; justify-content: flex-start; margin-bottom: 2rem;">
            <button class="skip-signup-button" style="
                background: rgba(255,255,255,0.15);
                border: none;
                color: var(--text);
                padding: 0.75rem 1.5rem;
                border-radius: 50px;
                font-size: 0.9rem;
                cursor: pointer;
                transition: all 0.3s ease;
            ">
                Skip
            </button>
        </div>
        
        <div class="signup-content" style="
            text-align: center;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            max-width: 600px;
            width: 100%;
        ">
            <h2 style="
                font-size: 2rem;
                color: var(--gold);
                margin-bottom: 1.5rem;
                animation: floatAnimation 3s ease-in-out infinite;
            ">Save Your Progress!</h2>
            
            <p style="
                font-size: 1.2rem;
                line-height: 1.6;
                margin-bottom: 2rem;
                color: var(--text);
            ">Create a free account to track your vocabulary progress, earn rewards, and unlock more advanced content</p>
            
            <div class="features-list" style="
                display: flex;
                flex-direction: column;
                gap: 1rem;
                margin-bottom: 3rem;
                text-align: left;
            ">
                <div class="feature-item" style="
                    display: flex;
                    align-items: center;
                    gap: 1rem;
                ">
                    <i class="fas fa-check-circle" style="color: var(--gold); font-size: 1.5rem;"></i>
                    <span>Track your learning progress</span>
                </div>
                <div class="feature-item" style="
                    display: flex;
                    align-items: center;
                    gap: 1rem;
                ">
                    <i class="fas fa-check-circle" style="color: var(--gold); font-size: 1.5rem;"></i>
                    <span>Practice custom word lists</span>
                </div>
                <div class="feature-item" style="
                    display: flex;
                    align-items: center;
                    gap: 1rem;
                ">
                    <i class="fas fa-check-circle" style="color: var(--gold); font-size: 1.5rem;"></i>
                    <span>Earn coins for premium content</span>
                </div>
            </div>
        </div>
        
        <div class="signup-footer" style="
            width: 100%;
            display: flex;
            justify-content: center;
            padding-bottom: 2rem;
        ">
            <button class="signup-now-button" style="
                background: var(--gold);
                color: var(--primary-dark);
                border: none;
                padding: 1.25rem 3rem;
                border-radius: 50px;
                font-size: 1.2rem;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s ease;
                box-shadow: 0 10px 20px rgba(255, 215, 0, 0.2);
                animation: pulseAnimation 1.5s infinite ease-in-out;
            ">
                Sign Up Now
            </button>
        </div>
    `;
    
  document.body.appendChild(warningContainer);
  
  const animationStyle = document.createElement('style');
  animationStyle.textContent = `
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes floatAnimation {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        @keyframes pulseAnimation {
            0%, 100% { transform: scale(1); box-shadow: 0 10px 20px rgba(255, 215, 0, 0.2); }
            50% { transform: scale(1.05); box-shadow: 0 10px 30px rgba(255, 215, 0, 0.4); }
        }
    `;
    
  document.head.appendChild(animationStyle);
  
  const skipButton = warningContainer.querySelector('.skip-signup-button');
  const signupButton = warningContainer.querySelector('.signup-now-button');
  
  skipButton.addEventListener('click', function() {
    document.body.removeChild(warningContainer);
    if (animationStyle.parentNode) {
      animationStyle.parentNode.removeChild(animationStyle);
    }
    if (callback) callback();
  });
  
  signupButton.addEventListener('click', function() {
    document.body.removeChild(warningContainer);
    if (animationStyle.parentNode) {
      animationStyle.parentNode.removeChild(animationStyle);
    }
    
    showScreen('welcome-screen');
    
    setTimeout(function() {
      const authModal = document.getElementById('authModal');
      if (authModal) {
        authModal.classList.add('show');
        
        const signupForm = document.getElementById('signupForm');
        const loginForm = document.getElementById('loginForm');
        
        if (signupForm && loginForm) {
          signupForm.classList.remove('hidden');
          loginForm.classList.add('hidden');
        }
      }
    }, 100);
  });
}

function toggleParentFields() {
  const isAdult = document.getElementById('isAdult').checked;
  const parentInfoSection = document.getElementById('parentInfoSection');
  const adultInfoSection = document.getElementById('adultInfoSection');
  const parentInputs = parentInfoSection.querySelectorAll('input');
  const adultInputs = adultInfoSection.querySelectorAll('input');
  
  if (isAdult) {
    parentInfoSection.style.display = 'none';
    adultInfoSection.style.display = 'block';
    parentInputs.forEach(input => input.required = false);
    adultInputs.forEach(input => input.required = true);
  } else {
    parentInfoSection.style.display = 'block';
    adultInfoSection.style.display = 'none';
    parentInputs.forEach(input => input.required = true);
    adultInputs.forEach(input => input.required = false);
  }
}

function showUpgradeScreen() {
  if (localStorage.getItem(`upgradeRequested_${currentUser.id}`)) {
    hideUpgradePromptAndContinue();
  } else {
    showScreen('upgrade-screen');
  }
}

function validateForm(isAdult) {
  if (isAdult) {
    return document.getElementById('fullName').value && 
           document.getElementById('phone').value;
  } else {
    return document.getElementById('parentName').value && 
           document.getElementById('parentPhone').value;
  }
}

function skipUpgrade() {
  hideUpgradePromptAndContinue();
}

function updateUserStatusDisplay(status) {
  const userProfileSection = document.querySelector('.user-profile-section');
  const userTierText = document.getElementById('userTierText');
  
  if (userProfileSection && userTierText) {
    userTierText.className = 'status-badge';
    
    if (currentUser) {
      userProfileSection.style.display = 'block';
      
      switch(status) {
        case 'free':
        default:
          userTierText.classList.add('trial');
          userTierText.textContent = 'Trial Account';
          break;
        case 'pending':
          userTierText.classList.add('pending');
          userTierText.textContent = 'Premium Pending';
          break;
        case 'premium':
          userTierText.classList.add('premium');
          userTierText.textContent = 'Premium';
          break;
      }
      
      updateUserStats();
    } else {
      userTierText.classList.add('unregistered');
      userTierText.textContent = 'Unregistered';
      userProfileSection.style.display = 'none';
    }
  } else {
    console.warn('User profile elements not found');
  }
}

async function updateUserStats() {
  try {
    if (!currentUser) return;
    
    const { data: progressData } = await supabaseClient
      .from('game_progress')
      .select('coins')
      .eq('user_id', currentUser.id)
      .single();
      
    const { data: statsData } = await supabaseClient
      .from('player_stats')
      .select('unique_words_practiced')
      .eq('user_id', currentUser.id)
      .single();
      
    if (progressData) {
      document.getElementById('totalCoins').textContent = progressData.coins || 0;
    }
    
    if (statsData) {
      document.getElementById('totalWords').textContent = statsData.unique_words_practiced || 0;
    }
    
    updateAllCoinDisplays();
    WordsManager.updateDisplays(statsData?.unique_words_practiced || 0);
  } catch (error) {
    console.error('Error updating user stats:', error);
  }
}

function setupUserStatusSubscription() {
  if (!currentUser) return;
  
  return supabaseClient
    .channel('user-status-' + currentUser.id)
    .on('postgres_changes', {
      event: 'UPDATE',
      schema: 'public',
      table: 'user_profiles',
      filter: `id=eq.${currentUser.id}`
    }, (payload) => {
      console.log('Profile update received:', payload.new);
      if (payload.new && payload.new.status) {
        updateUserStatusDisplay(payload.new.status);
        
        if (payload.new.status === 'premium') {
          showPremiumCelebration();
        }
      }
    })
    .subscribe(status => {
      console.log('Subscription status:', status);
    });
}

function restoreGameContext() {
  const savedContext = localStorage.getItem('gameContext');
  if (savedContext) {
    const context = JSON.parse(savedContext);
    gameState.currentStage = context.stage || 1;
    gameState.currentSet = context.set || 1;
    gameState.currentLevel = context.level;
    localStorage.removeItem('gameContext');
    return true;
  }
  return false;
}

function checkUpgradeStatus() {
  if (!currentUser) return false;
  
  const upgradeRequested = localStorage.getItem(`upgradeRequested_${currentUser.id}`);
  const isPremium = (currentUser.status === 'premium');
  const isPending = (currentUser.status === 'pending');
  
  return upgradeRequested || isPremium || isPending;
}

function navigateHome() {
  console.log('Navigating home with full refresh');
  saveProgress();
  window.location.reload(true);
}

function forceReload() {
  console.log('Force Reload Initiated');
  if (window.location) {
    window.location.href = window.location.href;
  }
  if (window.location.reload) {
    window.location.reload(true);
  }
  window.location.replace(window.location.pathname);
}

async function showLeaderboard() {
  showScreen('leaderboard-screen');
  
  const leaderboardContainer = document.getElementById('leaderboard-entries');
  
  try {
    async function updateLeaderboard() {
      const { data, error } = await supabaseClient
        .from('player_leaderboard')
        .select('*');
        
      if (error) {
        console.error('Leaderboard fetch error:', error);
        return;
      }
      
      // Store original positions for animation
      const existingEntries = leaderboardContainer.children;
      const originalPositions = {};
      
      Array.from(existingEntries).forEach(entry => {
        const username = entry.querySelector('[data-username]').dataset.username;
        originalPositions[username] = entry.getBoundingClientRect();
      });
      
      // Generate new leaderboard HTML
      leaderboardContainer.innerHTML = data.map((player, index) => `
                <div class="leaderboard-entry ${player.username === currentUser?.user_metadata?.username ? 'you' : ''} ${index < 3 ? `rank-${index+1}` : ''}"
                     data-rank="${index+1}">
                    <div>${player.player_rank}</div>
                    <div data-username="${player.username}">${player.username || 'Anonymous'}</div>
                    <div>${player.total_levels_completed}</div>
                    <div>${player.total_words_learned}</div>
                </div>
            `).join('');
            
      // Animate position changes
      const newEntries = leaderboardContainer.children;
      
      Array.from(newEntries).forEach(entry => {
        const username = entry.querySelector('[data-username]').dataset.username;
        
        if (originalPositions[username]) {
          const oldPos = originalPositions[username];
          const newPos = entry.getBoundingClientRect();
          const yDiff = oldPos.top - newPos.top;
          
          if (yDiff > 0) {
            entry.classList.add('moving-up');
          } else if (yDiff < 0) {
            entry.classList.add('moving-down');
          }
          
          entry.addEventListener('animationend', () => {
            entry.classList.remove('moving-up', 'moving-down');
          }, { once: true });
        }
      });
    }
    
    await updateLeaderboard();
    
    // Set up polling
    const pollInterval = setInterval(updateLeaderboard, 10000);
    const leaderboardScreen = document.getElementById('leaderboard-screen');
    
    if (leaderboardScreen) {
      // Store interval ID to clear it when leaving the screen
      if (leaderboardScreen.dataset.pollInterval) {
        clearInterval(parseInt(leaderboardScreen.dataset.pollInterval));
      }
      leaderboardScreen.dataset.pollInterval = pollInterval;
    }
  } catch (error) {
    console.error('Detailed leaderboard error:', error);
    leaderboardContainer.innerHTML = `<p>Error loading leaderboard: ${error.message}</p>`;
  }
}

function cleanupLeaderboard() {
  const leaderboardScreen = document.getElementById('leaderboard-screen');
  if (leaderboardScreen) {
    if (leaderboardScreen.dataset.channel) {
      supabaseClient.removeChannel(leaderboardScreen.dataset.channel);
      delete leaderboardScreen.dataset.channel;
    }
    
    if (leaderboardScreen.dataset.pollInterval) {
      clearInterval(parseInt(leaderboardScreen.dataset.pollInterval));
      delete leaderboardScreen.dataset.pollInterval;
    }
  }
}

async function updatePlayerStats(stage, set, level) {
  if (currentUser && currentUser.status === 'premium') {
    try {
      const { data, error } = await supabaseClient
        .from('player_stats')
        .select('*')
        .eq('user_id', currentUser.id)
        .single();
        
      if (error && error.code !== 'PGRST116') {
        throw error;
      }
      
      const uniqueWordsCount = [...new Set(currentGame.words)].length;
      
      const statsUpdate = {
        user_id: currentUser.id,
        total_levels_completed: (data?.total_levels_completed || 0) + 1,
        unique_words_practiced: (data?.unique_words_practiced || 0) + uniqueWordsCount,
        last_updated: new Date().toISOString()
      };
      
      const { error: updateError } = await supabaseClient
        .from('player_stats')
        .upsert(statsUpdate, { 
          onConflict: 'user_id',
          returning: 'minimal'
        });
        
      if (updateError) {
        throw updateError;
      }
      
      await WordsManager.updateWords(uniqueWordsCount);
    } catch (error) {
      console.error('Error updating player stats:', error);
    }
  }
}

function showNotification(message, type = 'info', duration = 2000) {
  const notification = document.createElement('div');
  notification.className = `game-notification ${type}`;
  notification.textContent = message;
  
  document.body.appendChild(notification);
  
  setTimeout(() => notification.classList.add('show'), 10);
  
  setTimeout(() => {
    notification.classList.remove('show');
    setTimeout(() => notification.remove(), 300);
  }, duration);
}

function createParticles(x, y) {
  const mobileDevice = window.matchMedia('(max-width: 768px)').matches;
  
  const config = mobileDevice ? {
    count: 10,
    size: 6,
    distance: 50,
    opacity: 0.7,
    duration: 1000
  } : {
    count: 40,
    size: 10,
    distance: 150,
    opacity: 1,
    duration: 1500
  };
  
  const colors = ['#ffd700', '#FFA500', '#4CAF50', '#FFD700'];
  const container = document.body;
  
  for (let i = 0; i < config.count; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
    particle.style.position = 'fixed';
    particle.style.left = `${x}px`;
    particle.style.top = `${y}px`;
    
    // Random angle and distance
    const angle = Math.random() * Math.PI * 2;
    const distance = config.distance + Math.random() * 50;
    
    particle.style.width = `${config.size}px`;
    particle.style.height = `${config.size}px`;
    particle.style.opacity = `${config.opacity}`;
    
    // Set custom properties for the CSS animation
    particle.style.setProperty('--x', Math.cos(angle) * distance + 'px');
    particle.style.setProperty('--y', Math.sin(angle) * distance + 'px');
    
    particle.style.animation = `particleBurst ${config.duration/1000}s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards`;
    
    container.appendChild(particle);
    
    setTimeout(() => {
      container.removeChild(particle);
    }, config.duration);
  }
}

function animateCoinsChange(element, oldValue, newValue) {
  if (!element) return;
  
  const fps = 1000 / (1000/60); // approx 60fps
  const steps = fps;
  const increment = (newValue - oldValue) / steps;
  
  let currentStep = 0;
  let currentValue = oldValue;
  
  function updateValue() {
    currentStep++;
    currentValue += increment;
    
    if (currentStep <= steps) {
      element.textContent = Math.round(currentValue);
      
      if (increment > 0) {
        element.style.color = 'var(--success)';
      } else if (increment < 0) {
        element.style.color = 'var(--error)';
      }
      
      requestAnimationFrame(updateValue);
    } else {
      element.textContent = newValue;
      setTimeout(() => {
        element.style.color = 'var(--text)';
      }, 300);
    }
  }
  
  updateValue();
}

function updateAllCoinDisplays() {
  document.querySelectorAll('.coin-count').forEach(element => {
    const oldValue = parseInt(element.textContent) || 0;
    let newValue;
    
    // Handle arcade mode
    if (window.location.pathname.includes('arcade')) {
      newValue = currentGame.coins || 0;
    } else {
      newValue = gameState.coins || 0;
    }
    
    animateNumber(element, Number(oldValue), Number(newValue));
  });
}

function animateNumber(element, fromValue, toValue, duration = 500) {
  if (fromValue === toValue) {
    element.textContent = toValue;
    return;
  }
  
  const increment = (toValue - fromValue) / 30;
  let currentValue = fromValue;
  let step = 0;
  
  requestAnimationFrame(function updateFrame() {
    currentValue += increment;
    step++;
    
    if (step >= 30 || 
        (increment > 0 && currentValue >= toValue) || 
        (increment < 0 && currentValue <= toValue)) {
      element.textContent = Math.round(toValue);
    } else {
      element.textContent = Math.round(currentValue);
      requestAnimationFrame(updateFrame);
    }
  });
}

function optimizeMobileRendering() {
  // Reduce particle count on mobile
  ParticleSystem.maxParticles = 20;
  
  // Debounce screen transitions
  const debouncedShowScreen = debounce(showScreen, 200);
  
  // Apply mobile optimizations
  if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    document.body.classList.add('mobile-device');
    
    // Add mobile-specific styles
    document.head.insertAdjacentHTML('beforeend', `
            <style>
                @media (max-width: 768px) {
                    .confetti, .particle {
                        display: none;
                    }
                }
            </style>
        `);
  }
}

function debounce(func, wait) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      clearTimeout(timeout);
      func(...args);
    }, wait);
  };
}

function optimizeMobileEvents() {
  // Use passive event listeners for better scrolling performance
  document.addEventListener('touchstart', () => {}, { passive: true });
  document.addEventListener('touchmove', () => {}, { passive: true });
}

function initAccessibilityMenu() {
  const accessibilityToggle = document.querySelector('.accessibility-toggle');
  const accessibilityModal = document.querySelector('.accessibility-modal');
  const closeButton = document.querySelector('.close-accessibility');
  
  // Load saved settings
  loadAccessibilitySettings();
  
  // Open modal
  if (accessibilityToggle && accessibilityModal) {
    accessibilityToggle.addEventListener('click', function() {
      accessibilityModal.classList.add('show');
    });
  }
  
  // Close modal
  if (closeButton && accessibilityModal) {
    closeButton.addEventListener('click', function() {
      accessibilityModal.classList.remove('show');
    });
    
    accessibilityModal.addEventListener('click', function(e) {
      if (e.target === accessibilityModal) {
        accessibilityModal.classList.remove('show');
      }
    });
  }
  
  // Set up buttons
  document.querySelectorAll('.accessibility-button').forEach(button => {
    button.addEventListener('click', function() {
      const action = this.getAttribute('data-action');
      
      if (applyAccessibilitySetting(action, this.getAttribute('data-value'))) {
        // Don't update active state for font size controls and reset
        if (action !== 'fontSize' && action !== 'reset') {
          // Remove active class from all buttons in this group
          document.querySelectorAll(`[data-action="${action}"]`)
            .forEach(btn => btn.classList.remove('active'));
            
          // Add active to this button
          this.classList.add('active');
        }
      }
    });
  });
}

function applyAccessibilitySetting(setting, value) {
  const body = document.body;
  
  switch (setting) {
    case 'contrast':
      body.classList.remove('high-contrast', 'inverted-colors');
      if (value === 'high') {
        body.classList.add('high-contrast');
      } else if (value === 'inverted') {
        body.classList.add('inverted-colors');
      }
      break;
      
    case 'theme':
      body.classList.remove('light-theme', 'dark-theme');
      if (value === 'light') {
        body.classList.add('light-theme');
      } else if (value === 'dark') {
        body.classList.add('dark-theme');
      }
      break;
      
    case 'saturation':
      body.classList.remove('grayscale');
      if (value === 'grayscale') {
        body.classList.add('grayscale');
      }
      break;
      
    case 'fontSize':
      let scale = parseFloat(getComputedStyle(body).getPropertyValue('--font-scale') || 1);
      
      if (value === 'increase') {
        scale = Math.min(scale + 0.1, 1.8);
        body.style.setProperty('--font-scale', scale);
        body.style.fontSize = `calc(1rem * ${scale})`;
      } else if (value === 'decrease') {
        scale = Math.max(scale - 0.1, 0.8);
        body.style.setProperty('--font-scale', scale);
        body.style.fontSize = `calc(1rem * ${scale})`;
      } else if (value === 'reset') {
        body.style.removeProperty('--font-scale');
        body.style.fontSize = '';
      }
      break;
      
    case 'fontFamily':
      body.classList.remove('dyslexic-font');
      if (value === 'dyslexic') {
        body.classList.add('dyslexic-font');
      }
      break;
      
    case 'letterSpacing':
      body.classList.remove('increased-letter-spacing');
      if (value === 'increased') {
        body.classList.add('increased-letter-spacing');
      }
      break;
      
    case 'animations':
      body.classList.remove('no-animations', 'reduced-animations');
      if (value === 'disabled') {
        body.classList.add('no-animations');
      } else if (value === 'reduced') {
        body.classList.add('reduced-animations');
      }
      break;
      
    case 'focus':
      body.classList.remove('high-focus');
      if (value === 'high') {
        body.classList.add('high-focus');
      }
      break;
      
    case 'buttonSize':
      body.classList.remove('large-buttons');
      if (value === 'large') {
        body.classList.add('large-buttons');
      }
      break;
      
    case 'cursorSize':
      body.classList.remove('large-cursor');
      if (value === 'large') {
        body.classList.add('large-cursor');
      }
      break;
      
    case 'reset':
      if (value === 'all') {
        resetAllAccessibilitySettings();
      }
      break;
      
    default:
      return false;
  }
  
  saveAccessibilitySettings();
  return true;
}

function saveAccessibilitySettings() {
  const body = document.body;
  const settings = {
    classNames: body.className,
    fontSize: body.style.fontSize,
    fontScale: body.style.getPropertyValue('--font-scale')
  };
  
  localStorage.setItem('accessibilitySettings', JSON.stringify(settings));
}

function loadAccessibilitySettings() {
  const savedSettings = localStorage.getItem('accessibilitySettings');
  if (savedSettings) {
    const settings = JSON.parse(savedSettings);
    const body = document.body;
    
    if (settings.classNames) {
      body.className = settings.classNames;
    }
    
    if (settings.fontSize) {
      body.style.fontSize = settings.fontSize;
    }
    
    if (settings.fontScale) {
      body.style.setProperty('--font-scale', settings.fontScale);
    }
    
    updateActiveButtons();
  }
}

function updateActiveButtons() {
  const body = document.body;
  
  // Map of class names to their corresponding button actions
  const classToAction = {
    'high-contrast': { action: 'contrast', value: 'high' },
    'inverted-colors': { action: 'contrast', value: 'inverted' },
    'light-theme': { action: 'theme', value: 'light' },
    'dark-theme': { action: 'theme', value: 'dark' },
    'grayscale': { action: 'saturation', value: 'grayscale' },
    'dyslexic-font': { action: 'fontFamily', value: 'dyslexic' },
    'increased-letter-spacing': { action: 'letterSpacing', value: 'increased' },
    'no-animations': { action: 'animations', value: 'disabled' },
    'reduced-animations': { action: 'animations', value: 'reduced' },
    'high-focus': { action: 'focus', value: 'high' },
    'large-buttons': { action: 'buttonSize', value: 'large' },
    'large-cursor': { action: 'cursorSize', value: 'large' }
  };
  
  // Update active state based on body classes
  Object.entries(classToAction).forEach(([className, actionInfo]) => {
    const hasClass = body.classList.contains(className);
    const button = document.querySelector(`[data-action="${actionInfo.action}"][data-value="${actionInfo.value}"]`);
    
    if (button) {
      if (hasClass) {
        button.classList.add('active');
      } else {
        button.classList.remove('active');
      }
    }
  });
  
  // Set default buttons to active if no option is selected in a category
  if (!document.querySelector('[data-action="contrast"].active')) {
    document.querySelector('[data-action="contrast"][data-value="normal"]')?.classList.add('active');
  }
  
  if (!document.querySelector('[data-action="theme"].active')) {
    document.querySelector('[data-action="theme"][data-value="default"]')?.classList.add('active');
  }
  
  if (!document.querySelector('[data-action="saturation"].active')) {
    document.querySelector('[data-action="saturation"][data-value="normal"]')?.classList.add('active');
  }
  
  if (!document.querySelector('[data-action="fontFamily"].active')) {
    document.querySelector('[data-action="fontFamily"][data-value="default"]')?.classList.add('active');
  }
  
  if (!document.querySelector('[data-action="letterSpacing"].active')) {
    document.querySelector('[data-action="letterSpacing"][data-value="normal"]')?.classList.add('active');
  }
  
  if (!document.querySelector('[data-action="animations"].active')) {
    document.querySelector('[data-action="animations"][data-value="enabled"]')?.classList.add('active');
  }
  
  if (!document.querySelector('[data-action="focus"].active')) {
    document.querySelector('[data-action="focus"][data-value="normal"]')?.classList.add('active');
  }
  
  if (!document.querySelector('[data-action="buttonSize"].active')) {
    document.querySelector('[data-action="buttonSize"][data-value="normal"]')?.classList.add('active');
  }
  
  if (!document.querySelector('[data-action="cursorSize"].active')) {
    document.querySelector('[data-action="cursorSize"][data-value="normal"]')?.classList.add('active');
  }
}

function resetAllAccessibilitySettings() {
  const body = document.body;
  
  // Remove all accessibility classes
  body.classList.remove(
    'high-contrast', 'inverted-colors', 
    'light-theme', 'dark-theme', 
    'grayscale', 
    'dyslexic-font', 
    'increased-letter-spacing', 
    'no-animations', 'reduced-animations', 
    'high-focus', 
    'large-buttons', 
    'large-cursor'
  );
  
  // Reset font size
  body.style.fontSize = '';
  body.style.removeProperty('--font-scale');
  
  // Reset active state of all buttons
  document.querySelectorAll('.accessibility-button.active').forEach(button => {
    button.classList.remove('active');
  });
  
  // Set default buttons as active
  document.querySelector('[data-action="contrast"][data-value="normal"]')?.classList.add('active');
  document.querySelector('[data-action="theme"][data-value="default"]')?.classList.add('active');
  document.querySelector('[data-action="saturation"][data-value="normal"]')?.classList.add('active');
  document.querySelector('[data-action="fontFamily"][data-value="default"]')?.classList.add('active');
  document.querySelector('[data-action="letterSpacing"][data-value="normal"]')?.classList.add('active');
  document.querySelector('[data-action="animations"][data-value="enabled"]')?.classList.add('active');
  document.querySelector('[data-action="focus"][data-value="normal"]')?.classList.add('active');
  document.querySelector('[data-action="buttonSize"][data-value="normal"]')?.classList.add('active');
  document.querySelector('[data-action="cursorSize"][data-value="normal"]')?.classList.add('active');
  
  // Clear saved settings
  localStorage.removeItem('accessibilitySettings');
}

function showScreen(screenId, forceRefresh = false) {
  if (screenId === 'welcome-screen') {
    console.log('Returning to welcome screen, clearing game context');
    localStorage.removeItem('gameContext');
  }
  
  console.log('showScreen called with:', {
    screenId: screenId,
    forceRefresh: forceRefresh,
    currentUser: currentUser ? currentUser.id : 'No user'
  });
  
  // Clean up leaderboard if leaving it
  if (document.querySelector('.screen.visible')?.id === 'leaderboard-screen') {
    cleanupLeaderboard();
  }
  
  // Clean up question screen if leaving it
  const currentScreen = document.querySelector('.screen.visible');
  if (currentScreen && currentScreen.id === 'question-screen') {
    clearTimer();
    isFrozen = false;
  }
  
  // Force refresh if requested
  if (forceRefresh && screenId === 'welcome-screen') {
    console.log('Initiating full page reload');
    saveProgress();
    window.location.reload(true);
    return;
  }
  
  // Hide all screens
  document.querySelectorAll('.screen').forEach(screen => {
    screen.classList.remove('visible');
    
    // Clean up any particle containers
    const particleContainer = screen.querySelector('.particle-container');
    if (particleContainer) {
      particleContainer.remove();
    }
  });
  
  // Show the requested screen
  const screen = document.getElementById(screenId);
  if (screen) {
    screen.classList.add('visible');
    
    // Initialize particles for the screen
    initializeParticles(screen);
    
    // Update coin displays
    updateAllCoinDisplays();
    
    // Handle screen-specific initializations
    switch (screenId) {
      case 'question-screen':
        updatePerkButtons();
        console.log('Question screen shown, checking for admin button');
        setTimeout(() => {
          addAdminTestButton();
        }, 100);
        break;
        
      case 'welcome-screen':
        if (restoreGameContext()) {
          startGame();
        }
        break;
        
      case 'stage-cascade-screen':
        return showStageCascadeScreen();
    }
    
    console.log(`Switched to screen: ${screenId}`);
  } else {
    console.error(`Screen with id ${screenId} not found`);
  }
}

function showLevelScreen(setNumber) {
  gameState.currentSet = setNumber;
  debugUnlockState();
  
  const levelContainer = document.getElementById('level-container');
  if (!levelContainer) return;
  
  levelContainer.innerHTML = '';
  
  const stage = gameStructure.stages[gameState.currentStage - 1];
  if (!stage) return;
  
  // Create level header
  const headerDiv = document.createElement('div');
  headerDiv.className = 'level-header';
  
  // Calculate completion percentage
  const totalLevels = stage.levelsPerSet;
  let completedLevels = 0;
  
  for (let i = 1; i <= totalLevels; i++) {
    const levelKey = `${gameState.currentStage}_${setNumber}_${i}`;
    if (gameState.perfectLevels.has(levelKey)) {
      completedLevels++;
    } else if (gameState.completedLevels.has(levelKey)) {
      completedLevels++;
    }
  }
  
  const completionPercentage = Math.round((completedLevels / totalLevels) * 100);
  const setIcon = getSetIcon(gameState.currentStage, setNumber);
  const setDescription = getSetDescription(gameState.currentStage, setNumber);
  
  headerDiv.innerHTML = `
        <div class="level-title-area">
            <div class="set-icon">
                <i class="${setIcon}"></i>
            </div>
            <div class="set-details">
                <div class="set-name">Stage ${gameState.currentStage} - Set ${setNumber}</div>
                <div class="set-desc">${setDescription}</div>
            </div>
        </div>
        <div class="set-progress">
            <div class="progress-bar">
                <div class="progress-fill" style="width: ${completionPercentage}%"></div>
            </div>
            <div class="progress-text">${completedLevels}/${totalLevels} levels</div>
        </div>
    `;
  
  levelContainer.appendChild(headerDiv);
  
  // Create level grid
  const levelGrid = document.createElement('div');
  levelGrid.className = 'level-grid';
  
  // Define test levels
  const testLevels = [3, 6, 9, 10, 13, 16, 19, 20];
  
  // Get unlocked levels for this set
  const setKey = `${gameState.currentStage}_${setNumber}`;
  if (!gameState.unlockedLevels[setKey]) {
    gameState.unlockedLevels[setKey] = new Set([1]);
  }
  
  console.log(`Rendering levels for ${setKey}. Unlocked levels:`, 
    Array.from(gameState.unlockedLevels[setKey] || []));
  
  for (let i = 1; i <= stage.levelsPerSet; i++) {
    const levelDiv = document.createElement('div');
    const levelKey = `${gameState.currentStage}_${setNumber}_${i}`;
    const isUnlocked = gameState.unlockedLevels[setKey]?.has(i);
    
    console.log(`Level ${i} unlocked:`, isUnlocked);
    
    const isPerfect = gameState.perfectLevels.has(levelKey);
    const isCompleted = gameState.completedLevels.has(levelKey);
    const isBoss = (i === stage.bossLevel);
    const isTest = testLevels.includes(i);
    
    levelDiv.className = 'level-item';
    
    if (isUnlocked) {
      levelDiv.classList.add('unlocked');
    }
    
    if (isPerfect) {
      levelDiv.classList.add('perfect');
    } else if (isCompleted) {
      levelDiv.classList.add('completed');
    }
    
    if (isBoss) {
      levelDiv.classList.add('boss');
    }
    
    if (isTest) {
      levelDiv.classList.add('test');
    }
    
    if (!isUnlocked) {
      levelDiv.classList.add('locked');
    }
    
    levelDiv.textContent = i;
    
    if (isUnlocked) {
      levelDiv.onclick = () => startLevel(i);
    }
    
    levelGrid.appendChild(levelDiv);
  }
  
  levelContainer.appendChild(levelGrid);
  
  // Add legend
  const legendDiv = document.createElement('div');
  legendDiv.className = 'level-type-legend';
  legendDiv.innerHTML = `
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, var(--accent), rgba(30, 144, 255, 0.7));"></div>
            <span>Normal</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, var(--success), #45b649);"></div>
            <span>Completed</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, var(--gold), #FFA500);"></div>
            <span>Perfect</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, var(--gold), var(--accent));"></div>
            <span>Boss</span>
        </div>
    `;
  
  levelContainer.appendChild(legendDiv);
  
  showScreen('level-screen');
}

function getSetIcon(stage, set) {
  if (set === 1) {
    return {
      1: 'fas fa-book',
      2: 'fas fa-graduation-cap',
      3: 'fas fa-school',
      4: 'fas fa-university',
      5: 'fas fa-brain'
    }[stage] || 'fas fa-star';
  } else {
    const icons = [
      'fas fa-book-open', 
      'fas fa-book-reader', 
      'fas fa-bookmark', 
      'fas fa-pencil-alt', 
      'fas fa-pen'
    ];
    
    return icons[(set - 2) % icons.length] || 'fas fa-star';
  }
}

function getSetDescription(stage, set) {
  return `${
    {
      1: 'Beginner',
      2: 'Elementary',
      3: 'Intermediate',
      4: 'Advanced',
      5: 'Expert'
    }[stage] || 'Advanced'
  } vocabulary - Group ${set}`;
}

function calculateWordsForLevel(level, vocabulary) {
  const totalWords = vocabulary.words.length;
  const remainingWords = totalWords - 50;

  // Create randomized indices if they don't exist
  if (!vocabulary.randomIndices) {
    vocabulary.randomIndices = Array.from({length: totalWords}, (_, i) => i);
    
    // Shuffle the indices
    for (let i = vocabulary.randomIndices.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [vocabulary.randomIndices[i], vocabulary.randomIndices[j]] = 
        [vocabulary.randomIndices[j], vocabulary.randomIndices[i]];
    }
    
    console.log('Created randomized word indices:', vocabulary.randomIndices);
  }

  // Boss level (level 21)
  if (level === 21) {
    return {
      startIndex: 0,
      count: totalWords,
      isBossLevel: true,
      speedChallenge: true,
      mixed: true,
      isTestLevel: true,
      isHebrewToEnglish: Math.random() < 0.5,
      testLevels: [],
      randomIndices: vocabulary.randomIndices
    };
  }

  // Levels 1-2
  if (level === 1 || level === 2) {
    const startIndex = 3 * (level - 1);
    return {
      startIndex: startIndex,
      count: 3,
      testLevels: [3, 10, 21],
      randomIndices: vocabulary.randomIndices.slice(startIndex, startIndex + 3)
    };
  }

  // Level 3 (test)
  if (level === 3) {
    return {
      startIndex: 0,
      count: 6,
      isTestLevel: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabulary.randomIndices.slice(0, 6)
    };
  }

  // Levels 4-5
  if (level === 4 || level === 5) {
    const startIndex = 6 + 3 * (level - 4);
    return {
      startIndex: startIndex,
      count: 3,
      testLevels: [6, 10, 21],
      randomIndices: vocabulary.randomIndices.slice(startIndex, startIndex + 3)
    };
  }

  // Level 6 (test)
  if (level === 6) {
    return {
      startIndex: 6,
      count: 6,
      isTestLevel: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabulary.randomIndices.slice(6, 12)
    };
  }

  // Levels 7-8
  if (level === 7 || level === 8) {
    const startIndex = 12 + 4 * (level - 7);
    return {
      startIndex: startIndex,
      count: 4,
      testLevels: [9, 10, 21],
      randomIndices: vocabulary.randomIndices.slice(startIndex, startIndex + 4)
    };
  }

  // Level 9 (test)
  if (level === 9) {
    return {
      startIndex: 12,
      count: 8,
      isTestLevel: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabulary.randomIndices.slice(12, 20)
    };
  }

  // Level 10 (speed challenge)
  if (level === 10) {
    return {
      startIndex: 0,
      count: 20,
      isTestLevel: true,
      speedChallenge: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabulary.randomIndices.slice(0, 20)
    };
  }

  // Levels 11-12
  if (level === 11 || level === 12) {
    const startIndex = 20 + 4 * (level - 11);
    return {
      startIndex: startIndex,
      count: 4,
      testLevels: [13, 20, 21],
      randomIndices: vocabulary.randomIndices.slice(startIndex, startIndex + 4)
    };
  }

  // Level 13 (test)
  if (level === 13) {
    return {
      startIndex: 20,
      count: 8,
      isTestLevel: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabulary.randomIndices.slice(20, 28)
    };
  }

  // Levels 14-15
  if (level === 14 || level === 15) {
    const count = level === 14 ? 5 : 6;
    const startIndex = 28 + (level === 14 ? 0 : 5);
    return {
      startIndex: startIndex,
      count: count,
      testLevels: [16, 20, 21],
      randomIndices: vocabulary.randomIndices.slice(startIndex, startIndex + count)
    };
  }

  // Level 16 (test)
  if (level === 16) {
    return {
      startIndex: 28,
      count: 11,
      isTestLevel: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabulary.randomIndices.slice(28, 39)
    };
  }

  // Levels 17-18
  if (level === 17 || level === 18) {
    const count = level === 17 ? 5 : 6;
    const extraWords = remainingWords > 0 ? remainingWords : 0;
    const totalCount = count + (extraWords);
    const startIndex = 39 + (level === 17 ? 0 : count);
    return {
      startIndex: startIndex,
      count: totalCount,
      testLevels: [19, 20, 21],
      randomIndices: vocabulary.randomIndices.slice(startIndex, startIndex + totalCount)
    };
  }

  // Level 19 (test)
  if (level === 19) {
    return {
      startIndex: 39,
      count: 11,
      isTestLevel: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabulary.randomIndices.slice(39, 50)
    };
  }

  // Level 20 (speed challenge)
  if (level === 20) {
    return {
      startIndex: 20,
      count: 30,
      isTestLevel: true,
      speedChallenge: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabulary.randomIndices.slice(20, 50)
    };
  }
}

function updateProgressCircle() {
  const progressCircle = document.querySelector('.progress-circle .progress');
  const circleContainer = document.querySelector('.progress-circle');
  
  const circumference = 2 * Math.PI * 54;
  const progress = currentGame.currentIndex / currentGame.words.length;
  
  progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
  progressCircle.style.strokeDashoffset = circumference * (1 - progress);
  
  // Change color based on progress
  let hue, saturation, lightness;
  
  if (progress <= 0.2) {
    hue = 0;
    saturation = 100;
    lightness = 20;
  } else if (progress <= 0.4) {
    hue = 0;
    saturation = 100;
    lightness = 50;
  } else if (progress <= 0.6) {
    hue = 30;
    saturation = 100;
    lightness = 50;
  } else if (progress <= 0.8) {
    hue = 120;
    saturation = 100;
    lightness = 40;
  } else {
    const blend = (progress - 0.8) * 5;
    hue = 120 * (1 - blend) + 60 * blend;
    saturation = 100;
    lightness = 40 + 20 * blend;
  }
  
  progressCircle.style.stroke = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}

function loadNextQuestion() {
  // Reset any previous button states
  document.querySelectorAll('.buttons button').forEach(button => {
    button.classList.remove('correct', 'wrong');
  });
  
  // If we're at the end of the words list, we're done
  if (currentGame.currentIndex >= currentGame.words.length) {
    return;
  }
  
  // Determine if this question should show Hebrew->English or English->Hebrew
  const isTestLevel = [3, 6, 9, 10, 13, 16, 19, 20, 21].includes(gameState.currentLevel);
  const useHebToEng = isTestLevel && Math.random() < 0.5;
  
  const wordIndex = currentGame.currentIndex;
  const questionWord = useHebToEng 
    ? currentGame.translations[wordIndex] 
    : currentGame.words[wordIndex];
  
  document.getElementById('question-word').textContent = questionWord;
  
  // Get the correct answer
  const correctAnswer = useHebToEng 
    ? currentGame.words[wordIndex] 
    : currentGame.translations[wordIndex];
  
  // Get possible answers (including the correct one)
  const possibleAnswers = useHebToEng 
    ? currentGame.words 
    : currentGame.translations;
  
  const answers = new Set([correctAnswer]);
  
  // Add random incorrect answers until we have 3 options
  while (answers.size < 3) {
    const randomAnswer = possibleAnswers[Math.floor(Math.random() * possibleAnswers.length)];
    if (randomAnswer !== correctAnswer) {
      answers.add(randomAnswer);
    }
  }
  
  // Randomize answer order
  const buttonsContainer = document.getElementById('buttons');
  buttonsContainer.innerHTML = '';
  
  Array.from(answers).sort(() => Math.random() - 0.5).forEach(answer => {
    const button = document.createElement('button');
    button.textContent = answer;
    button.onclick = () => handleAnswer(answer === correctAnswer);
    buttonsContainer.appendChild(button);
  });
}

// part 4

// Animate coins change
function animateCoinsChange(element, oldValue, newValue) {
  if (!element) return;
  
  const duration = 1000;
  const fps = 1000 / 60;
  const steps = duration / fps;
  const increment = (newValue - oldValue) / steps;
  
  let step = 0;
  let currentValue = oldValue;
  
  function animate() {
    step++;
    currentValue += increment;
    
    if (step <= steps) {
      element.textContent = Math.round(currentValue);
      
      if (increment > 0) {
        element.style.color = "var(--success)";
      } else if (increment < 0) {
        element.style.color = "var(--error)";
      }
      
      requestAnimationFrame(animate);
    } else {
      element.textContent = newValue;
      setTimeout(() => {
        element.style.color = "var(--text)";
      }, 300);
    }
  }
  
  animate();
}

// Update all coin displays
function updateAllCoinDisplays() {
  document.querySelectorAll('.coin-count').forEach(element => {
    const oldValue = parseInt(element.textContent) || 0;
    let newValue;
    
    newValue = gameState.coins || 0;
    
    animateNumber(element, Number(oldValue), Number(newValue));
  });
}

// Animate number
function animateNumber(element, oldValue, newValue, duration = 500) {
  if ((oldValue = Number(oldValue)) === (newValue = Number(newValue))) {
    element.textContent = newValue;
    return;
  }
  
  const increment = (newValue - oldValue) / 30;
  let current = oldValue;
  let step = 0;
  
  requestAnimationFrame(function animate() {
    current += increment;
    step++;
    
    if (step >= 30 || (increment > 0 && current >= newValue) || (increment < 0 && current <= newValue)) {
      element.textContent = Math.round(newValue);
    } else {
      element.textContent = Math.round(current);
      requestAnimationFrame(animate);
    }
  });
}

// Buy perk
function buyPerk(perkType) {
  const perkConfig = PERK_CONFIG[perkType];
  const perkBtn = document.getElementById(`${perkType}Perk`);
  
  if (!perkConfig) {
    console.error('Invalid perk type:', perkType);
    return;
  }
  
  if (gameState.coins < perkConfig.cost) {
    showNotification(`Need ${perkConfig.cost} coins for ${perkConfig.name}!`, 'error');
    return;
  }
  
  gameState.coins -= perkConfig.cost;
  
  const countElement = perkBtn.querySelector('.perk-count');
  const oldCount = parseInt(countElement.textContent) || 0;
  
  animateNumberChange(countElement, oldCount, oldCount - 1);
  
  switch (perkType) {
    case 'timeFreeze':
      isFrozen = true;
      perkBtn.disabled = true;
      setTimeout(() => {
        isFrozen = false;
        perkBtn.disabled = false;
      }, perkConfig.duration);
      break;
      
    case 'skip':
      handleAnswer(true, true);
      break;
      
    case 'clue':
      eliminateWrongAnswer();
      break;
      
    case 'reveal':
      revealCorrectAnswer();
      break;
  }
  
  updateAllCoinDisplays();
  
  if (perkBtn) {
    perkBtn.disabled = gameState.coins < perkConfig.cost;
    perkBtn.classList.toggle('disabled', gameState.coins < perkConfig.cost);
  }
  
  saveProgress();
}

// Animate number change
function animateNumberChange(element, oldValue, newValue) {
  if (!element) return;
  
  const increment = (newValue - oldValue) / 20;
  let step = 0;
  let current = oldValue;
  
  requestAnimationFrame(function animate() {
    step++;
    current += increment;
    
    if (step <= 20) {
      element.textContent = Math.round(current);
      requestAnimationFrame(animate);
    } else {
      element.textContent = newValue;
    }
  });
}

// Update perk buttons
function updatePerkButtons() {
  Object.entries(PERK_CONFIG).forEach(([perk, config]) => {
    const button = document.getElementById(`${perk}Perk`);
    if (button) {
      const affordableCount = Math.floor(gameState.coins / config.cost);
      const isAffordable = affordableCount > 0;
      
      button.disabled = !isAffordable;
      button.classList.toggle('disabled', !isAffordable);
      
      const countElement = button.querySelector('.perk-count');
      if (countElement) {
        countElement.textContent = isAffordable ? affordableCount.toString() : '0';
      }
    }
  });
}

// Eliminate wrong answer
function eliminateWrongAnswer() {
  const buttons = document.querySelectorAll('.buttons button');
  const correctAnswer = currentGame.isHebrewToEnglish 
    ? currentGame.words[currentGame.currentIndex] 
    : currentGame.translations[currentGame.currentIndex];
  
  const wrongButtons = Array.from(buttons).filter(
    button => button.textContent !== correctAnswer
  );
  
  if (wrongButtons.length > 0) {
    const buttonToDisable = wrongButtons[Math.floor(Math.random() * wrongButtons.length)];
    buttonToDisable.disabled = true;
    buttonToDisable.style.opacity = '0.5';
  }
}

// Reveal correct answer
function revealCorrectAnswer() {
  const correctAnswer = currentGame.isHebrewToEnglish 
    ? currentGame.words[currentGame.currentIndex] 
    : currentGame.translations[currentGame.currentIndex];
  
  document.querySelectorAll('.buttons button').forEach(button => {
    if (button.textContent === correctAnswer) {
      button.classList.add('correct');
      setTimeout(() => {
        currentGame.correctAnswers++;
        currentGame.currentIndex++;
        loadNextQuestion();
      }, 1000);
    } else {
      button.disabled = true;
      button.style.opacity = '0.5';
    }
  });
}

// Handle level completion
function handleLevelCompletion() {
  clearTimer();
  
  // Mark level as completed
  const levelKey = `${gameState.currentStage}_${gameState.currentSet}_${gameState.currentLevel}`;
  console.log(`Completing level: ${levelKey}`);
  
  const alreadyCompleted = gameState.perfectLevels.has(levelKey) || gameState.completedLevels.has(levelKey);
  console.log(`Level was previously completed: ${alreadyCompleted}`);
  
  // Check for perfect completion
  const isPerfect = currentGame.streakBonus && currentGame.correctAnswers === currentGame.words.length;
  
  if (!alreadyCompleted && isPerfect) {
    const bonusCoins = 5;
    CoinsManager.updateCoins(bonusCoins).then(() => {
      updateLevelProgress(gameState.currentStage, gameState.currentSet, gameState.currentLevel, true, true);
      
      const screenRect = document.getElementById('question-screen').getBoundingClientRect();
      createParticles(screenRect.left + screenRect.width / 2, screenRect.top + screenRect.height / 2);
    });
  } else if (!alreadyCompleted) {
    updateLevelProgress(gameState.currentStage, gameState.currentSet, gameState.currentLevel, true, false);
  }
  
  pulseCoins(5);
  updatePerkButtons();
  
  // Check if we need to advance to next level/set
  const stageInfo = gameStructure.stages[gameState.currentStage - 1];
  const isLastLevelInSet = gameState.currentLevel === stageInfo.levelsPerSet;
  const isLastSetInStage = gameState.currentSet === stageInfo.numSets;
  
  // Check user status for stage advancement
  const userStatus = currentUser ? currentUser.status : 'unregistered';
  
  if (isLastLevelInSet) {
    checkSetCompletion(gameState.currentStage, gameState.currentSet);
    
    if (isLastSetInStage) {
      if (userStatus === 'premium' && gameState.currentStage < 5) {
        setTimeout(() => {
          gameState.currentStage++;
          gameState.currentSet = 1;
          gameState.currentLevel = 1;
          startLevel(1);
        }, 1500);
      } else {
        setTimeout(() => showScreen('stage-cascade-screen'), 1500);
      }
    } else {
      setTimeout(() => {
        gameState.currentSet++;
        gameState.currentLevel = 1;
        startLevel(1);
      }, 1500);
    }
  } else {
    setTimeout(() => {
      gameState.currentLevel++;
      startLevel(gameState.currentLevel);
    }, 1500);
  }
}

// Check set completion
function checkSetCompletion(stage, set) {
  const totalLevels = gameStructure.stages[stage - 1].levelsPerSet;
  let completedLevels = 0;
  
  for (let level = 1; level <= totalLevels; level++) {
    const levelKey = `${stage}_${set}_${level}`;
    if (gameState.completedLevels.has(levelKey) || gameState.perfectLevels.has(levelKey)) {
      completedLevels++;
    }
  }
  
  console.log(`Set ${stage}-${set} completion: ${completedLevels}/${totalLevels}`);
  
  if (completedLevels === totalLevels) {
    console.log(`Set ${stage}-${set} is complete. Unlocking next set.`);
    unlockNextSet();
  }
}

// Handle progression
function handleProgression(shouldAdvance) {
  // Unlock current level in the set
  const setKey = `${gameState.currentStage}_${gameState.currentSet}`;
  if (!gameState.unlockedLevels[setKey]) {
    gameState.unlockedLevels[setKey] = new Set();
  }
  gameState.unlockedLevels[setKey].add(gameState.currentLevel);
  
  // Check if we need to unlock next stage/set/level
  const stageInfo = gameStructure.stages[gameState.currentStage - 1];
  const isLastLevelInSet = gameState.currentLevel === stageInfo.levelsPerSet;
  const isLastSetInStage = gameState.currentSet === stageInfo.numSets;
  
  if (isLastLevelInSet) {
    if (isLastSetInStage) {
      if (gameState.currentStage < 5) {
        unlockNextStage();
      }
    } else {
      unlockNextSet();
    }
  } else {
    // Unlock next level in current set
    gameState.unlockedLevels[setKey].add(gameState.currentLevel + 1);
  }
  
  saveProgress();
  updateAllCoinDisplays();
  
  // Progress to next level if needed
  setTimeout(() => {
    if (isLastLevelInSet) {
      if (isLastSetInStage) {
        if (gameState.currentStage < 5) {
          gameState.currentStage++;
          gameState.currentSet = 1;
          startLevel(1);
        } else {
          showScreen('stage-screen');
        }
      } else {
        gameState.currentSet++;
        startLevel(1);
      }
    } else {
      startLevel(gameState.currentLevel + 1);
    }
  }, 1500);
}

// Create completion particles
function createCompletionParticles() {
  const screenRect = document.getElementById('question-screen').getBoundingClientRect();
  const centerX = screenRect.left + screenRect.width / 2;
  const centerY = screenRect.top + screenRect.height / 2;
  
  for (let i = 0; i < 5; i++) {
    setTimeout(() => createParticles(centerX, centerY), i * 300);
  }
}

// Create particles
function createParticles(x, y) {
  const isMobile = window.matchMedia('(max-width: 768px)').matches;
  
  const config = isMobile ? {
    count: 10,
    size: 6,
    distance: 50,
    opacity: 0.7,
    duration: 1000
  } : {
    count: 40,
    size: 10,
    distance: 150,
    opacity: 1,
    duration: 1500
  };
  
  const colors = ['#ffd700', '#FFA500', '#4CAF50', '#FFD700'];
  const body = document.body;
  
  for (let i = 0; i < config.count; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
    particle.style.position = 'fixed';
    particle.style.left = `${x}px`;
    particle.style.top = `${y}px`;
    
    const angle = Math.random() * Math.PI * 2;
    const distance = config.distance + Math.random() * 50;
    
    particle.style.width = `${config.size}px`;
    particle.style.height = `${config.size}px`;
    particle.style.opacity = `${config.opacity}`;
    
    particle.style.setProperty('--x', Math.cos(angle) * distance + 'px');
    particle.style.setProperty('--y', Math.sin(angle) * distance + 'px');
    
    particle.style.animation = `particleBurst ${config.duration / 1000}s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards`;
    
    body.appendChild(particle);
    
    setTimeout(() => {
      body.removeChild(particle);
    }, config.duration);
  }
}

// Start timer
function startTimer(wordCount) {
  clearTimer();
  
  if (currentGame.currentIndex >= currentGame.words.length) {
    return;
  }
  
  // Set initial time based on number of words
  if (!currentGame.initialTimeRemaining) {
    currentGame.initialTimeRemaining = wordCount * 10;
    timeRemaining = currentGame.initialTimeRemaining;
    currentGame.totalTime = timeRemaining;
  } else {
    timeRemaining = currentGame.initialTimeRemaining;
  }
  
  console.log('Starting timer with:', timeRemaining, 'seconds');
  
  currentGame.questionStartTime = Date.now();
  updateTimerDisplay();
  updateTimerCircle(timeRemaining, currentGame.totalTime);
  
  timer = setInterval(() => {
    if (!isFrozen) {
      timeRemaining = Math.max(0, timeRemaining - 1);
      updateTimerDisplay();
      updateTimerCircle(timeRemaining, currentGame.totalTime);
      currentGame.initialTimeRemaining = timeRemaining;
      
      if (timeRemaining <= 10) {
        document.querySelector('.timer-value').classList.add('warning');
      }
      
      if (timeRemaining <= 0) {
        handleTimeUp();
      }
    }
  }, 1000);
}

// Update timer display
function updateTimerDisplay() {
  const minutes = Math.floor(timeRemaining / 60);
  const seconds = timeRemaining % 60;
  
  const timerValue = document.querySelector('.timer-value');
  timerValue.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
  
  if (timeRemaining <= 10) {
    timerValue.classList.add('warning');
  } else {
    timerValue.classList.remove('warning');
  }
}

// Clear timer
function clearTimer() {
  if (timer) {
    clearInterval(timer);
    timer = null;
  }
  
  timeRemaining = 0;
  isFrozen = false;
  
  const progressElement = document.querySelector('.timer-progress');
  if (progressElement) {
    progressElement.classList.remove('warning');
  }
  
  updateTimerCircle(0, 1);
}

// Update timer circle
function updateTimerCircle(current, total) {
  const progressCircle = document.querySelector('.timer-progress');
  if (!progressCircle) return;
  
  const circumference = 2 * Math.PI * 40;
  progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
  
  const offset = circumference * (1 - current / total);
  progressCircle.style.strokeDashoffset = offset;
  
  if (current <= 10) {
    progressCircle.classList.add('warning');
  } else {
    progressCircle.classList.remove('warning');
  }
}

// Handle time up
function handleTimeUp() {
  if (currentGame.currentIndex >= currentGame.words.length) {
    return;
  }
  
  clearTimer();
  showReviveOverlay();
}

// Show revive overlay
function showReviveOverlay() {
  const overlay = document.createElement('div');
  overlay.className = 'revive-overlay';
  overlay.innerHTML = `
    <div class="revive-content">
      <div class="ankh-symbol">☥</div>
      <h2 class="revive-title">Revive?</h2>
      <div class="revive-timer">5</div>
      <button class="revive-button">Revive</button>
    </div>
  `;
  
  document.body.appendChild(overlay);
  
  requestAnimationFrame(() => {
    overlay.classList.add('show');
  });
  
  let countdown = 5;
  const timerElement = overlay.querySelector('.revive-timer');
  
  const interval = setInterval(() => {
    countdown--;
    timerElement.textContent = countdown;
    
    if (countdown <= 0) {
      clearInterval(interval);
      handleReviveTimeout();
    }
  }, 1000);
  
  overlay.querySelector('.revive-button').onclick = () => {
    clearInterval(interval);
    handleRevive();
  };
  
  overlay.dataset.intervalId = interval;
}

// Handle revive timeout
function handleReviveTimeout() {
  const overlay = document.querySelector('.revive-overlay');
  if (overlay) {
    overlay.classList.remove('show');
    setTimeout(() => {
      overlay.remove();
      showScreen('welcome-screen');
    }, 500);
  }
}

// Handle revive
function handleRevive() {
  const overlay = document.querySelector('.revive-overlay');
  if (overlay) {
    overlay.querySelector('.revive-content').innerHTML = `
      <div class="resurrection-animation">
        <div class="progress-circle resurrection-circle">
          <svg width="100%" height="100%" viewBox="0 0 120 120">
            <circle class="bg" cx="60" cy="60" r="54" stroke-width="8"/>
            <circle class="resurrection-progress" cx="60" cy="60" r="54" stroke-width="8"/>
          </svg>
          <div class="ankh-symbol resurrection-ankh">☥</div>
        </div>
      </div>
    `;
    
    const progressElement = overlay.querySelector('.resurrection-progress');
    const circumference = 2 * Math.PI * 54;
    
    progressElement.style.strokeDasharray = `${circumference} ${circumference}`;
    progressElement.style.strokeDashoffset = circumference;
    
    createResurrectionParticles();
    
    setTimeout(() => {
      progressElement.style.transition = 'stroke-dashoffset 2s cubic-bezier(0.4, 0, 0.2, 1)';
      progressElement.style.strokeDashoffset = '0';
    }, 100);
    
    setTimeout(() => {
      overlay.classList.remove('show');
      setTimeout(() => {
        overlay.remove();
        currentGame.wrongStreak = 0;
        timeRemaining = currentGame.initialTimeRemaining;
        startLevel(gameState.currentLevel);
      }, 500);
    }, 2500);
  }
}

// Create resurrection particles
function createResurrectionParticles() {
  const animationContainer = document.querySelector('.resurrection-animation');
  if (!animationContainer) return;
  
  const rect = animationContainer.getBoundingClientRect();
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;
  
  for (let i = 0; i < 40; i++) {
    const particle = document.createElement('div');
    particle.className = 'resurrection-particle';
    
    const angle = Math.random() * Math.PI * 2;
    const distance = 100 + Math.random() * 150;
    const duration = 1 + Math.random() * 1.5;
    const delay = Math.random() * 0.5;
    const size = 3 + Math.random() * 7;
    
    const endX = Math.cos(angle) * distance;
    const endY = Math.sin(angle) * distance;
    
    particle.style.cssText = `
      position: fixed;
      left: ${centerX}px;
      top: ${centerY}px;
      width: ${size}px;
      height: ${size}px;
      background: #FFD700;
      border-radius: 50%;
      opacity: 0;
      z-index: 1001;
      box-shadow: 0 0 ${size}px #FFD700;
      transform: translate(-50%, -50%);
      animation: particleFlow ${duration}s ease-out ${delay}s forwards;
    `;
    
    particle.style.setProperty('--end-x', `${endX}px`);
    particle.style.setProperty('--end-y', `${endY}px`);
    
    document.body.appendChild(particle);
    
    setTimeout(() => {
      particle.remove();
    }, (duration + delay) * 1000 + 100);
  }
}

// Update level progress
function updateLevelProgress(stage, set, level, completed, perfect) {
  const levelKey = `${stage}_${set}_${level}`;
  
  if (perfect) {
    gameState.perfectLevels.add(levelKey);
    gameState.completedLevels.add(levelKey);
  } else if (completed) {
    gameState.completedLevels.add(levelKey);
  }
  
  // Unlock next level if available
  const setKey = `${stage}_${set}`;
  if (!gameState.unlockedLevels[setKey]) {
    gameState.unlockedLevels[setKey] = new Set();
  }
  gameState.unlockedLevels[setKey].add(level);
  
  const nextLevel = level + 1;
  const isLastLevel = level === gameStructure.stages[stage - 1].levelsPerSet;
  
  if (!isLastLevel) {
    gameState.unlockedLevels[setKey].add(nextLevel);
    console.log(`Unlocked next level: ${nextLevel} in set ${setKey}`);
  }
  
  if (isLastLevel && completed) {
    checkSetCompletion(stage, set);
  }
  
  saveProgress();
}

// Unlock next set
function unlockNextSet() {
  const stage = gameState.currentStage;
  const currentSet = gameState.currentSet;
  const stageInfo = gameStructure.stages[stage - 1];
  
  if (stageInfo) {
    if (currentSet < stageInfo.numSets) {
      const nextSet = currentSet + 1;
      
      if (!gameState.unlockedSets[stage]) {
        gameState.unlockedSets[stage] = new Set();
      }
      
      gameState.unlockedSets[stage].add(nextSet);
      
      const nextSetKey = `${stage}_${nextSet}`;
      if (!gameState.unlockedLevels[nextSetKey]) {
        gameState.unlockedLevels[nextSetKey] = new Set();
      }
      
      gameState.unlockedLevels[nextSetKey].add(1);
      
      console.log(`Unlocked set ${stage}-${nextSet} and its first level`);
      saveProgress();
    } else if (stage < 5) {
      unlockNextStage();
    }
  } else {
    console.error(`Invalid stage: ${stage}`);
  }
}

// Unlock next stage
function unlockNextStage() {
  const currentStage = gameState.currentStage;
  
  if (currentStage < 5) {
    const nextStage = currentStage + 1;
    
    if (!gameState.unlockedSets[nextStage]) {
      gameState.unlockedSets[nextStage] = new Set();
    }
    
    gameState.unlockedSets[nextStage].add(1);
    
    const nextStageFirstSetKey = `${nextStage}_1`;
    if (!gameState.unlockedLevels[nextStageFirstSetKey]) {
      gameState.unlockedLevels[nextStageFirstSetKey] = new Set();
    }
    
    gameState.unlockedLevels[nextStageFirstSetKey].add(1);
    
    console.log(`Unlocked stage ${nextStage}, set 1, level 1`);
    saveProgress();
  }
}

// Show level intro
function showLevelIntro(level, callback) {
  const overlay = document.createElement('div');
  overlay.className = 'slide-transition';
  
  const isTestLevel = [3, 6, 9, 10, 13, 16, 19, 20].includes(level);
  const isBossLevel = level === 21;
  
  let levelClass = 'normal-level';
  if (isTestLevel) levelClass = 'test-level';
  if (isBossLevel) levelClass = 'boss-level';
  
  overlay.innerHTML = `
    <div class="slide-panel-left"></div>
    <div class="slide-panel-right"></div>
    <div class="level-announcement ${levelClass}">
      <h1>${isBossLevel ? 'BOSS FIGHT!' : `Stage ${gameState.currentStage}`}</h1>
      <h2>${isBossLevel ? 'FINAL CHALLENGE' : `Level ${gameState.currentSet}-${level}`}</h2>
      ${isTestLevel ? '<div class="test-badge">Review Challenge</div>' : ''}
      ${isBossLevel ? '<div class="boss-badge">DANGER ZONE</div>' : ''}
    </div>
  `;
  
  document.body.appendChild(overlay);
  
  const announcement = overlay.querySelector('.level-announcement');
  
  // Trigger reflow
  overlay.offsetHeight;
  
  overlay.classList.add('show');
  announcement.classList.add('show');
  
  // Special styling for boss level
  if (isBossLevel) {
    const announcementElement = overlay.querySelector('.level-announcement');
    if (announcementElement) {
      announcementElement.style.background = 'linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%)';
      announcementElement.style.boxShadow = '0 0 30px rgba(255, 0, 0, 0.5)';
      
      const title = announcementElement.querySelector('h1');
      if (title) {
        title.style.color = '#ffffff';
        title.style.textShadow = '0 0 20px rgba(255, 0, 0, 0.8)';
      }
    }
  }
  
  setTimeout(() => {
    callback();
    overlay.classList.remove('show');
    announcement.classList.remove('show');
    
    setTimeout(() => {
      document.body.removeChild(overlay);
    }, 400);
  }, 1500);
}

// Award time bonus
function awardTimeBonus() {
  const elapsedTime = (Date.now() - currentGame.questionStartTime) / 1000;
  
  if (elapsedTime < 10) {
    const bonus = Math.floor(10 - elapsedTime);
    currentGame.timeBonus += bonus;
    return bonus;
  }
  
  return 0;
}

// Pulse coins
function pulseCoins(times = 1) {
  document.querySelectorAll('.coin-icon').forEach(coin => {
    let count = 0;
    
    const pulse = () => {
      coin.classList.add('coin-pulse');
      
      setTimeout(() => {
        coin.classList.remove('coin-pulse');
        count++;
        
        if (count < times) {
          setTimeout(pulse, 100);
        }
      }, 500);
    };
    
    pulse();
  });
}

// Start level
function startLevel(level) {
  gameState.currentLevel = level;
  
  // Save game context
  const context = {
    stage: gameState.currentStage,
    set: gameState.currentSet,
    level,
    timestamp: Date.now()
  };
  
  console.log('Setting game context at level start:', context);
  localStorage.setItem('gameContext', JSON.stringify(context));
  
  // Reset game state
  currentGame.wrongStreak = 0;
  currentGame.correctAnswers = 0;
  currentGame.levelStartTime = Date.now();
  currentGame.firstAttempt = true;
  currentGame.streakBonus = true;
  
  updatePerkButtons();
  
  console.log('Current unlocked levels:', gameState.unlockedLevels);
  
  const setKey = `${gameState.currentStage}_${gameState.currentSet}`;
  console.log(`Current set key: ${setKey}, unlocked levels in set:`, 
    gameState.unlockedLevels[setKey] 
      ? Array.from(gameState.unlockedLevels[setKey]) 
      : 'none'
  );
  
  // Configure UI elements
  const perksContainer = document.querySelector('.perks-container');
  const powerupsContainer = document.querySelector('.powerups-container');
  
  if (perksContainer) {
    perksContainer.style.display = 'flex';
  }
  
  if (powerupsContainer) {
    powerupsContainer.style.display = 'none';
  }
  
  const coinsElement = document.querySelector('.coin-count');
  if (coinsElement) {
    coinsElement.textContent = gameState.coins || 0;
  }
  
  const coinsContainer = document.querySelector('.coins-container');
  if (coinsContainer) {
    coinsContainer.style.display = 'flex';
  }
  
  // Set stage if not set
  gameState.currentStage = gameState.currentStage || 1;
  gameState.currentSet = gameState.currentSet || 1;
  gameState.currentLevel = level;
  
  console.log(`Starting level: Stage ${gameState.currentStage}, Set ${gameState.currentSet}, Level ${level}`);
  
  // Add admin test button
  addAdminTestButton();
  
  // Check user status for premium features
  const userStatus = currentUser ? currentUser.status : 'unregistered';
  
  // Check if level requires premium
  if ([2, 7, 11, 15, 20].includes(level) && userStatus !== 'premium') {
    const savedLevel = level;
    
    if (!currentUser) {
      return showUnregisteredWarning(() => {
        proceedWithLevel(savedLevel);
      });
    } else if (!localStorage.getItem(`upgradeRequested_${currentUser.id}`)) {
      return showUpgradePrompt(() => {
        proceedWithLevel(savedLevel);
      });
    }
  }
  
  // Special setup for boss level
  if (level === 21) {
    currentGame.isBossLevel = true;
    console.log('Boss level detected');
    setTimeout(applyBossLevelStyles, 100);
    setTimeout(applyBossLevelStyles, 500);
  } else {
    currentGame.isBossLevel = false;
  }
  
  proceedWithLevel(level);
}

// Proceed with level
function proceedWithLevel(level) {
  // Ensure we have restart count
  currentGame.restartsRemaining = currentGame.restartsRemaining || 2;
  gameState.currentLevel = level;
  
  // Get vocabulary set
  const setKey = `${gameState.currentStage}_${gameState.currentSet}`;
  const vocabSet = vocabularySets[setKey];
  
  // Update coins display
  const coinsDisplay = document.querySelector('.coin-count');
  if (coinsDisplay) {
    coinsDisplay.textContent = gameState.coins || 0;
    coinsDisplay.style.display = 'block';
  }
  
  // Remember starting state for restarts
  currentGame.startingCoins = gameState.coins;
  currentGame.startingPerks = {...gameState.perks};
  currentGame.timeBonus = 0;
  currentGame.initialTimeRemaining = null;
  currentGame.streakBonus = true;
  currentGame.levelStartTime = Date.now();
  
  // Show level intro, then start the level
  showLevelIntro(level, () => {
    setupGameState(calculateWordsForLevel(level, vocabSet), vocabSet);
    showScreen('question-screen');
    
    updateProgressCircle();
    loadNextQuestion();
    
    setTimeout(() => {
      startTimer(currentGame.words.length);
    }, 200);
  });
}

// Setup game state
function setupGameState(config, vocabSet) {
  if (typeof config === 'object') {
    if (config.randomIndices) {
      const words = config.randomIndices.map(i => vocabSet.words[i]);
      const translations = config.randomIndices.map(i => vocabSet.translations[i]);
      
      Object.assign(currentGame, {
        words,
        translations,
        currentIndex: 0,
        correctAnswers: 0,
        firstAttempt: true,
        isHebrewToEnglish: config.isHebrewToEnglish || false,
        mixed: config.mixed || false,
        speedChallenge: config.speedChallenge || false,
        isBossLevel: config.isBossLevel || false
      });
    } else {
      const { startIndex, count, isHebrewToEnglish, mixed, speedChallenge, isBossLevel } = config;
      
      Object.assign(currentGame, {
        words: vocabSet.words.slice(startIndex, startIndex + count),
        translations: vocabSet.translations.slice(startIndex, startIndex + count),
        currentIndex: 0,
        correctAnswers: 0,
        firstAttempt: true,
        isHebrewToEnglish: isHebrewToEnglish || false,
        mixed: mixed || false,
        speedChallenge: speedChallenge || false,
        isBossLevel: isBossLevel || false
      });
    }
  } else {
    // If config is a number, use it as count
    Object.assign(currentGame, {
      words: vocabSet.words.slice(0, config),
      translations: vocabSet.translations.slice(0, config),
      currentIndex: 0,
      correctAnswers: 0,
      firstAttempt: true,
      isHebrewToEnglish: false,
      mixed: false,
      speedChallenge: false,
      isBossLevel: false
    });
  }
}

// Calculate words for level
function calculateWordsForLevel(level, vocabSet) {
  const totalWords = vocabSet.words.length;
  const extraWords = totalWords - 50;
  
  // Create randomized indices for word selection if not already created
  if (!vocabSet.randomIndices) {
    vocabSet.randomIndices = Array.from({length: totalWords}, (_, i) => i);
    
    // Shuffle array
    for (let i = vocabSet.randomIndices.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [vocabSet.randomIndices[i], vocabSet.randomIndices[j]] = 
      [vocabSet.randomIndices[j], vocabSet.randomIndices[i]];
    }
    
    console.log('Created randomized word indices:', vocabSet.randomIndices);
  }
  
  // Boss level (level 21)
  if (level === 21) {
    return {
      startIndex: 0,
      count: totalWords,
      isBossLevel: true,
      speedChallenge: true,
      mixed: true,
      isTestLevel: true,
      isHebrewToEnglish: Math.random() < 0.5,
      testLevels: [],
      randomIndices: vocabSet.randomIndices
    };
  }
  
  // Levels 1-2
  if (level === 1 || level === 2) {
    const startIndex = 3 * (level - 1);
    return {
      startIndex,
      count: 3,
      testLevels: [3, 10, 21],
      randomIndices: vocabSet.randomIndices.slice(startIndex, startIndex + 3)
    };
  }
  
  // Level 3 (test)
  if (level === 3) {
    return {
      startIndex: 0,
      count: 6,
      isTestLevel: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabSet.randomIndices.slice(0, 6)
    };
  }
  
  // Levels 4-5
  if (level === 4 || level === 5) {
    const startIndex = 6 + 3 * (level - 4);
    return {
      startIndex,
      count: 3,
      testLevels: [6, 10, 21],
      randomIndices: vocabSet.randomIndices.slice(startIndex, startIndex + 3)
    };
  }
  
  // Level 6 (test)
  if (level === 6) {
    return {
      startIndex: 6,
      count: 6,
      isTestLevel: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabSet.randomIndices.slice(6, 12)
    };
  }
  
  // Levels 7-8
  if (level === 7 || level === 8) {
    const startIndex = 12 + 4 * (level - 7);
    return {
      startIndex,
      count: 4,
      testLevels: [9, 10, 21],
      randomIndices: vocabSet.randomIndices.slice(startIndex, startIndex + 4)
    };
  }
  
  // Level 9 (test)
  if (level === 9) {
    return {
      startIndex: 12,
      count: 8,
      isTestLevel: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabSet.randomIndices.slice(12, 20)
    };
  }
  
  // Level 10 (speed challenge)
  if (level === 10) {
    return {
      startIndex: 0,
      count: 20,
      isTestLevel: true,
      speedChallenge: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabSet.randomIndices.slice(0, 20)
    };
  }
  
  // Levels 11-12
  if (level === 11 || level === 12) {
    const startIndex = 20 + 4 * (level - 11);
    return {
      startIndex,
      count: 4,
      testLevels: [13, 20, 21],
      randomIndices: vocabSet.randomIndices.slice(startIndex, startIndex + 4)
    };
  }
  
  // Level 13 (test)
  if (level === 13) {
    return {
      startIndex: 20,
      count: 8,
      isTestLevel: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabSet.randomIndices.slice(20, 28)
    };
  }
  
  // Levels 14-15
  if (level === 14 || level === 15) {
    const count = level === 14 ? 5 : 6;
    const startIndex = 28 + (level === 14 ? 0 : 5);
    return {
      startIndex,
      count,
      testLevels: [16, 20, 21],
      randomIndices: vocabSet.randomIndices.slice(startIndex, startIndex + count)
    };
  }
  
  // Level 16 (test)
  if (level === 16) {
    return {
      startIndex: 28,
      count: 11,
      isTestLevel: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabSet.randomIndices.slice(28, 39)
    };
  }
  
  // Levels 17-18
  if (level === 17 || level === 18) {
    const count = level === 17 ? 5 : 6;
    const extraCount = count + (extraWords > 0 ? extraWords : 0);
    const startIndex = 39 + (level === 17 ? 0 : count);
    return {
      startIndex,
      count: extraCount,
      testLevels: [19, 20, 21],
      randomIndices: vocabSet.randomIndices.slice(startIndex, startIndex + extraCount)
    };
  }
  
  // Level 19 (test)
  if (level === 19) {
    return {
      startIndex: 39,
      count: 11,
      isTestLevel: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabSet.randomIndices.slice(39, 50)
    };
  }
  
  // Level 20 (speed challenge)
  if (level === 20) {
    return {
      startIndex: 20,
      count: 30,
      isTestLevel: true,
      speedChallenge: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabSet.randomIndices.slice(20, 50)
    };
  }
}

// Get unused words
function getUnusedWords(vocabSet) {
  if (!gameState.usedWords) {
    gameState.usedWords = new Set();
  }
  
  return vocabSet.words.map((_, i) => i).filter(i => !gameState.usedWords.has(i));
}

// Select random words
function selectRandomWords(wordIndices, count) {
  const selectedIndices = new Set();
  
  while (selectedIndices.size < count && wordIndices.length > selectedIndices.size) {
    const index = Math.floor(Math.random() * wordIndices.length);
    selectedIndices.add(wordIndices[index]);
    gameState.usedWords.add(wordIndices[index]);
  }
  
  return Array.from(selectedIndices);
}

// Generate answer choices
function generateAnswerChoices(correctAnswer, vocabSet) {
  const answersSet = new Set([correctAnswer]);
  const translationPool = vocabSet.translations;
  
  // Add random wrong answers until we have 3 total options
  while (answersSet.size < 3) {
    const randomTranslation = translationPool[Math.floor(Math.random() * translationPool.length)];
    answersSet.add(randomTranslation);
  }
  
  // Shuffle and return
  return Array.from(answersSet).sort(() => Math.random() - 0.5);
}

// Load next question
function loadNextQuestion() {
  // Clear previous button classes
  document.querySelectorAll('.buttons button').forEach(button => {
    button.classList.remove('correct', 'wrong');
  });
  
  // Check if we're out of questions
  if (currentGame.currentIndex >= currentGame.words.length) {
    return;
  }
  
  // For test levels, randomly choose whether to show Hebrew or English first
  const useRandomDirection = [3, 6, 9, 10, 13, 16, 19, 20, 21].includes(gameState.currentLevel) && Math.random() < 0.5;
  
  const questionIndex = currentGame.currentIndex;
  const questionWord = useRandomDirection ? currentGame.translations[questionIndex] : currentGame.words[questionIndex];
  
  document.getElementById('question-word').textContent = questionWord;
  
  // Prepare answer options
  const correctAnswer = useRandomDirection ? currentGame.words[questionIndex] : currentGame.translations[questionIndex];
  const answerPool = useRandomDirection ? currentGame.words : currentGame.translations;
  
  const possibleAnswers = new Set([correctAnswer]);
  
  // Add random wrong answers
  while (possibleAnswers.size < 3) {
    const randomAnswer = answerPool[Math.floor(Math.random() * answerPool.length)];
    if (randomAnswer !== correctAnswer) {
      possibleAnswers.add(randomAnswer);
    }
  }
  
  // Create and shuffle buttons
  const buttonsContainer = document.getElementById('buttons');
  buttonsContainer.innerHTML = '';
  
  Array.from(possibleAnswers)
    .sort(() => Math.random() - 0.5)
    .forEach(answer => {
      const button = document.createElement('button');
      button.textContent = answer;
      button.onclick = () => handleAnswer(answer === correctAnswer);
      buttonsContainer.appendChild(button);
    });
}

// Update progress circle
function updateProgressCircle() {
  const progressElement = document.querySelector('.progress-circle .progress');
  const progressCircle = document.querySelector('.progress-circle');
  
  const circumference = 2 * Math.PI * 54;
  const progress = currentGame.currentIndex / currentGame.words.length;
  
  progressElement.style.strokeDasharray = `${circumference} ${circumference}`;
  progressElement.style.strokeDashoffset = circumference * (1 - progress);
  
  // Update colors based on progress
  let hue, saturation, lightness;
  
  if (progress <= 0.2) {
    hue = 0;
    saturation = 100;
    lightness = 20;
  } else if (progress <= 0.4) {
    hue = 0;
    saturation = 100;
    lightness = 50;
  } else if (progress <= 0.6) {
    hue = 30;
    saturation = 100;
    lightness = 50;
  } else if (progress <= 0.8) {
    hue = 120;
    saturation = 100;
    lightness = 40;
  } else {
    // Linear interpolation for the last 20%
    const t = 5 * (progress - 0.8);
    hue = 120 * (1 - t) + 60 * t;
    saturation = 100;
    lightness = 40 + 20 * t;
  }
  
  progressElement.style.stroke = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}

// Handle answer
function handleAnswer(isCorrect, isSkipped = false) {
  const now = Date.now();
  
  // Throttle answer processing (prevent double-clicks)
  if (now - (currentGame.lastAnswerTime || 0) < 1000) {
    console.warn('Answer too quickly. Please wait a moment.');
    return;
  }
  
  // Check for valid game state
  if (!currentGame || !currentGame.words || currentGame.words.length === 0 || currentGame.currentIndex >= currentGame.words.length) {
    console.error('Invalid game state or index');
    return;
  }
  
  currentGame.lastAnswerTime = now;
  
  // Initialize perks if not present
  currentGame.perks = currentGame.perks || {
    clue: 0,
    skip: 0,
    timeFreeze: 0,
    reveal: 0
  };
  
  try {
    if (isCorrect) {
      // Move to next question
      currentGame.currentIndex++;
      
      // Handle boss level special case
      if (currentGame.isBossLevel) {
        const bossOrb = document.querySelector('.boss-orb-inner');
        if (bossOrb) {
          const colors = ['yellow', 'purple', 'turquoise', 'darkgreen', 'brown'];
          const randomColor = colors[Math.floor(Math.random() * colors.length)];
          const originalBg = bossOrb.style.background;
          
          bossOrb.style.background = `radial-gradient(circle at 30% 30%, ${randomColor}, #990000)`;
          bossOrb.style.transform = 'scale(1.3)';
          bossOrb.style.filter = 'brightness(1.5)';
          
          setTimeout(() => {
            bossOrb.style.transform = '';
            bossOrb.style.filter = '';
            bossOrb.style.background = originalBg;
          }, 300);
        }
        
        // Check if boss defeated
        if (currentGame.currentIndex >= currentGame.words.length) {
          console.log('Boss defeated - final hit!');
          currentGame.bossDefeated = true;
          clearTimer();
          
          // Update circle to full
          const progressCircle = document.querySelector('.progress-circle');
          if (progressCircle) {
            const progressElement = progressCircle.querySelector('.progress');
            if (progressElement) {
              const circumference = 2 * Math.PI * 54;
              progressElement.style.strokeDashoffset = circumference;
            }
          }
          
          showBossDefeatEffect();
          CoinsManager.updateCoins(100).then(() => {
            updateAllCoinDisplays();
          });
          return;
        }
        
        updateBossHealthBar();
      } else {
        updateProgressCircle();
      }
      
      // Award coins if not skipped
      if (!isSkipped) {
        let coinsToAdd = 0;
        
        // Time bonus
        const timeBonus = awardTimeBonus();
        if (timeBonus > 0) {
          coinsToAdd += timeBonus;
          pulseCoins(timeBonus);
        }
        
        // First attempt bonus
        if (currentGame.firstAttempt) {
          coinsToAdd += 3;
          pulseCoins(3);
        } else {
          coinsToAdd += 1;
          pulseCoins(1);
        }
        
        // Update coins
        CoinsManager.updateCoins(coinsToAdd).then(() => {
          updatePerkButtons();
          updateAllCoinDisplays();
        }).catch(error => {
          console.error('Error updating total coins:', error);
        });
        
        // Update tracking
        currentGame.correctAnswers++;
        
        // Track word if logged in
        if (currentUser) {
          const wordIndex = currentGame.currentIndex - 1;
          const word = currentGame.isHebrewToEnglish ? currentGame.words[wordIndex] : currentGame.translations[wordIndex];
          
          trackWordEncounter(word, currentGame.isCustomPractice ? 'custom' : currentGame.isArcadeMode ? 'arcade' : 'story');
        }
      }
    } else {
      // Mark first attempt as failed
      currentGame.firstAttempt = false;
      currentGame.streakBonus = false;
      
      // Track wrong streak
      currentGame.wrongStreak++;
      
      // Penalty for wrong answer
      CoinsManager.updateCoins(-3).then(() => {
        updatePerkButtons();
        updateAllCoinDisplays();
      }).catch(error => {
        console.error('Error updating coins:', error);
      });
      
      // Lose progress on wrong answer
      if (currentGame.currentIndex > 0) {
        currentGame.progressLost++;
        currentGame.currentIndex = Math.max(0, currentGame.currentIndex - 1);
        
        // Update boss health if in boss level
        if (currentGame.isBossLevel) {
          updateBossHealthBar();
        }
      }
      
      // Game over if too many wrong answers in a row
      if (currentGame.wrongStreak >= 3) {
        showGameOverOverlay();
        return;
      }
      
      // Highlight correct answer
      const buttons = document.querySelectorAll('.buttons button');
      const correctAnswer = currentGame.isHebrewToEnglish 
        ? currentGame.words[Math.max(0, currentGame.currentIndex - 1)] 
        : currentGame.translations[Math.max(0, currentGame.currentIndex - 1)];
        
      buttons.forEach(button => {
        if (button.textContent === correctAnswer) {
          button.classList.add('correct');
        } else if (!isCorrect && event && event.target && button.textContent === event.target.textContent) {
          button.classList.add('wrong');
        }
      });
    }
    
    // Save progress
    saveProgress();
    
    // Load next question after a short delay
    setTimeout(() => {
      // Clear button classes
      document.querySelectorAll('.buttons button').forEach(button => {
        button.classList.remove('correct', 'wrong');
      });
      
      // Check if we have more questions
      if (!currentGame || currentGame.bossDefeated && currentGame.isBossLevel) {
        // Do nothing, boss is already defeated
      } else if (currentGame.currentIndex < currentGame.words.length) {
        // Start timer and load next question
        startTimer(currentGame.words.length - currentGame.currentIndex);
        
        if (currentGame.isBossLevel) {
          loadNextBossQuestion();
        } else {
          loadNextQuestion();
        }
        
        updatePerkButtons();
      } else {
        // Level completed
        if (currentGame.isCustomPractice) {
          handleCustomLevelCompletion();
        } else {
          handleLevelCompletion();
        }
      }
    }, 500);
    
  } catch (error) {
    console.error('Unexpected error in handleAnswer:', error);
    console.error('Error details:', error.stack);
    
    // Try to recover
    try {
      if (currentGame && currentGame.currentIndex < currentGame.words.length && !currentGame.bossDefeated) {
        loadNextQuestion();
      } else {
        showScreen('welcome-screen');
      }
    } catch (recoveryError) {
      console.error('Failed to recover from error:', recoveryError);
      showScreen('welcome-screen');
    }
  }
}

// Show game over overlay
function showGameOverOverlay() {
  clearTimer();
  
  const overlay = document.querySelector('.failure-overlay');
  overlay.querySelector('.failure-title').textContent = 'Game Over!';
  overlay.style.display = 'flex';
  
  setTimeout(() => {
    overlay.classList.add('show');
  }, 100);
  
  document.querySelector('.restart-button').onclick = () => {
    overlay.classList.remove('show');
    setTimeout(() => {
      overlay.style.display = 'none';
      startLevel(gameState.currentLevel);
    }, 1000);
  };
  
  document.querySelector('.home-button').onclick = () => {
    overlay.classList.remove('show');
    setTimeout(() => {
      overlay.style.display = 'none';
      showScreen('welcome-screen');
    }, 1000);
  };
}

// Handle reset progress
function handleResetProgress() {
  if (!isFirstResetAttempt) {
    // Actually reset everything
    gameState.currentStage = 1;
    gameState.currentSet = 1;
    gameState.currentLevel = 1;
    gameState.coins = 0;
    gameState.unlockedSets = { 1: new Set([1]) };
    gameState.unlockedLevels = { '1_1': new Set([1]) };
    gameState.perfectLevels = new Set();
    gameState.completedLevels = new Set();
    
    localStorage.removeItem('simploxProgress');
    localStorage.removeItem('simploxCustomCoins');
    
    updatePerkButtons();
    updateAllCoinDisplays();
    showScreen('welcome-screen');
    
    isFirstResetAttempt = true;
    return;
  }
  
  // First attempt - show warning
  const resetButton = document.querySelector('.reset-button');
  resetButton.classList.add('warning');
  
  isFirstResetAttempt = false;
  
  setTimeout(() => {
    resetButton.classList.remove('warning');
  }, 1000);
  
  if (resetProgressTimeout) {
    clearTimeout(resetProgressTimeout);
  }
  
  resetProgressTimeout = setTimeout(() => {
    isFirstResetAttempt = true;
  }, 10000);
}

// Toggle fullscreen
function toggleFullScreen() {
  const fullscreenIcon = document.querySelector('.fullscreen-button i');
  
  if (document.fullscreenElement) {
    if (document.exitFullscreen) {
      document.exitFullscreen().then(() => {
        fullscreenIcon.classList.remove('fa-compress');
        fullscreenIcon.classList.add('fa-expand');
      }).catch(error => {
        console.log(`Error attempting to exit fullscreen: ${error.message}`);
      });
    }
  } else {
    document.documentElement.requestFullscreen().then(() => {
      fullscreenIcon.classList.remove('fa-expand');
      fullscreenIcon.classList.add('fa-compress');
    }).catch(error => {
      console.log(`Error attempting to enable fullscreen: ${error.message}`);
    });
  }
}

// Handle restart level
function handleRestartLevel() {
  if (currentGame.restartsRemaining <= 0) return;
  
  const restartButton = document.querySelector('.navigation-button.restart-level');
  
  currentGame.restartsRemaining--;
  
  if (currentGame.restartsRemaining === 1) {
    restartButton.style.opacity = '0.7';
  } else if (currentGame.restartsRemaining === 0) {
    restartButton.classList.add('disabled');
    restartButton.onclick = null;
    restartButton.disabled = true;
  }
  
  gameState.coins = currentGame.startingCoins;
  gameState.perks = {...currentGame.startingPerks};
  
  updatePerkButtons();
  updateAllCoinDisplays();
  saveProgress();
  
  startLevel(gameState.currentLevel);
}

// Show notification
function showNotification(message, type = 'info') {
  const notification = document.createElement('div');
  notification.className = `game-notification ${type}`;
  notification.textContent = message;
  
  document.body.appendChild(notification);
  
  requestAnimationFrame(() => {
    notification.classList.add('show');
  });
  
  setTimeout(() => {
    notification.classList.remove('show');
    setTimeout(() => {
      notification.remove();
    }, 300);
  }, 3000);
}

// Apply boss level styles
function applyBossLevelStyles() {
  console.log('Forcefully applying boss level styles');
  
  // Style the question screen
  const questionScreen = document.getElementById('question-screen');
  if (questionScreen) {
    questionScreen.style.setProperty('background', 'linear-gradient(135deg, #800000, #3a0000)', 'important');
    questionScreen.style.setProperty('animation', 'pulseBg 4s infinite', 'important');
  }
  
  // Add animations if not already added
  if (!document.getElementById('boss-animations')) {
    const styleSheet = document.createElement('style');
    styleSheet.id = 'boss-animations';
    styleSheet.textContent = `
      @keyframes pulseBg {
        0%, 100% { filter: brightness(1); }
        50% { filter: brightness(1.2); }
      }
      
      @keyframes pulseOrb {
        0%, 100% { transform: scale(1); filter: brightness(1); }
        50% { transform: scale(1.3); filter: brightness(1.4); }
      }
      
      @keyframes pulseWord {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
      }
    `;
    document.head.appendChild(styleSheet);
  }
  
  // Style the question word
  const questionWord = document.getElementById('question-word');
  if (questionWord) {
    questionWord.style.setProperty('color', '#ff3333', 'important');
    questionWord.style.setProperty('text-shadow', '0 0 10px rgba(255, 0, 0, 0.5)', 'important');
    questionWord.style.setProperty('animation', 'pulseWord 2s infinite', 'important');
  }
  
  // Replace coin container with boss orb
  const coinsContainer = document.querySelector('.coins-container');
  if (coinsContainer) {
    if (!window.originalCoinsHTML) {
      window.originalCoinsHTML = coinsContainer.innerHTML;
    }
    
    coinsContainer.innerHTML = `
      <div class="boss-orb" style="
        width: 85px;
        height: 85px;
        top: 50%;
        left: 50%;
        transform: translate(-75%, -75%);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
      ">
        <div class="boss-orb-inner" style="
          width: 50px;
          height: 50px;
          background: radial-gradient(circle at 30% 30%, #ff3333, #990000);
          border-radius: 50%;
          box-shadow: 0 0 20px #ff3333, inset 0 0 10px rgba(255,255,255,0.3);
          animation: pulseOrb 1s infinite;
        "></div>
      </div>
    `;
  }
}

// Track word encounter
async function trackWordEncounter(word, gameMode) {
  if (!currentUser) return;
  
  try {
    // Check if word already exists in history
    const { data, error } = await supabaseClient
      .from('word_practice_history')
      .select('*')
      .eq('user_id', currentUser.id)
      .eq('word', word)
      .single();
      
    if (error && error.code !== 'PGRST116') {
      return console.error('Error fetching word history:', error);
    }
    
    let isNewWord = false;
    let coinReward = 0;
    
    if (data) {
      // Word exists, update practice count
      const newCount = data.practice_count + 1;
      coinReward = newCount <= 5 ? 3 : 1;
      
      const { error: updateError } = await supabaseClient
        .from('word_practice_history')
        .update({
          practice_count: newCount,
          last_practiced_at: (new Date()).toISOString(),
          game_mode: gameMode,
          coins_earned: data.coins_earned + coinReward
        })
        .eq('user_id', currentUser.id)
        .eq('word', word);
        
      if (updateError) {
        return console.error('Error updating word history:', updateError);
      }
    } else {
      // New word, create record
      isNewWord = true;
      coinReward = 3;
      
      const { error: insertError } = await supabaseClient
        .from('word_practice_history')
        .insert([{
          user_id: currentUser.id,
          word: word,
          practice_count: 1,
          game_mode: gameMode,
          coins_earned: coinReward
        }]);
        
      if (insertError) {
        return console.error('Error inserting word history:', insertError);
      }
      
      // Update player stats for new words
      const { data: statsData, error: statsError } = await supabaseClient
        .from('player_stats')
        .select('unique_words_practiced')
        .eq('user_id', currentUser.id)
        .single();
        
      if (!statsError) {
        const newWordCount = (statsData?.unique_words_practiced || 0) + 1;
        
        const { error: updateStatsError } = await supabaseClient
          .from('player_stats')
          .update({ unique_words_practiced: newWordCount })
          .eq('user_id', currentUser.id);
          
        if (!updateStatsError) {
          document.querySelectorAll('#totalWords').forEach(element => {
            animateNumber(element, parseInt(element.textContent) || 0, newWordCount);
          });
        } else {
          console.error('Error updating player stats:', updateStatsError);
        }
      }
    }
    
    // Award coins for practicing words
    if (coinReward > 0) {
      await CoinsManager.updateCoins(coinReward);
    }
    
    return { isNewWord, coinReward };
  } catch (error) {
    console.error('Error in trackWordEncounter:', error);
  }
}

// Show upgrade prompt
function showUpgradePrompt(callback) {
  const contextState = {
    screen: document.querySelector('.screen.visible')?.id,
    stage: gameState.currentStage,
    set: gameState.currentSet,
    level: gameState.currentLevel
  };
  
  if (contextState.screen) {
    localStorage.setItem('gameContext', JSON.stringify(contextState));
  }
  
  if (currentUser) {
    if (checkUpgradeStatus()) {
      if (callback) callback();
      return;
    } else {
      showUpgradeScreen();
    }
  } else {
    showUnregisteredWarning(() => {
      if (callback) callback();
    });
  }
}

// Show unregistered warning
function showUnregisteredWarning(callback) {
  if (window.unregisteredWarningShown) {
    if (callback) callback();
    return;
  }
  
  window.unregisteredWarningShown = true;
  
  const overlay = document.createElement('div');
  overlay.className = 'fullscreen-signup-page';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--gradient);
    z-index: 2000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    padding: 2rem;
    animation: fadeIn 0.3s ease-in-out;
  `;
  
  overlay.innerHTML = `
    <div class="signup-header" style="width: 100%; display: flex; justify-content: flex-start; margin-bottom: 2rem;">
      <button class="skip-signup-button" style="
        background: rgba(255,255,255,0.15);
        border: none;
        color: var(--text);
        padding: 0.75rem 1.5rem;
        border-radius: 50px;
        font-size: 0.9rem;
        cursor: pointer;
        transition: all 0.3s ease;
      ">
        Skip
      </button>
    </div>
    
    <div class="signup-content" style="
      text-align: center;
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      max-width: 600px;
      width: 100%;
    ">
      <h2 style="
        font-size: 2rem;
        color: var(--gold);
        margin-bottom: 1.5rem;
        animation: floatAnimation 3s ease-in-out infinite;
      ">Save Your Progress!</h2>
      
      <p style="
        font-size: 1.2rem;
        line-height: 1.6;
        margin-bottom: 2rem;
        color: var(--text);
      ">Create a free account to track your vocabulary progress, earn rewards, and unlock more advanced content</p>
      
      <div class="features-list" style="
        display: flex;
        flex-direction: column;
        gap: 1rem;
        margin-bottom: 3rem;
        text-align: left;
      ">
        <div class="feature-item" style="
          display: flex;
          align-items: center;
          gap: 1rem;
        ">
          <i class="fas fa-check-circle" style="color: var(--gold); font-size: 1.5rem;"></i>
          <span>Track your learning progress</span>
        </div>
        <div class="feature-item" style="
          display: flex;
          align-items: center;
          gap: 1rem;
        ">
          <i class="fas fa-check-circle" style="color: var(--gold); font-size: 1.5rem;"></i>
          <span>Practice custom word lists</span>
        </div>
        <div class="feature-item" style="
          display: flex;
          align-items: center;
          gap: 1rem;
        ">
          <i class="fas fa-check-circle" style="color: var(--gold); font-size: 1.5rem;"></i>
          <span>Earn coins for premium content</span>
        </div>
      </div>
    </div>
    
    <div class="signup-footer" style="
      width: 100%;
      display: flex;
      justify-content: center;
      padding-bottom: 2rem;
    ">
      <button class="signup-now-button" style="
        background: var(--gold);
        color: var(--primary-dark);
        border: none;
        padding: 1.25rem 3rem;
        border-radius: 50px;
        font-size: 1.2rem;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 10px 20px rgba(255, 215, 0, 0.2);
        animation: pulseAnimation 1.5s infinite ease-in-out;
      ">
        Sign Up Now
      </button>
    </div>
  `;
  
  document.body.appendChild(overlay);
  
  const styleElement = document.createElement('style');
  styleElement.textContent = `
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    @keyframes floatAnimation {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    
    @keyframes pulseAnimation {
      0%, 100% { transform: scale(1); box-shadow: 0 10px 20px rgba(255, 215, 0, 0.2); }
      50% { transform: scale(1.05); box-shadow: 0 10px 30px rgba(255, 215, 0, 0.4); }
    }
  `;
  
  document.head.appendChild(styleElement);
  
  const skipButton = overlay.querySelector('.skip-signup-button');
  const signupButton = overlay.querySelector('.signup-now-button');
  
  skipButton.addEventListener('click', function() {
    document.body.removeChild(overlay);
    if (styleElement.parentNode) {
      styleElement.parentNode.removeChild(styleElement);
    }
    if (callback) callback();
  });
  
  signupButton.addEventListener('click', function() {
    document.body.removeChild(overlay);
    if (styleElement.parentNode) {
      styleElement.parentNode.removeChild(styleElement);
    }
    
    showScreen('welcome-screen');
    
    setTimeout(function() {
      const authModal = document.getElementById('authModal');
      if (authModal) {
        authModal.classList.add('show');
        
        const signupForm = document.getElementById('signupForm');
        const loginForm = document.getElementById('loginForm');
        
        if (signupForm && loginForm) {
          signupForm.classList.remove('hidden');
          loginForm.classList.add('hidden');
        }
      }
    }, 100);
  });
}

// Add admin test button
function addAdminTestButton() {
  console.log('Checking for admin user...');
  
  const existingButton = document.getElementById('admin-test-button');
  if (existingButton) {
    existingButton.remove();
  }
  
  console.log('Current user:', currentUser ? currentUser.email : 'No user');
  
  if (!currentUser || 
      (currentUser.email !== 'admin123@gmail.com' && 
       !currentUser.email?.includes('admin123'))) {
    console.log('Not admin user, not adding button');
    return;
  }
  
  console.log('Admin user detected, adding test buttons');
  
  const button = document.createElement('button');
  button.id = 'admin-test-button';
  button.textContent = 'Jump to Level 20';
  button.style.cssText = `
    position: fixed;
    top: 80px;
    right: 20px;
    background: #ff5722;
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 5px;
    cursor: pointer;
    z-index: 2000;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    font-weight: bold;
  `;
  
  button.onclick = function() {
    console.log('Admin button clicked, jumping to level 20');
    gameState.currentLevel = 21;
    startLevel(21);
  };
  
  document.body.appendChild(button);
  console.log('Admin test button added to body');
  
  addAdminSkipButton();
}

// Add admin skip button
function addAdminSkipButton() {
  if (!isAdminUser()) return;
  
  const existingButton = document.getElementById('admin-skip-10-button');
  if (existingButton) {
    existingButton.remove();
  }
  
  const button = document.createElement('button');
  button.id = 'admin-skip-10-button';
  button.innerHTML = '<i class="fas fa-forward"></i> Skip 10';
  button.style.cssText = `
    position: fixed;
    bottom: 80px;
    right: 20px;
    background: #9c27b0;
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 5px;
    cursor: pointer;
    z-index: 2000;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    font-weight: bold;
  `;
  
  button.onclick = function() {
    console.log('Admin skip-10 button clicked');
    handleAdminSkip10();
  };
  
  const questionScreen = document.getElementById('question-screen');
  if (questionScreen) {
    questionScreen.appendChild(button);
  }
}

// Handle admin skip
function handleAdminSkip10() {
  if (!isAdminUser()) return;
  
  if (!currentGame || !currentGame.words || !currentGame.words.length) {
    console.error('No active game found');
    return;
  }
  
  const skipCount = Math.min(10, currentGame.words.length - currentGame.currentIndex);
  console.log(`Skipping ${skipCount} questions`);
  
  if (currentGame.isBossLevel) {
    currentGame.currentIndex = Math.max(0, currentGame.words.length - 1);
    updateBossHealthBar();
    loadNextBossQuestion();
    showNotification('Boss almost defeated! One more hit!', 'success');
    return;
  }
  
  currentGame.currentIndex += skipCount;
  
  if (currentGame.currentIndex >= currentGame.words.length) {
    handleLevelCompletion();
  } else {
    updateProgressCircle();
    loadNextQuestion();
    showNotification(`Skipped ${skipCount} questions!`, 'success');
  }
}

// Check if user is admin
function isAdminUser() {
  return currentUser && currentUser.email === 'admin123@gmail.com';
}

// Show boss defeat effect
function showBossDefeatEffect() {
  console.log('Starting boss defeat effect sequence');
  
  setTimeout(() => {
    const questionScreen = document.querySelector('.question-screen');
    const bossOrb = document.querySelector('.boss-orb-inner');
    
    if (bossOrb) {
      console.log('Disintegrating boss orb');
      
      const effectElement = document.createElement('div');
      effectElement.className = 'incineration-effect';
      bossOrb.appendChild(effectElement);
      
      bossOrb.style.animation = 'boss-shrink 1.5s forwards';
      
      setTimeout(() => {
        console.log('Restoring coin counter');
        
        const coinsContainer = document.querySelector('.coins-container');
        if (coinsContainer && window.originalCoinsHTML) {
          coinsContainer.innerHTML = window.originalCoinsHTML;
          
          const coinIcon = coinsContainer.querySelector('.coin-icon');
          const coinCount = coinsContainer.querySelector('.coin-count');
          
          if (coinIcon) {
            coinIcon.style.transform = 'scale(0)';
            setTimeout(() => {
              coinIcon.style.transition = 'transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
              coinIcon.style.transform = 'scale(1)';
            }, 100);
          }
          
          if (coinCount) {
            coinCount.textContent = gameState.coins + 100;
            coinCount.style.transform = 'scale(0)';
            setTimeout(() => {
              coinCount.style.transition = 'transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
              coinCount.style.transform = 'scale(1)';
            }, 300);
          }
        }
      }, 1500);
    }
    
    if (questionScreen) {
      console.log('Starting background transition');
      
      const transitionOverlay = document.createElement('div');
      transitionOverlay.className = 'background-transition-overlay';
      transitionOverlay.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #800000, #3a0000);
        z-index: -1;
        transition: background 5s ease-in-out;
        pointer-events: none;
      `;
      
      questionScreen.insertBefore(transitionOverlay, questionScreen.firstChild);
      
      // Trigger reflow
      transitionOverlay.offsetWidth;
      
      setTimeout(() => {
        console.log('Transitioning to purple');
        transitionOverlay.style.background = 'linear-gradient(135deg, #4a1582, #0d47a1)';
        
        setTimeout(() => {
          console.log('Transitioning to normal blue');
          transitionOverlay.style.background = 'radial-gradient(circle at center, var(--secondary) 0%, var(--primary-dark) 100%)';
          
          if (typeof stopBossRainingLetters === 'function') {
            stopBossRainingLetters();
          }
          
          initializeParticles(questionScreen);
          
          setTimeout(() => {
            console.log('Showing victory notification');
            showBossVictoryNotification();
          }, 1000);
        }, 2500);
      }, 500);
    } else {
      setTimeout(() => showBossVictoryNotification(), 4000);
    }
  }, 2000);
}

// Show boss victory notification
function showBossVictoryNotification() {
  CoinsManager.updateCoins(100);
  updateAllCoinDisplays();
  
  const modal = document.createElement('div');
  modal.className = 'arcade-completion-modal';
  modal.innerHTML = `
    <div class="completion-modal-content">
      <h2 style="color: var(--gold)">Boss Defeated!</h2>
      <p style="font-size: 1.2rem; margin: 1rem 0;">Congratulations! You've conquered this challenge!</p>
      
      <div class="completion-stats">
        <div class="stat-item">
          <i class="fas fa-skull" style="font-size: 2rem; color: var(--gold); margin-bottom: 0.5rem;"></i>
          <span style="display: block; margin-bottom: 0.25rem;">Boss Defeated</span>
          <strong style="font-size: 1.5rem;">✓</strong>
        </div>
        <div class="stat-item">
          <i class="fas fa-coins" style="font-size: 2rem; color: var(--gold); margin-bottom: 0.5rem;"></i>
          <span style="display: block; margin-bottom: 0.25rem;">Bonus Coins</span>
          <strong style="font-size: 1.5rem;">100</strong>
        </div>
        <div class="stat-item">
          <i class="fas fa-unlock" style="font-size: 2rem; color: var(--gold); margin-bottom: 0.5rem;"></i>
          <span style="display: block; margin-bottom: 0.25rem;">New Set</span>
          <strong style="font-size: 1.5rem;">Unlocked</strong>
        </div>
      </div>
      
      <div style="display: flex; justify-content: space-around; margin-top: 2rem; gap: 1rem;">
        <button onclick="handleBossVictoryContinue()" class="start-button" style="
          background: var(--accent);
          color: var(--text);
          border: none;
          padding: 1rem 2rem;
          border-radius: 50px;
          font-size: 1.1rem;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.3s ease;
          box-shadow: 0 5px 15px rgba(30, 144, 255, 0.3);
        ">
          Next Set
        </button>
        <button onclick="handleBossVictoryHome()" class="start-button" style="
          background: transparent;
          color: var(--text);
          border: 2px solid var(--accent);
          padding: 1rem 2rem;
          border-radius: 50px;
          font-size: 1.1rem;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.3s ease;
        ">
          Return Home
        </button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  requestAnimationFrame(() => modal.classList.add('show'));
}

// Handle boss victory continue
function handleBossVictoryContinue() {
  console.log('Boss victory continue button clicked');
  
  const modal = document.querySelector('.arcade-completion-modal');
  updateAllCoinDisplays();
  
  if (modal) {
    modal.classList.remove('show');
    
    setTimeout(() => {
      modal.remove();
      
      const transitionOverlay = document.querySelector('.background-transition-overlay');
      if (transitionOverlay) {
        console.log('Using existing transition overlay for smooth transition');
        transitionOverlay.style.background = 'radial-gradient(circle at center, var(--secondary) 0%, var(--primary-dark) 100%)';
        resetBossStyles(true);
      } else {
        resetBossStyles();
      }
      
      unlockNextSet();
      
      const nextSet = gameState.currentSet + 1;
      gameState.currentSet = nextSet;
      gameState.currentLevel = 1;
      
      updateAllCoinDisplays();
      
      setTimeout(() => {
        console.log('Starting next level');
        if (transitionOverlay && transitionOverlay.parentNode) {
          transitionOverlay.parentNode.removeChild(transitionOverlay);
        }
        startLevel(1);
      }, 500);
    }, 300);
  }
}

// Reset boss styles
function resetBossStyles(preserveOverlay = false) {
  console.log('Resetting boss styles', preserveOverlay ? '(preserving overlay)' : '');
  
  // Reset progress circle
  const progressCircle = document.querySelector('.progress-circle');
  if (progressCircle) {
    const progressElement = progressCircle.querySelector('.progress');
    if (progressElement) {
      progressElement.classList.remove('warning', 'boss-health');
      progressElement.style.stroke = '';
      progressElement.style.animation = 'none';
      progressElement.offsetWidth; // Force reflow
      progressElement.style.animation = '';
    }
  }
  
  // Reset question screen
  const questionScreen = document.getElementById('question-screen');
  if (questionScreen) {
    const transitionOverlay = questionScreen.querySelector('.background-transition-overlay');
    
    if (preserveOverlay && transitionOverlay) {
      transitionOverlay.remove();
    }
    
    questionScreen.removeAttribute('style');
    
    if (preserveOverlay && transitionOverlay) {
      questionScreen.insertBefore(transitionOverlay, questionScreen.firstChild);
    } else if (!preserveOverlay) {
      questionScreen.querySelectorAll('.background-transition-overlay').forEach(el => el.remove());
      
      setTimeout(() => {
        questionScreen.style.background = 'radial-gradient(circle at center, var(--secondary) 0%, var(--primary-dark) 100%)';
      }, 10);
    }
  }
  
  // Reset question word
  const questionWord = document.getElementById('question-word');
  if (questionWord) {
    questionWord.removeAttribute('style');
  }
  
  // Stop raining letters effect if it exists
  if (typeof stopBossRainingLetters === 'function') {
    stopBossRainingLetters();
  }
  
  // Remove special elements
  const selector = preserveOverlay 
    ? '.incineration-effect, .boss-orb' 
    : '.incineration-effect, .boss-orb, .background-transition-overlay';
    
  document.querySelectorAll(selector).forEach(el => {
    if (el.parentNode) {
      el.parentNode.removeChild(el);
    }
  });
}

function handleBossVictoryHome() {
  console.log("Boss victory home button clicked");
  const modal = document.querySelector('.arcade-completion-modal');
  updateAllCoinDisplays();
  
  if (modal) {
    modal.classList.remove("show");
    setTimeout(() => {
      modal.remove();
      resetBossStyles();
      unlockNextSet();
      
      const nextSet = gameState.currentSet + 1;
      gameState.currentSet = nextSet;
      gameState.currentLevel = 1;
      saveProgress();
      showScreen("welcome-screen");
    }, 300);
  }
}

function isAdminUser() {
  return currentUser && currentUser.email === "admin123@gmail.com";
}

function addAdminSkipButton() {
  if (!isAdminUser()) return;
  
  const existingButton = document.getElementById('admin-skip-10-button');
  if (existingButton) existingButton.remove();
  
  const button = document.createElement('button');
  button.id = 'admin-skip-10-button';
  button.innerHTML = '<i class="fas fa-forward"></i> Skip 10';
  button.style.cssText = `
    position: fixed;
    bottom: 80px;
    right: 20px;
    background: #9c27b0;
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 5px;
    cursor: pointer;
    z-index: 2000;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    font-weight: bold;
  `;
  
  button.onclick = function() {
    console.log("Admin skip-10 button clicked");
    handleAdminSkip10();
  };
  
  const questionScreen = document.getElementById('question-screen');
  if (questionScreen) {
    questionScreen.appendChild(button);
  }
}

function handleAdminSkip10() {
  if (!isAdminUser()) return;
  
  if (!currentGame || !currentGame.words || !currentGame.words.length) {
    console.error("No active game found");
    return;
  }
  
  const skipCount = Math.min(10, currentGame.words.length - currentGame.currentIndex);
  console.log(`Skipping ${skipCount} questions`);
  
  if (currentGame.isBossLevel) {
    currentGame.currentIndex = Math.max(0, currentGame.words.length - 1);
    updateBossHealthBar();
    loadNextBossQuestion();
    showNotification("Boss almost defeated! One more hit!", "success");
    return;
  }
  
  currentGame.currentIndex += skipCount;
  
  if (currentGame.currentIndex >= currentGame.words.length) {
    handleLevelCompletion();
  } else {
    updateProgressCircle();
    loadNextQuestion();
    showNotification(`Skipped ${skipCount} questions!`, "success");
  }
}

function addAdminTestButton() {
  console.log("Checking for admin user...");
  
  const existingButton = document.getElementById('admin-test-button');
  if (existingButton) existingButton.remove();
  
  console.log("Current user:", currentUser ? currentUser.email : "No user");
  
  if (!currentUser || (currentUser.email !== "admin123@gmail.com" && !currentUser.email?.includes("admin123"))) {
    console.log("Not admin user, not adding button");
    return;
  }
  
  console.log("Admin user detected, adding test buttons");
  
  const button = document.createElement('button');
  button.id = 'admin-test-button';
  button.textContent = "Jump to Level 20";
  button.style.cssText = `
    position: fixed;
    top: 80px;
    right: 20px;
    background: #ff5722;
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 5px;
    cursor: pointer;
    z-index: 2000;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    font-weight: bold;
  `;
  
  button.onclick = function() {
    console.log("Admin button clicked, jumping to level 20");
    gameState.currentLevel = 21;
    startLevel(21);
  };
  
  document.body.appendChild(button);
  console.log("Admin test button added to body");
  
  addAdminSkipButton();
}

function updateSidePanelLink() {
  const stageScreenLink = document.querySelector('.nav-link[onclick*="stage-screen"]');
  if (stageScreenLink) {
    stageScreenLink.setAttribute("onclick", "showScreen('stage-cascade-screen'); return false;");
  }
}

document.addEventListener('DOMContentLoaded', () => {
  updateSidePanelLink();
});

function ensureScreenExists(screenId) {
  if (!document.getElementById(screenId)) {
    console.warn(`Screen ${screenId} doesn't exist. Creating it.`);
    const screen = document.createElement('div');
    screen.id = screenId;
    screen.className = 'screen';
    document.body.appendChild(screen);
  }
}

function safeShowScreen(screenId, forceRefresh = false) {
  ensureScreenExists(screenId);
  showScreen(screenId, forceRefresh);
}

function updateSidePanelLinks() {
  const stageScreenLink = document.querySelector('.nav-link[onclick*="stage-screen"]');
  if (stageScreenLink) {
    stageScreenLink.setAttribute("onclick", "safeShowScreen('stage-cascade-screen'); return false;");
  }
  
  document.querySelectorAll('button[onclick*="stage-screen"]').forEach(button => {
    const onclickAttr = button.getAttribute('onclick');
    if (onclickAttr && onclickAttr.includes('stage-screen')) {
      button.setAttribute('onclick', onclickAttr.replace('stage-screen', 'stage-cascade-screen'));
    }
  });
}

function initializeStageCascadeScreen() {
  const screen = document.getElementById('stage-cascade-screen');
  if (!screen.querySelector('.stages-container')) {
    const container = document.createElement('div');
    container.className = 'stages-container';
    screen.appendChild(container);
  }
}

function toggleSidePanel() {
  const sidePanel = document.querySelector('.side-panel');
  const hamburgerButton = document.querySelector('.hamburger-button');
  const modalOverlay = document.querySelector('.modal-overlay');
  
  if (sidePanel.classList.contains('open')) {
    sidePanel.classList.remove('open');
    hamburgerButton.classList.remove('open');
    if (modalOverlay) modalOverlay.classList.remove('open');
  } else {
    sidePanel.classList.add('open');
    hamburgerButton.classList.add('open');
    if (modalOverlay) modalOverlay.classList.add('open');
  }
}

function hasExistingProgress() {
  // Check for completed levels
  if (gameState.completedLevels.size > 0 || gameState.perfectLevels.size > 0) {
    return true;
  }
  
  // Check for unlocked sets beyond defaults
  for (let stage = 1; stage <= 5; stage++) {
    const sets = gameState.unlockedSets[stage];
    // Skip checking default unlocks for stage 1
    if (stage === 1 && (!sets || sets.size === 9)) continue;
    
    // If we have any sets and at least one is beyond the first set
    if (sets && sets.size > 1) {
      return true;
    }
  }
  
  // Check localStorage as a fallback
  const savedProgress = localStorage.getItem('simploxProgress');
  if (savedProgress) {
    const progress = JSON.parse(savedProgress);
    if (progress.completedLevels && progress.completedLevels.length > 0) return true;
    if (progress.perfectLevels && progress.perfectLevels.length > 0) return true;
  }
  
  return false;
}

function findFurthestLevelInStage(stage) {
  if (!gameState.unlockedSets[stage]) return null;
  
  // Sort sets in descending order to find the furthest
  const sets = Array.from(gameState.unlockedSets[stage]).sort((a, b) => b - a);
  
  for (const set of sets) {
    const setKey = `${stage}_${set}`;
    if (!gameState.unlockedLevels[setKey]) continue;
    
    // Sort levels in descending order to find the furthest
    const levels = Array.from(gameState.unlockedLevels[setKey]).sort((a, b) => b - a);
    
    for (const level of levels) {
      const levelKey = `${stage}_${set}_${level}`;
      // If level is not completed, this is the furthest progress
      if (!gameState.perfectLevels.has(levelKey) && !gameState.completedLevels.has(levelKey)) {
        return { stage, set, level };
      }
    }
  }
  
  // If all levels in all sets are completed, suggest the next set
  const stageInfo = gameStructure.stages[stage - 1];
  const lastSet = sets[0];
  
  if (lastSet < stageInfo.numSets) {
    // Suggest first level of next set in the same stage
    return { stage, set: lastSet + 1, level: 1 };
  } else if (stage < 5) {
    // Suggest first level of first set of next stage
    return { stage: stage + 1, set: 1, level: 1 };
  } else {
    // We've completed everything, just return the last set's first level
    return { stage, set: sets[0], level: 1 };
  }
}

function showGradeLevelSelector() {
  const modalBackdrop = document.createElement('div');
  modalBackdrop.className = 'modal-backdrop';
  modalBackdrop.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(5px);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
  const modal = document.createElement('div');
  modal.className = 'grade-level-modal';
  modal.style.cssText = `
        background: var(--glass);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 2rem;
        max-width: 500px;
        width: 90%;
        text-align: center;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
    `;
    
  modal.innerHTML = `
        <h2 style="color: var(--gold); margin-bottom: 1.5rem;">What grade level are you?</h2>
        <p style="margin-bottom: 2rem; opacity: 0.9;">Choose your education level for the best learning experience:</p>
        <div class="grade-options" style="display: flex; flex-direction: column; gap: 1rem;">
            <button class="grade-option" data-stage="2" style="padding: 1rem; border-radius: 10px; background: rgba(255,255,255,0.1); border: none; color: var(--text); cursor: pointer; transition: all 0.3s ease;">
                <i class="fas fa-school" style="margin-right: 0.5rem;"></i> Elementary School
            </button>
            <button class="grade-option" data-stage="3" style="padding: 1rem; border-radius: 10px; background: rgba(255,255,255,0.1); border: none; color: var(--text); cursor: pointer; transition: all 0.3s ease;">
                <i class="fas fa-graduation-cap" style="margin-right: 0.5rem;"></i> Junior High School
            </button>
            <button class="grade-option" data-stage="4" style="padding: 1rem; border-radius: 10px; background: rgba(255,255,255,0.1); border: none; color: var(--text); cursor: pointer; transition: all 0.3s ease;">
                <i class="fas fa-user-graduate" style="margin-right: 0.5rem;"></i> High School
            </button>
            <button class="grade-option" data-stage="5" style="padding: 1rem; border-radius: 10px; background: rgba(255,255,255,0.1); border: none; color: var(--text); cursor: pointer; transition: all 0.3s ease;">
                <i class="fas fa-university" style="margin-right: 0.5rem;"></i> University
            </button>
        </div>
    `;
    
  document.body.appendChild(modalBackdrop);
  modalBackdrop.appendChild(modal);
  
  // Add hover effects and click handlers to buttons
  modal.querySelectorAll('.grade-option').forEach(button => {
    button.addEventListener('mouseover', () => {
      button.style.background = 'rgba(255,255,255,0.2)';
      button.style.transform = 'translateY(-2px)';
    });
    
    button.addEventListener('mouseout', () => {
      button.style.background = 'rgba(255,255,255,0.1)';
      button.style.transform = 'translateY(0)';
    });
    
    button.addEventListener('click', () => {
      const stage = parseInt(button.dataset.stage);
      localStorage.setItem('preferredStage', stage);
      modalBackdrop.remove();
      
      gameState.currentStage = stage;
      gameState.currentSet = 1;
      startLevel(1);
    });
  });
}

function startGame() {
  console.log('Starting game');
  
  if (!hasExistingProgress()) {
    console.log('No existing progress found, showing grade selector');
    return showGradeLevelSelector();
  }
  
  // Check for saved game context
  const savedContext = localStorage.getItem('gameContext');
  if (savedContext) {
    try {
      const context = JSON.parse(savedContext);
      if (context.stage && context.set && context.level) {
        console.log('Found saved game context:', context);
        gameState.currentStage = context.stage;
        gameState.currentSet = context.set;
        gameState.currentLevel = context.level;
        return startLevel(gameState.currentLevel);
      }
    } catch (error) {
      console.error('Error parsing game context:', error);
    }
  }
  
  console.log('Using current game state:', {
    stage: gameState.currentStage, 
    set: gameState.currentSet, 
    level: gameState.currentLevel
  });
  
  startLevel(gameState.currentLevel);
}

function updateLevelProgress(stage, set, level, completed, perfect) {
  const levelKey = `${stage}_${set}_${level}`;
  
  if (perfect) {
    gameState.perfectLevels.add(levelKey);
    gameState.completedLevels.add(levelKey);
  } else if (completed) {
    gameState.completedLevels.add(levelKey);
  }
  
  // Ensure the set exists in unlockedLevels
  const setKey = `${stage}_${set}`;
  if (!gameState.unlockedLevels[setKey]) {
    gameState.unlockedLevels[setKey] = new Set();
  }
  
  // Add the current level to unlocked levels
  gameState.unlockedLevels[setKey].add(level);
  
  // If not at max level, unlock the next level
  const nextLevel = level + 1;
  const isMaxLevel = level === gameStructure.stages[stage - 1].levelsPerSet;
  
  if (!isMaxLevel) {
    gameState.unlockedLevels[setKey].add(nextLevel);
    console.log(`Unlocked next level: ${nextLevel} in set ${setKey}`);
  } else if (completed) {
    checkSetCompletion(stage, set);
  }
  
  saveProgress();
}

function checkSetCompletion(stage, set) {
  const maxLevels = gameStructure.stages[stage - 1].levelsPerSet;
  let completedCount = 0;
  
  for (let level = 1; level <= maxLevels; level++) {
    const levelKey = `${stage}_${set}_${level}`;
    if (gameState.completedLevels.has(levelKey) || gameState.perfectLevels.has(levelKey)) {
      completedCount++;
    }
  }
  
  console.log(`Set ${stage}-${set} completion: ${completedCount}/${maxLevels}`);
  
  if (completedCount === maxLevels) {
    console.log(`Set ${stage}-${set} is complete. Unlocking next set.`);
    unlockNextSet();
  }
}

function unlockNextSet() {
  const stage = gameState.currentStage;
  const set = gameState.currentSet;
  const stageInfo = gameStructure.stages[stage - 1];
  
  if (stageInfo) {
    if (set < stageInfo.numSets) {
      // Unlock next set in current stage
      const nextSet = set + 1;
      
      if (!gameState.unlockedSets[stage]) {
        gameState.unlockedSets[stage] = new Set();
      }
      
      gameState.unlockedSets[stage].add(nextSet);
      
      // Add first level of next set
      const nextSetKey = `${stage}_${nextSet}`;
      if (!gameState.unlockedLevels[nextSetKey]) {
        gameState.unlockedLevels[nextSetKey] = new Set();
      }
      
      gameState.unlockedLevels[nextSetKey].add(1);
      console.log(`Unlocked set ${stage}-${nextSet} and its first level`);
      
      saveProgress();
    } else if (stage < 5) {
      // We're at the last set of the stage, try to unlock the next stage
      unlockNextStage();
    }
  } else {
    console.error(`Invalid stage: ${stage}`);
  }
}

function unlockNextStage() {
  const currentStage = gameState.currentStage;
  
  if (currentStage < 5) {
    const nextStage = currentStage + 1;
    
    // Unlock first set of next stage
    if (!gameState.unlockedSets[nextStage]) {
      gameState.unlockedSets[nextStage] = new Set();
    }
    
    gameState.unlockedSets[nextStage].add(1);
    
    // Unlock first level of first set of next stage
    const nextStageSetKey = `${nextStage}_1`;
    if (!gameState.unlockedLevels[nextStageSetKey]) {
      gameState.unlockedLevels[nextStageSetKey] = new Set();
    }
    
    gameState.unlockedLevels[nextStageSetKey].add(1);
    console.log(`Unlocked stage ${nextStage}, set 1, level 1`);
    
    saveProgress();
  }
}

function showLevelIntro(level, callback) {
  if (currentGame.isCustomPractice) {
    return callback();
  }
  
  const transitionElem = document.createElement('div');
  transitionElem.className = 'slide-transition';
  
  const isTestLevel = [3, 6, 9, 10, 13, 16, 19, 20].includes(level);
  const isBossLevel = level === 21;
  
  let levelClass = 'normal-level';
  if (isTestLevel) levelClass = 'test-level';
  if (isBossLevel) levelClass = 'boss-level';
  
  transitionElem.innerHTML = `
    <div class="slide-panel-left"></div>
    <div class="slide-panel-right"></div>
    <div class="level-announcement ${levelClass}">
      <h1>${isBossLevel ? 'BOSS FIGHT!' : `Stage ${gameState.currentStage}`}</h1>
      <h2>${isBossLevel ? 'FINAL CHALLENGE' : `Level ${gameState.currentSet}-${level}`}</h2>
      ${isTestLevel ? '<div class="test-badge">Review Challenge</div>' : ''}
      ${isBossLevel ? '<div class="boss-badge">DANGER ZONE</div>' : ''}
    </div>
  `;
  
  document.body.appendChild(transitionElem);
  
  const announcement = transitionElem.querySelector('.level-announcement');
  
  // Force reflow
  transitionElem.offsetHeight;
  
  // Start animation
  transitionElem.classList.add('show');
  announcement.classList.add('show');
  
  // Special styling for boss level
  if (isBossLevel) {
    const levelAnnouncement = transitionElem.querySelector('.level-announcement');
    if (levelAnnouncement) {
      levelAnnouncement.style.background = 'linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%)';
      levelAnnouncement.style.boxShadow = '0 0 30px rgba(255, 0, 0, 0.5)';
      
      const title = levelAnnouncement.querySelector('h1');
      if (title) {
        title.style.color = '#ffffff';
        title.style.textShadow = '0 0 20px rgba(255, 0, 0, 0.8)';
      }
    }
  }
  
  // After animation completes, remove transition element
  setTimeout(() => {
    callback();
    transitionElem.classList.remove('show');
    announcement.classList.remove('show');
    setTimeout(() => {
      document.body.removeChild(transitionElem);
    }, 400);
  }, 1500);
}

// Event handler for admin test button
document.addEventListener('DOMContentLoaded', function() {
  if (document.getElementById('question-screen').classList.contains('visible')) {
    console.log('Question screen is visible on load, adding admin button');
    addAdminTestButton();
  }
  
  setTimeout(() => {
    if (currentUser && currentUser.email === 'admin123@gmail.com') {
      console.log('Admin user detected on page load');
      addAdminTestButton();
    }
  }, 2000);
});

// Home button event handler
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('.home-button').forEach(button => {
    button.addEventListener('click', (e) => {
      e.preventDefault();
      showScreen('welcome-screen', true);
    });
  });
});

// Fullscreen change event handler
document.addEventListener('fullscreenchange', function() {
  if (!document.fullscreenElement) {
    console.log('Exited full-screen');
  }
});

// Set up perk buttons in container
document.querySelector('.perks-container').innerHTML = `
    ${Object.entries(PERK_CONFIG).map(([perk, config]) => `
        <button class="perk-button" id="${perk}Perk" onclick="buyPerk('${perk}')">
            <i class="fas ${config.icon} perk-icon"></i>
            <span class="perk-count">0</span>
        </button>
    `).join('')}
`;

// Initialize on window load
window.onload = async () => {
  await checkExistingSession();
  initializeGame();
  updatePerkButtons();
  initializeParticles(document.getElementById('welcome-screen'));
};

function trackWordEncounter(word, gameMode) {
  if (!currentUser) return;
  
  try {
    const { data, error } = supabaseClient
      .from('word_practice_history')
      .select('*')
      .eq('user_id', currentUser.id)
      .eq('word', word)
      .single();
      
    if (error && error.code !== 'PGRST116') return;
    
    let isNewWord = false;
    let coinReward = 0;
    
    if (data) {
      // Existing word - update count
      const newCount = data.practice_count + 1;
      coinReward = newCount <= 5 ? 3 : 1;
      
      const { error } = supabaseClient
        .from('word_practice_history')
        .update({
          practice_count: newCount,
          last_practiced_at: (new Date()).toISOString(),
          game_mode: gameMode,
          coins_earned: data.coins_earned + coinReward
        })
        .eq('user_id', currentUser.id)
        .eq('word', word);
        
      if (error) return;
    } else {
      // New word - create record
      isNewWord = true;
      coinReward = 3;
      
      const { error } = supabaseClient
        .from('word_practice_history')
        .insert([{
          user_id: currentUser.id,
          word: word,
          practice_count: 1,
          game_mode: gameMode,
          coins_earned: coinReward
        }]);
        
      if (error) return;
      
      // Update total unique words count
      const { data, error: statsError } = supabaseClient
        .from('player_stats')
        .select('unique_words_practiced')
        .eq('user_id', currentUser.id)
        .single();
        
      if (!statsError) {
        const newWordCount = (data?.unique_words_practiced || 0) + 1;
        const { error } = supabaseClient
          .from('player_stats')
          .update({ unique_words_practiced: newWordCount })
          .eq('user_id', currentUser.id);
          
        if (!error) {
          document.querySelectorAll('#totalWords').forEach(element => {
            animateNumber(element, parseInt(element.textContent) || 0, newWordCount);
          });
        }
      }
    }
    
    // Award coins for practicing words
    if (coinReward > 0) {
      await CoinsManager.updateCoins(coinReward);
    }
    
    return { isNewWord, coinReward };
  } catch (error) {
    console.error('Error in trackWordEncounter:', error);
  }
}

function updateProgressCircle() {
  const progressCircle = document.querySelector('.progress-circle .progress');
  const progressCircleElement = document.querySelector('.progress-circle');
  
  if (!progressCircle) return;
  
  const circumference = 2 * Math.PI * 54;
  const progress = currentGame.currentIndex / currentGame.words.length;
  
  progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
  progressCircle.style.strokeDashoffset = circumference * (1 - progress);
  
  // Change color based on progress
  let hue, saturation, lightness;
  
  if (progress <= 0.2) {
    hue = 0;
    saturation = 100;
    lightness = 20;
  } else if (progress <= 0.4) {
    hue = 0;
    saturation = 100;
    lightness = 50;
  } else if (progress <= 0.6) {
    hue = 30;
    saturation = 100;
    lightness = 50;
  } else if (progress <= 0.8) {
    hue = 120;
    saturation = 100;
    lightness = 40;
  } else {
    // For the final stretch, transition from green to blue
    const finalProgress = (progress - 0.8) * 5; // Scale to 0-1 for final 20%
    hue = 120 * (1 - finalProgress) + 60 * finalProgress;
    saturation = 100;
    lightness = 40 + 20 * finalProgress;
  }
  
  progressCircle.style.stroke = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}

function loadNextQuestion() {
  // Clear previous button states
  document.querySelectorAll('.buttons button').forEach(button => {
    button.classList.remove('correct', 'wrong');
  });
  
  // Check if we're done with questions
  if (currentGame.currentIndex >= currentGame.words.length) {
    return;
  }
  
  // In test levels, randomly flip between Hebrew and English
  const isTestMode = [3, 6, 9, 10, 13, 16, 19, 20, 21].includes(gameState.currentLevel) && Math.random() < 0.5;
  const currentIndex = currentGame.currentIndex;
  
  // Display the question word
  const questionWord = isTestMode ? currentGame.translations[currentIndex] : currentGame.words[currentIndex];
  document.getElementById('question-word').textContent = questionWord;
  
  // Get the correct answer
  const correctAnswer = isTestMode ? currentGame.words[currentIndex] : currentGame.translations[currentIndex];
  
  // Generate wrong answers using other words from the set
  const wordPool = isTestMode ? currentGame.words : currentGame.translations;
  const answerOptions = new Set([correctAnswer]);
  
  // Add random wrong answers until we have 3 total options
  while (answerOptions.size < 3) {
    const randomAnswer = wordPool[Math.floor(Math.random() * wordPool.length)];
    if (randomAnswer !== correctAnswer) {
      answerOptions.add(randomAnswer);
    }
  }
  
  // Create the answer buttons
  const buttonsContainer = document.getElementById('buttons');
  buttonsContainer.innerHTML = '';
  
  // Convert to array and shuffle answer options
  Array.from(answerOptions).sort(() => Math.random() - 0.5).forEach(answer => {
    const button = document.createElement('button');
    button.textContent = answer;
    button.onclick = () => handleAnswer(answer === correctAnswer);
    buttonsContainer.appendChild(button);
  });
}

function showBossVictoryScreen() {
  console.log("Boss victory screen function called - redirecting to new implementation");
  showBossDefeatEffect();
}

function addAdminTestingButton() {
  if (!currentUser || currentUser.email !== 'admin123@gmail.com') return;
  
  const questionScreen = document.getElementById('question-screen');
  if (document.getElementById('admin-test-button')) return;
  
  const button = document.createElement('button');
  button.id = 'admin-test-button';
  button.innerHTML = 'Jump to Level 20';
  button.style.cssText = `
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: #ff5722;
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 5px;
    cursor: pointer;
    z-index: 1000;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
  `;
  
  button.onclick = function() {
    gameState.currentLevel = 20;
    startLevel(20);
  };
  
  questionScreen.appendChild(button);
}

function awardTimeBonus() {
  const elapsedSeconds = (Date.now() - currentGame.questionStartTime) / 1000;
  
  if (elapsedSeconds < 10) {
    const bonus = Math.floor(10 - elapsedSeconds);
    currentGame.timeBonus += bonus;
    return bonus;
  }
  
  return 0;
}

function pulseCoins(times = 1) {
  document.querySelectorAll('.coin-icon').forEach(icon => {
    let count = 0;
    const animate = () => {
      icon.classList.add('coin-pulse');
      setTimeout(() => {
        icon.classList.remove('coin-pulse');
        count++;
        if (count < times) {
          setTimeout(animate, 100);
        }
      }, 500);
    };
    animate();
  });
}

function updateAllCoinDisplays() {
  document.querySelectorAll('.coin-count').forEach(element => {
    const currentValue = parseInt(element.textContent) || 0;
    let newValue;
    
    // If we're in arcade path, use arcade coins, otherwise use game state coins
    if (window.location.pathname.includes('arcade')) {
      newValue = currentGame.coins || 0;
    } else {
      newValue = gameState.coins || 0;
    }
    
    animateNumber(element, Number(currentValue), Number(newValue));
  });
}

function eliminateWrongAnswer() {
  const buttons = document.querySelectorAll('.buttons button');
  const correctAnswer = currentGame.isHebrewToEnglish ? 
    currentGame.words[currentGame.currentIndex] : 
    currentGame.translations[currentGame.currentIndex];
  
  const wrongButtons = Array.from(buttons).filter(button => button.textContent !== correctAnswer);
  
  if (wrongButtons.length > 0) {
    const buttonToDisable = wrongButtons[Math.floor(Math.random() * wrongButtons.length)];
    buttonToDisable.disabled = true;
    buttonToDisable.style.opacity = '0.5';
  }
}

function revealCorrectAnswer() {
  const correctAnswer = currentGame.isHebrewToEnglish ? 
    currentGame.words[currentGame.currentIndex] : 
    currentGame.translations[currentGame.currentIndex];
  
  document.querySelectorAll('.buttons button').forEach(button => {
    if (button.textContent === correctAnswer) {
      button.classList.add('correct');
      setTimeout(() => {
        currentGame.correctAnswers++;
        currentGame.currentIndex++;
        loadNextQuestion();
      }, 1000);
    } else {
      button.disabled = true;
      button.style.opacity = '0.5';
    }
  });
}

function buyPerk(perkType) {
  const perkConfig = PERK_CONFIG[perkType];
  const perkButton = document.getElementById(`${perkType}Perk`);
  
  if (!perkConfig) {
    console.error('Invalid perk type:', perkType);
    return;
  }
  
  if (gameState.coins < perkConfig.cost) {
    showNotification(`Need ${perkConfig.cost} coins for ${perkConfig.name}!`, 'error');
    return;
  }
  
  // Deduct coins
  gameState.coins -= perkConfig.cost;
  
  // Animate perk count
  const perkCountElem = perkButton.querySelector('.perk-count');
  const currentCount = parseInt(perkCountElem.textContent) || 0;
  animateNumberChange(perkCountElem, currentCount, currentCount - 1);
  
  // Apply perk effect
  switch (perkType) {
    case 'timeFreeze':
      isFrozen = true;
      perkButton.disabled = true;
      setTimeout(() => {
        isFrozen = false;
        perkButton.disabled = false;
      }, perkConfig.duration);
      break;
      
    case 'skip':
      handleAnswer(true, true); // Skip with "correct" result
      break;
      
    case 'clue':
      eliminateWrongAnswer();
      break;
      
    case 'reveal':
      revealCorrectAnswer();
      break;
  }
  
  // Update UI
  updateAllCoinDisplays();
  if (perkButton) {
    perkButton.disabled = gameState.coins < perkConfig.cost;
    perkButton.classList.toggle('disabled', gameState.coins < perkConfig.cost);
  }
  
  saveProgress();
}

function animateNumberChange(element, start, end) {
  if (!element) return;
  
  const step = (end - start) / 20;
  let frame = 0;
  let current = start;
  
  requestAnimationFrame(function updateFrame() {
    frame++;
    current += step;
    
    if (frame <= 20) {
      element.textContent = Math.round(current);
      requestAnimationFrame(updateFrame);
    } else {
      element.textContent = end;
    }
  });
}

function handleLevelCompletion() {
  clearTimer();
  
  if (currentGame.isBossLevel) {
    restoreFromBossLevel();
    
    CoinsManager.updateCoins(100).then(() => {
      showBossDefeatEffect();
      
      const victoryMessage = document.createElement('div');
      victoryMessage.className = 'boss-victory-message';
      victoryMessage.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #4CAF50, #2E7D32);
        color: white;
        padding: 2rem;
        border-radius: 20px;
        text-align: center;
        z-index: 1000;
        max-width: 80%;
        box-shadow: 0 0 30px rgba(76, 175, 80, 0.5);
      `;
      
      victoryMessage.innerHTML = `
        <h2 style="font-size: 2rem; margin-bottom: 1rem;">Boss Defeated!</h2>
        <p style="font-size: 1.2rem; margin-bottom: 2rem;">You've earned 100 coins for defeating the boss!</p>
        <div style="display: flex; justify-content: center; gap: 1rem;">
          <button class="continue-button" style="
            background: white;
            color: #2E7D32;
            border: none;
            padding: 1rem 2rem;
            border-radius: 50px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
          ">Continue to Next Set</button>
          <button class="home-button" style="
            background: transparent;
            color: white;
            border: 2px solid white;
            padding: 1rem 2rem;
            border-radius: 50px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
          ">Return Home</button>
        </div>
      `;
      
      document.body.appendChild(victoryMessage);
      
      // Add event listeners to buttons
      const continueButton = victoryMessage.querySelector('.continue-button');
      if (continueButton) {
        continueButton.addEventListener('click', () => {
          victoryMessage.remove();
          unlockNextSet();
          
          const nextSet = gameState.currentSet + 1;
          gameState.currentSet = nextSet;
          gameState.currentLevel = 1;
          startLevel(1);
        });
      }
      
      const homeButton = victoryMessage.querySelector('.home-button');
      if (homeButton) {
        homeButton.addEventListener('click', () => {
          victoryMessage.remove();
          unlockNextSet();
          showScreen('welcome-screen');
        });
      }
    });
    
    return;
  }
  
  // Check level completion status
  const levelKey = `${gameState.currentStage}_${gameState.currentSet}_${gameState.currentLevel}`;
  console.log(`Completing level: ${levelKey}`);
  
  const previouslyCompleted = gameState.perfectLevels.has(levelKey) || gameState.completedLevels.has(levelKey);
  console.log(`Level was previously completed: ${previouslyCompleted}`);
  
  // Check if completed perfectly
  const perfectCompletion = currentGame.streakBonus && currentGame.correctAnswers === currentGame.words.length;
  
  // If not previously completed and perfect this time
  if (!previouslyCompleted && perfectCompletion) {
    const perfectBonus = 5;
    
    CoinsManager.updateCoins(perfectBonus).then(() => {
      updateLevelProgress(gameState.currentStage, gameState.currentSet, gameState.currentLevel, true, true);
      
      // Create celebration particles
      const screenRect = document.getElementById('question-screen').getBoundingClientRect();
      createParticles(screenRect.left + screenRect.width / 2, screenRect.top + screenRect.height / 2);
    });
  } else if (!previouslyCompleted) {
    // First time completion but not perfect
    updateLevelProgress(gameState.currentStage, gameState.currentSet, gameState.currentLevel, true, false);
  }
  
  // Visual feedback
  pulseCoins(5);
  updatePerkButtons();
  
  // Determine next step
  const stageInfo = gameStructure.stages[gameState.currentStage - 1];
  const isLastLevel = gameState.currentLevel === stageInfo.levelsPerSet;
  const isLastSet = gameState.currentSet === stageInfo.numSets;
  const userStatus = currentUser ? currentUser.status : 'unregistered';
  
  if (isLastLevel) {
    // Completed the last level in a set
    checkSetCompletion(gameState.currentStage, gameState.currentSet);
    
    if (isLastSet) {
      // Completed the last set in a stage
      if (userStatus === 'premium' && gameState.currentStage < 5) {
        // Premium users can advance to next stage
        setTimeout(() => {
          gameState.currentStage++;
          gameState.currentSet = 1;
          gameState.currentLevel = 1;
          startLevel(1);
        }, 1500);
      } else {
        // Others go back to stage selection
        setTimeout(() => showScreen('stage-cascade-screen'), 1500);
      }
    } else {
      // Move to next set
      setTimeout(() => {
        gameState.currentSet++;
        gameState.currentLevel = 1;
        startLevel(1);
      }, 1500);
    }
  } else {
    // Move to next level in current set
    setTimeout(() => {
      gameState.currentLevel++;
      startLevel(gameState.currentLevel);
    }, 1500);
  }
}

function checkSetCompletion(stage, set) {
  const maxLevels = gameStructure.stages[stage - 1].levelsPerSet;
  let completedCount = 0;
  
  for (let level = 1; level <= maxLevels; level++) {
    const levelKey = `${stage}_${set}_${level}`;
    if (gameState.completedLevels.has(levelKey) || gameState.perfectLevels.has(levelKey)) {
      completedCount++;
    }
  }
  
  console.log(`Set ${stage}-${set} completion: ${completedCount}/${maxLevels}`);
  
  if (completedCount === maxLevels) {
    console.log(`Set ${stage}-${set} is complete. Unlocking next set.`);
    unlockNextSet();
  }
}

function handleProgression(perfect) {
  // Unlock current level in the set
  const setKey = `${gameState.currentStage}_${gameState.currentSet}`;
  if (!gameState.unlockedLevels[setKey]) {
    gameState.unlockedLevels[setKey] = new Set();
  }
  
  gameState.unlockedLevels[setKey].add(gameState.currentLevel);
  
  // Check if we need to unlock the next level, set, or stage
  const stageInfo = gameStructure.stages[gameState.currentStage - 1];
  const isLastLevel = gameState.currentLevel === stageInfo.levelsPerSet;
  const isLastSet = gameState.currentSet === stageInfo.numSets;
  
  if (isLastLevel) {
    if (isLastSet) {
      // Last level of last set in stage - try to unlock next stage if not at max
      if (gameState.currentStage < 5) {
        unlockNextStage();
      }
    } else {
      // Last level of set but not last set - unlock next set
      unlockNextSet();
    }
  } else {
    // Not last level - unlock next level in current set
    gameState.unlockedLevels[setKey].add(gameState.currentLevel + 1);
  }
  
  saveProgress();
  updateAllCoinDisplays();
  
  // Navigate to next level/set/stage after a delay
  setTimeout(() => {
    if (isLastLevel) {
      if (isLastSet) {
        if (gameState.currentStage < 5) {
          gameState.currentStage++;
          gameState.currentSet = 1;
          startLevel(1);
        } else {
          showScreen('stage-screen');
        }
      } else {
        gameState.currentSet++;
        startLevel(1);
      }
    } else {
      startLevel(gameState.currentLevel + 1);
    }
  }, 1500);
}

function createCompletionParticles() {
  const screenRect = document.getElementById('question-screen').getBoundingClientRect();
  const centerX = screenRect.left + screenRect.width / 2;
  const centerY = screenRect.top + screenRect.height / 2;
  
  for (let i = 0; i < 5; i++) {
    setTimeout(() => createParticles(centerX, centerY), i * 300);
  }
}

function activatePerk(perkType, cost) {
  const lastUsed = powerupCooldowns.get(perkType) || 0;
  const now = Date.now();
  
  if (now - lastUsed < 5000) {
    showNotification('Perk is on cooldown', 'warning');
    return;
  }
  
  CoinsManager.updateCoins(-cost)
    .then(success => {
      if (success) {
        gameState.perks[perkType]++;
        saveProgress();
        updatePerkButtons();
        usePerk(perkType);
        powerupCooldowns.set(perkType, now);
        showNotification(`${perkType} activated!`, 'success');
      } else {
        showNotification('Not enough coins', 'error');
      }
    })
    .catch(error => {
      console.error('Perk activation failed:', error);
      showNotification('Failed to activate perk', 'error');
    });
}

function initializeParticles(container = document.body) {
  if (!(container instanceof HTMLElement)) {
    container = document.body;
  }
  
  // Check if container already has particles
  let particleContainer = container.querySelector('.particle-container');
  if (!particleContainer) {
    particleContainer = document.createElement('div');
    particleContainer.classList.add('particle-container');
    container.appendChild(particleContainer);
  }
  
  // Characters to use for particles
  const characters = [
    ..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
    ..."ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρστυφχψω",
    ..."אבגדהוזחטיכלמנסעפצקרשת"
  ];
  
  // Create a letter particle
  function createLetterParticle() {
    const particle = document.createElement('div');
    particle.classList.add('letter-particle');
    particle.textContent = characters[Math.floor(Math.random() * characters.length)];
    
    const x = Math.random() * container.clientWidth;
    const y = Math.random() * container.clientHeight;
    const moveX = Math.random() * 200 - 100;
    const moveY = Math.random() * 200 - 100;
    const fontSize = 12 + (Math.random() * 16);
    const opacity = 0.2 + Math.random() * 0.3;
    const rotation = Math.random() * 180;
    const duration = 8 + (Math.random() * 10);
    
    particle.style.cssText = `
            position: absolute;
            left: ${x}px;
            top: ${y}px;
            font-size: ${fontSize}px;
            animation: letterFloat ${duration}s ease-in-out forwards;
            --moveX: ${moveX}px;
            --moveY: ${moveY}px;
            --opacity: ${opacity};
            --rotate: ${rotation}deg;
            pointer-events: none;
        `;
        
    particleContainer.appendChild(particle);
    
    setTimeout(() => {
      particleContainer.removeChild(particle);
    }, duration * 1000);
  }
  
  // Create initial particles
  for (let i = 0; i < 50; i++) {
    createLetterParticle();
  }
  
  // Create new particles at an interval
  const intervalId = setInterval(createLetterParticle, 1000);
  
  // Store interval ID to be able to clear it later
  particleContainer.dataset.intervalId = intervalId;
}

function stopLevelAndGoBack() {
  clearTimer();
  isFrozen = false;
  
  currentGame = {
    words: [],
    translations: [],
    currentIndex: 0,
    correctAnswers: 0,
    firstAttempt: true,
    isHebrewToEnglish: false,
    mixed: false,
    speedChallenge: false,
    timeBonus: 0,
    initialTimeRemaining: null,
    streakBonus: true,
    levelStartTime: Date.now(),
    questionStartTime: 0,
    wrongStreak: 0,
    progressLost: 0,
    restartsRemaining: null
  };
  
  showScreen('welcome-screen');
}

function showGameOverOverlay() {
  clearTimer();
  
  const overlay = document.querySelector('.failure-overlay');
  overlay.querySelector('.failure-title').textContent = 'Game Over!';
  overlay.style.display = 'flex';
  
  setTimeout(() => {
    overlay.classList.add('show');
  }, 100);
  
  document.querySelector('.restart-button').onclick = () => {
    overlay.classList.remove('show');
    setTimeout(() => {
      overlay.style.display = 'none';
      startLevel(gameState.currentLevel);
    }, 1000);
  };
  
  document.querySelector('.home-button').onclick = () => {
    overlay.classList.remove('show');
    setTimeout(() => {
      overlay.style.display = 'none';
      showScreen('welcome-screen');
    }, 1000);
  };
}

function updateTimerCircle(remaining, total) {
  const timerProgress = document.querySelector('.timer-progress');
  if (!timerProgress) return;
  
  const circumference = 2 * Math.PI * 40;
  timerProgress.style.strokeDasharray = `${circumference} ${circumference}`;
  
  const offset = circumference * (1 - remaining / total);
  timerProgress.style.strokeDashoffset = offset;
  
  if (remaining <= 10) {
    timerProgress.classList.add('warning');
  } else {
    timerProgress.classList.remove('warning');
  }
}

function handleResetProgress() {
  if (!isFirstResetAttempt) {
    // Second click - perform actual reset
    gameState.currentStage = 1;
    gameState.currentSet = 1;
    gameState.currentLevel = 1;
    gameState.coins = 0;
    gameState.unlockedSets = { 1: new Set([1]) };
    gameState.unlockedLevels = { '1_1': new Set([1]) };
    gameState.perfectLevels = new Set();
    gameState.completedLevels = new Set();
    
    localStorage.removeItem('simploxProgress');
    localStorage.removeItem('simploxCustomCoins');
    
    updatePerkButtons();
    updateAllCoinDisplays();
    showScreen('welcome-screen');
    
    isFirstResetAttempt = true;
    return;
  }
  
  // First click - warning
  const resetButton = document.querySelector('.reset-button');
  resetButton.classList.add('warning');
  
  isFirstResetAttempt = false;
  
  setTimeout(() => {
    resetButton.classList.remove('warning');
  }, 1000);
  
  // Auto-reset the first attempt flag after delay
  if (resetProgressTimeout) {
    clearTimeout(resetProgressTimeout);
  }
  
  resetProgressTimeout = setTimeout(() => {
    isFirstResetAttempt = true;
  }, 10000);
}

function toggleFullScreen() {
  const icon = document.querySelector('.fullscreen-button i');
  
  if (document.fullscreenElement) {
    if (document.exitFullscreen) {
      document.exitFullscreen().then(() => {
        icon.classList.remove('fa-compress');
        icon.classList.add('fa-expand');
      }).catch(error => {
        console.log(`Error attempting to exit fullscreen: ${error.message}`);
      });
    }
  } else {
    document.documentElement.requestFullscreen().then(() => {
      icon.classList.remove('fa-expand');
      icon.classList.add('fa-compress');
    }).catch(error => {
      console.log(`Error attempting to enable fullscreen: ${error.message}`);
    });
  }
}

function handleRestartLevel() {
  if (currentGame.restartsRemaining <= 0) return;
  
  const restartButton = document.querySelector('.navigation-button.restart-level');
  
  currentGame.restartsRemaining--;
  
  if (currentGame.restartsRemaining === 1) {
    restartButton.style.opacity = '0.7';
  } else if (currentGame.restartsRemaining === 0) {
    restartButton.classList.add('disabled');
    restartButton.onclick = null;
    restartButton.disabled = true;
  }
  
  // Reset to starting state
  gameState.coins = currentGame.startingCoins;
  gameState.perks = { ...currentGame.startingPerks };
  
  updatePerkButtons();
  updateAllCoinDisplays();
  saveProgress();
  
  startLevel(gameState.currentLevel);
}

function showStagesFromMenu() {
  showScreen('stage-screen');
}

function startTimer(duration) {
  clearTimer();
  
  if (currentGame.currentIndex >= currentGame.words.length) {
    return;
  }
  
  if (currentGame.initialTimeRemaining) {
    timeRemaining = currentGame.initialTimeRemaining;
  } else {
    currentGame.initialTimeRemaining = 10 * currentGame.words.length;
    timeRemaining = currentGame.initialTimeRemaining;
    currentGame.totalTime = timeRemaining;
  }
  
  console.log('Starting timer with:', timeRemaining, 'seconds');
  
  currentGame.questionStartTime = Date.now();
  
  updateTimerDisplay();
  updateTimerCircle(timeRemaining, currentGame.totalTime);
  
  timer = setInterval(() => {
    if (!isFrozen) {
      timeRemaining = Math.max(0, timeRemaining - 1);
      updateTimerDisplay();
      updateTimerCircle(timeRemaining, currentGame.totalTime);
      
      currentGame.initialTimeRemaining = timeRemaining;
      
      if (timeRemaining <= 10) {
        document.querySelector('.timer-value').classList.add('warning');
      }
      
      if (timeRemaining <= 0) {
        handleTimeUp();
      }
    }
  }, 1000);
}

function updateTimerDisplay() {
  const minutes = Math.floor(timeRemaining / 60);
  const seconds = timeRemaining % 60;
  const timerElement = document.querySelector('.timer-value');
  
  timerElement.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
  
  if (timeRemaining <= 10) {
    timerElement.classList.add('warning');
  } else {
    timerElement.classList.remove('warning');
  }
}

function clearTimer() {
  if (timer) {
    clearInterval(timer);
    timer = null;
  }
  
  timeRemaining = 0;
  isFrozen = false;
  
  const timerProgressElement = document.querySelector('.timer-progress');
  if (timerProgressElement) {
    timerProgressElement.classList.remove('warning');
  }
  
  updateTimerCircle(0, 1);
}

function createParticles(x, y) {
  // Configuration for different screen sizes
  const config = window.matchMedia('(max-width: 768px)').matches
    ? { count: 10, size: 6, distance: 50, opacity: 0.7, duration: 1000 }
    : { count: 40, size: 10, distance: 150, opacity: 1, duration: 1500 };
  
  // Colors for particles
  const colors = ['#ffd700', '#FFA500', '#4CAF50', '#FFD700'];
  
  const bodyElement = document.body;
  
  for (let i = 0; i < config.count; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
    particle.style.position = 'fixed';
    particle.style.left = `${x}px`;
    particle.style.top = `${y}px`;
    
    // Calculate random angle and distance
    const angle = Math.random() * Math.PI * 2;
    const distance = config.distance + Math.random() * 50;
    
    // Set particle properties
    particle.style.width = `${config.size}px`;
    particle.style.height = `${config.size}px`;
    particle.style.opacity = `${config.opacity}`;
    particle.style.setProperty('--x', Math.cos(angle) * distance + 'px');
    particle.style.setProperty('--y', Math.sin(angle) * distance + 'px');
    
    particle.style.animation = `particleBurst ${config.duration / 1000}s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards`;
    
    bodyElement.appendChild(particle);
    
    // Remove particle after animation completes
    setTimeout(() => {
      bodyElement.removeChild(particle);
    }, config.duration);
  }
}

function animateCoinsChange(element, startValue, endValue) {
  if (!element) return;
  
  const fps = 1000 / (1000 / 60); // 60 fps
  const frames = fps;
  const step = (endValue - startValue) / frames;
  
  let currentFrame = 0;
  let currentValue = startValue;
  
  function animate() {
    currentFrame++;
    currentValue += step;
    
    if (currentFrame <= frames) {
      element.textContent = Math.round(currentValue);
      
      if (step > 0) {
        element.style.color = 'var(--success)';
      } else if (step < 0) {
        element.style.color = 'var(--error)';
      }
      
      requestAnimationFrame(animate);
    } else {
      element.textContent = endValue;
      
      setTimeout(() => {
        element.style.color = 'var(--text)';
      }, 300);
    }
  }
  
  animate();
}

function handleTimeUp() {
  if (currentGame.currentIndex >= currentGame.words.length) return;
  
  clearTimer();
  showReviveOverlay();
}

function showNotification(message, type = 'info') {
  const notification = document.createElement('div');
  notification.className = `game-notification ${type}`;
  notification.textContent = message;
  
  document.body.appendChild(notification);
  
  requestAnimationFrame(() => {
    notification.classList.add('show');
  });
  
  setTimeout(() => {
    notification.classList.remove('show');
    setTimeout(() => {
      notification.remove();
    }, 300);
  }, 3000);
}

function showReviveOverlay() {
  const overlay = document.createElement('div');
  overlay.className = 'revive-overlay';
  overlay.innerHTML = `
        <div class="revive-content">
            <div class="ankh-symbol">☥</div>
            <h2 class="revive-title">Revive?</h2>
            <div class="revive-timer">5</div>
            <button class="revive-button">Revive</button>
        </div>
    `;
    
  document.body.appendChild(overlay);
  
  requestAnimationFrame(() => {
    overlay.classList.add('show');
  });
  
  let countdown = 5;
  const timerElement = overlay.querySelector('.revive-timer');
  const interval = setInterval(() => {
    countdown--;
    timerElement.textContent = countdown;
    
    if (countdown <= 0) {
      clearInterval(interval);
      handleReviveTimeout();
    }
  }, 1000);
  
  overlay.querySelector('.revive-button').onclick = () => {
    clearInterval(interval);
    handleRevive();
  };
  
  overlay.dataset.intervalId = interval;
}

function handleReviveTimeout() {
  const overlay = document.querySelector('.revive-overlay');
  if (overlay) {
    overlay.classList.remove('show');
    setTimeout(() => {
      overlay.remove();
      showScreen('welcome-screen');
    }, 500);
  }
}

function handleRevive() {
  const overlay = document.querySelector('.revive-overlay');
  if (overlay) {
    overlay.querySelector('.revive-content').innerHTML = `
            <div class="resurrection-animation">
                <div class="progress-circle resurrection-circle">
                    <svg width="100%" height="100%" viewBox="0 0 120 120">
                        <circle class="bg" cx="60" cy="60" r="54" stroke-width="8"/>
                        <circle class="resurrection-progress" cx="60" cy="60" r="54" stroke-width="8"/>
                    </svg>
                    <div class="ankh-symbol resurrection-ankh">☥</div>
                </div>
            </div>
        `;
        
    const progressCircle = overlay.querySelector('.resurrection-progress');
    const circumference = 2 * Math.PI * 54;
    
    progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
    progressCircle.style.strokeDashoffset = circumference;
    
    createResurrectionParticles();
    
    setTimeout(() => {
      progressCircle.style.transition = 'stroke-dashoffset 2s cubic-bezier(0.4, 0, 0.2, 1)';
      progressCircle.style.strokeDashoffset = '0';
    }, 100);
    
    setTimeout(() => {
      overlay.classList.remove('show');
      setTimeout(() => {
        overlay.remove();
        
        // Reset game state for retry
        currentGame.wrongStreak = 0;
        timeRemaining = currentGame.initialTimeRemaining;
        
        if (currentGame.isCustomPractice) {
          startCustomLevel(currentGame.customLevel);
        } else {
          startLevel(gameState.currentLevel);
        }
      }, 500);
    }, 2500);
  }
}

function createResurrectionParticles() {
  const animation = document.querySelector('.resurrection-animation');
  if (!animation) return;
  
  const rect = animation.getBoundingClientRect();
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;
  
  for (let i = 0; i < 40; i++) {
    const particle = document.createElement('div');
    particle.className = 'resurrection-particle';
    
    const angle = Math.random() * Math.PI * 2;
    const distance = 100 + Math.random() * 150;
    const duration = 1 + Math.random() * 1.5;
    const delay = Math.random() * 0.5;
    const size = 3 + Math.random() * 7;
    
    const endX = Math.cos(angle) * distance;
    const endY = Math.sin(angle) * distance;
    
    particle.style.cssText = `
            position: fixed;
            left: ${centerX}px;
            top: ${centerY}px;
            width: ${size}px;
            height: ${size}px;
            background: #FFD700;
            border-radius: 50%;
            opacity: 0;
            z-index: 1001;
            box-shadow: 0 0 ${size}px #FFD700;
            transform: translate(-50%, -50%);
            animation: particleFlow ${duration}s ease-out ${delay}s forwards;
        `;
        
    particle.style.setProperty('--end-x', `${endX}px`);
    particle.style.setProperty('--end-y', `${endY}px`);
    
    document.body.appendChild(particle);
    
    setTimeout(() => {
      particle.remove();
    }, (duration + delay) * 1000 + 100);
  }
}

function startLevel(level) {
  gameState.currentLevel = level;
  
  // Save current context to localStorage
  const context = {
    stage: gameState.currentStage,
    set: gameState.currentSet,
    level: level,
    timestamp: Date.now()
  };
  
  console.log('Setting game context at level start:', context);
  localStorage.setItem('gameContext', JSON.stringify(context));
  
  // Initialize game state
  currentGame.wrongStreak = 0;
  currentGame.correctAnswers = 0;
  currentGame.levelStartTime = Date.now();
  currentGame.firstAttempt = true;
  currentGame.streakBonus = true;
  
  updatePerkButtons();
  
  console.log("Current unlocked levels:", gameState.unlockedLevels);
  
  const setKey = `${gameState.currentStage}_${gameState.currentSet}`;
  console.log(`Current set key: ${setKey}, unlocked levels in set:`, 
    gameState.unlockedLevels[setKey] ? Array.from(gameState.unlockedLevels[setKey]) : "none");
  
  // Show perk buttons, hide powerups for regular game
  const perksContainer = document.querySelector('.perks-container');
  const powerupsContainer = document.querySelector('.powerups-container');
  
  if (perksContainer) {
    perksContainer.style.display = 'flex';
  }
  
  if (powerupsContainer) {
    powerupsContainer.style.display = 'none';
  }
  
  // Display user's coins
  const coinDisplay = document.querySelector('.coin-count');
  if (coinDisplay) {
    coinDisplay.textContent = gameState.coins || 0;
    coinDisplay.style.display = 'flex';
  }
  
  const coinsContainer = document.querySelector('.coins-container');
  if (coinsContainer) {
    coinsContainer.style.display = 'flex';
  }
  
  // Set current game state
  gameState.currentStage = gameState.currentStage || 1;
  gameState.currentSet = gameState.currentSet || 1;
  gameState.currentLevel = level;
  
  console.log(`Starting level: Stage ${gameState.currentStage}, Set ${gameState.currentSet}, Level ${level}`);
  
  // Add admin test button if applicable
  addAdminTestButton();
  
  // Check if level needs premium
  const userStatus = currentUser ? currentUser.status : 'unregistered';
  
  if ([2, 7, 11, 15, 20].includes(level) && userStatus !== 'premium') {
    const targetLevel = level;
    
    if (!currentUser) {
      return showUnregisteredWarning(() => {
        proceedWithLevel(targetLevel);
      });
    }
    
    if (!localStorage.getItem(`upgradeRequested_${currentUser.id}`)) {
      return showUpgradePrompt(() => {
        proceedWithLevel(targetLevel);
      });
    }
  }
  
  // Check for boss level
  if (level === 21) {
    currentGame.isBossLevel = true;
    console.log("Boss level detected");
    setTimeout(applyBossLevelStyles, 100);
    setTimeout(applyBossLevelStyles, 500);
  } else {
    currentGame.isBossLevel = false;
  }
  
  proceedWithLevel(level);
}

function proceedWithLevel(level) {
  // Initialize restarts if not already set
  if (!currentGame.restartsRemaining) {
    currentGame.restartsRemaining = 2;
  }
  
  gameState.currentLevel = level;
  
  const setKey = `${gameState.currentStage}_${gameState.currentSet}`;
  const vocabSet = vocabularySets[setKey];
  
  // Set up coin display
  const coinDisplay = document.querySelector('.coin-count');
  if (coinDisplay) {
    coinDisplay.textContent = gameState.coins || 0;
    coinDisplay.style.display = 'block';
  }
  
  // Save current game state for potential restart
  currentGame.startingCoins = gameState.coins;
  currentGame.startingPerks = { ...gameState.perks };
  currentGame.timeBonus = 0;
  currentGame.initialTimeRemaining = null;
  currentGame.streakBonus = true;
  currentGame.levelStartTime = Date.now();
  
  // Show level introduction
  showLevelIntro(level, () => {
    // Set up game state with level words
    setupGameState(calculateWordsForLevel(level, vocabSet), vocabSet);
    
    // Show question screen
    showScreen('question-screen');
    
    // Add admin button if applicable
    addAdminTestButton();
    
    // Initialize boss level if needed
    if (level === 21) {
      console.log("Initializing boss level in proceedWithLevel");
      initializeBossLevel();
      setTimeout(applyBossLevelStyles, 200);
      loadNextBossQuestion();
    } else {
      // Update progress circle and load first question
      updateProgressCircle();
      loadNextQuestion();
    }
    
    // Start timer after a short delay
    setTimeout(() => {
      startTimer(currentGame.words.length);
    }, 200);
  });
}

function setupGameState(levelConfig, vocabSet) {
  if (typeof levelConfig === 'object') {
    // If we have specific random indices
    if (levelConfig.randomIndices) {
      const words = levelConfig.randomIndices.map(index => vocabSet.words[index]);
      const translations = levelConfig.randomIndices.map(index => vocabSet.translations[index]);
      
      Object.assign(currentGame, {
        words: words,
        translations: translations,
        currentIndex: 0,
        correctAnswers: 0,
        firstAttempt: true,
        isHebrewToEnglish: levelConfig.isHebrewToEnglish || false,
        mixed: levelConfig.mixed || false,
        speedChallenge: levelConfig.speedChallenge || false,
        isBossLevel: levelConfig.isBossLevel || false
      });
    } else {
      // If we have start/count configuration
      const { startIndex, count, isHebrewToEnglish, mixed, speedChallenge, isBossLevel } = levelConfig;
      
      Object.assign(currentGame, {
        words: vocabSet.words.slice(startIndex, startIndex + count),
        translations: vocabSet.translations.slice(startIndex, startIndex + count),
        currentIndex: 0,
        correctAnswers: 0,
        firstAttempt: true,
        isHebrewToEnglish: isHebrewToEnglish || false,
        mixed: mixed || false,
        speedChallenge: speedChallenge || false,
        isBossLevel: isBossLevel || false
      });
    }
  } else {
    // Simple count-based setup (legacy mode)
    Object.assign(currentGame, {
      words: vocabSet.words.slice(0, levelConfig),
      translations: vocabSet.translations.slice(0, levelConfig),
      currentIndex: 0,
      correctAnswers: 0,
      firstAttempt: true,
      isHebrewToEnglish: false,
      mixed: false,
      speedChallenge: false,
      isBossLevel: false
    });
  }
}

function calculateWordsForLevel(level, vocabSet) {
  const totalWords = vocabSet.words.length;
  const extraWords = totalWords - 50; // Adjust for sets with more than 50 words
  
  // Create randomized indices if they don't exist
  if (!vocabSet.randomIndices) {
    vocabSet.randomIndices = Array.from({ length: totalWords }, (_, i) => i);
    
    // Shuffle array
    for (let i = vocabSet.randomIndices.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [vocabSet.randomIndices[i], vocabSet.randomIndices[j]] = 
      [vocabSet.randomIndices[j], vocabSet.randomIndices[i]];
    }
    
    console.log("Created randomized word indices:", vocabSet.randomIndices);
  }
  
  // Boss level (final level)
  if (level === 21) {
    return {
      startIndex: 0,
      count: totalWords,
      isBossLevel: true,
      speedChallenge: true,
      mixed: true,
      isTestLevel: true,
      isHebrewToEnglish: Math.random() < 0.5,
      testLevels: [],
      randomIndices: vocabSet.randomIndices
    };
  }
  
  // Levels 1-2: Basic introductory levels
  if (level === 1 || level === 2) {
    const startIdx = 3 * (level - 1);
    return {
      startIndex: startIdx,
      count: 3,
      testLevels: [3, 10, 21],
      randomIndices: vocabSet.randomIndices.slice(startIdx, startIdx + 3)
    };
  }
  
  // Level 3: First test level
  if (level === 3) {
    return {
      startIndex: 0,
      count: 6,
      isTestLevel: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabSet.randomIndices.slice(0, 6)
    };
  }
  
  // Levels 4-5: More basic words
  if (level === 4 || level === 5) {
    const startIdx = 6 + 3 * (level - 4);
    return {
      startIndex: startIdx,
      count: 3,
      testLevels: [6, 10, 21],
      randomIndices: vocabSet.randomIndices.slice(startIdx, startIdx + 3)
    };
  }
  
  // Level 6: Second test level
  if (level === 6) {
    return {
      startIndex: 6,
      count: 6,
      isTestLevel: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabSet.randomIndices.slice(6, 12)
    };
  }
  
  // Levels 7-8: More words
  if (level === 7 || level === 8) {
    const startIdx = 12 + 4 * (level - 7);
    return {
      startIndex: startIdx,
      count: 4,
      testLevels: [9, 10, 21],
      randomIndices: vocabSet.randomIndices.slice(startIdx, startIdx + 4)
    };
  }
  
  // Level 9: Third test level
  if (level === 9) {
    return {
      startIndex: 12,
      count: 8,
      isTestLevel: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabSet.randomIndices.slice(12, 20)
    };
  }
  
  // Level 10: Speed challenge
  if (level === 10) {
    return {
      startIndex: 0,
      count: 20,
      isTestLevel: true,
      speedChallenge: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabSet.randomIndices.slice(0, 20)
    };
  }
  
  // Levels 11-12: More words
  if (level === 11 || level === 12) {
    const startIdx = 20 + 4 * (level - 11);
    return {
      startIndex: startIdx,
      count: 4,
      testLevels: [13, 20, 21],
      randomIndices: vocabSet.randomIndices.slice(startIdx, startIdx + 4)
    };
  }
  
  // Level 13: Fourth test level
  if (level === 13) {
    return {
      startIndex: 20,
      count: 8,
      isTestLevel: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabSet.randomIndices.slice(20, 28)
    };
  }
  
  // Levels 14-15: More words
  if (level === 14 || level === 15) {
    const count = level === 14 ? 5 : 6;
    const startIdx = 28 + (level === 14 ? 0 : 5);
    return {
      startIndex: startIdx,
      count: count,
      testLevels: [16, 20, 21],
      randomIndices: vocabSet.randomIndices.slice(startIdx, startIdx + count)
    };
  }
  
  // Level 16: Fifth test level
  if (level === 16) {
    return {
      startIndex: 28,
      count: 11,
      isTestLevel: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabSet.randomIndices.slice(28, 39)
    };
  }
  
  // Levels 17-18: More words with extras if available
  if (level === 17 || level === 18) {
    const baseCount = level === 17 ? 5 : 6;
    const extraCount = baseCount + (extraWords > 0 ? extraWords : 0);
    const startIdx = 39 + (level === 17 ? 0 : baseCount);
    return {
      startIndex: startIdx,
      count: extraCount,
      testLevels: [19, 20, 21],
      randomIndices: vocabSet.randomIndices.slice(startIdx, startIdx + extraCount)
    };
  }
  
  // Level 19: Sixth test level
  if (level === 19) {
    return {
      startIndex: 39,
      count: 11,
      isTestLevel: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabSet.randomIndices.slice(39, 50)
    };
  }
  
  // Level 20: Second speed challenge
  if (level === 20) {
    return {
      startIndex: 20,
      count: 30,
      isTestLevel: true,
      speedChallenge: true,
      mixed: true,
      isHebrewToEnglish: Math.random() < 0.5,
      randomIndices: vocabSet.randomIndices.slice(20, 50)
    };
  }
}

function getUnusedWords(vocabSet) {
  // Initialize used words Set if it doesn't exist
  if (!gameState.usedWords) {
    gameState.usedWords = new Set();
  }
  
  // Get all indices that haven't been used yet
  return vocabSet.words.map((_, i) => i)
    .filter(idx => !gameState.usedWords.has(idx));
}

function selectRandomWords(availableIndices, count) {
  const selectedIndices = new Set();
  
  // Add random indices until we have enough or run out
  while (selectedIndices.size < count && availableIndices.length > selectedIndices.size) {
    const randomIndex = Math.floor(Math.random() * availableIndices.length);
    selectedIndices.add(availableIndices[randomIndex]);
    gameState.usedWords.add(availableIndices[randomIndex]);
  }
  
  return Array.from(selectedIndices);
}

function generateAnswerChoices(correctAnswer, vocabSet) {
  const choices = new Set([correctAnswer]);
  const allTranslations = vocabSet.translations;
  
  // Add random wrong answers until we have 3 total options
  while (choices.size < 3) {
    const randomAnswer = allTranslations[Math.floor(Math.random() * allTranslations.length)];
    choices.add(randomAnswer);
  }
  
  // Convert to array and shuffle
  return Array.from(choices).sort(() => Math.random() - 0.5);
}

function handleAnswer(correct, skipMode = false) {
  const now = Date.now();
  
  // Prevent rapid clicking
  if (now - (currentGame.lastAnswerTime || 0) < 1000) {
    console.warn("Answer too quickly. Please wait a moment.");
    return;
  }
  
  // Validate game state
  if (!currentGame || !currentGame.words || currentGame.words.length === 0 || 
      currentGame.currentIndex >= currentGame.words.length) {
    console.error("Invalid game state or index");
    return;
  }
  
  currentGame.lastAnswerTime = now;
  
  // Initialize perks if not already set
  currentGame.perks = currentGame.perks || { 
    clue: 0, 
    skip: 0, 
    timeFreeze: 0, 
    reveal: 0 
  };
  
  try {
    if (correct) {
      // Correct answer handling
      currentGame.currentIndex++;
      
      // Special handling for boss level
      if (currentGame.isBossLevel) {
        // Visual feedback for boss orb hit
        const bossOrb = document.querySelector(".boss-orb-inner");
        if (bossOrb) {
          const colors = ["yellow", "purple", "turquoise", "darkgreen", "brown"];
          const randomColor = colors[Math.floor(Math.random() * colors.length)];
          const originalBg = bossOrb.style.background;
          
          bossOrb.style.background = `radial-gradient(circle at 30% 30%, ${randomColor}, #990000)`;
          bossOrb.style.transform = "scale(1.3)";
          bossOrb.style.filter = "brightness(1.5)";
          
          setTimeout(() => {
            bossOrb.style.transform = "";
            bossOrb.style.filter = "";
            bossOrb.style.background = originalBg;
          }, 300);
        }
        
        // Check for boss defeat
        if (currentGame.currentIndex >= currentGame.words.length) {
          console.log("Boss defeated - final hit!");
          currentGame.bossDefeated = true;
          clearTimer();
          
          // Update progress circle to show complete
          const progressCircle = document.querySelector('.progress-circle');
          if (progressCircle) {
            const progress = progressCircle.querySelector('.progress');
            if (progress) {
              const circumference = 2 * Math.PI * 54;
              progress.style.strokeDashoffset = circumference;
            }
          }
          
          showBossDefeatEffect();
          
          // Award boss completion coins
          CoinsManager.updateCoins(100).then(() => {
            updateAllCoinDisplays();
          });
          
          return;
        }
        
        // Update boss health
        updateBossHealthBar();
      } else {
        // Regular level progress update
        updateProgressCircle();
      }
      
      // Skip mode doesn't award coins or track words
      if (!skipMode) {
        // Award coins based on performance
        let coinsEarned = 0;
        
        // Time bonus for quick answers
        const timeBonus = awardTimeBonus();
        if (timeBonus > 0) {
          coinsEarned += timeBonus;
          pulseCoins(timeBonus);
        }
        
        // First attempt bonus
        if (currentGame.firstAttempt) {
          coinsEarned += 3;
          pulseCoins(3);
        } else {
          coinsEarned += 1;
          pulseCoins(1);
        }
        
        // Update coins
        CoinsManager.updateCoins(coinsEarned)
          .then(() => {
            updatePerkButtons();
            updateAllCoinDisplays();
          })
          .catch(error => {
            console.error("Error updating total coins:", error);
          });
        
        // Increment correct answers counter
        currentGame.correctAnswers++;
        
        // Track word for user
        if (currentUser) {
          const wordIndex = currentGame.currentIndex - 1;
          const word = currentGame.isHebrewToEnglish ? 
            currentGame.words[wordIndex] : 
            currentGame.translations[wordIndex];
            
          trackWordEncounter(
            word, 
            currentGame.isCustomPractice ? "custom" : "story"
          );
        }
      }
    } else {
      // Wrong answer handling
      currentGame.firstAttempt = false;
      currentGame.streakBonus = false;
      currentGame.wrongStreak++;
      
      // Deduct coins for wrong answer
      CoinsManager.updateCoins(-3)
        .then(() => {
          updatePerkButtons();
          updateAllCoinDisplays();
        })
        .catch(error => {
          console.error("Error updating coins:", error);
        });
      
      // Lose progress for wrong answers
      if (currentGame.currentIndex > 0) {
        currentGame.progressLost++;
        currentGame.currentIndex = Math.max(0, currentGame.currentIndex - 1);
        
        // Update boss health bar if in boss level
        if (currentGame.isBossLevel) {
          updateBossHealthBar();
        }
      }
      
      // Check for game over (too many wrong answers in a row)
      if (currentGame.wrongStreak >= 3) {
        return showGameOverOverlay();
      }
      
      // Highlight correct/wrong buttons
      const buttons = document.querySelectorAll('.buttons button');
      const correctAnswer = currentGame.isHebrewToEnglish ? 
        currentGame.words[Math.max(0, currentGame.currentIndex - 1)] : 
        currentGame.translations[Math.max(0, currentGame.currentIndex - 1)];
        
      buttons.forEach(button => {
        if (button.textContent === correctAnswer) {
          button.classList.add('correct');
        } else if (!correct && event && event.target && 
                  button.textContent === event.target.textContent) {
          button.classList.add('wrong');
        }
      });
    }
    
    // Save progress
    saveProgress();
    
    // Load next question after a delay
    setTimeout(() => {
      // Clear button styles
      document.querySelectorAll('.buttons button').forEach(button => {
        button.classList.remove('correct', 'wrong');
      });
      
      // If game is still valid
      if (!currentGame || (currentGame.bossDefeated && currentGame.isBossLevel)) {
        // Game ended or boss defeated
        return;
      }
      
      if (currentGame.currentIndex < currentGame.words.length) {
        // Continue with next question
        startTimer(currentGame.words.length - currentGame.currentIndex);
        
        if (currentGame.isBossLevel) {
          loadNextBossQuestion();
        } else {
          loadNextQuestion();
        }
        
        updatePerkButtons();
      } else {
        // Level completed
        if (currentGame.isCustomPractice) {
          handleCustomLevelCompletion();
        } else {
          handleLevelCompletion();
        }
      }
    }, 500);
  } catch (error) {
    console.error("Unexpected error in handleAnswer:", error);
    console.error("Error details:", error.stack);
    
    // Recovery attempt
    try {
      if (currentGame && currentGame.currentIndex < currentGame.words.length && !currentGame.bossDefeated) {
        loadNextQuestion();
      } else {
        showScreen('welcome-screen');
      }
    } catch (recoveryError) {
      console.error("Failed to recover from error:", recoveryError);
      showScreen('welcome-screen');
    }
  }
}

// Show Auth Modal function (needed for login/signup)
function showAuthModal() {
  const authModal = document.getElementById('authModal');
  authModal && authModal.classList.add('show');
}

// Hide Auth Modal function
function hideAuthModal() {
  const authModal = document.getElementById('authModal');
  authModal && authModal.classList.remove('show');
}

// Toggle Side Panel function
function toggleSidePanel() {
  const sidePanel = document.querySelector('.side-panel');
  const hamburgerButton = document.querySelector('.hamburger-button');
  const modalOverlay = document.querySelector('.modal-overlay');
  
  if (sidePanel.classList.contains('open')) {
    sidePanel.classList.remove('open');
    hamburgerButton.classList.remove('open');
    if (modalOverlay) modalOverlay.classList.remove('open');
  } else {
    sidePanel.classList.add('open');
    hamburgerButton.classList.add('open');
    if (modalOverlay) modalOverlay.classList.add('open');
  }
}

// Show Screen function - central navigation function
function showScreen(screenId, forceRefresh = false) {
  if (screenId === 'welcome-screen') {
    console.log('Returning to welcome screen, clearing game context');
    localStorage.removeItem('gameContext');
  }
  
  console.log('showScreen called with:', {
    screenId: screenId,
    forceRefresh: forceRefresh,
    currentUser: currentUser ? currentUser.id : 'No user'
  });
  
  // Clean up question screen if leaving it
  const currentScreen = document.querySelector('.screen.visible');
  if (currentScreen && currentScreen.id === 'question-screen') {
    clearTimer();
    isFrozen = false;
  }
  
  // Force refresh if requested
  if (forceRefresh && screenId === 'welcome-screen') {
    console.log('Initiating full page reload');
    saveProgress();
    window.location.reload(true);
    return;
  }
  
  // Hide all screens
  document.querySelectorAll('.screen').forEach(screen => {
    screen.classList.remove('visible');
    
    // Clean up any particle containers
    const particleContainer = screen.querySelector('.particle-container');
    if (particleContainer) {
      particleContainer.remove();
    }
  });
  
  // Show the requested screen
  const screen = document.getElementById(screenId);
  if (screen) {
    screen.classList.add('visible');
    
    // Initialize particles for the screen
    initializeParticles(screen);
    
    // Update coin displays
    updateAllCoinDisplays();
    
    // Handle screen-specific initializations
    switch (screenId) {
      case 'question-screen':
        updatePerkButtons();
        console.log('Question screen shown, checking for admin button');
        setTimeout(() => {
          addAdminTestButton();
        }, 100);
        break;
        
      case 'welcome-screen':
        if (restoreGameContext()) {
          startGame();
        }
        break;
        
      case 'stage-cascade-screen':
        return showStageCascadeScreen();
    }
    
    console.log(`Switched to screen: ${screenId}`);
  } else {
    console.error(`Screen with id ${screenId} not found`);
  }
}

// Function to safely show a screen (ensures screen exists first)
function safeShowScreen(screenId, forceRefresh = false) {
  ensureScreenExists(screenId);
  showScreen(screenId, forceRefresh);
}

// Function to ensure a screen exists
function ensureScreenExists(screenId) {
  if (!document.getElementById(screenId)) {
    console.warn(`Screen ${screenId} doesn't exist. Creating it.`);
    const screen = document.createElement('div');
    screen.id = screenId;
    screen.className = 'screen';
    document.body.appendChild(screen);
  }
}

// Start Game function - critical main function
function startGame() {
  console.log('Starting game');
  
  if (!hasExistingProgress()) {
    console.log('No existing progress found, showing grade selector');
    return showGradeLevelSelector();
  }
  
  // Check for saved game context
  const savedContext = localStorage.getItem('gameContext');
  if (savedContext) {
    try {
      const context = JSON.parse(savedContext);
      if (context.stage && context.set && context.level) {
        console.log('Found saved game context:', context);
        gameState.currentStage = context.stage;
        gameState.currentSet = context.set;
        gameState.currentLevel = context.level;
        return startLevel(gameState.currentLevel);
      }
    } catch (error) {
      console.error('Error parsing game context:', error);
    }
  }
  
  console.log('Using current game state:', {
    stage: gameState.currentStage, 
    set: gameState.currentSet, 
    level: gameState.currentLevel
  });
  
  startLevel(gameState.currentLevel);
}

// Function to check if user has existing game progress
function hasExistingProgress() {
  // Check for completed levels
  if (gameState.completedLevels.size > 0 || gameState.perfectLevels.size > 0) {
    return true;
  }
  
  // Check for unlocked sets beyond defaults
  for (let stage = 1; stage <= 5; stage++) {
    const sets = gameState.unlockedSets[stage];
    // Skip checking default unlocks for stage 1
    if (stage === 1 && (!sets || sets.size === 9)) continue;
    
    // If we have any sets and at least one is beyond the first set
    if (sets && sets.size > 1) {
      return true;
    }
  }
  
  // Check localStorage as a fallback
  const savedProgress = localStorage.getItem('simploxProgress');
  if (savedProgress) {
    const progress = JSON.parse(savedProgress);
    if (progress.completedLevels && progress.completedLevels.length > 0) return true;
    if (progress.perfectLevels && progress.perfectLevels.length > 0) return true;
  }
  
  return false;
}

// Show grade level selector for new players
function showGradeLevelSelector() {
  const modalBackdrop = document.createElement('div');
  modalBackdrop.className = 'modal-backdrop';
  modalBackdrop.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(5px);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
  const modal = document.createElement('div');
  modal.className = 'grade-level-modal';
  modal.style.cssText = `
        background: var(--glass);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 2rem;
        max-width: 500px;
        width: 90%;
        text-align: center;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
    `;
    
  modal.innerHTML = `
        <h2 style="color: var(--gold); margin-bottom: 1.5rem;">What grade level are you?</h2>
        <p style="margin-bottom: 2rem; opacity: 0.9;">Choose your education level for the best learning experience:</p>
        <div class="grade-options" style="display: flex; flex-direction: column; gap: 1rem;">
            <button class="grade-option" data-stage="2" style="padding: 1rem; border-radius: 10px; background: rgba(255,255,255,0.1); border: none; color: var(--text); cursor: pointer; transition: all 0.3s ease;">
                <i class="fas fa-school" style="margin-right: 0.5rem;"></i> Elementary School
            </button>
            <button class="grade-option" data-stage="3" style="padding: 1rem; border-radius: 10px; background: rgba(255,255,255,0.1); border: none; color: var(--text); cursor: pointer; transition: all 0.3s ease;">
                <i class="fas fa-graduation-cap" style="margin-right: 0.5rem;"></i> Junior High School
            </button>
            <button class="grade-option" data-stage="4" style="padding: 1rem; border-radius: 10px; background: rgba(255,255,255,0.1); border: none; color: var(--text); cursor: pointer; transition: all 0.3s ease;">
                <i class="fas fa-user-graduate" style="margin-right: 0.5rem;"></i> High School
            </button>
            <button class="grade-option" data-stage="5" style="padding: 1rem; border-radius: 10px; background: rgba(255,255,255,0.1); border: none; color: var(--text); cursor: pointer; transition: all 0.3s ease;">
                <i class="fas fa-university" style="margin-right: 0.5rem;"></i> University
            </button>
        </div>
    `;
    
  document.body.appendChild(modalBackdrop);
  modalBackdrop.appendChild(modal);
  
  // Add hover effects and click handlers to buttons
  modal.querySelectorAll('.grade-option').forEach(button => {
    button.addEventListener('mouseover', () => {
      button.style.background = 'rgba(255,255,255,0.2)';
      button.style.transform = 'translateY(-2px)';
    });
    
    button.addEventListener('mouseout', () => {
      button.style.background = 'rgba(255,255,255,0.1)';
      button.style.transform = 'translateY(0)';
    });
    
    button.addEventListener('click', () => {
      const stage = parseInt(button.dataset.stage);
      localStorage.setItem('preferredStage', stage);
      modalBackdrop.remove();
      
      gameState.currentStage = stage;
      gameState.currentSet = 1;
      startLevel(1);
    });
  });
}

// Show cascade screen for stage/set selection
function showStageCascadeScreen() {
  const container = document.querySelector('.stages-container');
  if (!container) {
    console.error('Stages container not found');
    return false;
  }
  
  container.innerHTML = '';
  
  // Create stage wrappers
  for (let stageIndex = 0; stageIndex < gameStructure.stages.length; stageIndex++) {
    const stage = gameStructure.stages[stageIndex];
    const stageNumber = stage.id;
    
    // Check if any sets in this stage are unlocked
    const stageUnlocked = gameState.unlockedSets[stageNumber] && gameState.unlockedSets[stageNumber].size > 0;
    
    if (!stageUnlocked) continue; // Skip locked stages
    
    const stageWrapper = document.createElement('div');
    stageWrapper.className = 'stage-wrapper';
    stageWrapper.dataset.stage = stageNumber;
    
    // Create stage button
    const stageButton = document.createElement('div');
    stageButton.className = 'stage-button';
    stageButton.innerHTML = `
      <div class="stage-info">
        <div class="stage-icon">
          <i class="${getStageIcon(stageNumber)}"></i>
        </div>
        <div class="stage-text">
          <div class="stage-name">${getStageName(stageNumber)}</div>
          <div class="stage-desc">${getStageDescription(stageNumber)}</div>
        </div>
      </div>
      <div class="stage-toggle">
        <i class="fas fa-chevron-down"></i>
      </div>
    `;
    
    // Create sets container
    const setsContainer = document.createElement('div');
    setsContainer.className = 'sets-container';
    
    const setsGrid = document.createElement('div');
    setsGrid.className = 'sets-grid';
    
    // Add sets
    for (let set = 1; set <= stage.numSets; set++) {
      const setButton = document.createElement('div');
      
      // Check if set is unlocked
      const isUnlocked = gameState.unlockedSets[stageNumber] && 
                        gameState.unlockedSets[stageNumber].has(set);
                        
      setButton.className = `set-button ${isUnlocked ? 'active' : 'locked'}`;
      
      if (isUnlocked) {
        // Check if set is completed
        const isCompleted = checkIfSetCompleted(stageNumber, set);
        
        setButton.textContent = `Set ${set}`;
        
        if (isCompleted) {
          const completedIndicator = document.createElement('div');
          completedIndicator.className = 'completed-indicator';
          completedIndicator.innerHTML = '<i class="fas fa-check-circle"></i>';
          setButton.appendChild(completedIndicator);
        }
        
        setButton.onclick = () => showLevelScreen(set);
      } else {
        setButton.innerHTML = `
          <div class="lock-icon">
            <i class="fas fa-lock"></i>
          </div>
        `;
      }
      
      setsGrid.appendChild(setButton);
    }
    
    setsContainer.appendChild(setsGrid);
    stageWrapper.appendChild(stageButton);
    stageWrapper.appendChild(setsContainer);
    container.appendChild(stageWrapper);
    
    // Set up toggle functionality
    stageButton.addEventListener('click', function() {
      const wrapper = this.parentElement;
      wrapper.classList.toggle('open');
    });
  }
  
  // Open first stage by default
  const firstStage = container.querySelector('.stage-wrapper');
  if (firstStage) {
    firstStage.classList.add('open');
  }
  
  showScreen('stage-cascade-screen');
  return true;
}

// Check if a set is completed
function checkIfSetCompleted(stage, set) {
  const totalLevels = gameStructure.stages[stage - 1].levelsPerSet;
  let completedCount = 0;
  
  for (let level = 1; level <= totalLevels; level++) {
    const levelKey = `${stage}_${set}_${level}`;
    if (gameState.perfectLevels.has(levelKey) || gameState.completedLevels.has(levelKey)) {
      completedCount++;
    }
  }
  
  return completedCount === totalLevels;
}

// Get stage icon
function getStageIcon(stage) {
  const icons = {
    1: 'fas fa-book',
    2: 'fas fa-graduation-cap',
    3: 'fas fa-school',
    4: 'fas fa-university',
    5: 'fas fa-brain'
  };
  
  return icons[stage] || 'fas fa-star';
}

// Get stage name
function getStageName(stage) {
  const names = {
    1: 'Stage 1: Fundamentals',
    2: 'Stage 2: Elementary',
    3: 'Stage 3: Intermediate',
    4: 'Stage 4: Advanced',
    5: 'Stage 5: Expert'
  };
  
  return names[stage] || `Stage ${stage}`;
}

// Get stage description
function getStageDescription(stage) {
  const descriptions = {
    1: 'Basic vocabulary and phrases',
    2: 'Elementary vocabulary building',
    3: 'Intermediate language skills',
    4: 'Advanced concepts and usage',
    5: 'Expert level mastery'
  };
  
  return descriptions[stage] || `Stage ${stage} content`;
}

// Show level screen with sets
function showLevelScreen(setNumber) {
  gameState.currentSet = setNumber;
  debugUnlockState();
  
  const levelContainer = document.getElementById('level-container');
  if (!levelContainer) return;
  
  levelContainer.innerHTML = '';
  
  const stage = gameStructure.stages[gameState.currentStage - 1];
  if (!stage) return;
  
  // Create level header
  const headerDiv = document.createElement('div');
  headerDiv.className = 'level-header';
  
  // Calculate completion percentage
  const totalLevels = stage.levelsPerSet;
  let completedLevels = 0;
  
  for (let i = 1; i <= totalLevels; i++) {
    const levelKey = `${gameState.currentStage}_${setNumber}_${i}`;
    if (gameState.perfectLevels.has(levelKey)) {
      completedLevels++;
    } else if (gameState.completedLevels.has(levelKey)) {
      completedLevels++;
    }
  }
  
  const completionPercentage = Math.round((completedLevels / totalLevels) * 100);
  const setIcon = getSetIcon(gameState.currentStage, setNumber);
  const setDescription = getSetDescription(gameState.currentStage, setNumber);
  
  headerDiv.innerHTML = `
        <div class="level-title-area">
            <div class="set-icon">
                <i class="${setIcon}"></i>
            </div>
            <div class="set-details">
                <div class="set-name">Stage ${gameState.currentStage} - Set ${setNumber}</div>
                <div class="set-desc">${setDescription}</div>
            </div>
        </div>
        <div class="set-progress">
            <div class="progress-bar">
                <div class="progress-fill" style="width: ${completionPercentage}%"></div>
            </div>
            <div class="progress-text">${completedLevels}/${totalLevels} levels</div>
        </div>
    `;
  
  levelContainer.appendChild(headerDiv);
  
  // Create level grid
  const levelGrid = document.createElement('div');
  levelGrid.className = 'level-grid';
  
  // Define test levels
  const testLevels = [3, 6, 9, 10, 13, 16, 19, 20];
  
  // Get unlocked levels for this set
  const setKey = `${gameState.currentStage}_${setNumber}`;
  if (!gameState.unlockedLevels[setKey]) {
    gameState.unlockedLevels[setKey] = new Set([1]);
  }
  
  console.log(`Rendering levels for ${setKey}. Unlocked levels:`, 
    Array.from(gameState.unlockedLevels[setKey] || []));
  
  for (let i = 1; i <= stage.levelsPerSet; i++) {
    const levelDiv = document.createElement('div');
    const levelKey = `${gameState.currentStage}_${setNumber}_${i}`;
    const isUnlocked = gameState.unlockedLevels[setKey]?.has(i);
    
    console.log(`Level ${i} unlocked:`, isUnlocked);
    
    const isPerfect = gameState.perfectLevels.has(levelKey);
    const isCompleted = gameState.completedLevels.has(levelKey);
    const isBoss = (i === stage.bossLevel);
    const isTest = testLevels.includes(i);
    
    levelDiv.className = 'level-item';
    
    if (isUnlocked) {
      levelDiv.classList.add('unlocked');
    }
    
    if (isPerfect) {
      levelDiv.classList.add('perfect');
    } else if (isCompleted) {
      levelDiv.classList.add('completed');
    }
    
    if (isBoss) {
      levelDiv.classList.add('boss');
    }
    
    if (isTest) {
      levelDiv.classList.add('test');
    }
    
    if (!isUnlocked) {
      levelDiv.classList.add('locked');
    }
    
    levelDiv.textContent = i;
    
    if (isUnlocked) {
      levelDiv.onclick = () => startLevel(i);
    }
    
    levelGrid.appendChild(levelDiv);
  }
  
  levelContainer.appendChild(levelGrid);
  
  // Add legend
  const legendDiv = document.createElement('div');
  legendDiv.className = 'level-type-legend';
  legendDiv.innerHTML = `
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, var(--accent), rgba(30, 144, 255, 0.7));"></div>
            <span>Normal</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, var(--success), #45b649);"></div>
            <span>Completed</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, var(--gold), #FFA500);"></div>
            <span>Perfect</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, var(--gold), var(--accent));"></div>
            <span>Boss</span>
        </div>
    `;
  
  levelContainer.appendChild(legendDiv);
  
  showScreen('level-screen');
}




</script>
  