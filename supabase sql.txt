----------------------------------------------------------------------------------------
-- üîë USER PROFILES
--------------------------------------------------------------------------------------
-- Drop existing objects to prevent conflicts
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;
DROP TABLE IF EXISTS public.user_profiles CASCADE;

CREATE TABLE IF NOT EXISTS public.user_profiles (
    id uuid PRIMARY KEY REFERENCES auth.users,
    username text UNIQUE,
    email text,
    role text CHECK (role IN ('student', 'teacher', 'admin')) DEFAULT 'student',
    status text DEFAULT 'free' CHECK (status IN ('free', 'pending', 'premium')),
    payment_pending boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);

-- Trigger for automatic profile creation on user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    -- Create user profile
    INSERT INTO public.user_profiles (
        id,
        username,
        email,
        role,
        status
    ) VALUES (
        NEW.id,
        COALESCE(
            NEW.raw_user_meta_data->>'username', 
            split_part(NEW.email, '@', 1)
        ),
        NEW.email,
        'student',
        'free'
    );

    RETURN NEW;
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Error in handle_new_user: %', SQLERRM;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger for new user creation
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_new_user();

----------------------------------------------------------------------------------------
-- üõ°Ô∏è POLICIES
----------------------------------------------------------------------------------------
-- Dynamic policy cleanup for user_profiles
DO $$
DECLARE 
    policy_name text;
BEGIN
    FOR policy_name IN 
        SELECT policyname 
        FROM pg_policies 
        WHERE schemaname = 'public' AND tablename = 'user_profiles'
    LOOP
        EXECUTE 'DROP POLICY IF EXISTS ' || quote_ident(policy_name) || ' ON public.user_profiles';
    END LOOP;
END $$;

-- Row Level Security Policies
ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own profile"
ON public.user_profiles FOR SELECT
USING (auth.uid() = id);

CREATE POLICY "Users can update their own profile"
ON public.user_profiles FOR UPDATE
USING (auth.uid() = id);

CREATE POLICY "Users can insert their own profile"
ON public.user_profiles FOR INSERT
WITH CHECK (auth.uid() = id);

----------------------------------------------------------------------------------------
-- üéÆ GAME PROGRESS
----------------------------------------------------------
-- First, identify and remove duplicate game progress records
WITH duplicate_records AS (
    SELECT 
        user_id, 
        ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY created_at DESC) as rn
    FROM game_progress
)
DELETE FROM game_progress
WHERE id IN (
    SELECT id FROM (
        SELECT 
            id,
            ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY created_at DESC) as rn
        FROM game_progress
    ) t
    WHERE rn > 1
);


-- Add a unique constraint to prevent multiple game progress records for a user
ALTER TABLE game_progress 
ADD CONSTRAINT unique_user_game_progress 
UNIQUE (user_id);

-- Drop existing objects
DROP TABLE IF EXISTS game_progress CASCADE;

CREATE TABLE IF NOT EXISTS game_progress (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id uuid REFERENCES auth.users NOT NULL,
    stage integer NOT NULL DEFAULT 1,
    set_number integer NOT NULL DEFAULT 1,
    level integer NOT NULL DEFAULT 1,
    coins integer NOT NULL DEFAULT 0,
    perks jsonb NOT NULL DEFAULT '{}',
    unlocked_sets jsonb NOT NULL DEFAULT '{}',
    unlocked_levels jsonb NOT NULL DEFAULT '{}',
    perfect_levels jsonb NOT NULL DEFAULT '[]',
    completed_levels jsonb NOT NULL DEFAULT '[]',
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);

-- Enable Row Level Security
ALTER TABLE game_progress ENABLE ROW LEVEL SECURITY;

-- Dynamic policy cleanup for player_stats
DO $$
DECLARE 
    policy_name text;
BEGIN
    FOR policy_name IN 
        SELECT policyname 
        FROM pg_policies 
        WHERE schemaname = 'public' AND tablename = 'player_stats'
    LOOP
        EXECUTE 'DROP POLICY IF EXISTS ' || quote_ident(policy_name) || ' ON player_stats';
    END LOOP;
END $$;

CREATE POLICY "Users can manage own game progress" 
ON game_progress FOR ALL 
USING (auth.uid() = user_id);

----------------------------------------------------------------------------------------
-- üìä STATS
----------------------------------------------------------------------------------------
-- Drop existing objects
DROP TABLE IF EXISTS player_stats CASCADE;
DROP VIEW IF EXISTS player_leaderboard CASCADE;
DROP INDEX IF EXISTS idx_player_stats_user;
DROP INDEX IF EXISTS idx_player_stats_levels;

CREATE TABLE IF NOT EXISTS player_stats (
    user_id uuid REFERENCES auth.users PRIMARY KEY,
    total_levels_completed integer DEFAULT 0,
    unique_words_practiced INTEGER DEFAULT 0,
    last_updated timestamp with time zone DEFAULT timezone('utc'::text, now())
);

-- Indices for performance
CREATE INDEX IF NOT EXISTS idx_player_stats_user ON player_stats(user_id);
CREATE INDEX IF NOT EXISTS idx_player_stats_levels ON player_stats(total_levels_completed DESC);

-- Enable Row Level Security
ALTER TABLE player_stats ENABLE ROW LEVEL SECURITY;

-- Dynamic policy cleanup for custom_lists
DO $$
DECLARE 
    policy_name text;
BEGIN
    FOR policy_name IN 
        SELECT policyname 
        FROM pg_policies 
        WHERE schemaname = 'public' AND tablename = 'custom_lists'
    LOOP
        EXECUTE 'DROP POLICY IF EXISTS ' || quote_ident(policy_name) || ' ON custom_lists';
    END LOOP;
END $$;

CREATE POLICY "Users can read any player stats" 
    ON player_stats FOR SELECT 
    USING (true);

CREATE POLICY "Users can update their own stats" 
    ON player_stats FOR UPDATE 
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own stats" 
    ON player_stats FOR INSERT 
    WITH CHECK (auth.uid() = user_id);

-- Leaderboard View
CREATE OR REPLACE VIEW player_leaderboard AS
WITH user_rankings AS (
    SELECT 
        up.username,
        COALESCE(ps.total_levels_completed, 0) as total_levels_completed,
        COALESCE(ps.unique_words_practiced, 0) as total_words_learned,
        ROW_NUMBER() OVER (
            ORDER BY COALESCE(ps.total_levels_completed, 0) DESC, 
            COALESCE(ps.unique_words_practiced, 0) DESC
        ) as player_rank
    FROM user_profiles up
    LEFT JOIN player_stats ps ON up.id = ps.user_id
    WHERE up.username IS NOT NULL
)
SELECT 
    username,
    total_levels_completed,
    total_words_learned,
    player_rank
FROM user_rankings
ORDER BY player_rank ASC;

-- Grant permissions for leaderboard
GRANT SELECT ON player_leaderboard TO authenticated;
GRANT ALL ON player_stats TO authenticated;

----------------------------------------------------------------------------------------
-- üìù CUSTOM LISTS
----------------------------------------------------------------------------------------

-- Drop existing objects
DROP TABLE IF EXISTS custom_lists CASCADE;

CREATE TABLE IF NOT EXISTS custom_lists (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id uuid REFERENCES auth.users NOT NULL,
    name text NOT NULL,
    words text[] DEFAULT '{}',
    translations text[] DEFAULT '{}',
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    local_id BIGINT,
    is_shared boolean DEFAULT false,
    shared_with uuid[] DEFAULT '{}'::uuid[],
    shared_by uuid REFERENCES auth.users(id)
);

-- Enable Row Level Security
ALTER TABLE custom_lists ENABLE ROW LEVEL SECURITY;

-- Dynamic policy cleanup for custom_lists
DO $$
DECLARE 
    policy_name text;
BEGIN
    FOR policy_name IN 
        SELECT policyname 
        FROM pg_policies 
        WHERE schemaname = 'public' AND tablename = 'custom_lists'
    LOOP
        EXECUTE 'DROP POLICY IF EXISTS ' || quote_ident(policy_name) || ' ON custom_lists';
    END LOOP;
END $$;

CREATE POLICY "Users can view own and shared lists" ON custom_lists
FOR SELECT USING (
    auth.uid() = user_id 
    OR auth.uid() = ANY(shared_with)
);

CREATE POLICY "Users can manage own lists" ON custom_lists
FOR ALL USING (auth.uid() = user_id);

-- Grant permissions
GRANT ALL ON custom_lists TO authenticated;

----------------------------------------------------------------------------------------
-- üí∞ PAYMENTS
----------------------------------------------------------------------------------------
-- Drop existing objects
DROP TABLE IF EXISTS payment_requests CASCADE;

CREATE TABLE IF NOT EXISTS payment_requests (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id uuid REFERENCES auth.users NOT NULL,
    payment_method text CHECK (payment_method IN ('bit', 'paybox', 'kashkash', 'bank')),
    amount numeric(10,2) NOT NULL,
    status text DEFAULT 'pending' CHECK (status IN ('pending', 'verified', 'rejected')),
    reference_code text UNIQUE,
    submission_time timestamp with time zone DEFAULT timezone('utc'::text, now()),
    verification_time timestamp with time zone,
    admin_verified_by uuid REFERENCES auth.users(id)
);

-- Enable Row Level Security
ALTER TABLE payment_requests ENABLE ROW LEVEL SECURITY;

-- Dynamic policy cleanup for payment_requests
DO $$
DECLARE 
    policy_name text;
BEGIN
    FOR policy_name IN 
        SELECT policyname 
        FROM pg_policies 
        WHERE schemaname = 'public' AND tablename = 'payment_requests'
    LOOP
        EXECUTE 'DROP POLICY IF EXISTS ' || quote_ident(policy_name) || ' ON payment_requests';
    END LOOP;
END $$;

CREATE POLICY "Users can view their own payment requests"
ON payment_requests FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Admin can manage all payment requests"
ON payment_requests FOR ALL
USING (
    auth.uid() IN (
        SELECT id FROM user_profiles 
        WHERE role = 'admin'
    )
);

-- First, identify duplicate records
WITH duplicate_records AS (
    SELECT 
        user_id, 
        ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY created_at DESC) as rn
    FROM game_progress
)
-- Delete all but the most recent record for each user
DELETE FROM game_progress
WHERE id IN (
    SELECT id FROM (
        SELECT 
            id,
            ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY created_at DESC) as rn
        FROM game_progress
    ) t
    WHERE rn > 1
);

-- Now, create the unique index
CREATE UNIQUE INDEX unique_user_game_progress ON game_progress (user_id);