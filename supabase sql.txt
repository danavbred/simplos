-- First clean up existing objects
DROP VIEW IF EXISTS player_leaderboard CASCADE;
DROP POLICY IF EXISTS "Users can read any player stats" ON player_stats;
DROP POLICY IF EXISTS "Users can update their own stats" ON player_stats;
DROP POLICY IF EXISTS "Users can insert their own stats" ON player_stats;
DROP TABLE IF EXISTS player_stats;

-- Create enhanced leaderboard stats table
CREATE TABLE IF NOT EXISTS player_stats (
    user_id uuid REFERENCES auth.users PRIMARY KEY,
    total_levels_completed integer DEFAULT 0,
    total_time_spent bigint DEFAULT 0,
    total_mistakes integer DEFAULT 0,
    best_streak integer DEFAULT 0,
    current_streak integer DEFAULT 0,
    highest_score integer DEFAULT 0,
    unique_words_practiced INTEGER DEFAULT 0,
    words_practiced_today INTEGER DEFAULT 0,
    practiced_words TEXT[] DEFAULT '{}',
    time_spent_today_ms BIGINT DEFAULT 0,
    perfect_levels_count INTEGER DEFAULT 0,
    daily_login_streak INTEGER DEFAULT 0,
    last_login_date DATE DEFAULT CURRENT_DATE,
    last_practice_date DATE DEFAULT CURRENT_DATE,
    last_updated timestamp with time zone DEFAULT timezone('utc'::text, now())
);

-- Create indices for performance
CREATE INDEX IF NOT EXISTS idx_player_stats_user ON player_stats(user_id);
CREATE INDEX IF NOT EXISTS idx_player_stats_scores ON player_stats(highest_score DESC);
CREATE INDEX IF NOT EXISTS idx_player_stats_streaks ON player_stats(best_streak DESC);
CREATE INDEX IF NOT EXISTS idx_player_stats_practice_date ON player_stats(last_practice_date);

-- Enable RLS
ALTER TABLE player_stats ENABLE ROW LEVEL SECURITY;

-- Set up RLS policies
CREATE POLICY "Users can read any player stats" 
    ON player_stats FOR SELECT 
    USING (true);

CREATE POLICY "Users can update their own stats" 
    ON player_stats FOR UPDATE 
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own stats" 
    ON player_stats FOR INSERT 
    WITH CHECK (auth.uid() = user_id);

CREATE OR REPLACE VIEW player_leaderboard AS
WITH user_rankings AS (
    SELECT 
        ps.user_id,
        up.username,
        ps.words_practiced_today,
        ps.time_spent_today_ms / 1000.0 as time_spent_today_seconds,
        ps.unique_words_practiced,
        ps.total_time_spent / 1000.0 as total_practice_time_seconds,
        ps.best_streak,
        ps.total_mistakes,
        ps.total_levels_completed,
        CASE 
            WHEN ps.total_levels_completed > 0 
            THEN CAST(((ps.total_time_spent::float / ps.total_levels_completed) / 1000.0) AS NUMERIC(10,2))
            ELSE 0 
        END as avg_time_per_level,
        ROW_NUMBER() OVER (ORDER BY ps.best_streak DESC) as player_rank
    FROM player_stats ps
    JOIN user_profiles up ON ps.user_id = up.id
)
SELECT * FROM user_rankings
ORDER BY player_rank ASC;

-- Grant permissions
GRANT SELECT ON player_leaderboard TO authenticated;
GRANT ALL ON player_stats TO authenticated;

-- Optional: Insert test data
WITH user_ids AS (
    SELECT id FROM user_profiles LIMIT 5
)
INSERT INTO player_stats (
    user_id,
    total_levels_completed,
    total_time_spent,
    total_mistakes,
    best_streak,
    current_streak,
    highest_score,
    words_practiced_today,
    time_spent_today_ms,
    perfect_levels_count,
    daily_login_streak
)
SELECT 
    id,
    FLOOR(RANDOM() * 50 + 10)::integer,
    FLOOR(RANDOM() * 500000 + 100000)::bigint,
    FLOOR(RANDOM() * 20)::integer,
    FLOOR(RANDOM() * 15 + 5)::integer,
    FLOOR(RANDOM() * 10)::integer,
    FLOOR(RANDOM() * 1000)::integer,
    FLOOR(RANDOM() * 100)::integer,
    FLOOR(RANDOM() * 3600000)::bigint,
    FLOOR(RANDOM() * 10)::integer,
    FLOOR(RANDOM() * 7)::integer
FROM user_ids
WHERE id NOT IN (SELECT user_id FROM player_stats);

-- Create function to reset daily stats
CREATE OR REPLACE FUNCTION reset_daily_stats()
RETURNS void AS $$
BEGIN
    UPDATE player_stats
    SET words_practiced_today = 0,
        time_spent_today_ms = 0,
        last_practice_date = CURRENT_DATE
    WHERE last_practice_date < CURRENT_DATE;
END;
$$ LANGUAGE plpgsql;

-- Create daily stats reset trigger
CREATE OR REPLACE FUNCTION trigger_reset_daily_stats()
RETURNS trigger AS $$
BEGIN
    IF OLD.last_practice_date < CURRENT_DATE THEN
        NEW.words_practiced_today := 0;
        NEW.time_spent_today_ms := 0;
        NEW.last_practice_date := CURRENT_DATE;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER daily_stats_reset
    BEFORE UPDATE ON player_stats
    FOR EACH ROW
    EXECUTE FUNCTION trigger_reset_daily_stats();

-- Verify the data
SELECT * FROM player_leaderboard LIMIT 5;