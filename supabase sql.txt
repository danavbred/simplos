CREATE LEADERBOARD VIEW


-- Drop view if exists (will not error if it doesn't exist)
DROP VIEW IF EXISTS player_leaderboard;

-- Create the leaderboard view
CREATE OR REPLACE VIEW player_leaderboard AS
WITH user_rankings AS (
    SELECT 
        up.username,
        ps.total_levels_completed,
        ps.unique_words_practiced as total_words_learned,
        ROW_NUMBER() OVER (
            ORDER BY ps.total_levels_completed DESC,
            ps.unique_words_practiced DESC
        ) as player_rank
    FROM user_profiles up
    LEFT JOIN player_stats ps ON up.id = ps.user_id
    WHERE up.username IS NOT NULL
        AND (ps.total_levels_completed > 0 OR ps.unique_words_practiced > 0)
)
SELECT 
    username,
    COALESCE(total_levels_completed, 0) as total_levels_completed,
    COALESCE(total_words_learned, 0) as total_words_learned,
    player_rank
FROM user_rankings
ORDER BY player_rank ASC;

-- Grant necessary permissions
GRANT SELECT ON player_leaderboard TO authenticated;


USER PROFILES MANAGEMENT

-- Drop existing triggers and functions first
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;

-- Modify user_profiles to be more lenient
ALTER TABLE public.user_profiles 
ALTER COLUMN role DROP NOT NULL,
ALTER COLUMN status SET DEFAULT 'free',
ALTER COLUMN username DROP NOT NULL;

-- Ensure RLS is properly set
ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;

-- Update RLS policies
DROP POLICY IF EXISTS "Users can view their own profile" ON public.user_profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.user_profiles;

CREATE POLICY "Users can view their own profile"
ON public.user_profiles FOR SELECT
USING (auth.uid() = id);

CREATE POLICY "Users can update their own profile"
ON public.user_profiles FOR UPDATE
USING (auth.uid() = id);

CREATE POLICY "Users can insert their own profile"
ON public.user_profiles FOR INSERT
WITH CHECK (auth.uid() = id);




LEADERBOARD


-- First drop dependent objects
DROP VIEW IF EXISTS player_leaderboard CASCADE;
DROP TABLE IF EXISTS player_stats CASCADE;

-- Create player_stats table first
CREATE TABLE IF NOT EXISTS player_stats (
    user_id uuid REFERENCES auth.users PRIMARY KEY,
    total_levels_completed integer DEFAULT 0,
    unique_words_practiced INTEGER DEFAULT 0,
    last_updated timestamp with time zone DEFAULT timezone('utc'::text, now())
);

-- Create indices
CREATE INDEX IF NOT EXISTS idx_player_stats_user ON player_stats(user_id);
CREATE INDEX IF NOT EXISTS idx_player_stats_levels ON player_stats(total_levels_completed DESC);

-- Enable RLS
ALTER TABLE player_stats ENABLE ROW LEVEL SECURITY;

-- Set up RLS policies
CREATE POLICY "Users can read any player stats" 
    ON player_stats FOR SELECT 
    USING (true);

CREATE POLICY "Users can update their own stats" 
    ON player_stats FOR UPDATE 
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own stats" 
    ON player_stats FOR INSERT 
    WITH CHECK (auth.uid() = user_id);

-- Now create the leaderboard view
CREATE OR REPLACE VIEW player_leaderboard AS
WITH user_rankings AS (
    SELECT 
        up.username,
        COALESCE(ps.total_levels_completed, 0) as total_levels_completed,
        COALESCE(ps.unique_words_practiced, 0) as total_words_learned,
        ROW_NUMBER() OVER (
            ORDER BY COALESCE(ps.total_levels_completed, 0) DESC, 
            COALESCE(ps.unique_words_practiced, 0) DESC
        ) as player_rank
    FROM user_profiles up
    LEFT JOIN player_stats ps ON up.id = ps.user_id
    WHERE up.username IS NOT NULL
)
SELECT 
    username,
    total_levels_completed,
    total_words_learned,
    player_rank
FROM user_rankings
ORDER BY player_rank ASC;

-- Grant permissions
GRANT SELECT ON player_leaderboard TO authenticated;
GRANT ALL ON player_stats TO authenticated;

-- Finally update the handle_new_user function
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    -- Create user profile
    INSERT INTO public.user_profiles (
        id,
        username,
        role,
        status
    ) VALUES (
        NEW.id,
        COALESCE(NEW.raw_user_meta_data->>'username', split_part(NEW.email, '@', 1)),
        'student',
        'free'
    );

    -- Initialize game progress
    INSERT INTO game_progress (
        user_id,
        stage,
        set_number,
        level,
        unlocked_sets,
        unlocked_levels
    ) VALUES (
        NEW.id,
        1,
        1,
        1,
        '{"1": [1]}'::jsonb,
        '{"1_1": [1]}'::jsonb
    );

    -- Initialize player stats
    INSERT INTO player_stats (
        user_id,
        total_levels_completed,
        unique_words_practiced
    ) VALUES (
        NEW.id,
        0,
        0
    );

    RETURN NEW;
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Error in handle_new_user: %', SQLERRM;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


GAME LOGIC



-- Start fresh - Drop existing objects safely
DROP VIEW IF EXISTS public.user_list CASCADE;
DROP TABLE IF EXISTS payment_requests CASCADE;
DROP TABLE IF EXISTS custom_lists CASCADE;
DROP TABLE IF EXISTS game_progress CASCADE;
DROP TABLE IF EXISTS user_profiles CASCADE;
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create core tables
CREATE TABLE IF NOT EXISTS public.user_profiles (
    id uuid REFERENCES auth.users PRIMARY KEY,
    username text UNIQUE,
    role text CHECK (role IN ('student', 'teacher', 'admin')),
    status text DEFAULT 'free' CHECK (status IN ('free', 'pending', 'premium')),
    payment_pending boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);

CREATE TABLE IF NOT EXISTS game_progress (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id uuid REFERENCES auth.users NOT NULL,
    stage integer NOT NULL DEFAULT 1,
    set_number integer NOT NULL DEFAULT 1,
    level integer NOT NULL DEFAULT 1,
    coins integer NOT NULL DEFAULT 0,
    perks jsonb NOT NULL DEFAULT '{}',
    unlocked_sets jsonb NOT NULL DEFAULT '{}',
    unlocked_levels jsonb NOT NULL DEFAULT '{}',
    perfect_levels jsonb NOT NULL DEFAULT '[]',
    completed_levels jsonb NOT NULL DEFAULT '[]',
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    -- Create user profile
    INSERT INTO public.user_profiles (
        id,
        username,
        email,  -- Added this field
        role,
        status
    ) VALUES (
        NEW.id,
        COALESCE(NEW.raw_user_meta_data->>'username', split_part(NEW.email, '@', 1)),
        NEW.email,  -- Added this value
        'student',
        'free'
    );

    -- Initialize game progress
    INSERT INTO game_progress (
        user_id,
        stage,
        set_number,
        level,
        unlocked_sets,
        unlocked_levels
    ) VALUES (
        NEW.id,
        1,
        1,
        1,
        '{"1": [1]}'::jsonb,
        '{"1_1": [1]}'::jsonb
    );

    RETURN NEW;
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Error in handle_new_user: %', SQLERRM;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Create trigger
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_new_user();

-- Enable RLS
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE game_progress ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can view their own profile"
ON public.user_profiles FOR SELECT
USING (auth.uid() = id);

CREATE POLICY "Users can update their own profile"
ON public.user_profiles FOR UPDATE
USING (auth.uid() = id);

CREATE POLICY "Users can manage own game progress" 
ON game_progress FOR ALL 
USING (auth.uid() = user_id);

-- Drop existing RLS policies for user_profiles
DROP POLICY IF EXISTS "Users can view their own profile" ON public.user_profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.user_profiles;
DROP POLICY IF EXISTS "Users can insert their own profile" ON public.user_profiles;

-- Recreate RLS policies
CREATE POLICY "Users can view their own profile"
ON public.user_profiles FOR SELECT
USING (auth.uid() = id);

CREATE POLICY "Users can update their own profile"
ON public.user_profiles FOR UPDATE
USING (auth.uid() = id);

CREATE POLICY "Users can insert their own profile"
ON public.user_profiles FOR INSERT
WITH CHECK (auth.uid() = id);

-- Drop and recreate custom_lists table
DROP TABLE IF EXISTS custom_lists CASCADE;

CREATE TABLE IF NOT EXISTS custom_lists (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id uuid REFERENCES auth.users NOT NULL,
    name text NOT NULL,
    words text[] DEFAULT '{}',
    translations text[] DEFAULT '{}',
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    local_id BIGINT,
    is_shared boolean DEFAULT false,
    shared_with uuid[] DEFAULT '{}'::uuid[],
    shared_by uuid REFERENCES auth.users(id)
);

-- Enable RLS
ALTER TABLE custom_lists ENABLE ROW LEVEL SECURITY;

-- Add RLS policies for custom_lists
DROP POLICY IF EXISTS "Users can view own and shared lists" ON custom_lists;
DROP POLICY IF EXISTS "Users can manage own lists" ON custom_lists;

CREATE POLICY "Users can view own and shared lists" ON custom_lists
FOR SELECT USING (
    auth.uid() = user_id 
    OR auth.uid() = ANY(shared_with)
);

CREATE POLICY "Users can manage own lists" ON custom_lists
FOR ALL USING (auth.uid() = user_id);

-- Grant permissions
GRANT ALL ON custom_lists TO authenticated;


-- Drop and recreate RLS policies for user_profiles
DROP POLICY IF EXISTS "Users can insert their own profile" ON user_profiles;
DROP POLICY IF EXISTS "Users can view their own profile" ON user_profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON user_profiles;

-- Create less restrictive policies
CREATE POLICY "Users can insert their own profile"
ON user_profiles FOR INSERT
WITH CHECK (auth.uid() = id);

CREATE POLICY "Users can view their own profile"
ON user_profiles FOR SELECT
USING (auth.uid() = id);

CREATE POLICY "Users can update their own profile"
ON user_profiles FOR UPDATE
USING (auth.uid() = id);

-- Enable RLS
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;