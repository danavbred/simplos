CREATE LEADERBOARD VIEW


-- Drop view if exists (will not error if it doesn't exist)
DROP VIEW IF EXISTS player_leaderboard;

-- Create the leaderboard view
CREATE OR REPLACE VIEW player_leaderboard AS
WITH user_rankings AS (
    SELECT 
        up.username,
        ps.total_levels_completed,
        ps.unique_words_practiced as total_words_learned,
        ROW_NUMBER() OVER (
            ORDER BY ps.total_levels_completed DESC,
            ps.unique_words_practiced DESC
        ) as player_rank
    FROM user_profiles up
    LEFT JOIN player_stats ps ON up.id = ps.user_id
    WHERE up.username IS NOT NULL
        AND (ps.total_levels_completed > 0 OR ps.unique_words_practiced > 0)
)
SELECT 
    username,
    COALESCE(total_levels_completed, 0) as total_levels_completed,
    COALESCE(total_words_learned, 0) as total_words_learned,
    player_rank
FROM user_rankings
ORDER BY player_rank ASC;

-- Grant necessary permissions
GRANT SELECT ON player_leaderboard TO authenticated;



USER PROFILES MANAGEMENT

-- Drop existing triggers and functions first
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;

-- Modify user_profiles to be more lenient
ALTER TABLE public.user_profiles 
ALTER COLUMN role DROP NOT NULL,
ALTER COLUMN status SET DEFAULT 'free',
ALTER COLUMN username DROP NOT NULL;

-- Ensure RLS is properly set
ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;

-- Update RLS policies
DROP POLICY IF EXISTS "Users can view their own profile" ON public.user_profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.user_profiles;

CREATE POLICY "Users can view their own profile"
ON public.user_profiles FOR SELECT
USING (auth.uid() = id);

CREATE POLICY "Users can update their own profile"
ON public.user_profiles FOR UPDATE
USING (auth.uid() = id);

CREATE POLICY "Users can insert their own profile"
ON public.user_profiles FOR INSERT
WITH CHECK (auth.uid() = id);



LEADERBOARD


-- First clean up existing objects
DROP VIEW IF EXISTS player_leaderboard CASCADE;
DROP POLICY IF EXISTS "Users can read any player stats" ON player_stats;
DROP POLICY IF EXISTS "Users can update their own stats" ON player_stats;
DROP POLICY IF EXISTS "Users can insert their own stats" ON player_stats;
DROP TABLE IF EXISTS player_stats;

-- Create enhanced leaderboard stats table
CREATE TABLE IF NOT EXISTS player_stats (
    user_id uuid REFERENCES auth.users PRIMARY KEY,
    total_levels_completed integer DEFAULT 0,
    total_time_spent bigint DEFAULT 0,
    total_mistakes integer DEFAULT 0,
    best_streak integer DEFAULT 0,
    current_streak integer DEFAULT 0,
    highest_score integer DEFAULT 0,
    unique_words_practiced INTEGER DEFAULT 0,
    words_practiced_today INTEGER DEFAULT 0,
    practiced_words TEXT[] DEFAULT '{}',
    time_spent_today_ms BIGINT DEFAULT 0,
    perfect_levels_count INTEGER DEFAULT 0,
    daily_login_streak INTEGER DEFAULT 0,
    last_login_date DATE DEFAULT CURRENT_DATE,
    last_practice_date DATE DEFAULT CURRENT_DATE,
    last_updated timestamp with time zone DEFAULT timezone('utc'::text, now())
);

-- Create indices for performance
CREATE INDEX IF NOT EXISTS idx_player_stats_user ON player_stats(user_id);
CREATE INDEX IF NOT EXISTS idx_player_stats_scores ON player_stats(highest_score DESC);
CREATE INDEX IF NOT EXISTS idx_player_stats_streaks ON player_stats(best_streak DESC);
CREATE INDEX IF NOT EXISTS idx_player_stats_practice_date ON player_stats(last_practice_date);

-- Enable RLS
ALTER TABLE player_stats ENABLE ROW LEVEL SECURITY;

-- Set up RLS policies
CREATE POLICY "Users can read any player stats" 
    ON player_stats FOR SELECT 
    USING (true);

CREATE POLICY "Users can update their own stats" 
    ON player_stats FOR UPDATE 
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own stats" 
    ON player_stats FOR INSERT 
    WITH CHECK (auth.uid() = user_id);

-- Create and update leaderboard view
DROP VIEW IF EXISTS player_leaderboard;

CREATE OR REPLACE VIEW player_leaderboard AS
WITH user_rankings AS (
    SELECT 
        up.username,
        COALESCE(ps.total_levels_completed, 0) as total_levels_completed,
        COALESCE(ps.unique_words_practiced, 0) as total_words_learned,
        ROW_NUMBER() OVER (
            ORDER BY COALESCE(ps.total_levels_completed, 0) DESC, 
            COALESCE(ps.unique_words_practiced, 0) DESC
        ) as player_rank
    FROM user_profiles up
    LEFT JOIN player_stats ps ON up.id = ps.user_id
    WHERE up.username IS NOT NULL
)
SELECT 
    username,
    total_levels_completed,
    total_words_learned,
    player_rank
FROM user_rankings
ORDER BY player_rank ASC;

-- Grant permissions
GRANT SELECT ON player_leaderboard TO authenticated;
GRANT ALL ON player_stats TO authenticated;

-- Create function to reset daily stats
CREATE OR REPLACE FUNCTION reset_daily_stats()
RETURNS void AS $$
BEGIN
    UPDATE player_stats
    SET words_practiced_today = 0,
        time_spent_today_ms = 0,
        last_practice_date = CURRENT_DATE
    WHERE last_practice_date < CURRENT_DATE;
END;
$$ LANGUAGE plpgsql;

-- Create daily stats reset trigger
CREATE OR REPLACE FUNCTION trigger_reset_daily_stats()
RETURNS trigger AS $$
BEGIN
    IF OLD.last_practice_date < CURRENT_DATE THEN
        NEW.words_practiced_today := 0;
        NEW.time_spent_today_ms := 0;
        NEW.last_practice_date := CURRENT_DATE;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER daily_stats_reset
    BEFORE UPDATE ON player_stats
    FOR EACH ROW
    EXECUTE FUNCTION trigger_reset_daily_stats();




GAME LOGIC





-- Drop existing function and trigger
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;

-- Create new function with better error handling
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    -- Create user profile first
    INSERT INTO public.user_profiles (
        id,
        username,
        role,
        status
    ) VALUES (
        NEW.id,
        COALESCE(NEW.raw_user_meta_data->>'username', split_part(NEW.email, '@', 1)),
        'student',
        'free'
    );

    -- Only proceed with game progress if profile was created
    IF FOUND THEN
        -- Initialize game progress
        INSERT INTO game_progress (
            user_id,
            stage,
            set_number,
            level,
            unlocked_sets,
            unlocked_levels
        ) VALUES (
            NEW.id,
            1,
            1,
            1,
            '{"1": [1]}'::jsonb,
            '{"1_1": [1]}'::jsonb
        );

        -- Initialize player stats
        INSERT INTO player_stats (
            user_id,
            total_levels_completed,
            unique_words_practiced
        ) VALUES (
            NEW.id,
            0,
            0
        );
    END IF;

    RETURN NEW;
EXCEPTION WHEN OTHERS THEN
    -- Log error details if possible
    RAISE NOTICE 'Error in handle_new_user: %', SQLERRM;
    -- Still return NEW to allow user creation
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Recreate trigger
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_new_user();

-- Start fresh - Drop existing objects safely
DROP VIEW IF EXISTS public.user_list CASCADE;
DROP TABLE IF EXISTS payment_requests CASCADE;
DROP TABLE IF EXISTS custom_lists CASCADE;
DROP TABLE IF EXISTS game_progress CASCADE;
DROP TABLE IF EXISTS user_profiles CASCADE;
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create core tables
CREATE TABLE IF NOT EXISTS public.user_profiles (
    id uuid REFERENCES auth.users PRIMARY KEY,
    username text UNIQUE,
    role text CHECK (role IN ('student', 'teacher', 'admin')),
    status text DEFAULT 'free' CHECK (status IN ('free', 'pending', 'premium')),
    payment_pending boolean DEFAULT false,
    shared_lists INTEGER[] DEFAULT '{}',
    received_lists INTEGER[] DEFAULT '{}',
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);

CREATE INDEX idx_user_profiles_status ON user_profiles(status);

CREATE TABLE IF NOT EXISTS game_progress (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id uuid REFERENCES auth.users NOT NULL,
    stage integer NOT NULL DEFAULT 1,
    set_number integer NOT NULL DEFAULT 1,
    level integer NOT NULL DEFAULT 1,
    coins integer NOT NULL DEFAULT 0,
    perks jsonb NOT NULL DEFAULT '{}',
    unlocked_sets jsonb NOT NULL DEFAULT '{}',
    unlocked_levels jsonb NOT NULL DEFAULT '{}',
    perfect_levels jsonb NOT NULL DEFAULT '[]',
    completed_levels jsonb NOT NULL DEFAULT '[]',
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);

CREATE TABLE IF NOT EXISTS custom_lists (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id uuid REFERENCES auth.users NOT NULL,
    name text NOT NULL,
    words text[] DEFAULT '{}',
    translations text[] DEFAULT '{}',
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    local_id BIGINT,
    is_shared boolean DEFAULT false,
    shared_with uuid[] DEFAULT '{}'::uuid[],
    shared_by uuid REFERENCES auth.users(id)
);

CREATE TABLE IF NOT EXISTS payment_requests (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id uuid REFERENCES auth.users NOT NULL,
    payment_method text CHECK (payment_method IN ('bit', 'paybox', 'kashkash', 'bank')),
    amount decimal(10,2) NOT NULL,
    reference_code text UNIQUE,
    status text DEFAULT 'pending' CHECK (status IN ('pending', 'verified', 'rejected')),
    submission_time timestamp with time zone DEFAULT now(),
    verification_time timestamp with time zone,
    verification_notes text,
    whatsapp_number text,
    admin_verified_by uuid REFERENCES auth.users(id),
    created_at timestamp with time zone DEFAULT now()
);

CREATE INDEX idx_payment_reference ON payment_requests(reference_code);

-- Create views
CREATE OR REPLACE VIEW public.user_list AS
SELECT DISTINCT ON (up.id)
    up.id,
    username,
    status,
    role,
    payment_pending
FROM public.user_profiles up
WHERE up.id IS NOT NULL;

-- Create consolidated function for new user initialization
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
    extracted_username text;
BEGIN
    -- Extract username with fallback options
    extracted_username := COALESCE(
        NEW.raw_user_meta_data->>'username', 
        NEW.email, 
        split_part(NEW.email, '@', 1)
    );

    -- Create user profile
    INSERT INTO public.user_profiles (
        id, 
        username, 
        role, 
        status
    )
    VALUES (
        NEW.id, 
        extracted_username,
        'student',
        'free'
    );

    -- Initialize game progress
    INSERT INTO game_progress (
        user_id,
        stage,
        set_number,
        level,
        coins,
        perks,
        unlocked_sets,
        unlocked_levels,
        perfect_levels,
        completed_levels
    ) VALUES (
        NEW.id,
        1,
        1,
        1,
        0,
        '{}',
        '{"1": [1]}',
        '{"1_1": [1]}',
        '[]',
        '[]'
    );

    -- Initialize player stats
    INSERT INTO player_stats (
        user_id,
        total_levels_completed,
        total_time_spent,
        total_mistakes,
        best_streak,
        current_streak,
        highest_score,
        unique_words_practiced,
        words_practiced_today,
        practiced_words,
        time_spent_today_ms,
        perfect_levels_count,
        daily_login_streak
    ) VALUES (
        NEW.id,
        0, 0, 0, 0, 0, 0, 0, 0,
        ARRAY[]::TEXT[],
        0, 0, 0
    );

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger for new user initialization
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Enable RLS on all tables
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE game_progress ENABLE ROW LEVEL SECURITY;
ALTER TABLE custom_lists ENABLE ROW LEVEL SECURITY;
ALTER TABLE payment_requests ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
CREATE POLICY "Users can view their own profile"
ON public.user_profiles FOR SELECT
USING (auth.uid() = id);

CREATE POLICY "Users can update their own profile"
ON public.user_profiles FOR UPDATE
USING (auth.uid() = id);

CREATE POLICY "Access control based on user status" ON game_progress
FOR SELECT USING (
    CASE 
        WHEN auth.role() = 'anon' THEN 
            (stage = 1) OR 
            (stage IN (2,3,4,5) AND set_number = 1)
        WHEN EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE id = auth.uid() 
            AND status = 'free'
        ) THEN 
            (stage = 1) OR 
            (stage IN (2,3,4,5) AND set_number = 1)
        WHEN EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE id = auth.uid() 
            AND status = 'premium'
        ) THEN 
            true
        ELSE false
    END
);

CREATE POLICY "Users can manage own game progress" ON game_progress
FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can view own and shared lists" ON custom_lists
FOR SELECT USING (
    auth.uid() = user_id 
    OR auth.uid() = ANY(shared_with)
);

CREATE POLICY "Users can manage own lists" ON custom_lists
FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can view own payment requests" ON payment_requests
FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can create payment requests" ON payment_requests
FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Grant necessary permissions
GRANT SELECT ON public.user_list TO authenticated;
GRANT SELECT, UPDATE ON public.user_profiles TO authenticated;
GRANT ALL ON game_progress TO authenticated;
GRANT ALL ON custom_lists TO authenticated;
GRANT ALL ON payment_requests TO authenticated;

-- Verify payment function
CREATE OR REPLACE FUNCTION verify_payment(
    payment_id uuid,
    user_id uuid
) RETURNS void AS $$
BEGIN
    UPDATE payment_requests 
    SET 
        status = 'verified',
        verification_time = NOW()
    WHERE id = payment_id;

    UPDATE user_profiles 
    SET 
        status = 'premium',
        payment_pending = false
    WHERE id = user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION verify_payment(uuid, uuid) TO authenticated;