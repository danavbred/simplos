----------------------------------------------------------------------------------------
-- üîë USER PROFILES
----------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.user_profiles (
    id uuid PRIMARY KEY REFERENCES auth.users,
    username text UNIQUE,
    email text,
    role text CHECK (role IN ('student', 'teacher', 'admin')) DEFAULT 'student',
    status text DEFAULT 'free' CHECK (status IN ('free', 'pending', 'premium')),
    payment_pending boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);

-- Trigger for automatic profile creation on user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.user_profiles (
        id,
        username,
        email,
        role,
        status
    ) VALUES (
        NEW.id,
        COALESCE(
            NEW.raw_user_meta_data->>'username', 
            split_part(NEW.email, '@', 1)
        ),
        NEW.email,
        'student',
        'free'
    );
    RETURN NEW;
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Error in handle_new_user: %', SQLERRM;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_new_user();

----------------------------------------------------------------------------------------
-- üõ°Ô∏è POLICIES
----------------------------------------------------------------------------------------
-- Drop existing policies first
DROP POLICY IF EXISTS "Allow users to view all profiles" ON public.user_profiles;
DROP POLICY IF EXISTS "Enable read access for authenticated users" ON public.user_profiles;
DROP POLICY IF EXISTS "Enable update for users based on id" ON public.user_profiles;
DROP POLICY IF EXISTS "Enable insert for authenticated users only" ON public.user_profiles;
DROP POLICY IF EXISTS "Users can view their own profile" ON public.user_profiles;

-- Create a completely permissive SELECT policy
CREATE POLICY "anyone_can_view_all_profiles"
ON public.user_profiles
FOR SELECT
USING (true);

-- Policy for users to update their own profiles
CREATE POLICY "users_can_update_own_profile"
ON public.user_profiles
FOR UPDATE
USING (auth.uid() = id);

-- Policy for inserting new profiles
CREATE POLICY "users_can_insert_own_profile"
ON public.user_profiles
FOR INSERT
WITH CHECK (auth.uid() = id);

-- Make sure RLS is enabled
ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;

-- Grant explicit permissions
GRANT SELECT, UPDATE, INSERT ON public.user_profiles TO authenticated;----------------------------------------------------------------------------------------
-- üéÆ GAME PROGRESS
----------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS game_progress (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id uuid REFERENCES auth.users NOT NULL,
    stage integer NOT NULL DEFAULT 1,
    set_number integer NOT NULL DEFAULT 1,
    level integer NOT NULL DEFAULT 1,
    coins integer NOT NULL DEFAULT 0,
    perks jsonb NOT NULL DEFAULT '{}',
    unlocked_sets jsonb NOT NULL DEFAULT '{}',
    unlocked_levels jsonb NOT NULL DEFAULT '{}',
    perfect_levels jsonb NOT NULL DEFAULT '[]',
    completed_levels jsonb NOT NULL DEFAULT '[]',
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);

-- Enable Row Level Security
ALTER TABLE game_progress ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage own game progress" 
ON game_progress FOR ALL 
USING (auth.uid() = user_id);

CREATE UNIQUE INDEX unique_user_game_progress ON game_progress (user_id);

----------------------------------------------------------------------------------------
-- üìä STATS
----------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS player_stats (
    user_id uuid REFERENCES auth.users PRIMARY KEY,
    total_levels_completed integer DEFAULT 0,
    unique_words_practiced INTEGER DEFAULT 0,
    last_updated timestamp with time zone DEFAULT timezone('utc'::text, now())
);

-- Indices for performance
CREATE INDEX IF NOT EXISTS idx_player_stats_user ON player_stats(user_id);
CREATE INDEX IF NOT EXISTS idx_player_stats_levels ON player_stats(total_levels_completed DESC);

-- Enable Row Level Security
ALTER TABLE player_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read any player stats" 
    ON player_stats FOR SELECT 
    USING (true);

CREATE POLICY "Users can update their own stats" 
    ON player_stats FOR UPDATE 
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own stats" 
    ON player_stats FOR INSERT 
    WITH CHECK (auth.uid() = user_id);

-- Leaderboard View
CREATE OR REPLACE VIEW player_leaderboard AS
WITH user_rankings AS (
    SELECT 
        up.username,
        COALESCE(ps.total_levels_completed, 0) as total_levels_completed,
        COALESCE(ps.unique_words_practiced, 0) as total_words_learned,
        ROW_NUMBER() OVER (
            ORDER BY COALESCE(ps.total_levels_completed, 0) DESC, 
            COALESCE(ps.unique_words_practiced, 0) DESC
        ) as player_rank
    FROM user_profiles up
    LEFT JOIN player_stats ps ON up.id = ps.user_id
    WHERE up.username IS NOT NULL
)
SELECT 
    username,
    total_levels_completed,
    total_words_learned,
    player_rank
FROM user_rankings
ORDER BY player_rank ASC;

-- Grant permissions for leaderboard
GRANT SELECT ON player_leaderboard TO authenticated;
GRANT ALL ON player_stats TO authenticated;

----------------------------------------------------------------------------------------
-- üìù CUSTOM LISTS
----------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS custom_lists (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id uuid REFERENCES auth.users NOT NULL,
    name text NOT NULL,
    words text[] DEFAULT '{}',
    translations text[] DEFAULT '{}',
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    local_id BIGINT,
    is_shared boolean DEFAULT false,
    shared_with uuid[] DEFAULT '{}'::uuid[],
    shared_by uuid REFERENCES auth.users(id)
);

-- Enable Row Level Security
ALTER TABLE custom_lists ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own and shared lists" ON custom_lists
FOR SELECT USING (
    auth.uid() = user_id 
    OR auth.uid() = ANY(shared_with)
);

CREATE POLICY "Users can manage own lists" ON custom_lists
FOR ALL USING (auth.uid() = user_id);

-- Grant permissions
GRANT ALL ON custom_lists TO authenticated;

----------------------------------------------------------------------------------------
-- üí∞ PAYMENTS
----------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS payment_requests (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id uuid REFERENCES auth.users NOT NULL,
    payment_method text CHECK (payment_method IN ('bit', 'paybox', 'kashkash', 'bank')),
    amount numeric(10,2) NOT NULL,
    status text DEFAULT 'pending' CHECK (status IN ('pending', 'verified', 'rejected')),
    reference_code text UNIQUE,
    submission_time timestamp with time zone DEFAULT timezone('utc'::text, now()),
    verification_time timestamp with time zone,
    admin_verified_by uuid REFERENCES auth.users(id)
);

-- Enable Row Level Security
ALTER TABLE payment_requests ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own payment requests"
ON payment_requests FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Admin can manage all payment requests"
ON payment_requests FOR ALL
USING (
    auth.uid() IN (
        SELECT id FROM user_profiles 
        WHERE role = 'admin'
    )
);

-- Add this new policy to allow users to see other users for sharing
CREATE POLICY "Users can view other users profiles for sharing"
ON public.user_profiles 
FOR SELECT
USING (true);  -- This allows all authenticated users to view user profiles